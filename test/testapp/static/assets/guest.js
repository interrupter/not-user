(function () {
	'use strict';

	/** @returns {void} */
	function noop$1() {}

	const identity = (x) => x;

	/**
	 * @template T
	 * @template S
	 * @param {T} tar
	 * @param {S} src
	 * @returns {T & S}
	 */
	function assign(tar, src) {
		// @ts-ignore
		for (const k in src) tar[k] = src[k];
		return /** @type {T & S} */ (tar);
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function run_all(fns) {
		fns.forEach(run);
	}

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	/** @returns {boolean} */
	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
	}

	let src_url_equal_anchor;

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
		if (element_src === url) return true;
		if (!src_url_equal_anchor) {
			src_url_equal_anchor = document.createElement('a');
		}
		// This is actually faster than doing URL(..).href
		src_url_equal_anchor.href = url;
		return element_src === src_url_equal_anchor.href;
	}

	/** @returns {boolean} */
	function is_empty(obj) {
		return Object.keys(obj).length === 0;
	}

	function subscribe(store, ...callbacks) {
		if (store == null) {
			for (const callback of callbacks) {
				callback(undefined);
			}
			return noop$1;
		}
		const unsub = store.subscribe(...callbacks);
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @returns {void} */
	function component_subscribe(component, store, callback) {
		component.$$.on_destroy.push(subscribe(store, callback));
	}

	function create_slot(definition, ctx, $$scope, fn) {
		if (definition) {
			const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
			return definition[0](slot_ctx);
		}
	}

	function get_slot_context(definition, ctx, $$scope, fn) {
		return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
	}

	function get_slot_changes(definition, $$scope, dirty, fn) {
		if (definition[2] && fn) {
			const lets = definition[2](fn(dirty));
			if ($$scope.dirty === undefined) {
				return lets;
			}
			if (typeof lets === 'object') {
				const merged = [];
				const len = Math.max($$scope.dirty.length, lets.length);
				for (let i = 0; i < len; i += 1) {
					merged[i] = $$scope.dirty[i] | lets[i];
				}
				return merged;
			}
			return $$scope.dirty | lets;
		}
		return $$scope.dirty;
	}

	/** @returns {void} */
	function update_slot_base(
		slot,
		slot_definition,
		ctx,
		$$scope,
		slot_changes,
		get_slot_context_fn
	) {
		if (slot_changes) {
			const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
			slot.p(slot_context, slot_changes);
		}
	}

	/** @returns {any[] | -1} */
	function get_all_dirty_from_scope($$scope) {
		if ($$scope.ctx.length > 32) {
			const dirty = [];
			const length = $$scope.ctx.length / 32;
			for (let i = 0; i < length; i++) {
				dirty[i] = -1;
			}
			return dirty;
		}
		return -1;
	}

	/** @returns {{}} */
	function exclude_internal_props(props) {
		const result = {};
		for (const k in props) if (k[0] !== '$') result[k] = props[k];
		return result;
	}

	/** @returns {{}} */
	function compute_rest_props(props, keys) {
		const rest = {};
		keys = new Set(keys);
		for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
		return rest;
	}

	function null_to_empty(value) {
		return value == null ? '' : value;
	}

	const is_client = typeof window !== 'undefined';

	/** @type {() => number} */
	let now = is_client ? () => window.performance.now() : () => Date.now();

	let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop$1;

	const tasks = new Set();

	/**
	 * @param {number} now
	 * @returns {void}
	 */
	function run_tasks(now) {
		tasks.forEach((task) => {
			if (!task.c(now)) {
				tasks.delete(task);
				task.f();
			}
		});
		if (tasks.size !== 0) raf(run_tasks);
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {import('./private.js').TaskCallback} callback
	 * @returns {import('./private.js').Task}
	 */
	function loop(callback) {
		/** @type {import('./private.js').TaskEntry} */
		let task;
		if (tasks.size === 0) raf(run_tasks);
		return {
			promise: new Promise((fulfill) => {
				tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				tasks.delete(task);
			}
		};
	}

	/** @type {typeof globalThis} */
	const globals =
		typeof window !== 'undefined'
			? window
			: typeof globalThis !== 'undefined'
			? globalThis
			: // @ts-ignore Node typings have this
			  global;

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append(target, node) {
		target.appendChild(node);
	}

	/**
	 * @param {Node} node
	 * @returns {ShadowRoot | Document}
	 */
	function get_root_for_style(node) {
		if (!node) return document;
		const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
		if (root && /** @type {ShadowRoot} */ (root).host) {
			return /** @type {ShadowRoot} */ (root);
		}
		return node.ownerDocument;
	}

	/**
	 * @param {Node} node
	 * @returns {CSSStyleSheet}
	 */
	function append_empty_stylesheet(node) {
		const style_element = element('style');
		// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,
		// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.
		// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.
		// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.
		// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.
		style_element.textContent = '/* empty */';
		append_stylesheet(get_root_for_style(node), style_element);
		return style_element.sheet;
	}

	/**
	 * @param {ShadowRoot | Document} node
	 * @param {HTMLStyleElement} style
	 * @returns {CSSStyleSheet}
	 */
	function append_stylesheet(node, style) {
		append(/** @type {Document} */ (node).head || node, style);
		return style.sheet;
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert(target, node, anchor) {
		target.insertBefore(node, anchor || null);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach(node) {
		if (node.parentNode) {
			node.parentNode.removeChild(node);
		}
	}

	/**
	 * @returns {void} */
	function destroy_each(iterations, detaching) {
		for (let i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detaching);
		}
	}

	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */
	function element(name) {
		return document.createElement(name);
	}

	/**
	 * @template {keyof SVGElementTagNameMap} K
	 * @param {K} name
	 * @returns {SVGElement}
	 */
	function svg_element(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	function text(data) {
		return document.createTextNode(data);
	}

	/**
	 * @returns {Text} */
	function space() {
		return text(' ');
	}

	/**
	 * @returns {Text} */
	function empty() {
		return text('');
	}

	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */
	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	/**
	 * @returns {(event: any) => any} */
	function prevent_default(fn) {
		return function (event) {
			event.preventDefault();
			// @ts-ignore
			return fn.call(this, event);
		};
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}
	/**
	 * List of attributes that should always be set through the attr method,
	 * because updating them through the property setter doesn't work reliably.
	 * In the example of `width`/`height`, the problem is that the setter only
	 * accepts numeric values, but the attribute can also be set to a string like `50%`.
	 * If this list becomes too big, rethink this approach.
	 */
	const always_set_through_set_attribute = ['width', 'height'];

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {{ [x: string]: string }} attributes
	 * @returns {void}
	 */
	function set_attributes(node, attributes) {
		// @ts-ignore
		const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
		for (const key in attributes) {
			if (attributes[key] == null) {
				node.removeAttribute(key);
			} else if (key === 'style') {
				node.style.cssText = attributes[key];
			} else if (key === '__value') {
				/** @type {any} */ (node).value = node[key] = attributes[key];
			} else if (
				descriptors[key] &&
				descriptors[key].set &&
				always_set_through_set_attribute.indexOf(key) === -1
			) {
				node[key] = attributes[key];
			} else {
				attr(node, key, attributes[key]);
			}
		}
	}

	/** @returns {number} */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */
	function children(element) {
		return Array.from(element.childNodes);
	}

	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */
	function set_data(text, data) {
		data = '' + data;
		if (text.data === data) return;
		text.data = /** @type {string} */ (data);
	}

	/**
	 * @returns {void} */
	function set_input_value(input, value) {
		input.value = value == null ? '' : value;
	}

	/**
	 * @returns {void} */
	function set_style(node, key, value, important) {
		if (value == null) {
			node.style.removeProperty(key);
		} else {
			node.style.setProperty(key, value, '');
		}
	}

	/**
	 * @returns {void} */
	function toggle_class(element, name, toggle) {
		// The `!!` is required because an `undefined` flag means flipping the current state.
		element.classList.toggle(name, !!toggle);
	}

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */
	function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}
	/** */
	class HtmlTag {
		/**
		 * @private
		 * @default false
		 */
		is_svg = false;
		/** parent for creating node */
		e = undefined;
		/** html tag nodes */
		n = undefined;
		/** target */
		t = undefined;
		/** anchor */
		a = undefined;
		constructor(is_svg = false) {
			this.is_svg = is_svg;
			this.e = this.n = null;
		}

		/**
		 * @param {string} html
		 * @returns {void}
		 */
		c(html) {
			this.h(html);
		}

		/**
		 * @param {string} html
		 * @param {HTMLElement | SVGElement} target
		 * @param {HTMLElement | SVGElement} anchor
		 * @returns {void}
		 */
		m(html, target, anchor = null) {
			if (!this.e) {
				if (this.is_svg)
					this.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));
				/** #7364  target for <template> may be provided as #document-fragment(11) */ else
					this.e = element(
						/** @type {keyof HTMLElementTagNameMap} */ (
							target.nodeType === 11 ? 'TEMPLATE' : target.nodeName
						)
					);
				this.t =
					target.tagName !== 'TEMPLATE'
						? target
						: /** @type {HTMLTemplateElement} */ (target).content;
				this.c(html);
			}
			this.i(anchor);
		}

		/**
		 * @param {string} html
		 * @returns {void}
		 */
		h(html) {
			this.e.innerHTML = html;
			this.n = Array.from(
				this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes
			);
		}

		/**
		 * @returns {void} */
		i(anchor) {
			for (let i = 0; i < this.n.length; i += 1) {
				insert(this.t, this.n[i], anchor);
			}
		}

		/**
		 * @param {string} html
		 * @returns {void}
		 */
		p(html) {
			this.d();
			this.h(html);
			this.i(this.a);
		}

		/**
		 * @returns {void} */
		d() {
			this.n.forEach(detach);
		}
	}

	function construct_svelte_component(component, props) {
		return new component(props);
	}

	/**
	 * @typedef {Node & {
	 * 	claim_order?: number;
	 * 	hydrate_init?: true;
	 * 	actual_end_child?: NodeEx;
	 * 	childNodes: NodeListOf<NodeEx>;
	 * }} NodeEx
	 */

	/** @typedef {ChildNode & NodeEx} ChildNodeEx */

	/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

	/**
	 * @typedef {ChildNodeEx[] & {
	 * 	claim_info?: {
	 * 		last_index: number;
	 * 		total_claimed: number;
	 * 	};
	 * }} ChildNodeArray
	 */

	// we need to store the information for multiple documents because a Svelte application could also contain iframes
	// https://github.com/sveltejs/svelte/issues/3624
	/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */
	const managed_styles = new Map();

	let active$1 = 0;

	// https://github.com/darkskyapp/string-hash/blob/master/index.js
	/**
	 * @param {string} str
	 * @returns {number}
	 */
	function hash$1(str) {
		let hash = 5381;
		let i = str.length;
		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return hash >>> 0;
	}

	/**
	 * @param {Document | ShadowRoot} doc
	 * @param {Element & ElementCSSInlineStyle} node
	 * @returns {{ stylesheet: any; rules: {}; }}
	 */
	function create_style_information(doc, node) {
		const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
		managed_styles.set(doc, info);
		return info;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {number} a
	 * @param {number} b
	 * @param {number} duration
	 * @param {number} delay
	 * @param {(t: number) => number} ease
	 * @param {(t: number, u: number) => string} fn
	 * @param {number} uid
	 * @returns {string}
	 */
	function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
		const step = 16.666 / duration;
		let keyframes = '{\n';
		for (let p = 0; p <= 1; p += step) {
			const t = a + (b - a) * ease(p);
			keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
		}
		const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
		const name = `__svelte_${hash$1(rule)}_${uid}`;
		const doc = get_root_for_style(node);
		const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
		if (!rules[name]) {
			rules[name] = true;
			stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
		}
		const animation = node.style.animation || '';
		node.style.animation = `${
		animation ? `${animation}, ` : ''
	}${name} ${duration}ms linear ${delay}ms 1 both`;
		active$1 += 1;
		return name;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {string} [name]
	 * @returns {void}
	 */
	function delete_rule(node, name) {
		const previous = (node.style.animation || '').split(', ');
		const next = previous.filter(
			name
				? (anim) => anim.indexOf(name) < 0 // remove specific animation
				: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations
		);
		const deleted = previous.length - next.length;
		if (deleted) {
			node.style.animation = next.join(', ');
			active$1 -= deleted;
			if (!active$1) clear_rules();
		}
	}

	/** @returns {void} */
	function clear_rules() {
		raf(() => {
			if (active$1) return;
			managed_styles.forEach((info) => {
				const { ownerNode } = info.stylesheet;
				// there is no ownerNode if it runs on jsdom.
				if (ownerNode) detach(ownerNode);
			});
			managed_styles.clear();
		});
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {import('./private.js').PositionRect} from
	 * @param {import('./private.js').AnimationFn} fn
	 */
	function create_animation(node, from, fn, params) {
		if (!from) return noop$1;
		const to = node.getBoundingClientRect();
		if (
			from.left === to.left &&
			from.right === to.right &&
			from.top === to.top &&
			from.bottom === to.bottom
		)
			return noop$1;
		const {
			delay = 0,
			duration = 300,
			easing = identity,
			// @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
			start: start_time = now() + delay,
			// @ts-ignore todo:
			end = start_time + duration,
			tick = noop$1,
			css
		} = fn(node, { from, to }, params);
		let running = true;
		let started = false;
		let name;
		/** @returns {void} */
		function start() {
			if (css) {
				name = create_rule(node, 0, 1, duration, delay, easing, css);
			}
			if (!delay) {
				started = true;
			}
		}
		/** @returns {void} */
		function stop() {
			if (css) delete_rule(node, name);
			running = false;
		}
		loop((now) => {
			if (!started && now >= start_time) {
				started = true;
			}
			if (started && now >= end) {
				tick(1, 0);
				stop();
			}
			if (!running) {
				return false;
			}
			if (started) {
				const p = now - start_time;
				const t = 0 + 1 * easing(p / duration);
				tick(t, 1 - t);
			}
			return true;
		});
		start();
		tick(0, 1);
		return stop;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @returns {void}
	 */
	function fix_position(node) {
		const style = getComputedStyle(node);
		if (style.position !== 'absolute' && style.position !== 'fixed') {
			const { width, height } = style;
			const a = node.getBoundingClientRect();
			node.style.position = 'absolute';
			node.style.width = width;
			node.style.height = height;
			add_transform(node, a);
		}
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {import('./private.js').PositionRect} a
	 * @returns {void}
	 */
	function add_transform(node, a) {
		const b = node.getBoundingClientRect();
		if (a.left !== b.left || a.top !== b.top) {
			const style = getComputedStyle(node);
			const transform = style.transform === 'none' ? '' : style.transform;
			node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
		}
	}

	let current_component;

	/** @returns {void} */
	function set_current_component(component) {
		current_component = component;
	}

	function get_current_component() {
		if (!current_component) throw new Error('Function called outside component initialization');
		return current_component;
	}

	/**
	 * Schedules a callback to run immediately before the component is updated after any state change.
	 *
	 * The first time the callback runs will be before the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#beforeupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function beforeUpdate(fn) {
		get_current_component().$$.before_update.push(fn);
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#afterupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		get_current_component().$$.after_update.push(fn);
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * https://svelte.dev/docs/svelte#ondestroy
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		get_current_component().$$.on_destroy.push(fn);
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * https://svelte.dev/docs/svelte#createeventdispatcher
	 * @template {Record<string, any>} [EventMap=any]
	 * @returns {import('./public.js').EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const component = get_current_component();
		return (type, detail, { cancelable = false } = {}) => {
			const callbacks = component.$$.callbacks[type];
			if (callbacks) {
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = custom_event(/** @type {string} */ (type), detail, { cancelable });
				callbacks.slice().forEach((fn) => {
					fn.call(component, event);
				});
				return !event.defaultPrevented;
			}
			return true;
		};
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	/**
	 * @param component
	 * @param event
	 * @returns {void}
	 */
	function bubble(component, event) {
		const callbacks = component.$$.callbacks[event.type];
		if (callbacks) {
			// @ts-ignore
			callbacks.slice().forEach((fn) => fn.call(this, event));
		}
	}

	const dirty_components = [];
	const binding_callbacks = [];

	let render_callbacks = [];

	const flush_callbacks = [];

	const resolved_promise = /* @__PURE__ */ Promise.resolve();

	let update_scheduled = false;

	/** @returns {void} */
	function schedule_update() {
		if (!update_scheduled) {
			update_scheduled = true;
			resolved_promise.then(flush);
		}
	}

	/** @returns {void} */
	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	/** @returns {void} */
	function add_flush_callback(fn) {
		flush_callbacks.push(fn);
	}

	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();

	let flushidx = 0; // Do *not* move this inside the flush() function

	/** @returns {void} */
	function flush() {
		// Do not reenter flush while dirty components are updated, as this can
		// result in an infinite loop. Instead, let the inner flush handle it.
		// Reentrancy is ok afterwards for bindings etc.
		if (flushidx !== 0) {
			return;
		}
		const saved_component = current_component;
		do {
			// first, call beforeUpdate functions
			// and update components
			try {
				while (flushidx < dirty_components.length) {
					const component = dirty_components[flushidx];
					flushidx++;
					set_current_component(component);
					update(component.$$);
				}
			} catch (e) {
				// reset dirty state to not end up in a deadlocked state and then rethrow
				dirty_components.length = 0;
				flushidx = 0;
				throw e;
			}
			set_current_component(null);
			dirty_components.length = 0;
			flushidx = 0;
			while (binding_callbacks.length) binding_callbacks.pop()();
			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			for (let i = 0; i < render_callbacks.length; i += 1) {
				const callback = render_callbacks[i];
				if (!seen_callbacks.has(callback)) {
					// ...so guard against infinite loops
					seen_callbacks.add(callback);
					callback();
				}
			}
			render_callbacks.length = 0;
		} while (dirty_components.length);
		while (flush_callbacks.length) {
			flush_callbacks.pop()();
		}
		update_scheduled = false;
		seen_callbacks.clear();
		set_current_component(saved_component);
	}

	/** @returns {void} */
	function update($$) {
		if ($$.fragment !== null) {
			$$.update();
			run_all($$.before_update);
			const dirty = $$.dirty;
			$$.dirty = [-1];
			$$.fragment && $$.fragment.p($$.ctx, dirty);
			$$.after_update.forEach(add_render_callback);
		}
	}

	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function flush_render_callbacks(fns) {
		const filtered = [];
		const targets = [];
		render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
		targets.forEach((c) => c());
		render_callbacks = filtered;
	}

	/**
	 * @type {Promise<void> | null}
	 */
	let promise;

	/**
	 * @returns {Promise<void>}
	 */
	function wait() {
		if (!promise) {
			promise = Promise.resolve();
			promise.then(() => {
				promise = null;
			});
		}
		return promise;
	}

	/**
	 * @param {Element} node
	 * @param {INTRO | OUTRO | boolean} direction
	 * @param {'start' | 'end'} kind
	 * @returns {void}
	 */
	function dispatch(node, direction, kind) {
		node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	const outroing = new Set();

	/**
	 * @type {Outro}
	 */
	let outros;

	/**
	 * @returns {void} */
	function group_outros() {
		outros = {
			r: 0,
			c: [],
			p: outros // parent group
		};
	}

	/**
	 * @returns {void} */
	function check_outros() {
		if (!outros.r) {
			run_all(outros.c);
		}
		outros = outros.p;
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */
	function transition_in(block, local) {
		if (block && block.i) {
			outroing.delete(block);
			block.i(local);
		}
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */
	function transition_out(block, local, detach, callback) {
		if (block && block.o) {
			if (outroing.has(block)) return;
			outroing.add(block);
			outros.c.push(() => {
				outroing.delete(block);
				if (callback) {
					if (detach) block.d(1);
					callback();
				}
			});
			block.o(local);
		} else if (callback) {
			callback();
		}
	}

	/**
	 * @type {import('../transition/public.js').TransitionConfig}
	 */
	const null_transition = { duration: 0 };

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {TransitionFn} fn
	 * @param {any} params
	 * @param {boolean} intro
	 * @returns {{ run(b: 0 | 1): void; end(): void; }}
	 */
	function create_bidirectional_transition(node, fn, params, intro) {
		/**
		 * @type {TransitionOptions} */
		const options = { direction: 'both' };
		let config = fn(node, params, options);
		let t = intro ? 0 : 1;

		/**
		 * @type {Program | null} */
		let running_program = null;

		/**
		 * @type {PendingProgram | null} */
		let pending_program = null;
		let animation_name = null;

		/** @type {boolean} */
		let original_inert_value;

		/**
		 * @returns {void} */
		function clear_animation() {
			if (animation_name) delete_rule(node, animation_name);
		}

		/**
		 * @param {PendingProgram} program
		 * @param {number} duration
		 * @returns {Program}
		 */
		function init(program, duration) {
			const d = /** @type {Program['d']} */ (program.b - t);
			duration *= Math.abs(d);
			return {
				a: t,
				b: program.b,
				d,
				duration,
				start: program.start,
				end: program.start + duration,
				group: program.group
			};
		}

		/**
		 * @param {INTRO | OUTRO} b
		 * @returns {void}
		 */
		function go(b) {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick = noop$1,
				css
			} = config || null_transition;

			/**
			 * @type {PendingProgram} */
			const program = {
				start: now() + delay,
				b
			};

			if (!b) {
				// @ts-ignore todo: improve typings
				program.group = outros;
				outros.r += 1;
			}

			if ('inert' in node) {
				if (b) {
					if (original_inert_value !== undefined) {
						// aborted/reversed outro — restore previous inert value
						node.inert = original_inert_value;
					}
				} else {
					original_inert_value = /** @type {HTMLElement} */ (node).inert;
					node.inert = true;
				}
			}

			if (running_program || pending_program) {
				pending_program = program;
			} else {
				// if this is an intro, and there's a delay, we need to do
				// an initial tick and/or apply CSS animation immediately
				if (css) {
					clear_animation();
					animation_name = create_rule(node, t, b, duration, delay, easing, css);
				}
				if (b) tick(0, 1);
				running_program = init(program, duration);
				add_render_callback(() => dispatch(node, b, 'start'));
				loop((now) => {
					if (pending_program && now > pending_program.start) {
						running_program = init(pending_program, duration);
						pending_program = null;
						dispatch(node, running_program.b, 'start');
						if (css) {
							clear_animation();
							animation_name = create_rule(
								node,
								t,
								running_program.b,
								running_program.duration,
								0,
								easing,
								config.css
							);
						}
					}
					if (running_program) {
						if (now >= running_program.end) {
							tick((t = running_program.b), 1 - t);
							dispatch(node, running_program.b, 'end');
							if (!pending_program) {
								// we're done
								if (running_program.b) {
									// intro — we can tidy up immediately
									clear_animation();
								} else {
									// outro — needs to be coordinated
									if (!--running_program.group.r) run_all(running_program.group.c);
								}
							}
							running_program = null;
						} else if (now >= running_program.start) {
							const p = now - running_program.start;
							t = running_program.a + running_program.d * easing(p / running_program.duration);
							tick(t, 1 - t);
						}
					}
					return !!(running_program || pending_program);
				});
			}
		}
		return {
			run(b) {
				if (is_function(config)) {
					wait().then(() => {
						const opts = { direction: b ? 'in' : 'out' };
						// @ts-ignore
						config = config(opts);
						go(b);
					});
				} else {
					go(b);
				}
			},
			end() {
				clear_animation();
				running_program = pending_program = null;
			}
		};
	}

	/** @typedef {1} INTRO */
	/** @typedef {0} OUTRO */
	/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
	/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

	/**
	 * @typedef {Object} Outro
	 * @property {number} r
	 * @property {Function[]} c
	 * @property {Object} p
	 */

	/**
	 * @typedef {Object} PendingProgram
	 * @property {number} start
	 * @property {INTRO|OUTRO} b
	 * @property {Outro} [group]
	 */

	/**
	 * @typedef {Object} Program
	 * @property {number} a
	 * @property {INTRO|OUTRO} b
	 * @property {1|-1} d
	 * @property {number} duration
	 * @property {number} start
	 * @property {number} end
	 * @property {Outro} [group]
	 */

	// general each functions:

	function ensure_array_like(array_like_or_iterator) {
		return array_like_or_iterator?.length !== undefined
			? array_like_or_iterator
			: Array.from(array_like_or_iterator);
	}

	// keyed each functions:

	/** @returns {void} */
	function destroy_block(block, lookup) {
		block.d(1);
		lookup.delete(block.key);
	}

	/** @returns {void} */
	function outro_and_destroy_block(block, lookup) {
		transition_out(block, 1, 1, () => {
			lookup.delete(block.key);
		});
	}

	/** @returns {void} */
	function fix_and_outro_and_destroy_block(block, lookup) {
		block.f();
		outro_and_destroy_block(block, lookup);
	}

	/** @returns {any[]} */
	function update_keyed_each(
		old_blocks,
		dirty,
		get_key,
		dynamic,
		ctx,
		list,
		lookup,
		node,
		destroy,
		create_each_block,
		next,
		get_context
	) {
		let o = old_blocks.length;
		let n = list.length;
		let i = o;
		const old_indexes = {};
		while (i--) old_indexes[old_blocks[i].key] = i;
		const new_blocks = [];
		const new_lookup = new Map();
		const deltas = new Map();
		const updates = [];
		i = n;
		while (i--) {
			const child_ctx = get_context(ctx, list, i);
			const key = get_key(child_ctx);
			let block = lookup.get(key);
			if (!block) {
				block = create_each_block(key, child_ctx);
				block.c();
			} else {
				// defer updates until all the DOM shuffling is done
				updates.push(() => block.p(child_ctx, dirty));
			}
			new_lookup.set(key, (new_blocks[i] = block));
			if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
		}
		const will_move = new Set();
		const did_move = new Set();
		/** @returns {void} */
		function insert(block) {
			transition_in(block, 1);
			block.m(node, next);
			lookup.set(block.key, block);
			next = block.first;
			n--;
		}
		while (o && n) {
			const new_block = new_blocks[n - 1];
			const old_block = old_blocks[o - 1];
			const new_key = new_block.key;
			const old_key = old_block.key;
			if (new_block === old_block) {
				// do nothing
				next = new_block.first;
				o--;
				n--;
			} else if (!new_lookup.has(old_key)) {
				// remove old block
				destroy(old_block, lookup);
				o--;
			} else if (!lookup.has(new_key) || will_move.has(new_key)) {
				insert(new_block);
			} else if (did_move.has(old_key)) {
				o--;
			} else if (deltas.get(new_key) > deltas.get(old_key)) {
				did_move.add(new_key);
				insert(new_block);
			} else {
				will_move.add(old_key);
				o--;
			}
		}
		while (o--) {
			const old_block = old_blocks[o];
			if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
		}
		while (n) insert(new_blocks[n - 1]);
		run_all(updates);
		return new_blocks;
	}

	/** @returns {{}} */
	function get_spread_update(levels, updates) {
		const update = {};
		const to_null_out = {};
		const accounted_for = { $$scope: 1 };
		let i = levels.length;
		while (i--) {
			const o = levels[i];
			const n = updates[i];
			if (n) {
				for (const key in o) {
					if (!(key in n)) to_null_out[key] = 1;
				}
				for (const key in n) {
					if (!accounted_for[key]) {
						update[key] = n[key];
						accounted_for[key] = 1;
					}
				}
				levels[i] = n;
			} else {
				for (const key in o) {
					accounted_for[key] = 1;
				}
			}
		}
		for (const key in to_null_out) {
			if (!(key in update)) update[key] = undefined;
		}
		return update;
	}

	function get_spread_object(spread_props) {
		return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
	}

	/** @returns {void} */
	function bind(component, name, callback) {
		const index = component.$$.props[name];
		if (index !== undefined) {
			component.$$.bound[index] = callback;
			callback(component.$$.ctx[index]);
		}
	}

	/** @returns {void} */
	function create_component(block) {
		block && block.c();
	}

	/** @returns {void} */
	function mount_component(component, target, anchor) {
		const { fragment, after_update } = component.$$;
		fragment && fragment.m(target, anchor);
		// onMount happens before the initial afterUpdate
		add_render_callback(() => {
			const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
			// if the component was destroyed immediately
			// it will update the `$$.on_destroy` reference to `null`.
			// the destructured on_destroy may still reference to the old array
			if (component.$$.on_destroy) {
				component.$$.on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});
		after_update.forEach(add_render_callback);
	}

	/** @returns {void} */
	function destroy_component(component, detaching) {
		const $$ = component.$$;
		if ($$.fragment !== null) {
			flush_render_callbacks($$.after_update);
			run_all($$.on_destroy);
			$$.fragment && $$.fragment.d(detaching);
			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			$$.on_destroy = $$.fragment = null;
			$$.ctx = [];
		}
	}

	/** @returns {void} */
	function make_dirty(component, i) {
		if (component.$$.dirty[0] === -1) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty.fill(0);
		}
		component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
	}

	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */
	function init(
		component,
		options,
		instance,
		create_fragment,
		not_equal,
		props,
		append_styles = null,
		dirty = [-1]
	) {
		const parent_component = current_component;
		set_current_component(component);
		/** @type {import('./private.js').T$$} */
		const $$ = (component.$$ = {
			fragment: null,
			ctx: [],
			// state
			props,
			update: noop$1,
			not_equal,
			bound: blank_object(),
			// lifecycle
			on_mount: [],
			on_destroy: [],
			on_disconnect: [],
			before_update: [],
			after_update: [],
			context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
			// everything else
			callbacks: blank_object(),
			dirty,
			skip_bound: false,
			root: options.target || parent_component.$$.root
		});
		append_styles && append_styles($$.root);
		let ready = false;
		$$.ctx = instance
			? instance(component, options.props || {}, (i, ret, ...rest) => {
					const value = rest.length ? rest[0] : ret;
					if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
						if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
						if (ready) make_dirty(component, i);
					}
					return ret;
			  })
			: [];
		$$.update();
		ready = true;
		run_all($$.before_update);
		// `false` as a special case of no DOM component
		$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
		if (options.target) {
			if (options.hydrate) {
				// TODO: what is the correct type here?
				// @ts-expect-error
				const nodes = children(options.target);
				$$.fragment && $$.fragment.l(nodes);
				nodes.forEach(detach);
			} else {
				// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
				$$.fragment && $$.fragment.c();
			}
			if (options.intro) transition_in(component.$$.fragment);
			mount_component(component, options.target, options.anchor);
			flush();
		}
		set_current_component(parent_component);
	}

	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */
	class SvelteComponent {
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$ = undefined;
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$set = undefined;

		/** @returns {void} */
		$destroy() {
			destroy_component(this, 1);
			this.$destroy = noop$1;
		}

		/**
		 * @template {Extract<keyof Events, string>} K
		 * @param {K} type
		 * @param {((e: Events[K]) => void) | null | undefined} callback
		 * @returns {() => void}
		 */
		$on(type, callback) {
			if (!is_function(callback)) {
				return noop$1;
			}
			const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
			callbacks.push(callback);
			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		/**
		 * @param {Partial<Props>} props
		 * @returns {void}
		 */
		$set(props) {
			if (this.$$set && !is_empty(props)) {
				this.$$.skip_bound = true;
				this.$$set(props);
				this.$$.skip_bound = false;
			}
		}
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	// generated during release, do not modify

	const PUBLIC_VERSION = '4';

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

	/* node_modules/not-bulma/src/elements/block/ui.block.svelte generated by Svelte v4.2.19 */

	function create_fragment$1J(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "id", /*id*/ ctx[0]);
				attr(div, "class", div_class_value = "block " + /*classes*/ ctx[1]);
				attr(div, "role", "button");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[5]),
						listen(div, "keyup", /*keyup_handler*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && div_class_value !== (div_class_value = "block " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$1I($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		const dispatch = createEventDispatcher();
		let { id = "" } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler = () => dispatch("click");

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		return [id, classes, dispatch, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_block extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1I, create_fragment$1J, safe_not_equal, { id: 0, classes: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/block/ui.block.inner.vertical.svelte generated by Svelte v4.2.19 */

	function create_default_slot$7(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

		return {
			c() {
				if (default_slot) default_slot.c();
			},
			m(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
							null
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function create_fragment$1I(ctx) {
		let uiblock;
		let updating_id;
		let updating_classes;
		let current;

		function uiblock_id_binding(value) {
			/*uiblock_id_binding*/ ctx[4](value);
		}

		function uiblock_classes_binding(value) {
			/*uiblock_classes_binding*/ ctx[5](value);
		}

		let uiblock_props = {
			$$slots: { default: [create_default_slot$7] },
			$$scope: { ctx }
		};

		if (/*id*/ ctx[0] !== void 0) {
			uiblock_props.id = /*id*/ ctx[0];
		}

		if (/*classesInner*/ ctx[1] !== void 0) {
			uiblock_props.classes = /*classesInner*/ ctx[1];
		}

		uiblock = new Ui_block({ props: uiblock_props });
		binding_callbacks.push(() => bind(uiblock, 'id', uiblock_id_binding));
		binding_callbacks.push(() => bind(uiblock, 'classes', uiblock_classes_binding));

		return {
			c() {
				create_component(uiblock.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiblock, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uiblock_changes = {};

				if (dirty & /*$$scope*/ 64) {
					uiblock_changes.$$scope = { dirty, ctx };
				}

				if (!updating_id && dirty & /*id*/ 1) {
					updating_id = true;
					uiblock_changes.id = /*id*/ ctx[0];
					add_flush_callback(() => updating_id = false);
				}

				if (!updating_classes && dirty & /*classesInner*/ 2) {
					updating_classes = true;
					uiblock_changes.classes = /*classesInner*/ ctx[1];
					add_flush_callback(() => updating_classes = false);
				}

				uiblock.$set(uiblock_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiblock.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiblock.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiblock, detaching);
			}
		};
	}

	function instance$1H($$self, $$props, $$invalidate) {
		let classesInner;
		let { $$slots: slots = {}, $$scope } = $$props;
		let { id = "" } = $$props;
		let { classes = "" } = $$props;

		function uiblock_id_binding(value) {
			id = value;
			$$invalidate(0, id);
		}

		function uiblock_classes_binding(value) {
			classesInner = value;
			($$invalidate(1, classesInner), $$invalidate(2, classes));
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*classes*/ 4) {
				$$invalidate(1, classesInner = `block-inner-vertical ${classes}`);
			}
		};

		return [
			id,
			classesInner,
			classes,
			slots,
			uiblock_id_binding,
			uiblock_classes_binding,
			$$scope
		];
	}

	class Ui_block_inner_vertical extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1H, create_fragment$1I, safe_not_equal, { id: 0, classes: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/block/ui.box.svelte generated by Svelte v4.2.19 */

	function create_fragment$1H(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "id", /*id*/ ctx[0]);
				attr(div, "class", div_class_value = "box " + /*classes*/ ctx[1] + "");
				attr(div, "role", "button");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[5]),
						listen(div, "keyup", /*keyup_handler*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && div_class_value !== (div_class_value = "box " + /*classes*/ ctx[1] + "")) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$1G($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		const dispatch = createEventDispatcher();
		let { id = "" } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler = () => dispatch("click");

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		return [id, classes, dispatch, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_box extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1G, create_fragment$1H, safe_not_equal, { id: 0, classes: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/block/ui.content.svelte generated by Svelte v4.2.19 */

	function create_fragment$1G(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				attr(div, "id", /*id*/ ctx[0]);
				attr(div, "class", div_class_value = "content " + /*classes*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[5]),
						listen(div, "keyup", /*keyup_handler*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && div_class_value !== (div_class_value = "content " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$1F($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		const dispatch = createEventDispatcher();
		let { id = "" } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler = () => dispatch("click");

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		return [id, classes, dispatch, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_content extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1F, create_fragment$1G, safe_not_equal, { id: 0, classes: 1 });
		}
	}

	var index$b = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBlock: Ui_block,
		UIBlockInnerVertical: Ui_block_inner_vertical,
		UIBox: Ui_box,
		UIContent: Ui_content
	});

	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#writable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Writable<T>}
	 */
	function writable(value, start = noop$1) {
		/** @type {import('./public.js').Unsubscriber} */
		let stop;
		/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();
		/** @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {import('./public.js').Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(value));
		}

		/**
		 * @param {import('./public.js').Subscriber<T>} run
		 * @param {import('./private.js').Invalidator<T>} [invalidate]
		 * @returns {import('./public.js').Unsubscriber}
		 */
		function subscribe(run, invalidate = noop$1) {
			/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop$1;
			}
			run(value);
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	function initDict(target = {}) {
	    const handler = {
	        get: function (target, prop) {
	            if (!Object.hasOwn(target, prop)) {
	                return prop;
	            }
	            return Reflect.get(...arguments);
	        },
	    };
	    return new Proxy(target, handler);
	}

	function createLocale() {
	    const { subscribe, set, update } = writable(initDict());
	    return {
	        subscribe,
	        update,
	        set: (val) => {
	            set(initDict(val));
	        },
	        reset: () => set(initDict()),
	    };
	}

	const LOCALE = createLocale();

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var EventEmitter$1 = {exports: {}};

	/*!
	 * EventEmitter v5.2.9 - git.io/ee
	 * Unlicense - http://unlicense.org/
	 * Oliver Caldwell - https://oli.me.uk/
	 * @preserve
	 */

	(function (module) {
	(function (exports) {

		    /**
		     * Class for managing events.
		     * Can be extended to provide event functionality in other classes.
		     *
		     * @class EventEmitter Manages event registering and emitting.
		     */
		    function EventEmitter() {}

		    // Shortcuts to improve speed and size
		    var proto = EventEmitter.prototype;
		    var originalGlobalValue = exports.EventEmitter;

		    /**
		     * Finds the index of the listener for the event in its storage array.
		     *
		     * @param {Function[]} listeners Array of listeners to search through.
		     * @param {Function} listener Method to look for.
		     * @return {Number} Index of the specified listener, -1 if not found
		     * @api private
		     */
		    function indexOfListener(listeners, listener) {
		        var i = listeners.length;
		        while (i--) {
		            if (listeners[i].listener === listener) {
		                return i;
		            }
		        }

		        return -1;
		    }

		    /**
		     * Alias a method while keeping the context correct, to allow for overwriting of target method.
		     *
		     * @param {String} name The name of the target method.
		     * @return {Function} The aliased method
		     * @api private
		     */
		    function alias(name) {
		        return function aliasClosure() {
		            return this[name].apply(this, arguments);
		        };
		    }

		    /**
		     * Returns the listener array for the specified event.
		     * Will initialise the event object and listener arrays if required.
		     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
		     * Each property in the object response is an array of listener functions.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Function[]|Object} All listener functions for the event.
		     */
		    proto.getListeners = function getListeners(evt) {
		        var events = this._getEvents();
		        var response;
		        var key;

		        // Return a concatenated array of all matching events if
		        // the selector is a regular expression.
		        if (evt instanceof RegExp) {
		            response = {};
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    response[key] = events[key];
		                }
		            }
		        }
		        else {
		            response = events[evt] || (events[evt] = []);
		        }

		        return response;
		    };

		    /**
		     * Takes a list of listener objects and flattens it into a list of listener functions.
		     *
		     * @param {Object[]} listeners Raw listener objects.
		     * @return {Function[]} Just the listener functions.
		     */
		    proto.flattenListeners = function flattenListeners(listeners) {
		        var flatListeners = [];
		        var i;

		        for (i = 0; i < listeners.length; i += 1) {
		            flatListeners.push(listeners[i].listener);
		        }

		        return flatListeners;
		    };

		    /**
		     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Object} All listener functions for an event in an object.
		     */
		    proto.getListenersAsObject = function getListenersAsObject(evt) {
		        var listeners = this.getListeners(evt);
		        var response;

		        if (listeners instanceof Array) {
		            response = {};
		            response[evt] = listeners;
		        }

		        return response || listeners;
		    };

		    function isValidListener (listener) {
		        if (typeof listener === 'function' || listener instanceof RegExp) {
		            return true
		        } else if (listener && typeof listener === 'object') {
		            return isValidListener(listener.listener)
		        } else {
		            return false
		        }
		    }

		    /**
		     * Adds a listener function to the specified event.
		     * The listener will not be added if it is a duplicate.
		     * If the listener returns true then it will be removed after it is called.
		     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListener = function addListener(evt, listener) {
		        if (!isValidListener(listener)) {
		            throw new TypeError('listener must be a function');
		        }

		        var listeners = this.getListenersAsObject(evt);
		        var listenerIsWrapped = typeof listener === 'object';
		        var key;

		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
		                listeners[key].push(listenerIsWrapped ? listener : {
		                    listener: listener,
		                    once: false
		                });
		            }
		        }

		        return this;
		    };

		    /**
		     * Alias of addListener
		     */
		    proto.on = alias('addListener');

		    /**
		     * Semi-alias of addListener. It will add a listener that will be
		     * automatically removed after its first execution.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addOnceListener = function addOnceListener(evt, listener) {
		        return this.addListener(evt, {
		            listener: listener,
		            once: true
		        });
		    };

		    /**
		     * Alias of addOnceListener.
		     */
		    proto.once = alias('addOnceListener');

		    /**
		     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
		     * You need to tell it what event names should be matched by a regex.
		     *
		     * @param {String} evt Name of the event to create.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvent = function defineEvent(evt) {
		        this.getListeners(evt);
		        return this;
		    };

		    /**
		     * Uses defineEvent to define multiple events.
		     *
		     * @param {String[]} evts An array of event names to define.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvents = function defineEvents(evts) {
		        for (var i = 0; i < evts.length; i += 1) {
		            this.defineEvent(evts[i]);
		        }
		        return this;
		    };

		    /**
		     * Removes a listener function from the specified event.
		     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to remove the listener from.
		     * @param {Function} listener Method to remove from the event.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListener = function removeListener(evt, listener) {
		        var listeners = this.getListenersAsObject(evt);
		        var index;
		        var key;

		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key)) {
		                index = indexOfListener(listeners[key], listener);

		                if (index !== -1) {
		                    listeners[key].splice(index, 1);
		                }
		            }
		        }

		        return this;
		    };

		    /**
		     * Alias of removeListener
		     */
		    proto.off = alias('removeListener');

		    /**
		     * Adds listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
		     * You can also pass it a regular expression to add the array of listeners to all events that match it.
		     * Yeah, this function does quite a bit. That's probably a bad thing.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListeners = function addListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(false, evt, listeners);
		    };

		    /**
		     * Removes listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be removed.
		     * You can also pass it a regular expression to remove the listeners from all events that match it.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListeners = function removeListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(true, evt, listeners);
		    };

		    /**
		     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
		     * The first argument will determine if the listeners are removed (true) or added (false).
		     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be added/removed.
		     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
		     *
		     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		        var i;
		        var value;
		        var single = remove ? this.removeListener : this.addListener;
		        var multiple = remove ? this.removeListeners : this.addListeners;

		        // If evt is an object then pass each of its properties to this method
		        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
		            for (i in evt) {
		                if (evt.hasOwnProperty(i) && (value = evt[i])) {
		                    // Pass the single listener straight through to the singular method
		                    if (typeof value === 'function') {
		                        single.call(this, i, value);
		                    }
		                    else {
		                        // Otherwise pass back to the multiple function
		                        multiple.call(this, i, value);
		                    }
		                }
		            }
		        }
		        else {
		            // So evt must be a string
		            // And listeners must be an array of listeners
		            // Loop over it and pass each one to the multiple method
		            i = listeners.length;
		            while (i--) {
		                single.call(this, evt, listeners[i]);
		            }
		        }

		        return this;
		    };

		    /**
		     * Removes all listeners from a specified event.
		     * If you do not specify an event then all listeners will be removed.
		     * That means every event will be emptied.
		     * You can also pass a regex to remove all events that match it.
		     *
		     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeEvent = function removeEvent(evt) {
		        var type = typeof evt;
		        var events = this._getEvents();
		        var key;

		        // Remove different things depending on the state of evt
		        if (type === 'string') {
		            // Remove all listeners for the specified event
		            delete events[evt];
		        }
		        else if (evt instanceof RegExp) {
		            // Remove all events matching the regex.
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    delete events[key];
		                }
		            }
		        }
		        else {
		            // Remove all listeners in all events
		            delete this._events;
		        }

		        return this;
		    };

		    /**
		     * Alias of removeEvent.
		     *
		     * Added to mirror the node API.
		     */
		    proto.removeAllListeners = alias('removeEvent');

		    /**
		     * Emits an event of your choice.
		     * When emitted, every listener attached to that event will be executed.
		     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
		     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
		     * So they will not arrive within the array on the other side, they will be separate.
		     * You can also pass a regular expression to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {Array} [args] Optional array of arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emitEvent = function emitEvent(evt, args) {
		        var listenersMap = this.getListenersAsObject(evt);
		        var listeners;
		        var listener;
		        var i;
		        var key;
		        var response;

		        for (key in listenersMap) {
		            if (listenersMap.hasOwnProperty(key)) {
		                listeners = listenersMap[key].slice(0);

		                for (i = 0; i < listeners.length; i++) {
		                    // If the listener returns true then it shall be removed from the event
		                    // The function is executed either with a basic call or an apply if there is an args array
		                    listener = listeners[i];

		                    if (listener.once === true) {
		                        this.removeListener(evt, listener.listener);
		                    }

		                    response = listener.listener.apply(this, args || []);

		                    if (response === this._getOnceReturnValue()) {
		                        this.removeListener(evt, listener.listener);
		                    }
		                }
		            }
		        }

		        return this;
		    };

		    /**
		     * Alias of emitEvent
		     */
		    proto.trigger = alias('emitEvent');

		    /**
		     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
		     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {...*} Optional additional arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emit = function emit(evt) {
		        var args = Array.prototype.slice.call(arguments, 1);
		        return this.emitEvent(evt, args);
		    };

		    /**
		     * Sets the current value to check against when executing listeners. If a
		     * listeners return value matches the one set here then it will be removed
		     * after execution. This value defaults to true.
		     *
		     * @param {*} value The new value to check for when executing listeners.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.setOnceReturnValue = function setOnceReturnValue(value) {
		        this._onceReturnValue = value;
		        return this;
		    };

		    /**
		     * Fetches the current value to check against when executing listeners. If
		     * the listeners return value matches this one then it should be removed
		     * automatically. It will return true by default.
		     *
		     * @return {*|Boolean} The current value to check for or the default, true.
		     * @api private
		     */
		    proto._getOnceReturnValue = function _getOnceReturnValue() {
		        if (this.hasOwnProperty('_onceReturnValue')) {
		            return this._onceReturnValue;
		        }
		        else {
		            return true;
		        }
		    };

		    /**
		     * Fetches the events object and creates one if required.
		     *
		     * @return {Object} The events storage object.
		     * @api private
		     */
		    proto._getEvents = function _getEvents() {
		        return this._events || (this._events = {});
		    };

		    /**
		     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
		     *
		     * @return {Function} Non conflicting EventEmitter class.
		     */
		    EventEmitter.noConflict = function noConflict() {
		        exports.EventEmitter = originalGlobalValue;
		        return EventEmitter;
		    };

		    // Expose the class either via AMD, CommonJS or the global object
		    if (module.exports){
		        module.exports = EventEmitter;
		    }
		    else {
		        exports.EventEmitter = EventEmitter;
		    }
		}(typeof window !== 'undefined' ? window : commonjsGlobal || {})); 
	} (EventEmitter$1));

	var EventEmitterExports = EventEmitter$1.exports;
	var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(EventEmitterExports);

	/*
		:property.sub1.func().funcProp
		 = return funcProp of function result of sub1 property of property of object
		:{::helperVal}.sub
		 = return sub property of object property with name retrieved from helperVal property of helpers object
		:{::helperFunc()}.sub
		= return sub property of object property with name retrieved from helperVal function result of helpers object.
		if helpersFunx return 'car' then source path becomes :car.sub

	*/

	const SUB_PATH_START = "{",
	    SUB_PATH_END = "}",
	    PATH_SPLIT = ".",
	    PATH_START_OBJECT = ":",
	    PATH_START_HELPERS = "::",
	    FUNCTION_MARKER = "()",
	    MAX_DEEP = 10;

	/**
	 * Set of tools to use notPath property access notation
	 * : is for item
	 * :: is for helpers
	 * {} subpath
	 * . path splitter
	 * () function and should be executed with params (item, helper | undefined)
	 * sub-paths will be parsed and replaced by results in source path
	 */
	let notPath$2 = class notPath {
	    static get SUB_PATH_START() {
	        return SUB_PATH_START;
	    }
	    static get SUB_PATH_END() {
	        return SUB_PATH_END;
	    }
	    static get PATH_SPLIT() {
	        return PATH_SPLIT;
	    }
	    static get PATH_START_OBJECT() {
	        return PATH_START_OBJECT;
	    }
	    static get PATH_START_HELPERS() {
	        return PATH_START_HELPERS;
	    }
	    static get FUNCTION_MARKER() {
	        return FUNCTION_MARKER;
	    }
	    static get MAX_DEEP() {
	        return MAX_DEEP;
	    }

	    /*
			input ':{::helperVal}.sub'
			return ::helperVal
		*/

	    /**
	     * Returns first subpath in path
	     * if subpath not closed will return it anyway
	     * @param {string} path path in string notation
	     * @return {string|null} subpath or null if no sub path were found
	     */
	    static findNextSubPath(path) {
	        let subPath = "",
	            find = false;
	        for (let i = 0; i < path.length; i++) {
	            if (path[i] === SUB_PATH_START) {
	                find = true;
	                subPath = "";
	            } else {
	                if (path[i] === SUB_PATH_END && find) {
	                    return subPath;
	                } else {
	                    subPath += path[i];
	                }
	            }
	        }
	        return find ? subPath : null;
	    }

	    /**
	     * Replace sub-path in parent path by parsed version
	     * @param {string} path path to process
	     * @param {string} sub sub path to replace
	     * @param {string} parsed parsed sub path
	     * @return {string} parsed path
	     */

	    static replaceSubPath(path, sub, parsed) {
	        let subf = SUB_PATH_START + sub + SUB_PATH_END,
	            i = 0;
	        while (path.indexOf(subf) > -1 && i < MAX_DEEP) {
	            path = path.replace(subf, parsed);
	            i++;
	        }
	        return path;
	    }

	    /**
	     * Parses path while there any sub-paths
	     * @param {string} path raw unparsed path
	     * @param {object} item data
	     * @param {object} helpers helpers
	     * @return {string} parsed path
	     */
	    static parseSubs(path, item, helpers) {
	        let subPath = this.findNextSubPath(path),
	            subPathParsed,
	            i = 0;
	        while (subPath) {
	            subPathParsed = this.getValueByPath(
	                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
	                subPath,
	                item,
	                helpers
	            );
	            path = this.replaceSubPath(path, subPath, subPathParsed);
	            i++;
	            if (i > MAX_DEEP) {
	                break;
	            }
	            subPath = this.findNextSubPath(path);
	        }
	        return path;
	    }

	    /**
	     * Get property value
	     * @param {string} path path to property
	     * @param {object} item item object
	     * @param {object} [helpers] helpers object
	     */

	    static get(path, item, helpers = undefined) {
	        switch (path) {
	            case PATH_START_OBJECT:
	                return item;
	            case PATH_START_HELPERS:
	                return helpers;
	        }
	        path = this.parseSubs(path, item, helpers);
	        return this.getValueByPath(
	            path.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
	            path,
	            item,
	            helpers
	        );
	    }

	    /**
	     * Set property value
	     * @param {string}  path path to property
	     * @param {object}  item item object
	     * @param {object}  helpers         helpers object if 4 arguments or attrValue if only 3 provided
	     * @param {any}     [attrValue]     value we want to assign
	     */

	    static set(path, item, helpers, attrValue = undefined) {
	        if (arguments.length === 3) {
	            attrValue = helpers;
	            helpers = undefined;
	        }
	        let subPath = this.findNextSubPath(path),
	            subPathParsed,
	            i = 0;
	        while (subPath) {
	            subPathParsed = this.getValueByPath(
	                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
	                subPath,
	                item,
	                helpers
	            );
	            path = this.replaceSubPath(path, subPath, subPathParsed);
	            if (i > MAX_DEEP) {
	                break;
	            }
	            subPath = this.findNextSubPath(path);
	            i++;
	        }
	        this.setValueByPath(item, path, attrValue);
	        if (
	            item.isRecord &&
	            this.normilizePath(path).length > 1 &&
	            item.__isActive
	        ) {
	            item.trigger("change", item, path, attrValue);
	        }
	    }

	    /**
	     * Set target property to null
	     * @param {string} path path to property
	     * @param {object} item item object
	     * @param {object} helpers helpers object
	     */

	    static unset(path, item, helpers) {
	        this.set(path, item, helpers, null);
	    }

	    /**
	     * Parses step key, transforms it to end-form
	     * @param {string} step not parsed step key
	     * @param {object} item item object
	     * @param {object} helper helpers object
	     * @return {string|number} parsed step key
	     */

	    static parsePathStep(step, item, helper) {
	        let rStep = null;
	        if (step.indexOf(PATH_START_HELPERS) === 0 && helper) {
	            rStep = step.replace(PATH_START_HELPERS, "");
	            if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
	                rStep = rStep.replace(FUNCTION_MARKER, "");
	                if (Object.prototype.hasOwnProperty.call(helper, rStep)) {
	                    return helper[rStep](item, undefined);
	                }
	            } else {
	                return helper[rStep];
	            }
	        } else {
	            if (step.indexOf(PATH_START_OBJECT) === 0 && item) {
	                rStep = step.replace(PATH_START_OBJECT, "");
	                if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
	                    rStep = rStep.replace(FUNCTION_MARKER, "");
	                    if (Object.prototype.hasOwnProperty.call(item, rStep)) {
	                        return item[rStep](item, undefined);
	                    }
	                } else {
	                    return item[rStep];
	                }
	            }
	        }
	        return step;
	    }

	    //::fieldName.result
	    //{}
	    //{fieldName: 'targetRecordField'}
	    ////['targetRecordField', 'result']
	    /**
	     * Transforms path with sub paths to path without
	     * @param {string|array} path path to target property
	     * @param {object} item item object
	     * @param {object} helper helper object
	     * @return {array} parsed path
	     **/
	    static parsePath(path, item, helper) {
	        if (!Array.isArray(path)) {
	            path = path.split(PATH_SPLIT);
	        }
	        for (var i = 0; i < path.length; i++) {
	            path[i] = this.parsePathStep(path[i], item, helper);
	        }
	        return path;
	    }

	    /**
	     * Transforms path from string notation to array of keys
	     * @param {string|array} path  input path, if array does nothing
	     * @return {array} path in array notation
	     */

	    static normilizePath(path) {
	        if (Array.isArray(path)) {
	            return path;
	        } else {
	            while (path.indexOf(PATH_START_OBJECT) > -1) {
	                path = path.replace(PATH_START_OBJECT, "");
	            }
	            return path.split(PATH_SPLIT);
	        }
	    }

	    /*
			small = ["todo"],
			big = ["todo", "length"]
			return true;

		*/

	    /**
	     * Identifies if first path includes second, compared from start,
	     * no floating start position inside ['join', 'me'], ['me']
	     * will result in false
	     * @param {array} big where we will search
	     * @param {array} small what we will search
	     * @return {boolean} if we succeed
	     */

	    static ifFullSubPath(big, small) {
	        if (big.length < small.length) {
	            return false;
	        }
	        for (let t = 0; t < small.length; t++) {
	            if (small[t] !== big[t]) {
	                return false;
	            }
	        }
	        return true;
	    }

	    /**
	     * Getter through third object
	     * Path is parsed, no event triggering for notRecord
	     * @param {object} object object to be used as getter
	     * @param {string|array} attrPath path to property
	     * @param {object} item supporting data
	     * @param {helpers} object  supporting helpers
	     */

	    static getValueByPath(object, attrPath, item, helpers) {
	        attrPath = this.normilizePath(attrPath);
	        let attrName = attrPath.shift(),
	            isFunction = attrName.indexOf(FUNCTION_MARKER) > -1;
	        if (isFunction) {
	            attrName = attrName.replace(FUNCTION_MARKER, "");
	        }
	        if (
	            (typeof object === "object" || typeof object === "function") &&
	            typeof object !== "undefined" &&
	            object !== null &&
	            typeof object[attrName] !== "undefined" &&
	            object[attrName] !== null
	        ) {
	            let newObj = isFunction
	                ? object[attrName]({
	                      item,
	                      helpers,
	                  })
	                : object[attrName];
	            if (attrPath.length > 0) {
	                return this.getValueByPath(newObj, attrPath, item, helpers);
	            } else {
	                return newObj;
	            }
	        } else {
	            return undefined;
	        }
	    }

	    /**
	     * Setter through third object
	     * Path is parsed, no event triggering for notRecord
	     * @param {object} object object to be modified
	     * @param {string|array} attrPath path to property
	     * @param {any} attrValue  value to assign
	     */

	    static setValueByPath(object, attrPath, attrValue) {
	        attrPath = this.normilizePath(attrPath);
	        let attrName = attrPath.shift();
	        if (attrPath.length > 0) {
	            if (!Object.prototype.hasOwnProperty.call(object, attrName)) {
	                object[attrName] = {};
	            }
	            this.setValueByPath(object[attrName], attrPath, attrValue);
	        } else {
	            object[attrName] = attrValue;
	        }
	    }

	    /**
	     * Joins passed in strings with PATH_SPLIT
	     * @param {string} arguments path to be glued
	     * @return {string} composite path
	     */

	    static join() {
	        let args = Array.prototype.slice.call(arguments);
	        return args.join(PATH_SPLIT);
	    }
	};

	var src$1 = notPath$2;

	var notPath = src$1;

	var notPath$1 = /*@__PURE__*/getDefaultExportFromCjs(notPath);

	/*
	https://github.com/TehShrike/is-mergeable-object

	Included for convinience only. All rights belongs to their authors and etc.
	start of my code marked.

	*/

	let isMergeableObject = function isMergeableObject(value) {
	    return isNonNullObject(value) && !isSpecial(value);
	};

	function isNonNullObject(value) {
	    return !!value && typeof value === "object";
	}

	function isSpecial(value) {
	    var stringValue = Object.prototype.toString.call(value);

	    return (
	        stringValue === "[object RegExp]" ||
	        stringValue === "[object Date]" ||
	        isReactElement(value)
	    );
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === "function" && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 0xeac7;

	function isReactElement(value) {
	    return value.$$typeof === REACT_ELEMENT_TYPE;
	}

	/*
	https://github.com/KyleAMathews/deepmerge

	The MIT License (MIT)

	Copyright (c) 2012 Nicholas Fisher

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/

	function emptyTarget(val) {
	    return Array.isArray(val) ? [] : {};
	}

	function cloneUnlessOtherwiseSpecified(value, optionsArgument) {
	    var clone = !optionsArgument || optionsArgument.clone !== false;

	    return clone && isMergeableObject(value)
	        ? deepmerge(emptyTarget(value), value, optionsArgument)
	        : value;
	}

	function defaultArrayMerge(target, source, optionsArgument) {
	    return target.concat(source).map(function (element) {
	        return cloneUnlessOtherwiseSpecified(element, optionsArgument);
	    });
	}

	function mergeObject(target, source, optionsArgument) {
	    var destination = {};
	    if (isMergeableObject(target)) {
	        Object.keys(target).forEach(function (key) {
	            destination[key] = cloneUnlessOtherwiseSpecified(
	                target[key],
	                optionsArgument
	            );
	        });
	    }
	    Object.keys(source).forEach(function (key) {
	        if (!isMergeableObject(source[key]) || !target[key]) {
	            destination[key] = cloneUnlessOtherwiseSpecified(
	                source[key],
	                optionsArgument
	            );
	        } else {
	            destination[key] = deepmerge(
	                target[key],
	                source[key],
	                optionsArgument
	            );
	        }
	    });
	    return destination;
	}

	function deepmerge(target, source, optionsArgument) {
	    var sourceIsArray = Array.isArray(source);
	    var targetIsArray = Array.isArray(target);
	    var options = optionsArgument || {
	        arrayMerge: defaultArrayMerge,
	    };
	    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	    if (!sourceAndTargetTypesMatch) {
	        return cloneUnlessOtherwiseSpecified(source, optionsArgument);
	    } else if (sourceIsArray) {
	        var arrayMerge = options.arrayMerge || defaultArrayMerge;
	        return arrayMerge(target, source, optionsArgument);
	    } else {
	        return mergeObject(target, source, optionsArgument);
	    }
	}

	deepmerge.all = function deepmergeAll(array, optionsArgument) {
	    if (!Array.isArray(array)) {
	        throw new Error("first argument should be an array");
	    }

	    return array.reduce(function (prev, next) {
	        return deepmerge(prev, next, optionsArgument);
	    }, {});
	};

	/**
	 *  Collection of common functions
	 *  @class
	 */
	let notCommon$2 = class notCommon {
	    /**
	     *  @static {Object} [MANAGER=null]  application manager, in some cases used to control initialization routine
	     */
	    static MANAGER = null;
	    /**
	     *  @static {string} [LOG="console"]  logger, window[LOG]
	     */
	    static LOG = "console";
	    /**
	     *  @static {function} deepMerge  function to perform deep merges of objects
	     */
	    static deepMerge = deepmerge;

	    /**
	     *  @static {function} isError  function to perform object test, if it's an error object or not
	     * @param   {object}    e   object to test
	     */
	    static isError(e) {
	        return (
	            e instanceof Error ||
	            (Object.hasOwn(e, "status") && e.status === "error")
	        );
	    }

	    static TZ_OFFSET = (new Date().getTimezoneOffset() / 60) * -1;
	    static DEV_ENV = "production";
	    // @ts-ignore
	    static ENV_TYPE = window.NOT_ENV_TYPE
	        ? // @ts-ignore
	          window.NOT_ENV_TYPE
	        : notCommon.DEV_ENV;
	    static NOOP = () => {};

	    static mute() {
	        notCommon.ENV_TYPE = "production";
	    }

	    static pad(n) {
	        return n < 10 ? "0" + n : n;
	    }
	    /**
	     *  Returns today Date object without hours, minutes, seconds
	     *  @return {number}  current date with 00:00:00 in ms of unix time
	     */
	    static getTodayDate() {
	        let t = new Date();
	        return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();
	    }

	    /**
	     *  Returns true if object has field of name
	     *   @param   {object}    obj    some object
	     *  @param  {string}    name  field name
	     *  @return {boolean}          if object contains field with name
	     **/
	    static objHas(obj, name) {
	        return Object.hasOwn(obj, name);
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	    static copyObj(obj) {
	        return JSON.parse(JSON.stringify(obj));
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	    static partCopyObj(obj, list) {
	        let partObj = Object.keys(obj).reduce((prev, curr) => {
	            if (list.includes(curr)) {
	                prev[curr] = obj[curr];
	            }
	            return prev;
	        }, {});
	        return JSON.parse(JSON.stringify(partObj));
	    }

	    static compareTwoArrays(a, b) {
	        return (
	            a.length === b.length &&
	            a.every((element, index) => element === b[index])
	        );
	    }

	    /**
	     * Test argument type to be 'function'
	     * @param {any}  func    possible function
	     * @return {boolean}     if this is a function
	     **/
	    static isFunc(func) {
	        return typeof func === "function";
	    }

	    /**
	     * Returns true if argument is Async function
	     * @param {function} func  to test
	     * @return {boolean}       if this function is constructed as AsyncFunction
	     **/
	    static isAsync(func) {
	        return func.constructor.name === "AsyncFunction";
	    }

	    /**
	     *  Executes method of object in appropriate way inside Promise
	     * @param {object}   obj     original object
	     * @param {string}   name    method name to execute
	     * @param {Array}     params  array of params
	     * @return {Promise}          results of method execution
	     **/
	    static async executeObjectFunction(obj, name, params) {
	        if (obj) {
	            const proc = notPath$1.get(":" + name, obj);
	            if (notCommon.isFunc(proc)) {
	                if (notCommon.isAsync(proc)) {
	                    return await proc(...params);
	                } else {
	                    return proc(...params);
	                }
	            }
	        }
	    }

	    /**
	     *  Executes method of object in apropriate way inside Promise
	     * @param {Object}   from     original object
	     * @param {Object}   to    method name to execute
	     * @param {Array}     list  array of params
	     * @return {undefined}          results of method execution
	     **/
	    static mapBind(from, to, list) {
	        list.forEach((item) => {
	            if (typeof from[item] === "function") {
	                to[item] = from[item].bind(from);
	            }
	        });
	    }

	    static isClass(fn) {
	        return /^\s*class/.test(fn.toString());
	    }

	    static detectType(testie) {
	        if (typeof testie !== "function") {
	            return typeof testie;
	        } else {
	            if (notCommon.isClass(testie)) {
	                return "class";
	            } else {
	                return "function";
	            }
	        }
	    }

	    //Проверка является ли переменная массивом
	    static isArray(data) {
	        return typeof data == "object" && data instanceof Array;
	    }

	    static localIsoDate(date) {
	        date = date || new Date();
	        let localIsoString =
	            date.getFullYear() +
	            "-" +
	            notCommon.pad(date.getMonth() + 1) +
	            "-" +
	            notCommon.pad(date.getDate()) +
	            "T" +
	            notCommon.pad(date.getHours()) +
	            ":" +
	            notCommon.pad(date.getMinutes()) +
	            ":" +
	            notCommon.pad(date.getSeconds());
	        return localIsoString;
	    }

	    static getToday() {
	        let today = new Date();
	        let date =
	            today.getFullYear() +
	            "-" +
	            notCommon.pad(today.getMonth() + 1) +
	            "-" +
	            notCommon.pad(today.getDate());
	        return date;
	    }

	    static backlog = [];

	    static backlogAdd(msg, type = "log") {
	        if (notCommon.get("backlog") === true) {
	            notCommon.backlog.push({ msg, type });
	        }
	    }

	    static dumpBacklog() {
	        while (notCommon.backlog.length) {
	            let row = notCommon.backlog.shift();
	            window[notCommon.LOG][row.type](...row.msg);
	        }
	    }

	    static logMsg() {
	        let now = notCommon.localIsoDate();
	        // eslint-disable-next-line no-console
	        window[notCommon.LOG].log(`[${now}]: `, ...arguments);
	        notCommon.backlogAdd([`[${now}]: `, ...arguments], "log");
	    }

	    static log() {
	        notCommon.logMsg(...arguments);
	    }

	    static createLogger(prefix) {
	        return {
	            log: notCommon.genLogMsg(prefix),
	            error: notCommon.genLogError(prefix),
	            debug: notCommon.genLogDebug(prefix),
	            report: notCommon.report,
	        };
	    }

	    //Генерация метода вывода сообщений в консоль с указанием префикса.
	    static genLogMsg(prefix) {
	        return function () {
	            //not arrow bc of arguments special var is not available in arrow functions
	            let now = notCommon.localIsoDate();
	            // eslint-disable-next-line no-console
	            window[notCommon.LOG].log(`[${now}]: ${prefix}::`, ...arguments);
	            notCommon.backlogAdd(
	                [`[${now}]: ${prefix}::`, ...arguments],
	                "log"
	            );
	        };
	    }

	    /**
	     * Определяет является ли окружение окружением разработки
	     * @returns  {boolean} true если это запущено в окружении разработки
	     **/
	    static isDev() {
	        return notCommon.ENV_TYPE === notCommon.DEV_ENV;
	    }

	    static debug() {
	        if (notCommon.isDev()) {
	            return notCommon.logMsg(...arguments);
	        } else {
	            return notCommon.NOOP;
	        }
	    }

	    static genLogDebug(prefix) {
	        if (notCommon.isDev()) {
	            return notCommon.genLogMsg(prefix);
	        } else {
	            return notCommon.NOOP;
	        }
	    }

	    static error() {
	        notCommon.logError(...arguments);
	    }

	    //Функция вывода сообщения об ошибке
	    static logError() {
	        let now = notCommon.localIsoDate();
	        // eslint-disable-next-line no-console
	        window[notCommon.LOG].error(`[${now}]: `, ...arguments);
	        notCommon.backlogAdd([`[${now}]: `, ...arguments], "error");
	    }

	    static genLogError(prefix) {
	        return function () {
	            //do not change to arrow function, bc of arguments
	            let now = notCommon.localIsoDate();
	            // eslint-disable-next-line no-console
	            window[notCommon.LOG].error(`[${now}]: ${prefix}::`, ...arguments);
	            notCommon.backlogAdd(
	                [`[${now}]: ${prefix}::`, ...arguments],
	                "error"
	            );
	        };
	    }

	    static report(e) {
	        if (notCommon.getApp()) {
	            let reporter = notCommon.getApp().getService("nsErrorReporter");
	            if (reporter) {
	                reporter.report(e).catch(notCommon.error);
	            }
	        } else {
	            if (!notCommon.get("production")) {
	                notCommon.error(...arguments);
	            }
	        }
	    }

	    static trace() {
	        if (!notCommon.get("production")) {
	            notCommon.trace(...arguments);
	        }
	    }

	    static trimBackslash(str) {
	        if (str.indexOf("/") === 0) {
	            str = str.substring(1);
	        }
	        if (str[str.length - 1] === "/") {
	            str = str.substring(0, str.length - 1);
	        }
	        return str;
	    }

	    /**
	     *  Builds URL with structure like prefix/module/model/id/action
	     * If some part absent or set to false it will be excluded from result
	     *  @param {object} urlParts
	     *  @param {string} [urlParts.prefix='']
	     *  @param {string} [urlParts.module='']
	     *  @param {string} [urlParts.model='']
	     *  @param {string} [urlParts.id='']
	     *  @param {string} [urlParts.action='']
	     *  @return {string}  url path
	     */
	    static buildURL(
	        { prefix, module, model, id, action } = {
	            prefix: "",
	            module: "",
	            model: "",
	            id: "",
	            action: "",
	        }
	    ) {
	        let url = ["/"];
	        if (prefix) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(prefix)));
	        }
	        if (module) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(module)));
	        }
	        if (model) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(model)));
	        }
	        if (id) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(id)));
	        }
	        if (action) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(action)));
	        }
	        url = url.filter((el) => el !== "");
	        return url.join("/").replace(/\/\//g, "/");
	    }

	    static capitalizeFirstLetter(name) {
	        return name.charAt(0).toUpperCase() + name.slice(1);
	    }

	    static lowerFirstLetter(string) {
	        return string.charAt(0).toLowerCase() + string.slice(1);
	    }

	    static strLengthCap(str, MAX_TITLE_LENGTH = 50, POST_FIX = "...") {
	        if (typeof str === "string" && str.length > MAX_TITLE_LENGTH) {
	            return str.substr(0, MAX_TITLE_LENGTH) + POST_FIX;
	        } else {
	            return str;
	        }
	    }

	    static escapeHtml(unsafe) {
	        return unsafe
	            .replace(/&/g, "&amp;")
	            .replace(/</g, "&lt;")
	            .replace(/>/g, "&gt;")
	            .replace(/"/g, "&quot;")
	            .replace(/'/g, "&#039;");
	    }

	    static startApp(starter) {
	        document.addEventListener("DOMContentLoaded", starter);
	    }

	    static getApp() {
	        return notCommon.get("app");
	    }

	    static extendAppConfig(conf, conf2) {
	        return notCommon.deepMerge(conf, conf2);
	    }

	    static absorbModule() {
	        let defaultConf, //app options
	            mod, //module options
	            targets = {}; //various collections
	        if (arguments.length == 1) {
	            targets = { ...arguments[0] };
	            if (Object.hasOwnProperty.call(arguments[0], "defaultConf")) {
	                defaultConf = arguments[0].defaultConf;
	                delete targets.defaultConf;
	            }
	            if (Object.hasOwnProperty.call(arguments[0], "mod")) {
	                mod = arguments[0].mod;
	                delete targets.mod;
	            }
	        } else {
	            notCommon.log(
	                "WARNING: absorbModule format obsoleted, use object {defaultConf, mod, services, uis, wsc, etc}"
	            );
	            defaultConf = arguments[0];
	            mod = arguments[1];
	            if (arguments.length > 2) {
	                targets.services = arguments[2];
	            }
	            if (arguments.length > 3) {
	                targets.uis = arguments[3];
	            }
	            if (arguments.length > 4) {
	                targets.wcs = arguments[4];
	            }
	        }
	        for (let prop in mod) {
	            //add manifest to other
	            if (prop === "manifest") {
	                defaultConf = notCommon.extendAppConfig(
	                    defaultConf,
	                    mod.manifest
	                );
	                continue;
	            }
	            if (typeof notCommon.get(`absorb.${prop}`) === "function") {
	                if (!Object.hasOwn(targets, prop)) {
	                    targets[prop] = {};
	                    notCommon.log(
	                        `WARNING: no accamulator object provided for '${prop}' collection`
	                    );
	                }
	                notCommon.get(`absorb.${prop}`)(targets[prop], mod[prop]);
	            } else if (prop.indexOf("nc") === 0) {
	                if (!Object.hasOwn(defaultConf, "controllers")) {
	                    defaultConf.controllers = {};
	                }
	                defaultConf.controllers[prop] = mod[prop];
	            } else {
	                //in case of some other stuff presented, isolating it in special var
	                if (!Object.hasOwn(window, "notEnv")) {
	                    // @ts-ignore
	                    window.notEnv = {};
	                }
	                // @ts-ignore
	                window.notEnv[prop] = mod[prop];
	            }
	        }
	        return defaultConf;
	    }

	    static defineIfNotExists(obj, key, defaultValue) {
	        if (!Object.hasOwn(obj, key)) {
	            obj[key] = defaultValue;
	        }
	    }

	    static registry = {};

	    static register(key, val) {
	        notCommon.registry[key] = val;
	    }

	    static get(key) {
	        return Object.hasOwn(notCommon.registry, key)
	            ? notCommon.registry[key]
	            : null;
	    }

	    static moveItem(array, old_index, new_index) {
	        const inRange = (num) => num < array.length && num > -1;
	        if (inRange(new_index) && inRange(old_index)) {
	            array.splice(new_index, 0, array.splice(old_index, 1)[0]);
	        }
	    }

	    static stripProxy(obj) {
	        if (typeof obj !== "undefined" && obj !== null) {
	            if (obj.isProxy) {
	                if (Array.isArray(obj)) {
	                    obj = Array.from(obj);
	                } else {
	                    obj = Object.assign({}, obj);
	                }
	                for (let t in obj) {
	                    if (Object.hasOwn(obj, t)) {
	                        obj[t] = notCommon.stripProxy(obj[t]);
	                    }
	                }
	            }
	        }
	        return obj;
	    }

	    static pipe(data /* feed data */, funcs /* functions array */) {
	        let result;
	        for (let func of funcs) {
	            result = func(result || data);
	        }
	        return result;
	    }

	    static getAPI(type) {
	        return notCommon.getManager()
	            ? // @ts-ignore
	              notCommon.getManager()?.getAPI(type)
	            : null;
	    }

	    static setManager(v) {
	        notCommon.MANAGER = v;
	    }

	    static getManager() {
	        return notCommon.MANAGER;
	    }

	    static getJSON(url) {
	        return fetch(url).then((response) => response.json());
	    }

	    static wait(sec) {
	        return new Promise((res) => {
	            setTimeout(res, sec * 1000);
	        });
	    }

	    static registerWidgetEvents(events) {
	        if (notCommon.getApp()) {
	            Object.keys(events).forEach((eventName) => {
	                notCommon.getApp().on(eventName, events[eventName]);
	            });
	        }
	    }

	    static navigate(url) {
	        notCommon.getApp() &&
	            notCommon.getApp().getWorking("router").navigate(url);
	    }

	    static select(variantsSet, value, def) {
	        if (
	            variantsSet &&
	            typeof variantsSet == "object" &&
	            notCommon.objHas(variantsSet, value) &&
	            typeof variantsSet[value] !== "undefined" &&
	            variantsSet[value] !== null
	        ) {
	            return variantsSet[value];
	        } else {
	            return def;
	        }
	    }
	};

	function absorbServices(target, src) {
	    if (target) {
	        for (let serv in src) {
	            if (Object.hasOwn(target, serv)) {
	                notCommon$2.logError(`services property duplication ${serv}`);
	            }
	            target[serv] = src[serv];
	        }
	    }
	}

	function extendWSClient(wcs, wscName, wscOptions) {
	    if (!Object.hasOwn(wcs, wscName)) {
	        wcs[wscName] = {
	            connection: {},
	            router: {
	                routes: {},
	            },
	            messenger: {},
	        };
	    }
	    let target = wcs[wscName];
	    if (Object.hasOwn(wscOptions, "router")) {
	        if (Object.hasOwn(wscOptions.router, "routes")) {
	            for (let routeType in wscOptions.router.routes) {
	                if (!Object.hasOwn(target.router.routes, routeType)) {
	                    target.router.routes[routeType] = {};
	                }
	                Object.assign(target.router.routes[routeType], {
	                    ...wscOptions.router.routes[routeType],
	                });
	            }
	        }
	    }
	    if (Object.hasOwn(wscOptions, "messenger")) {
	        Object.assign(target.messenger, { ...wscOptions.messenger });
	    }
	    if (Object.hasOwn(wscOptions, "connection")) {
	        Object.assign(target.connection, { ...wscOptions.connection });
	    }
	    for (let t of ["name", "getToken", "logger", "identity", "credentials"]) {
	        if (Object.hasOwn(wscOptions, t)) {
	            target[t] = wscOptions[t];
	        }
	    }
	}

	function absorbWSC(target, src) {
	    if (target) {
	        for (let wsClientName in src) {
	            extendWSClient(target, wsClientName, src[wsClientName]);
	        }
	    }
	}

	function absorbUIs(target, src) {
	    if (target) {
	        for (let ui in src) {
	            if (Object.hasOwn(target, ui)) {
	                notCommon$2.logError(`uis property duplication ${ui}`);
	            }
	            target[ui] = src[ui];
	        }
	    }
	}

	function absorbFields(target, src) {
	    if (target) {
	        for (let ui in src) {
	            if (Object.hasOwn(target, ui)) {
	                notCommon$2.logError(`fields property duplication ${ui}`);
	            }
	            target[ui] = src[ui];
	        }
	    }
	}

	notCommon$2.register("absorb.wsc", absorbWSC);
	notCommon$2.register("absorb.services", absorbServices);
	notCommon$2.register("absorb.uis", absorbUIs);
	notCommon$2.register("absorb.uis", absorbFields);

	/**
	 * Purpose of this Locale object is that it will hold library of localization
	 * templates and provide basic localization service to other modules
	 **/


	/**
	 * strings localization and formating model
	 * @class
	 */
	class notLocale extends EventEmitter {
	    constructor() {
	        super();
	        this.dict = {}; //dictionary of phrases
	        this.helpers = {}; //additional helper functions and constants
	        let dict = this.restoreFromStorage();
	        if (dict) {
	            this.set(dict);
	        }
	    }

	    /**
	     * String format should comply notPath standart.
	     * {path_to_access} - is
	     * : - is used to access to params
	     * :: - is used to access to helpers
	     * Welcome, {:where}! - will replace {:where} with content of params.where
	     * Welcome, {::where}! - will replace {:where} with content of this.helpers.where
	     * () - after path is to invoke function of target object
	     * Welcome, {::where()}! - will try to exec this.helpers.where(params, undefined)
	     * @param    {string}  str         localized string template with mark to include data
	     * @param    {object}  params      params to use in string
	     * @returns  {string}              localized version of string with
	     */
	    format(str, params) {
	        return notPath$1.parseSubs(str, params, this.helpers);
	    }

	    /**
	     * Return localized version of string with injected data from provided object
	     * may also use Locale.helpers as source of data
	     * @param {string}   phrase    name of string to localize
	     * @param {object}   params    object with data to inject in phrase template
	     * @return {string}            localized string with injected data
	     */
	    say(phrase, params = false) {
	        try {
	            if (notCommon$2.objHas(this.dict, phrase)) {
	                let tmpl = this.dict[phrase],
	                    result = "";
	                if (params) {
	                    result = this.format(tmpl, params);
	                } else {
	                    result = tmpl;
	                }
	                return result;
	            } else {
	                throw new Error(`Unknown locale phrase: ${phrase}`);
	            }
	        } catch (e) {
	            notCommon$2.debug(e);
	            return phrase;
	        }
	    }

	    /**
	     * Setting new dictionary. triggers event 'change'
	     * @param {object}     dict      vocabulary of phrases and templates
	     **/
	    set(dict) {
	        LOCALE.set(dict);
	        this.saveToStorage(dict);
	        this.dict = Object.assign({}, { ...dict });
	        this.emit("change");
	    }

	    saveToStorage(dict) {
	        if (window.localStorage) {
	            try {
	                return window.localStorage.setItem(
	                    "dictionary",
	                    JSON.stringify(dict)
	                );
	            } catch (e) {
	                notCommon$2.debug(e);
	                return false;
	            }
	        }
	        return false;
	    }

	    restoreFromStorage() {
	        if (window.localStorage) {
	            try {
	                let str = window.localStorage.getItem("dictionary");
	                if (str) {
	                    let dict = JSON.parse(str);
	                    return dict;
	                } else {
	                    return false;
	                }
	            } catch (e) {
	                notCommon$2.debug(e);
	                return false;
	            }
	        }
	        return false;
	    }

	    /**
	     * Returns writable store of phrases
	     * @return {object}  writable store
	     */
	    vocabulary() {
	        return LOCALE;
	    }
	}

	var notLocale$1 = new notLocale();

	notLocale$1.say.bind(notLocale$1);

	/* node_modules/not-bulma/src/elements/various/ui.tag.svelte generated by Svelte v4.2.19 */

	function create_if_block$Z(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[13][/*title*/ ctx[0]] + "";
		let t;
		let span_id_value;
		let span_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "id", span_id_value = "tag-" + /*id*/ ctx[1]);

				attr(span, "class", span_class_value = "tag " + (/*bold*/ ctx[5] ? 'has-text-weight-bold' : '') + " " + (/*padding*/ ctx[4] !== 'normal'
				? `is-padded-${/*padding*/ ctx[4]}`
				: '') + " is-" + /*size*/ ctx[3] + " is-" + /*color*/ ctx[2] + " " + (/*sided*/ ctx[12] ? 'is-sided' : '') + " " + (/*right*/ ctx[6] ? 'is-sided-right' : '') + " " + (/*left*/ ctx[7] ? 'is-sided-left' : '') + " " + (/*top*/ ctx[8] ? 'is-sided-top' : '') + " " + (/*bottom*/ ctx[9] ? 'is-sided-bottom' : '') + " " + /*classes*/ ctx[10]);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);

				if (!mounted) {
					dispose = listen(span, "click", function () {
						if (is_function(/*action*/ ctx[11] ? /*action*/ ctx[11] : undefined)) (/*action*/ ctx[11] ? /*action*/ ctx[11] : undefined).apply(this, arguments);
					});

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty & /*$LOCALE, title*/ 8193 && t_value !== (t_value = /*$LOCALE*/ ctx[13][/*title*/ ctx[0]] + "")) set_data(t, t_value);

				if (dirty & /*id*/ 2 && span_id_value !== (span_id_value = "tag-" + /*id*/ ctx[1])) {
					attr(span, "id", span_id_value);
				}

				if (dirty & /*bold, padding, size, color, sided, right, left, top, bottom, classes*/ 6140 && span_class_value !== (span_class_value = "tag " + (/*bold*/ ctx[5] ? 'has-text-weight-bold' : '') + " " + (/*padding*/ ctx[4] !== 'normal'
				? `is-padded-${/*padding*/ ctx[4]}`
				: '') + " is-" + /*size*/ ctx[3] + " is-" + /*color*/ ctx[2] + " " + (/*sided*/ ctx[12] ? 'is-sided' : '') + " " + (/*right*/ ctx[6] ? 'is-sided-right' : '') + " " + (/*left*/ ctx[7] ? 'is-sided-left' : '') + " " + (/*top*/ ctx[8] ? 'is-sided-top' : '') + " " + (/*bottom*/ ctx[9] ? 'is-sided-bottom' : '') + " " + /*classes*/ ctx[10])) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$1F(ctx) {
		let if_block_anchor;
		let if_block = /*title*/ ctx[0] && create_if_block$Z(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*title*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$Z(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$1E($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let { id = "tagId" } = $$props;
		let { title = "tag" } = $$props;
		let { color = "info" } = $$props;
		let { size = "normal" } = $$props;
		let { padding = "normal" } = $$props;
		let { bold = false } = $$props;
		let { right = false } = $$props;
		let { left = false } = $$props;
		let { top = false } = $$props;
		let { bottom = false } = $$props;
		let { classes = "" } = $$props;
		let sided = false;
		let { events = {} } = $$props;
		let { register = notCommon$2.registerWidgetEvents.bind(notCommon$2) } = $$props;

		let { onUpdate = data => {
			if (Object.hasOwn(data, "title")) {
				$$invalidate(0, title = data.title);
			}
		} } = $$props;

		let { action = () => {
			return true;
		} } = $$props;

		function getStandartUpdateEventName() {
			return `tag-${id}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events, getStandartUpdateEventName())) {
				$$invalidate(14, events[getStandartUpdateEventName()] = onUpdate, events);
			}

			register(events);
		});

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(1, id = $$props.id);
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('color' in $$props) $$invalidate(2, color = $$props.color);
			if ('size' in $$props) $$invalidate(3, size = $$props.size);
			if ('padding' in $$props) $$invalidate(4, padding = $$props.padding);
			if ('bold' in $$props) $$invalidate(5, bold = $$props.bold);
			if ('right' in $$props) $$invalidate(6, right = $$props.right);
			if ('left' in $$props) $$invalidate(7, left = $$props.left);
			if ('top' in $$props) $$invalidate(8, top = $$props.top);
			if ('bottom' in $$props) $$invalidate(9, bottom = $$props.bottom);
			if ('classes' in $$props) $$invalidate(10, classes = $$props.classes);
			if ('events' in $$props) $$invalidate(14, events = $$props.events);
			if ('register' in $$props) $$invalidate(15, register = $$props.register);
			if ('onUpdate' in $$props) $$invalidate(16, onUpdate = $$props.onUpdate);
			if ('action' in $$props) $$invalidate(11, action = $$props.action);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*right, left, top, bottom*/ 960) {
				$$invalidate(12, sided = right || left || top || bottom);
			}
		};

		return [
			title,
			id,
			color,
			size,
			padding,
			bold,
			right,
			left,
			top,
			bottom,
			classes,
			action,
			sided,
			$LOCALE,
			events,
			register,
			onUpdate
		];
	}

	class Ui_tag extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1E, create_fragment$1F, safe_not_equal, {
				id: 1,
				title: 0,
				color: 2,
				size: 3,
				padding: 4,
				bold: 5,
				right: 6,
				left: 7,
				top: 8,
				bottom: 9,
				classes: 10,
				events: 14,
				register: 15,
				onUpdate: 16,
				action: 11
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.boolean.svelte generated by Svelte v4.2.19 */

	function create_fragment$1E(ctx) {
		let uitag;
		let current;
		const uitag_spread_levels = [/*tagValue*/ ctx[0]];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uitag_changes = (dirty & /*tagValue*/ 1)
				? get_spread_update(uitag_spread_levels, [get_spread_object(/*tagValue*/ ctx[0])])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	function instance$1D($$self, $$props, $$invalidate) {
		let tagValue;
		let { LC_TRUE = "not-node:booleans_true" } = $$props;
		let { LC_FALSE = "not-node:booleans_false" } = $$props;
		let { value } = $$props;
		let { inverted = false } = $$props;

		const FALSE_VALUE = {
			title: LC_FALSE,
			color: inverted ? "success" : "danger"
		};

		const TRUE_VALUE = {
			title: LC_TRUE,
			color: inverted ? "danger" : "success"
		};

		$$self.$$set = $$props => {
			if ('LC_TRUE' in $$props) $$invalidate(1, LC_TRUE = $$props.LC_TRUE);
			if ('LC_FALSE' in $$props) $$invalidate(2, LC_FALSE = $$props.LC_FALSE);
			if ('value' in $$props) $$invalidate(3, value = $$props.value);
			if ('inverted' in $$props) $$invalidate(4, inverted = $$props.inverted);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value*/ 8) {
				//if inverted === true, inverts value
				$$invalidate(0, tagValue = value ? TRUE_VALUE : FALSE_VALUE);
			}
		};

		return [tagValue, LC_TRUE, LC_FALSE, value, inverted];
	}

	class Ui_boolean extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1D, create_fragment$1E, safe_not_equal, {
				LC_TRUE: 1,
				LC_FALSE: 2,
				value: 3,
				inverted: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.boolean.labeled.svelte generated by Svelte v4.2.19 */

	function create_fragment$1D(ctx) {
		let span;
		let t0_value = /*$LOCALE*/ ctx[3][/*label*/ ctx[1]] + "";
		let t0;
		let t1;
		let uiboolean;
		let current;

		uiboolean = new Ui_boolean({
				props: {
					value: /*value*/ ctx[0],
					inverted: /*inverted*/ ctx[2]
				}
			});

		return {
			c() {
				span = element("span");
				t0 = text(t0_value);
				t1 = text(": ");
				create_component(uiboolean.$$.fragment);
				attr(span, "class", "label");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t0);
				append(span, t1);
				mount_component(uiboolean, span, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if ((!current || dirty & /*$LOCALE, label*/ 10) && t0_value !== (t0_value = /*$LOCALE*/ ctx[3][/*label*/ ctx[1]] + "")) set_data(t0, t0_value);
				const uiboolean_changes = {};
				if (dirty & /*value*/ 1) uiboolean_changes.value = /*value*/ ctx[0];
				if (dirty & /*inverted*/ 4) uiboolean_changes.inverted = /*inverted*/ ctx[2];
				uiboolean.$set(uiboolean_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiboolean.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiboolean.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				destroy_component(uiboolean);
			}
		};
	}

	function instance$1C($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { value } = $$props;
		let { label } = $$props;
		let { inverted = false } = $$props;

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
			if ('inverted' in $$props) $$invalidate(2, inverted = $$props.inverted);
		};

		return [value, label, inverted, $LOCALE];
	}

	class Ui_boolean_labeled extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1C, create_fragment$1D, safe_not_equal, { value: 0, label: 1, inverted: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.booleans.svelte generated by Svelte v4.2.19 */

	function get_each_context$p(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[3] = list[i];
		return child_ctx;
	}

	// (9:0) {#each values as item}
	function create_each_block$p(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*item*/ ctx[3],
			{
				inverted: /*inverted*/ ctx[1] || /*item*/ ctx[3].inverted
			}
		];

		var switch_value = /*componentConstructor*/ ctx[2];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*values, inverted*/ 3) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[3]),
					{
						inverted: /*inverted*/ ctx[1] || /*item*/ ctx[3].inverted
					}
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*componentConstructor*/ 4 && switch_value !== (switch_value = /*componentConstructor*/ ctx[2])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*values, inverted*/ 3)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[3]),
							{
								inverted: /*inverted*/ ctx[1] || /*item*/ ctx[3].inverted
							}
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1C(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$p(get_each_context$p(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*componentConstructor, values, inverted*/ 7) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$p(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$p(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$1B($$self, $$props, $$invalidate) {
		let { values = [] } = $$props;
		let { inverted = false } = $$props;
		let { componentConstructor = Ui_boolean } = $$props;

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
			if ('inverted' in $$props) $$invalidate(1, inverted = $$props.inverted);
			if ('componentConstructor' in $$props) $$invalidate(2, componentConstructor = $$props.componentConstructor);
		};

		return [values, inverted, componentConstructor];
	}

	class Ui_booleans extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1B, create_fragment$1C, safe_not_equal, {
				values: 0,
				inverted: 1,
				componentConstructor: 2
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.censored.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$M(ctx) {
		let span;
		let i;
		let i_class_value;
		let span_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*copyIcon*/ ctx[3]);

				attr(span, "class", span_class_value = "icon is-small is-right is-clickable " + (/*tooltipActive*/ ctx[10]
				? ` ${/*tooltipClass*/ ctx[8]} `
				: "") + " is-vertical-middle");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
				/*span_binding*/ ctx[18](span);

				if (!mounted) {
					dispose = listen(span, "click", /*copyContent*/ ctx[13]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*copyIcon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*copyIcon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}

				if (dirty & /*tooltipActive, tooltipClass*/ 1280 && span_class_value !== (span_class_value = "icon is-small is-right is-clickable " + (/*tooltipActive*/ ctx[10]
				? ` ${/*tooltipClass*/ ctx[8]} `
				: "") + " is-vertical-middle")) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				/*span_binding*/ ctx[18](null);
				mounted = false;
				dispose();
			}
		};
	}

	// (61:0) {#if showable}
	function create_if_block$Y(ctx) {
		let span;
		let i;
		let i_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				i = element("i");

				attr(i, "class", i_class_value = "fas fa-" + (/*hidden*/ ctx[0]
				? /*showIcon*/ ctx[4]
				: /*hideIcon*/ ctx[5]));

				attr(span, "class", "icon is-small is-right is-clickable is-vertical-middle");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);

				if (!mounted) {
					dispose = listen(span, "click", /*toggleView*/ ctx[12]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*hidden, showIcon, hideIcon*/ 49 && i_class_value !== (i_class_value = "fas fa-" + (/*hidden*/ ctx[0]
				? /*showIcon*/ ctx[4]
				: /*hideIcon*/ ctx[5]))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$1B(ctx) {
		let span;
		let t0_value = (/*hidden*/ ctx[0] ? "" : /*value*/ ctx[9]) + "";
		let t0;
		let span_class_value;
		let span_style_value;
		let t1;
		let t2;
		let if_block1_anchor;
		let if_block0 = /*copiable*/ ctx[2] && create_if_block_1$M(ctx);
		let if_block1 = /*showable*/ ctx[1] && create_if_block$Y(ctx);

		return {
			c() {
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();

				attr(span, "class", span_class_value = (/*hidden*/ ctx[0]
				? "is-censored " + /*shadowClass*/ ctx[7]
				: "") + " is-vertical-middle ");

				attr(span, "style", span_style_value = `display:inline-block; width: ${/*maxLength*/ ctx[6]}rem; height: var(--bulma-size-medium); overflow-x:hidden;`);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t0);
				insert(target, t1, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t2, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (dirty & /*hidden, value*/ 513 && t0_value !== (t0_value = (/*hidden*/ ctx[0] ? "" : /*value*/ ctx[9]) + "")) set_data(t0, t0_value);

				if (dirty & /*hidden, shadowClass*/ 129 && span_class_value !== (span_class_value = (/*hidden*/ ctx[0]
				? "is-censored " + /*shadowClass*/ ctx[7]
				: "") + " is-vertical-middle ")) {
					attr(span, "class", span_class_value);
				}

				if (dirty & /*maxLength*/ 64 && span_style_value !== (span_style_value = `display:inline-block; width: ${/*maxLength*/ ctx[6]}rem; height: var(--bulma-size-medium); overflow-x:hidden;`)) {
					attr(span, "style", span_style_value);
				}

				if (/*copiable*/ ctx[2]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$M(ctx);
						if_block0.c();
						if_block0.m(t2.parentNode, t2);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*showable*/ ctx[1]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$Y(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
					detach(t1);
					detach(t2);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	function instance$1A($$self, $$props, $$invalidate) {
		let { hidden = true } = $$props;
		let { showable = true } = $$props;
		let { copiable = true } = $$props;
		let { copyIcon = "copy" } = $$props;
		let { showIcon = "eye" } = $$props;
		let { hideIcon = "eye-slash" } = $$props;
		let { maxLength = 20 } = $$props;
		let { shadowClass = "has-background-primary-90" } = $$props;
		let { tooltip = true } = $$props;
		let { tooltipTTL = 2000 } = $$props;
		let { tooltipText = "Скопировано в буфер" } = $$props;
		let { tooltipClass = "has-tooltip-info" } = $$props;
		let { value = "" } = $$props;

		function toggleView() {
			$$invalidate(0, hidden = !hidden);
		}

		let contentCopied = false, tooltipActive, tooltipTarget;

		async function copyContent() {
			try {
				await navigator.clipboard.writeText(value);

				if (tooltip) {
					$$invalidate(17, contentCopied = true);
					$$invalidate(11, tooltipTarget.dataset.tooltip = tooltipText, tooltipTarget);

					setTimeout(
						() => {
							$$invalidate(17, contentCopied = false);
							tooltipTarget.removeAttribute("data-tooltip");
						},
						tooltipTTL
					);
				}
			} catch(err) {
				console.error("Failed to copy: ", err);
			}
		}

		function span_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				tooltipTarget = $$value;
				$$invalidate(11, tooltipTarget);
			});
		}

		$$self.$$set = $$props => {
			if ('hidden' in $$props) $$invalidate(0, hidden = $$props.hidden);
			if ('showable' in $$props) $$invalidate(1, showable = $$props.showable);
			if ('copiable' in $$props) $$invalidate(2, copiable = $$props.copiable);
			if ('copyIcon' in $$props) $$invalidate(3, copyIcon = $$props.copyIcon);
			if ('showIcon' in $$props) $$invalidate(4, showIcon = $$props.showIcon);
			if ('hideIcon' in $$props) $$invalidate(5, hideIcon = $$props.hideIcon);
			if ('maxLength' in $$props) $$invalidate(6, maxLength = $$props.maxLength);
			if ('shadowClass' in $$props) $$invalidate(7, shadowClass = $$props.shadowClass);
			if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
			if ('tooltipTTL' in $$props) $$invalidate(15, tooltipTTL = $$props.tooltipTTL);
			if ('tooltipText' in $$props) $$invalidate(16, tooltipText = $$props.tooltipText);
			if ('tooltipClass' in $$props) $$invalidate(8, tooltipClass = $$props.tooltipClass);
			if ('value' in $$props) $$invalidate(9, value = $$props.value);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*tooltip, contentCopied*/ 147456) {
				$$invalidate(10, tooltipActive = tooltip && contentCopied);
			}
		};

		return [
			hidden,
			showable,
			copiable,
			copyIcon,
			showIcon,
			hideIcon,
			maxLength,
			shadowClass,
			tooltipClass,
			value,
			tooltipActive,
			tooltipTarget,
			toggleView,
			copyContent,
			tooltip,
			tooltipTTL,
			tooltipText,
			contentCopied,
			span_binding
		];
	}

	class Ui_censored extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1A, create_fragment$1B, safe_not_equal, {
				hidden: 0,
				showable: 1,
				copiable: 2,
				copyIcon: 3,
				showIcon: 4,
				hideIcon: 5,
				maxLength: 6,
				shadowClass: 7,
				tooltip: 14,
				tooltipTTL: 15,
				tooltipText: 16,
				tooltipClass: 8,
				value: 9
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.indicator.svelte generated by Svelte v4.2.19 */

	function create_fragment$1A(ctx) {
		let span;
		let t_value = /*labels*/ ctx[2][/*state*/ ctx[0]] + "";
		let t;
		let span_class_value;

		return {
			c() {
				span = element("span");
				t = text(t_value);

				attr(span, "class", span_class_value = "tag is-" + /*size*/ ctx[1] + " " + (/*bold*/ ctx[5] ? 'has-text-weight-bold' : '') + " " + (/*padding*/ ctx[4] !== 'normal'
				? `is-padded-${/*padding*/ ctx[4]}`
				: '') + " " + (/*sided*/ ctx[10] ? 'is-sided' : '') + " " + (/*right*/ ctx[6] ? 'is-sided-right' : '') + " " + (/*left*/ ctx[7] ? 'is-sided-left' : '') + " " + (/*top*/ ctx[8] ? 'is-sided-top' : '') + " " + (/*bottom*/ ctx[9] ? 'is-sided-bottom' : '') + " is-" + /*state*/ ctx[0] + " " + /*classes*/ ctx[3] + "");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, [dirty]) {
				if (dirty & /*labels, state*/ 5 && t_value !== (t_value = /*labels*/ ctx[2][/*state*/ ctx[0]] + "")) set_data(t, t_value);

				if (dirty & /*size, bold, padding, sided, right, left, top, bottom, state, classes*/ 2043 && span_class_value !== (span_class_value = "tag is-" + /*size*/ ctx[1] + " " + (/*bold*/ ctx[5] ? 'has-text-weight-bold' : '') + " " + (/*padding*/ ctx[4] !== 'normal'
				? `is-padded-${/*padding*/ ctx[4]}`
				: '') + " " + (/*sided*/ ctx[10] ? 'is-sided' : '') + " " + (/*right*/ ctx[6] ? 'is-sided-right' : '') + " " + (/*left*/ ctx[7] ? 'is-sided-left' : '') + " " + (/*top*/ ctx[8] ? 'is-sided-top' : '') + " " + (/*bottom*/ ctx[9] ? 'is-sided-bottom' : '') + " is-" + /*state*/ ctx[0] + " " + /*classes*/ ctx[3] + "")) {
					attr(span, "class", span_class_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function instance$1z($$self, $$props, $$invalidate) {
		let { id = "tagId" } = $$props;
		let { state = "light" } = $$props;
		let { size = "normal" } = $$props;

		let { labels = {
			black: "black",
			dark: "dark",
			light: "light",
			white: "white",
			primary: "primary",
			link: "link",
			info: "info",
			success: "success",
			warning: "warning",
			danger: "danger"
		} } = $$props;

		let { classes = "mx-1" } = $$props;
		let { padding = "normal" } = $$props;
		let { bold = false } = $$props;
		let { right = false } = $$props;
		let { left = false } = $$props;
		let { top = false } = $$props;
		let { bottom = false } = $$props;
		let sided = false;
		let { events = {} } = $$props;
		let { register = notCommon$2.registerWidgetEvents.bind(notCommon$2) } = $$props;

		let { onUpdate = data => {
			if (Object.hasOwn(data, "state")) {
				$$invalidate(0, state = data.state);
			}
		} } = $$props;

		function getStandartUpdateEventName() {
			return `indicator-${id}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events, getStandartUpdateEventName())) {
				$$invalidate(11, events[getStandartUpdateEventName()] = onUpdate, events);
			}

			register(events);
		});

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(12, id = $$props.id);
			if ('state' in $$props) $$invalidate(0, state = $$props.state);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
			if ('labels' in $$props) $$invalidate(2, labels = $$props.labels);
			if ('classes' in $$props) $$invalidate(3, classes = $$props.classes);
			if ('padding' in $$props) $$invalidate(4, padding = $$props.padding);
			if ('bold' in $$props) $$invalidate(5, bold = $$props.bold);
			if ('right' in $$props) $$invalidate(6, right = $$props.right);
			if ('left' in $$props) $$invalidate(7, left = $$props.left);
			if ('top' in $$props) $$invalidate(8, top = $$props.top);
			if ('bottom' in $$props) $$invalidate(9, bottom = $$props.bottom);
			if ('events' in $$props) $$invalidate(11, events = $$props.events);
			if ('register' in $$props) $$invalidate(13, register = $$props.register);
			if ('onUpdate' in $$props) $$invalidate(14, onUpdate = $$props.onUpdate);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*right, left, top, bottom*/ 960) {
				$$invalidate(10, sided = right || left || top || bottom);
			}
		};

		return [
			state,
			size,
			labels,
			classes,
			padding,
			bold,
			right,
			left,
			top,
			bottom,
			sided,
			events,
			id,
			register,
			onUpdate
		];
	}

	class Ui_indicator extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1z, create_fragment$1A, safe_not_equal, {
				id: 12,
				state: 0,
				size: 1,
				labels: 2,
				classes: 3,
				padding: 4,
				bold: 5,
				right: 6,
				left: 7,
				top: 8,
				bottom: 9,
				events: 11,
				register: 13,
				onUpdate: 14
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.loader.svelte generated by Svelte v4.2.19 */

	function create_if_block$X(ctx) {
		let div;
		let span;
		let t_value = /*$LOCALE*/ ctx[3][/*title*/ ctx[2]] + "";
		let t;
		let div_class_value;

		return {
			c() {
				div = element("div");
				span = element("span");
				t = text(t_value);
				attr(span, "class", "title");

				attr(div, "class", div_class_value = "" + ((/*size*/ ctx[1] === 'page'
				? 'pageloader'
				: 'containerloader') + " " + (/*loading*/ ctx[0] ? 'is-active' : '')));
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, title*/ 12 && t_value !== (t_value = /*$LOCALE*/ ctx[3][/*title*/ ctx[2]] + "")) set_data(t, t_value);

				if (dirty & /*size, loading*/ 3 && div_class_value !== (div_class_value = "" + ((/*size*/ ctx[1] === 'page'
				? 'pageloader'
				: 'containerloader') + " " + (/*loading*/ ctx[0] ? 'is-active' : '')))) {
					attr(div, "class", div_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$1z(ctx) {
		let if_block_anchor;
		let if_block = /*size*/ ctx[1] !== "hidden" && create_if_block$X(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*size*/ ctx[1] !== "hidden") {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$X(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$1y($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { loading = false } = $$props;
		let { size = "container" } = $$props;
		let { title = "Waiting..." } = $$props;

		$$self.$$set = $$props => {
			if ('loading' in $$props) $$invalidate(0, loading = $$props.loading);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
			if ('title' in $$props) $$invalidate(2, title = $$props.title);
		};

		return [loading, size, title, $LOCALE];
	}

	class Ui_loader extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1y, create_fragment$1z, safe_not_equal, { loading: 0, size: 1, title: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.select.option.svelte generated by Svelte v4.2.19 */

	function create_fragment$1y(ctx) {
		let option;
		let t_value = /*$LOCALE*/ ctx[3][/*title*/ ctx[1]] + "";
		let t;

		return {
			c() {
				option = element("option");
				t = text(t_value);
				option.__value = /*value*/ ctx[0];
				set_input_value(option, option.__value);
				option.selected = /*selected*/ ctx[2];
			},
			m(target, anchor) {
				insert(target, option, anchor);
				append(option, t);
			},
			p(ctx, [dirty]) {
				if (dirty & /*$LOCALE, title*/ 10 && t_value !== (t_value = /*$LOCALE*/ ctx[3][/*title*/ ctx[1]] + "")) set_data(t, t_value);

				if (dirty & /*value*/ 1) {
					option.__value = /*value*/ ctx[0];
					set_input_value(option, option.__value);
				}

				if (dirty & /*selected*/ 4) {
					option.selected = /*selected*/ ctx[2];
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	function instance$1x($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { value } = $$props;
		let { title } = $$props;
		let { selected } = $$props;

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('selected' in $$props) $$invalidate(2, selected = $$props.selected);
		};

		return [value, title, selected, $LOCALE];
	}

	class Ui_select_option extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1x, create_fragment$1y, safe_not_equal, { value: 0, title: 1, selected: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.errors.list.svelte generated by Svelte v4.2.19 */

	function get_each_context$o(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	// (9:0) {#if Array.isArray(errors) && errors.length}
	function create_if_block$W(ctx) {
		let p;
		let p_class_value;

		function select_block_type(ctx, dirty) {
			if (/*show*/ ctx[1]) return create_if_block_1$L;
			return create_else_block$C;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				p = element("p");
				if_block.c();
				attr(p, "class", p_class_value = "help " + /*classes*/ ctx[2]);
				attr(p, "id", /*id*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				if_block.m(p, null);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(p, null);
					}
				}

				if (dirty & /*classes*/ 4 && p_class_value !== (p_class_value = "help " + /*classes*/ ctx[2])) {
					attr(p, "class", p_class_value);
				}

				if (dirty & /*id*/ 8) {
					attr(p, "id", /*id*/ ctx[3]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}

				if_block.d();
			}
		};
	}

	// (15:8) {:else}
	function create_else_block$C(ctx) {
		let t;

		return {
			c() {
				t = text(" ");
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (11:8) {#if show}
	function create_if_block_1$L(ctx) {
		let each_1_anchor;
		let each_value = ensure_array_like(/*errors*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$o(get_each_context$o(ctx, each_value, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, errors*/ 17) {
					each_value = ensure_array_like(/*errors*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$o(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$o(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (12:12) {#each errors as error}
	function create_each_block$o(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[4][/*error*/ ctx[5]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, errors*/ 17 && t_value !== (t_value = /*$LOCALE*/ ctx[4][/*error*/ ctx[5]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$1x(ctx) {
		let show_if = Array.isArray(/*errors*/ ctx[0]) && /*errors*/ ctx[0].length;
		let if_block_anchor;
		let if_block = show_if && create_if_block$W(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (dirty & /*errors*/ 1) show_if = Array.isArray(/*errors*/ ctx[0]) && /*errors*/ ctx[0].length;

				if (show_if) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$W(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$1w($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(4, $LOCALE = $$value));
		let { errors = [] } = $$props;
		let { show = false } = $$props;
		let { classes = "" } = $$props;
		let { id = "errors-list" } = $$props;

		$$self.$$set = $$props => {
			if ('errors' in $$props) $$invalidate(0, errors = $$props.errors);
			if ('show' in $$props) $$invalidate(1, show = $$props.show);
			if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
			if ('id' in $$props) $$invalidate(3, id = $$props.id);
		};

		return [errors, show, classes, id, $LOCALE];
	}

	class Ui_errors_list extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1w, create_fragment$1x, safe_not_equal, { errors: 0, show: 1, classes: 2, id: 3 });
		}
	}

	class UICommon {
	    static CLEAR_MACRO = "__CLEAR__";
	    static ERROR_DEFAULT = "Что пошло не так.";
	    static DEFAULT_REDIRECT_TIMEOUT = 3000;
	    static CLASS_OK = "is-success";
	    static CLASS_ERR = "is-danger";
	    static FILLER = "_";

	    static SCROLL_OPTIONS = {
	        top: 0,
	        behavior: "smooth",
	    };

	    /**
	     *  Reformats input from any string to strict phone format
	     *  @param {string}    val    free style phone number
	     *  @param {string}    [filler=UICommon.FILLER]    free style phone number
	     *  @returns {string}          phone number
	     **/
	    static formatPhone(val, filler = this.FILLER) {
	        //starting from 11 digits in phone number
	        const slots = [1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5];
	        let digits = val.replace(/\D/g, "");
	        //if there are more, move them to country code slot
	        if (digits.length > 11) {
	            let d = digits.length - 11;
	            while (d > 0) {
	                d--;
	                slots.unshift(1);
	            }
	        }
	        let stack = ["", "", "", "", ""];
	        Array.from(digits).forEach((digit, index) => {
	            let slot = slots[index];
	            stack[slot - 1] = stack[slot - 1] + digit;
	        });
	        //creating map of parts lengths
	        const lens = slots.reduce((acc, curr) => {
	            if (typeof acc[curr] === "undefined") {
	                acc[curr] = 1;
	            } else {
	                acc[curr] += 1;
	            }
	            return acc;
	        }, {});
	        //fill empty positions with filler (_)
	        for (let t in stack) {
	            let dif = lens[parseInt(t) + 1] - stack[t].length;
	            while (dif > 0) {
	                stack[t] = stack[t] + filler;
	                dif--;
	            }
	        }
	        return `+${stack[0]} (${stack[1]}) ${stack[2]}-${stack[3]}-${stack[4]}`;
	    }

	    static MONEY_SIGN = "&#8381;";

	    static setMoneySign(val) {
	        this.MONEY_SIGN = val;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {number} price
	     * @return {string}
	     * @memberof UICommon
	     */
	    static formatPrice(price) {
	        let major = Math.floor(price / 100),
	            minor = price % 100;
	        return `${this.MONEY_SIGN}${major.toString()}.${minor.toString()}`;
	    }

	    static formatLocaleDatetime(dt, opts = { date: true, time: true }) {
	        const date = dt.toLocaleDateString(window.navigator.language);
	        const time = dt.toLocaleTimeString(window.navigator.language);
	        if (opts.date && opts.time) {
	            return `${date} ${time}`;
	        } else if (opts.date && !opts.time) {
	            return date;
	        } else {
	            return time;
	        }
	    }

	    static tryFormatLocaleDateTime(value, opts = { date: true, time: true }) {
	        if (typeof value == "string" || typeof value == "number") {
	            const dt = new Date(value);
	            return UICommon.formatLocaleDatetime(dt, opts);
	        } else if (typeof value == "object") {
	            return UICommon.formatLocaleDatetime(value, opts);
	        } else {
	            return "";
	        }
	    }

	    static formatTimestamp(timestamp, offset = 0) {
	        let offsetLocal = new Date().getTimezoneOffset();
	        let deltaOffset = (offsetLocal - offset) * 60 * 1000;
	        let localDateTime = new Date(parseInt(timestamp) - deltaOffset);
	        return localDateTime.toLocaleString(window.navigator.language);
	    }

	    static TIME = {
	        SECONDS: ["секунду", "секунды", "секунд"],
	        MINUTES: ["минуту", "минуты", "минут"],
	        HOURS: ["час", "часа", "часов"],
	    };

	    static declOfNum(n, text_forms) {
	        n = Math.abs(n) % 100;
	        let n1 = n % 10;
	        if (n > 10 && n < 20) {
	            return text_forms[2];
	        }
	        if (n1 > 1 && n1 < 5) {
	            return text_forms[1];
	        }
	        if (n1 == 1) {
	            return text_forms[0];
	        }
	        return text_forms[2];
	    }

	    static humanizedTimeDiff(date /* unix time */) {
	        let currentTime = new Date().getTime();
	        let sec = Math.round((currentTime - date) / 1000);
	        let unit;
	        if (sec < 60) {
	            unit = this.declOfNum(sec, this.TIME.SECONDS);
	            return `${sec} ${unit} назад`;
	        } else if (sec < 3600) {
	            let min = Math.floor(sec / 60);
	            unit = this.declOfNum(min, this.TIME.MINUTES);
	            return `${min} ${unit} назад`;
	        } else {
	            let hours = Math.floor(sec / (60 * 60));
	            unit = this.declOfNum(hours, this.TIME.HOURS);
	            return `${hours} ${unit} назад`;
	        }
	    }
	}

	/* node_modules/not-bulma/src/elements/form/ui.select.svelte generated by Svelte v4.2.19 */

	function get_each_context_1$8(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[35] = list[i];
		return child_ctx;
	}

	function get_each_context$n(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[32] = list[i];
		return child_ctx;
	}

	// (128:4) {:else}
	function create_else_block_1$7(ctx) {
		let div;
		let select;
		let if_block0_anchor;
		let select_id_value;
		let select_size_value;
		let div_class_value;
		let t0;
		let t1;
		let if_block2_anchor;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*placeholder*/ ctx[2].length > 0 && create_if_block_7$5(ctx);
		let each_value_1 = ensure_array_like(/*variants*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block1 = /*icon*/ ctx[5] && create_if_block_5$8(ctx);
		let if_block2 = /*validated*/ ctx[11] === true && create_if_block_2$w(ctx);

		return {
			c() {
				div = element("div");
				select = element("select");
				if (if_block0) if_block0.c();
				if_block0_anchor = empty();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
				attr(select, "id", select_id_value = "form-field-select-" + /*fieldname*/ ctx[4]);
				attr(select, "name", /*fieldname*/ ctx[4]);
				attr(select, "readonly", /*readonly*/ ctx[7]);
				select.required = /*required*/ ctx[6];
				select.multiple = /*multiple*/ ctx[8];
				attr(select, "size", select_size_value = /*multiple*/ ctx[8] ? /*size*/ ctx[9] : false);
				attr(div, "class", div_class_value = "select " + /*validationClasses*/ ctx[14] + " " + /*multipleClass*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, select);
				if (if_block0) if_block0.m(select, null);
				append(select, if_block0_anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(select, null);
					}
				}

				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
				current = true;

				if (!mounted) {
					dispose = [
						listen(select, "blur", /*onBlur*/ ctx[19]),
						listen(select, "input", /*onInput*/ ctx[20])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (/*placeholder*/ ctx[2].length > 0) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*placeholder*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_7$5(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(select, if_block0_anchor);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (dirty[0] & /*variants, value, multiple*/ 259) {
					each_value_1 = ensure_array_like(/*variants*/ ctx[1]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$8(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$8(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(select, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty[0] & /*fieldname*/ 16 && select_id_value !== (select_id_value = "form-field-select-" + /*fieldname*/ ctx[4])) {
					attr(select, "id", select_id_value);
				}

				if (!current || dirty[0] & /*fieldname*/ 16) {
					attr(select, "name", /*fieldname*/ ctx[4]);
				}

				if (!current || dirty[0] & /*readonly*/ 128) {
					attr(select, "readonly", /*readonly*/ ctx[7]);
				}

				if (!current || dirty[0] & /*required*/ 64) {
					select.required = /*required*/ ctx[6];
				}

				if (!current || dirty[0] & /*multiple*/ 256) {
					select.multiple = /*multiple*/ ctx[8];
				}

				if (!current || dirty[0] & /*multiple, size*/ 768 && select_size_value !== (select_size_value = /*multiple*/ ctx[8] ? /*size*/ ctx[9] : false)) {
					attr(select, "size", select_size_value);
				}

				if (!current || dirty[0] & /*validationClasses, multipleClass*/ 24576 && div_class_value !== (div_class_value = "select " + /*validationClasses*/ ctx[14] + " " + /*multipleClass*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				if (/*icon*/ ctx[5]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_5$8(ctx);
						if_block1.c();
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*validated*/ ctx[11] === true) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_2$w(ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(if_block0);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t0);
					detach(t1);
					detach(if_block2_anchor);
				}

				if (if_block0) if_block0.d();
				destroy_each(each_blocks, detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (120:4) {#if readonly}
	function create_if_block$V(ctx) {
		let if_block_anchor;

		function select_block_type_1(ctx, dirty) {
			if (/*value*/ ctx[0]) return create_if_block_1$K;
			return create_else_block$B;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	// (140:16) {#if placeholder.length > 0}
	function create_if_block_7$5(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_8$3, create_else_block_3$1];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*value*/ ctx[0]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (146:20) {:else}
	function create_else_block_3$1(ctx) {
		let uiselectoption;
		let current;

		uiselectoption = new Ui_select_option({
				props: {
					value: UICommon.CLEAR_MACRO,
					selected: "selected",
					title: /*placeholder*/ ctx[2]
				}
			});

		return {
			c() {
				create_component(uiselectoption.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselectoption, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiselectoption_changes = {};
				if (dirty[0] & /*placeholder*/ 4) uiselectoption_changes.title = /*placeholder*/ ctx[2];
				uiselectoption.$set(uiselectoption_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselectoption.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselectoption.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselectoption, detaching);
			}
		};
	}

	// (141:20) {#if value}
	function create_if_block_8$3(ctx) {
		let uiselectoption;
		let current;

		uiselectoption = new Ui_select_option({
				props: {
					value: UICommon.CLEAR_MACRO,
					title: /*placeholder*/ ctx[2]
				}
			});

		return {
			c() {
				create_component(uiselectoption.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselectoption, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiselectoption_changes = {};
				if (dirty[0] & /*placeholder*/ 4) uiselectoption_changes.title = /*placeholder*/ ctx[2];
				uiselectoption.$set(uiselectoption_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselectoption.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselectoption.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselectoption, detaching);
			}
		};
	}

	// (161:20) {:else}
	function create_else_block_2$5(ctx) {
		let uiselectoption;
		let current;

		uiselectoption = new Ui_select_option({
				props: {
					value: /*variant*/ ctx[35].id,
					selected: /*value*/ ctx[0] == /*variant*/ ctx[35].id,
					title: /*variant*/ ctx[35].title
				}
			});

		return {
			c() {
				create_component(uiselectoption.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselectoption, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiselectoption_changes = {};
				if (dirty[0] & /*variants*/ 2) uiselectoption_changes.value = /*variant*/ ctx[35].id;
				if (dirty[0] & /*value, variants*/ 3) uiselectoption_changes.selected = /*value*/ ctx[0] == /*variant*/ ctx[35].id;
				if (dirty[0] & /*variants*/ 2) uiselectoption_changes.title = /*variant*/ ctx[35].title;
				uiselectoption.$set(uiselectoption_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselectoption.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselectoption.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselectoption, detaching);
			}
		};
	}

	// (155:20) {#if multiple}
	function create_if_block_6$5(ctx) {
		let uiselectoption;
		let current;

		uiselectoption = new Ui_select_option({
				props: {
					value: /*variant*/ ctx[35].id,
					selected: /*value*/ ctx[0] && /*value*/ ctx[0].indexOf(/*variant*/ ctx[35].id) > -1,
					title: /*variant*/ ctx[35].title
				}
			});

		return {
			c() {
				create_component(uiselectoption.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselectoption, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiselectoption_changes = {};
				if (dirty[0] & /*variants*/ 2) uiselectoption_changes.value = /*variant*/ ctx[35].id;
				if (dirty[0] & /*value, variants*/ 3) uiselectoption_changes.selected = /*value*/ ctx[0] && /*value*/ ctx[0].indexOf(/*variant*/ ctx[35].id) > -1;
				if (dirty[0] & /*variants*/ 2) uiselectoption_changes.title = /*variant*/ ctx[35].title;
				uiselectoption.$set(uiselectoption_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselectoption.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselectoption.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselectoption, detaching);
			}
		};
	}

	// (154:16) {#each variants as variant}
	function create_each_block_1$8(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_6$5, create_else_block_2$5];
		const if_blocks = [];

		function select_block_type_3(ctx, dirty) {
			if (/*multiple*/ ctx[8]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_3(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_3(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (171:8) {#if icon}
	function create_if_block_5$8(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[5]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*icon*/ 32 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[5])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (176:8) {#if validated === true}
	function create_if_block_2$w(ctx) {
		let span;

		function select_block_type_4(ctx, dirty) {
			if (/*valid*/ ctx[10] === true) return create_if_block_3$p;
			if (/*valid*/ ctx[10] === false) return create_if_block_4$h;
		}

		let current_block_type = select_block_type_4(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_4(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (180:42) 
	function create_if_block_4$h(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (178:16) {#if valid === true}
	function create_if_block_3$p(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (125:8) {:else}
	function create_else_block$B(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[18][/*emptyValueTitle*/ ctx[3]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "class", "mr-2");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, emptyValueTitle*/ 262152 && t_value !== (t_value = /*$LOCALE*/ ctx[18][/*emptyValueTitle*/ ctx[3]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (121:8) {#if value}
	function create_if_block_1$K(ctx) {
		let each_1_anchor;
		let each_value = ensure_array_like(/*selectedVariants*/ ctx[12]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$n(get_each_context$n(ctx, each_value, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, selectedVariants*/ 266240) {
					each_value = ensure_array_like(/*selectedVariants*/ ctx[12]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$n(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$n(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (122:12) {#each selectedVariants as selectedVariant}
	function create_each_block$n(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[18][/*selectedVariant*/ ctx[32].title] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "class", "mr-2");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, selectedVariants*/ 266240 && t_value !== (t_value = /*$LOCALE*/ ctx[18][/*selectedVariant*/ ctx[32].title] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$1w(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		const if_block_creators = [create_if_block$V, create_else_block_1$7];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[7]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[25](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[26](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[27](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[4]
		};

		if (/*allErrors*/ ctx[16] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[16];
		}

		if (/*showErrors*/ ctx[15] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[15];
		}

		if (/*validationClasses*/ ctx[14] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[14];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[17]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}

				if (!current || dirty[0] & /*iconClasses*/ 131072 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[17])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 16) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[4];

				if (!updating_errors && dirty[0] & /*allErrors*/ 65536) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[16];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 32768) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[15];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 16384) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[14];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$1v($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let validationClasses;
		let multipleClass;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(18, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { variants = [] } = $$props;
		let { placeholder = "" } = $$props;
		let { emptyValueTitle = "" } = $$props;
		let { fieldname = "select" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { multiple = false } = $$props;
		let { size = 8 } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let selectedVariants = [];

		function filterSelectedVariants(variant) {
			if (Array.isArray(value) && multiple) {
				return value.indexOf(variant.id) > -1;
			} else if (value) {
				return value == variant.id;
			} else {
				return false;
			}
		}

		let lastChange;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			if (lastChange === data.value) {
				return true;
			} else {
				if (Array.isArray(data.value) && notCommon$2.compareTwoArrays(lastChange, data.value)) {
					return true;
				}
			}

			if (multiple) {
				$$invalidate(0, value = Array.from(ev.target.selectedOptions).map(el => el.value));

				if (value.indexOf(UICommon.CLEAR_MACRO) > -1) {
					$$invalidate(0, value = []);
				}

				data.value = value;
			} else {
				if (data.value === UICommon.CLEAR_MACRO) {
					$$invalidate(0, value = "");
				} else {
					$$invalidate(0, value = data.value);
				}
			}

			$$invalidate(21, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			if (multiple) {
				$$invalidate(0, value = Array.from(ev.target.selectedOptions).map(el => el.value));

				if (value.indexOf(UICommon.CLEAR_MACRO) > -1) {
					$$invalidate(0, value = []);
				}

				data.value = value;
			} else {
				if (data.value === UICommon.CLEAR_MACRO) {
					$$invalidate(0, value = "");
				} else {
					$$invalidate(0, value = data.value);
				}
			}

			$$invalidate(21, inputStarted = true);
			lastChange = data.value;
			dispatch("change", data);
			return true;
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(16, allErrors), $$invalidate(22, errors)), $$invalidate(23, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(15, showErrors), $$invalidate(11, validated)), $$invalidate(10, valid)), $$invalidate(21, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(14, validationClasses), $$invalidate(10, valid)), $$invalidate(21, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(21, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('variants' in $$props) $$invalidate(1, variants = $$props.variants);
			if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
			if ('emptyValueTitle' in $$props) $$invalidate(3, emptyValueTitle = $$props.emptyValueTitle);
			if ('fieldname' in $$props) $$invalidate(4, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(5, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(6, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(7, readonly = $$props.readonly);
			if ('multiple' in $$props) $$invalidate(8, multiple = $$props.multiple);
			if ('size' in $$props) $$invalidate(9, size = $$props.size);
			if ('valid' in $$props) $$invalidate(10, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(11, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(22, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(23, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(24, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 32) {
				$$invalidate(17, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 12582912) {
				$$invalidate(16, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 2100224) {
				$$invalidate(15, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 16778240) ;

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 2098176) {
				$$invalidate(14, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}

			if ($$self.$$.dirty[0] & /*multiple*/ 256) {
				$$invalidate(13, multipleClass = multiple ? " is-multiple " : "");
			}

			if ($$self.$$.dirty[0] & /*value, variants*/ 3) {
				{

					$$invalidate(12, selectedVariants = Array.isArray(variants)
					? variants.filter(filterSelectedVariants)
					: []);
				}
			}
		};

		return [
			value,
			variants,
			placeholder,
			emptyValueTitle,
			fieldname,
			icon,
			required,
			readonly,
			multiple,
			size,
			valid,
			validated,
			selectedVariants,
			multipleClass,
			validationClasses,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_select extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$1v,
				create_fragment$1w,
				safe_not_equal,
				{
					inputStarted: 21,
					value: 0,
					variants: 1,
					placeholder: 2,
					emptyValueTitle: 3,
					fieldname: 4,
					icon: 5,
					required: 6,
					readonly: 7,
					multiple: 8,
					size: 9,
					valid: 10,
					validated: 11,
					errors: 22,
					formErrors: 23,
					formLevelError: 24
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.button.svelte generated by Svelte v4.2.19 */

	function create_else_block$A(ctx) {
		let t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[0]] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, title*/ 32769 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[0]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (54:8) {#if icon}
	function create_if_block$U(ctx) {
		let t0;
		let t1;
		let if_block2_anchor;
		let if_block0 = /*iconSide*/ ctx[14] === "left" && create_if_block_3$o(ctx);
		let if_block1 = /*title*/ ctx[0] && create_if_block_2$v(ctx);
		let if_block2 = /*iconSide*/ ctx[14] === "right" && create_if_block_1$J(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*iconSide*/ ctx[14] === "left") {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$o(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*title*/ ctx[0]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$v(ctx);
						if_block1.c();
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*iconSide*/ ctx[14] === "right") {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_1$J(ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(if_block2_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
			}
		};
	}

	// (55:12) {#if iconSide === "left"}
	function create_if_block_3$o(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[13] + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : ''));
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon, size*/ 10240 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[13] + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : ''))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (62:12) {#if title}
	function create_if_block_2$v(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[0]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, title*/ 32769 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[0]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (65:12) {#if iconSide === "right"}
	function create_if_block_1$J(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[13] + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : ''));
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon, size*/ 10240 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[13] + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : ''))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (53:10)          
	function fallback_block$1(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*icon*/ ctx[13]) return create_if_block$U;
			return create_else_block$A;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function create_fragment$1v(ctx) {
		let button;
		let button_type_value;
		let button_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[20].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
		const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

		return {
			c() {
				button = element("button");
				if (default_slot_or_fallback) default_slot_or_fallback.c();
				button.disabled = /*disabled*/ ctx[7];
				attr(button, "type", button_type_value = /*type*/ ctx[9] ? /*type*/ ctx[9] : "");
				attr(button, "class", button_class_value = "button " + /*classes*/ ctx[12] + " " + (/*state*/ ctx[8] ? `is-${/*state*/ ctx[8]}` : '') + " " + (/*inverted*/ ctx[5] ? `is-inverted` : '') + " " + (/*outlined*/ ctx[4] ? `is-outlined` : '') + " " + (/*raised*/ ctx[3] ? `is-raised` : '') + " " + (/*rounded*/ ctx[6] ? `is-rounded` : '') + " " + (/*light*/ ctx[1] ? `is-light` : '') + " " + (/*loading*/ ctx[2] ? `is-loading` : '') + " " + (/*color*/ ctx[10] ? `is-${/*color*/ ctx[10]}` : '') + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : '') + "");
			},
			m(target, anchor) {
				insert(target, button, anchor);

				if (default_slot_or_fallback) {
					default_slot_or_fallback.m(button, null);
				}

				current = true;

				if (!mounted) {
					dispose = listen(button, "click", /*onClick*/ ctx[16]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[19],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
							null
						);
					}
				} else {
					if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*icon, size, iconSide, $LOCALE, title*/ 59393)) {
						default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
					}
				}

				if (!current || dirty & /*disabled*/ 128) {
					button.disabled = /*disabled*/ ctx[7];
				}

				if (!current || dirty & /*type*/ 512 && button_type_value !== (button_type_value = /*type*/ ctx[9] ? /*type*/ ctx[9] : "")) {
					attr(button, "type", button_type_value);
				}

				if (!current || dirty & /*classes, state, inverted, outlined, raised, rounded, light, loading, color, size*/ 7550 && button_class_value !== (button_class_value = "button " + /*classes*/ ctx[12] + " " + (/*state*/ ctx[8] ? `is-${/*state*/ ctx[8]}` : '') + " " + (/*inverted*/ ctx[5] ? `is-inverted` : '') + " " + (/*outlined*/ ctx[4] ? `is-outlined` : '') + " " + (/*raised*/ ctx[3] ? `is-raised` : '') + " " + (/*rounded*/ ctx[6] ? `is-rounded` : '') + " " + (/*light*/ ctx[1] ? `is-light` : '') + " " + (/*loading*/ ctx[2] ? `is-loading` : '') + " " + (/*color*/ ctx[10] ? `is-${/*color*/ ctx[10]}` : '') + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : '') + "")) {
					attr(button, "class", button_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
				mounted = false;
				dispose();
			}
		};
	}

	function instance$1u($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(15, $LOCALE = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		const dispatch = createEventDispatcher();
		let { title = "" } = $$props;
		let { light = false } = $$props;
		let { loading = false } = $$props;
		let { raised = false } = $$props;
		let { outlined = false } = $$props;
		let { inverted = false } = $$props;
		let { rounded = false } = $$props;
		let { disabled = false } = $$props;
		let { state = "" } = $$props;
		let { type = "" } = $$props;
		let { color = "" } = $$props;
		let { size = "" } = $$props;
		let { classes = "" } = $$props;
		let { icon = false } = $$props;
		let { iconSide = "right" } = $$props;

		let { action = () => {
			return true;
		} } = $$props;

		let { value } = $$props;

		function onClick(event) {
			event.stopPropagation();
			dispatch("click", { event, value });
			return action(event, value);
		}

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('light' in $$props) $$invalidate(1, light = $$props.light);
			if ('loading' in $$props) $$invalidate(2, loading = $$props.loading);
			if ('raised' in $$props) $$invalidate(3, raised = $$props.raised);
			if ('outlined' in $$props) $$invalidate(4, outlined = $$props.outlined);
			if ('inverted' in $$props) $$invalidate(5, inverted = $$props.inverted);
			if ('rounded' in $$props) $$invalidate(6, rounded = $$props.rounded);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('state' in $$props) $$invalidate(8, state = $$props.state);
			if ('type' in $$props) $$invalidate(9, type = $$props.type);
			if ('color' in $$props) $$invalidate(10, color = $$props.color);
			if ('size' in $$props) $$invalidate(11, size = $$props.size);
			if ('classes' in $$props) $$invalidate(12, classes = $$props.classes);
			if ('icon' in $$props) $$invalidate(13, icon = $$props.icon);
			if ('iconSide' in $$props) $$invalidate(14, iconSide = $$props.iconSide);
			if ('action' in $$props) $$invalidate(17, action = $$props.action);
			if ('value' in $$props) $$invalidate(18, value = $$props.value);
			if ('$$scope' in $$props) $$invalidate(19, $$scope = $$props.$$scope);
		};

		return [
			title,
			light,
			loading,
			raised,
			outlined,
			inverted,
			rounded,
			disabled,
			state,
			type,
			color,
			size,
			classes,
			icon,
			iconSide,
			$LOCALE,
			onClick,
			action,
			value,
			$$scope,
			slots
		];
	}

	class Ui_button extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1u, create_fragment$1v, safe_not_equal, {
				title: 0,
				light: 1,
				loading: 2,
				raised: 3,
				outlined: 4,
				inverted: 5,
				rounded: 6,
				disabled: 7,
				state: 8,
				type: 9,
				color: 10,
				size: 11,
				classes: 12,
				icon: 13,
				iconSide: 14,
				action: 17,
				value: 18
			});
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.buttons.svelte generated by Svelte v4.2.19 */

	function get_each_context$m(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[9] = list[i];
		child_ctx[10] = list;
		child_ctx[11] = i;
		return child_ctx;
	}

	// (22:4) {#each values as item (item.id)}
	function create_each_block$m(key_1, ctx) {
		let first;
		let switch_instance;
		let updating_value;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*item*/ ctx[9],
			{
				action: /*item*/ ctx[9].action
				? /*item*/ ctx[9].action
				: /*action*/ ctx[5]
			}
		];

		function switch_instance_value_binding(value) {
			/*switch_instance_value_binding*/ ctx[6](value, /*item*/ ctx[9]);
		}

		var switch_value = /*buttonComponent*/ ctx[4];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*values, action*/ 33) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[9]),
					{
						action: /*item*/ ctx[9].action
						? /*item*/ ctx[9].action
						: /*action*/ ctx[5]
					}
				]));
			}

			if (/*item*/ ctx[9].value !== void 0) {
				switch_instance_props.value = /*item*/ ctx[9].value;
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
			switch_instance.$on("click", /*click_handler*/ ctx[7]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*buttonComponent*/ 16 && switch_value !== (switch_value = /*buttonComponent*/ ctx[4])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
						switch_instance.$on("click", /*click_handler*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*values, action*/ 33)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[9]),
							{
								action: /*item*/ ctx[9].action
								? /*item*/ ctx[9].action
								: /*action*/ ctx[5]
							}
						])
					: {};

					if (!updating_value && dirty & /*values*/ 1) {
						updating_value = true;
						switch_instance_changes.value = /*item*/ ctx[9].value;
						add_flush_callback(() => updating_value = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1u(ctx) {
		let div;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div_class_value;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[9].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$m(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$m(key, child_ctx));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", div_class_value = "buttons has-addons " + (/*centered*/ ctx[1] ? 'is-centered' : '') + " " + (/*right*/ ctx[2] ? 'is-right' : '') + " " + /*classes*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*buttonComponent, values, action*/ 49) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$m, null, get_each_context$m);
					check_outros();
				}

				if (!current || dirty & /*centered, right, classes*/ 14 && div_class_value !== (div_class_value = "buttons has-addons " + (/*centered*/ ctx[1] ? 'is-centered' : '') + " " + (/*right*/ ctx[2] ? 'is-right' : '') + " " + /*classes*/ ctx[3])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	function instance$1t($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { values = [] } = $$props;
		let { centered = false } = $$props;
		let { right = false } = $$props;
		let { classes = "" } = $$props;
		let { buttonComponent = Ui_button } = $$props;

		let { action = e => {
			dispatch("click", e);
		} } = $$props;

		function switch_instance_value_binding(value, item) {
			if ($$self.$$.not_equal(item.value, value)) {
				item.value = value;
				$$invalidate(0, values);
			}
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
			if ('centered' in $$props) $$invalidate(1, centered = $$props.centered);
			if ('right' in $$props) $$invalidate(2, right = $$props.right);
			if ('classes' in $$props) $$invalidate(3, classes = $$props.classes);
			if ('buttonComponent' in $$props) $$invalidate(4, buttonComponent = $$props.buttonComponent);
			if ('action' in $$props) $$invalidate(5, action = $$props.action);
		};

		return [
			values,
			centered,
			right,
			classes,
			buttonComponent,
			action,
			switch_instance_value_binding,
			click_handler
		];
	}

	class Ui_buttons extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1t, create_fragment$1u, safe_not_equal, {
				values: 0,
				centered: 1,
				right: 2,
				classes: 3,
				buttonComponent: 4,
				action: 5
			});
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.buttons.row.svelte generated by Svelte v4.2.19 */

	function create_fragment$1t(ctx) {
		let div3;
		let div0;
		let uibuttons0;
		let t0;
		let div1;
		let uibuttons1;
		let t1;
		let div2;
		let uibuttons2;
		let div3_class_value;
		let current;
		uibuttons0 = new Ui_buttons({ props: { values: /*left*/ ctx[1] } });

		uibuttons1 = new Ui_buttons({
				props: {
					values: /*center*/ ctx[2],
					centered: true
				}
			});

		uibuttons2 = new Ui_buttons({
				props: { values: /*right*/ ctx[3], right: true }
			});

		return {
			c() {
				div3 = element("div");
				div0 = element("div");
				create_component(uibuttons0.$$.fragment);
				t0 = space();
				div1 = element("div");
				create_component(uibuttons1.$$.fragment);
				t1 = space();
				div2 = element("div");
				create_component(uibuttons2.$$.fragment);
				attr(div0, "class", "column");
				attr(div1, "class", "column");
				attr(div2, "class", "column");
				attr(div3, "class", div3_class_value = "columns " + /*classes*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, div3, anchor);
				append(div3, div0);
				mount_component(uibuttons0, div0, null);
				append(div3, t0);
				append(div3, div1);
				mount_component(uibuttons1, div1, null);
				append(div3, t1);
				append(div3, div2);
				mount_component(uibuttons2, div2, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibuttons0_changes = {};
				if (dirty & /*left*/ 2) uibuttons0_changes.values = /*left*/ ctx[1];
				uibuttons0.$set(uibuttons0_changes);
				const uibuttons1_changes = {};
				if (dirty & /*center*/ 4) uibuttons1_changes.values = /*center*/ ctx[2];
				uibuttons1.$set(uibuttons1_changes);
				const uibuttons2_changes = {};
				if (dirty & /*right*/ 8) uibuttons2_changes.values = /*right*/ ctx[3];
				uibuttons2.$set(uibuttons2_changes);

				if (!current || dirty & /*classes*/ 1 && div3_class_value !== (div3_class_value = "columns " + /*classes*/ ctx[0])) {
					attr(div3, "class", div3_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons0.$$.fragment, local);
				transition_in(uibuttons1.$$.fragment, local);
				transition_in(uibuttons2.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons0.$$.fragment, local);
				transition_out(uibuttons1.$$.fragment, local);
				transition_out(uibuttons2.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div3);
				}

				destroy_component(uibuttons0);
				destroy_component(uibuttons1);
				destroy_component(uibuttons2);
			}
		};
	}

	function instance$1s($$self, $$props, $$invalidate) {
		let { classes = "" } = $$props;
		let { left = [] } = $$props;
		let { center = [] } = $$props;
		let { right = [] } = $$props;

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('left' in $$props) $$invalidate(1, left = $$props.left);
			if ('center' in $$props) $$invalidate(2, center = $$props.center);
			if ('right' in $$props) $$invalidate(3, right = $$props.right);
		};

		return [classes, left, center, right];
	}

	class Ui_buttons_row extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1s, create_fragment$1t, safe_not_equal, { classes: 0, left: 1, center: 2, right: 3 });
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.button.switch.svelte generated by Svelte v4.2.19 */

	function create_fragment$1s(ctx) {
		let uibutton;
		let current;

		let uibutton_props = {
			title: /*title*/ ctx[0],
			light: /*light*/ ctx[1],
			loading: /*loading*/ ctx[2],
			raised: /*raised*/ ctx[3],
			outlined: /*outlined*/ ctx[4],
			inverted: /*inverted*/ ctx[5],
			rounded: /*rounded*/ ctx[6],
			disabled: /*disabled*/ ctx[7],
			state: /*state*/ ctx[8],
			type: /*type*/ ctx[9],
			color: /*color*/ ctx[10],
			size: /*size*/ ctx[11],
			classes: /*classes*/ ctx[12],
			icon: /*icon*/ ctx[13],
			iconSide: /*iconSide*/ ctx[14],
			value: /*value*/ ctx[15]
		};

		uibutton = new Ui_button({ props: uibutton_props });
		/*uibutton_binding*/ ctx[22](uibutton);
		uibutton.$on("click", /*onClick*/ ctx[17]);

		return {
			c() {
				create_component(uibutton.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibutton_changes = {};
				if (dirty & /*title*/ 1) uibutton_changes.title = /*title*/ ctx[0];
				if (dirty & /*light*/ 2) uibutton_changes.light = /*light*/ ctx[1];
				if (dirty & /*loading*/ 4) uibutton_changes.loading = /*loading*/ ctx[2];
				if (dirty & /*raised*/ 8) uibutton_changes.raised = /*raised*/ ctx[3];
				if (dirty & /*outlined*/ 16) uibutton_changes.outlined = /*outlined*/ ctx[4];
				if (dirty & /*inverted*/ 32) uibutton_changes.inverted = /*inverted*/ ctx[5];
				if (dirty & /*rounded*/ 64) uibutton_changes.rounded = /*rounded*/ ctx[6];
				if (dirty & /*disabled*/ 128) uibutton_changes.disabled = /*disabled*/ ctx[7];
				if (dirty & /*state*/ 256) uibutton_changes.state = /*state*/ ctx[8];
				if (dirty & /*type*/ 512) uibutton_changes.type = /*type*/ ctx[9];
				if (dirty & /*color*/ 1024) uibutton_changes.color = /*color*/ ctx[10];
				if (dirty & /*size*/ 2048) uibutton_changes.size = /*size*/ ctx[11];
				if (dirty & /*classes*/ 4096) uibutton_changes.classes = /*classes*/ ctx[12];
				if (dirty & /*icon*/ 8192) uibutton_changes.icon = /*icon*/ ctx[13];
				if (dirty & /*iconSide*/ 16384) uibutton_changes.iconSide = /*iconSide*/ ctx[14];
				if (dirty & /*value*/ 32768) uibutton_changes.value = /*value*/ ctx[15];
				uibutton.$set(uibutton_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				/*uibutton_binding*/ ctx[22](null);
				destroy_component(uibutton, detaching);
			}
		};
	}

	function instance$1r($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { title = "" } = $$props;
		let { light = false } = $$props;
		let { loading = false } = $$props;
		let { raised = false } = $$props;
		let { outlined = false } = $$props;
		let { inverted = false } = $$props;
		let { rounded = false } = $$props;
		let { disabled = false } = $$props;
		let { state = "" } = $$props;
		let { type = "" } = $$props;
		let { color = "" } = $$props;
		let { size = "" } = $$props;
		let { classes = "" } = $$props;
		let { icon = false } = $$props;
		let { iconSide = "right" } = $$props;

		let { uiOff = () => {
			return { color: "" };
		} } = $$props;

		let { uiOn = () => {
			return { color: "success" };
		} } = $$props;

		let { action = () => {
			return !selected;
		} } = $$props;

		let { value } = $$props;
		let { selected = false } = $$props;

		function onClick(event) {
			$$invalidate(18, selected = action(event, value, selected));
			dispatch("click", { value, selected });
			onChange();
		}

		function onChange() {
			dispatch("change", { value, selected });
		}

		let uiElement;

		function uibutton_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				uiElement = $$value;
				$$invalidate(16, uiElement);
			});
		}

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('light' in $$props) $$invalidate(1, light = $$props.light);
			if ('loading' in $$props) $$invalidate(2, loading = $$props.loading);
			if ('raised' in $$props) $$invalidate(3, raised = $$props.raised);
			if ('outlined' in $$props) $$invalidate(4, outlined = $$props.outlined);
			if ('inverted' in $$props) $$invalidate(5, inverted = $$props.inverted);
			if ('rounded' in $$props) $$invalidate(6, rounded = $$props.rounded);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('state' in $$props) $$invalidate(8, state = $$props.state);
			if ('type' in $$props) $$invalidate(9, type = $$props.type);
			if ('color' in $$props) $$invalidate(10, color = $$props.color);
			if ('size' in $$props) $$invalidate(11, size = $$props.size);
			if ('classes' in $$props) $$invalidate(12, classes = $$props.classes);
			if ('icon' in $$props) $$invalidate(13, icon = $$props.icon);
			if ('iconSide' in $$props) $$invalidate(14, iconSide = $$props.iconSide);
			if ('uiOff' in $$props) $$invalidate(19, uiOff = $$props.uiOff);
			if ('uiOn' in $$props) $$invalidate(20, uiOn = $$props.uiOn);
			if ('action' in $$props) $$invalidate(21, action = $$props.action);
			if ('value' in $$props) $$invalidate(15, value = $$props.value);
			if ('selected' in $$props) $$invalidate(18, selected = $$props.selected);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*uiElement, selected, uiOn, uiOff*/ 1900544) {
				{
					if (uiElement) {
						selected
						? uiElement.$set(uiOn())
						: uiElement.$set(uiOff());
					}
				}
			}
		};

		return [
			title,
			light,
			loading,
			raised,
			outlined,
			inverted,
			rounded,
			disabled,
			state,
			type,
			color,
			size,
			classes,
			icon,
			iconSide,
			value,
			uiElement,
			onClick,
			selected,
			uiOff,
			uiOn,
			action,
			uibutton_binding
		];
	}

	class Ui_button_switch extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1r, create_fragment$1s, safe_not_equal, {
				title: 0,
				light: 1,
				loading: 2,
				raised: 3,
				outlined: 4,
				inverted: 5,
				rounded: 6,
				disabled: 7,
				state: 8,
				type: 9,
				color: 10,
				size: 11,
				classes: 12,
				icon: 13,
				iconSide: 14,
				uiOff: 19,
				uiOn: 20,
				action: 21,
				value: 15,
				selected: 18
			});
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.buttons.switchers.svelte generated by Svelte v4.2.19 */

	function get_each_context$l(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[21] = list[i];
		child_ctx[22] = list;
		child_ctx[23] = i;
		return child_ctx;
	}

	// (124:4) {#each values as item (item.id)}
	function create_each_block$l(key_1, ctx) {
		let first;
		let switch_instance;
		let updating_value;
		let updating_selected;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*item*/ ctx[21],
			{
				action: /*item*/ ctx[21].action
				? /*item*/ ctx[21].action
				: /*action*/ ctx[5]
			}
		];

		function switch_instance_value_binding(value) {
			/*switch_instance_value_binding*/ ctx[10](value, /*item*/ ctx[21]);
		}

		function switch_instance_selected_binding(value) {
			/*switch_instance_selected_binding*/ ctx[11](value, /*item*/ ctx[21]);
		}

		var switch_value = /*buttonComponent*/ ctx[4];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*values, action*/ 33) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[21]),
					{
						action: /*item*/ ctx[21].action
						? /*item*/ ctx[21].action
						: /*action*/ ctx[5]
					}
				]));
			}

			if (/*item*/ ctx[21].value !== void 0) {
				switch_instance_props.value = /*item*/ ctx[21].value;
			}

			if (/*item*/ ctx[21].selected !== void 0) {
				switch_instance_props.selected = /*item*/ ctx[21].selected;
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
			binding_callbacks.push(() => bind(switch_instance, 'selected', switch_instance_selected_binding));
			switch_instance.$on("click", /*click_handler*/ ctx[12]);
			switch_instance.$on("change", /*change_handler*/ ctx[13]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*buttonComponent*/ 16 && switch_value !== (switch_value = /*buttonComponent*/ ctx[4])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
						binding_callbacks.push(() => bind(switch_instance, 'selected', switch_instance_selected_binding));
						switch_instance.$on("click", /*click_handler*/ ctx[12]);
						switch_instance.$on("change", /*change_handler*/ ctx[13]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*values, action*/ 33)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[21]),
							{
								action: /*item*/ ctx[21].action
								? /*item*/ ctx[21].action
								: /*action*/ ctx[5]
							}
						])
					: {};

					if (!updating_value && dirty & /*values*/ 1) {
						updating_value = true;
						switch_instance_changes.value = /*item*/ ctx[21].value;
						add_flush_callback(() => updating_value = false);
					}

					if (!updating_selected && dirty & /*values*/ 1) {
						updating_selected = true;
						switch_instance_changes.selected = /*item*/ ctx[21].selected;
						add_flush_callback(() => updating_selected = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1r(ctx) {
		let div;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div_class_value;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[21].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$l(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$l(key, child_ctx));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", div_class_value = "buttons has-addons " + (/*centered*/ ctx[1] ? 'is-centered' : '') + " " + (/*right*/ ctx[2] ? 'is-right' : '') + " " + /*classes*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*buttonComponent, values, action*/ 49) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$l, null, get_each_context$l);
					check_outros();
				}

				if (!current || dirty & /*centered, right, classes*/ 14 && div_class_value !== (div_class_value = "buttons has-addons " + (/*centered*/ ctx[1] ? 'is-centered' : '') + " " + (/*right*/ ctx[2] ? 'is-right' : '') + " " + /*classes*/ ctx[3])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	function instance$1q($$self, $$props, $$invalidate) {
		createEventDispatcher();
		let { values = [] } = $$props;
		let { centered = false } = $$props;
		let { right = false } = $$props;
		let { classes = "" } = $$props;
		let { buttonComponent = Ui_button_switch } = $$props;

		function selectAll() {
			values.forEach(itm => {
				itm.selected = true;
			});

			$$invalidate(0, values);
		}

		function deselectAll() {
			values.forEach(itm => {
				itm.selected = false;
			});

			$$invalidate(0, values);
		}

		onMount(() => {
			if (min) {
				selectUpToMin(0, -1);
			}
		});

		function countSelected() {
			return values.filter(btn => btn.selected).length;
		}

		function selectUpToMin(cnt, indexOfCurrent) {
			let delta = min - cnt;

			if (!delta) {
				return;
			}

			for (let t in values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (!values[t].selected) {
					$$invalidate(0, values[t].selected = true, values);
					delta--;

					if (!delta) {
						break;
					}
				}
			}
		}

		function deselectDownToMin(cnt, indexOfCurrent) {
			let delta = cnt - max;

			if (!delta) {
				return;
			}

			for (let t in values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (values[t].selected) {
					$$invalidate(0, values[t].selected = false, values);
					delta--;

					if (!delta) {
						break;
					}
				}
			}
		}

		let { action = (ev, value, selected) => {
			let newSelected = !selected;
			const indexOfCurrent = values.indexOf(itm => itm.value === value);
			const cnt = countSelected() + (newSelected ? 1 : -1);

			if (min) {
				if (cnt < min) {
					selectUpToMin(cnt, indexOfCurrent);
					$$invalidate(0, values);
				}
			}

			if (max) {
				if (max < cnt) {
					deselectDownToMin(cnt, indexOfCurrent);
					$$invalidate(0, values);
				}
			}

			return newSelected;
		} } = $$props;

		let { min = 0 } = $$props;
		let { max = 100 } = $$props;

		function switch_instance_value_binding(value, item) {
			if ($$self.$$.not_equal(item.value, value)) {
				item.value = value;
				$$invalidate(0, values);
			}
		}

		function switch_instance_selected_binding(value, item) {
			if ($$self.$$.not_equal(item.selected, value)) {
				item.selected = value;
				$$invalidate(0, values);
			}
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function change_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
			if ('centered' in $$props) $$invalidate(1, centered = $$props.centered);
			if ('right' in $$props) $$invalidate(2, right = $$props.right);
			if ('classes' in $$props) $$invalidate(3, classes = $$props.classes);
			if ('buttonComponent' in $$props) $$invalidate(4, buttonComponent = $$props.buttonComponent);
			if ('action' in $$props) $$invalidate(5, action = $$props.action);
			if ('min' in $$props) $$invalidate(8, min = $$props.min);
			if ('max' in $$props) $$invalidate(9, max = $$props.max);
		};

		return [
			values,
			centered,
			right,
			classes,
			buttonComponent,
			action,
			selectAll,
			deselectAll,
			min,
			max,
			switch_instance_value_binding,
			switch_instance_selected_binding,
			click_handler,
			change_handler
		];
	}

	class Ui_buttons_switchers extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1q, create_fragment$1r, safe_not_equal, {
				values: 0,
				centered: 1,
				right: 2,
				classes: 3,
				buttonComponent: 4,
				selectAll: 6,
				deselectAll: 7,
				action: 5,
				min: 8,
				max: 9
			});
		}

		get selectAll() {
			return this.$$.ctx[6];
		}

		get deselectAll() {
			return this.$$.ctx[7];
		}
	}

	var index$a = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIButton: Ui_button,
		UIButtonSwitch: Ui_button_switch,
		UIButtons: Ui_buttons,
		UIButtonsRow: Ui_buttons_row,
		UIButtonsSwitchers: Ui_buttons_switchers
	});

	const DEFAULT_STATUS_SUCCESS = "ok";

	const NAVIGATION_DELAY_SHORT = 500;
	const NAVIGATION_DELAY_NORMAL = 1500;
	const NAVIGATION_DELAY_LONG = 5000;

	const NAVIGATION_DELAYS = {
	    SHORT: NAVIGATION_DELAY_SHORT,
	    NORMAL: NAVIGATION_DELAY_NORMAL,
	    LONG: NAVIGATION_DELAY_LONG,
	};

	const NAVIGATION_DELAY_DEFAULT = NAVIGATION_DELAY_NORMAL;

	/* node_modules/not-bulma/src/elements/various/ui.select.from.model.on.demand.inline.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$I(ctx) {
		let div0;
		let uiselect;
		let t;
		let div1;
		let uibuttons;
		let current;

		uiselect = new Ui_select({
				props: {
					inputStarted: /*inputStarted*/ ctx[2],
					value: /*value*/ ctx[3],
					variants: /*variants*/ ctx[0],
					placeholder: /*placeholder*/ ctx[4],
					fieldname: /*fieldname*/ ctx[5],
					icon: /*icon*/ ctx[6],
					required: /*required*/ ctx[7],
					readonly: /*readonly*/ ctx[8],
					disabled: /*disabled*/ ctx[16],
					multiple: /*multiple*/ ctx[9],
					size: /*size*/ ctx[10],
					valid: /*valid*/ ctx[11],
					validated: /*validated*/ ctx[12],
					errors: /*errors*/ ctx[1],
					formErrors: /*formErrors*/ ctx[13],
					formLevelError: /*formLevelError*/ ctx[14]
				}
			});

		uiselect.$on("change", /*onModelChanged*/ ctx[17]);

		uibuttons = new Ui_buttons({
				props: {
					values: [/*ACTIONS*/ ctx[18].resolve, /*ACTIONS*/ ctx[18].reject]
				}
			});

		return {
			c() {
				div0 = element("div");
				create_component(uiselect.$$.fragment);
				t = space();
				div1 = element("div");
				create_component(uibuttons.$$.fragment);
				attr(div0, "class", "field has-addons");
				attr(div1, "class", "control");
			},
			m(target, anchor) {
				insert(target, div0, anchor);
				mount_component(uiselect, div0, null);
				insert(target, t, anchor);
				insert(target, div1, anchor);
				mount_component(uibuttons, div1, null);
				current = true;
			},
			p(ctx, dirty) {
				const uiselect_changes = {};
				if (dirty & /*inputStarted*/ 4) uiselect_changes.inputStarted = /*inputStarted*/ ctx[2];
				if (dirty & /*value*/ 8) uiselect_changes.value = /*value*/ ctx[3];
				if (dirty & /*variants*/ 1) uiselect_changes.variants = /*variants*/ ctx[0];
				if (dirty & /*placeholder*/ 16) uiselect_changes.placeholder = /*placeholder*/ ctx[4];
				if (dirty & /*fieldname*/ 32) uiselect_changes.fieldname = /*fieldname*/ ctx[5];
				if (dirty & /*icon*/ 64) uiselect_changes.icon = /*icon*/ ctx[6];
				if (dirty & /*required*/ 128) uiselect_changes.required = /*required*/ ctx[7];
				if (dirty & /*readonly*/ 256) uiselect_changes.readonly = /*readonly*/ ctx[8];
				if (dirty & /*disabled*/ 65536) uiselect_changes.disabled = /*disabled*/ ctx[16];
				if (dirty & /*multiple*/ 512) uiselect_changes.multiple = /*multiple*/ ctx[9];
				if (dirty & /*size*/ 1024) uiselect_changes.size = /*size*/ ctx[10];
				if (dirty & /*valid*/ 2048) uiselect_changes.valid = /*valid*/ ctx[11];
				if (dirty & /*validated*/ 4096) uiselect_changes.validated = /*validated*/ ctx[12];
				if (dirty & /*errors*/ 2) uiselect_changes.errors = /*errors*/ ctx[1];
				if (dirty & /*formErrors*/ 8192) uiselect_changes.formErrors = /*formErrors*/ ctx[13];
				if (dirty & /*formLevelError*/ 16384) uiselect_changes.formLevelError = /*formLevelError*/ ctx[14];
				uiselect.$set(uiselect_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselect.$$.fragment, local);
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselect.$$.fragment, local);
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div0);
					detach(t);
					detach(div1);
				}

				destroy_component(uiselect);
				destroy_component(uibuttons);
			}
		};
	}

	// (104:0) {#if state === "hidden"}
	function create_if_block$T(ctx) {
		let uibutton;
		let current;
		const uibutton_spread_levels = [/*ACTIONS*/ ctx[18].add];
		let uibutton_props = {};

		for (let i = 0; i < uibutton_spread_levels.length; i += 1) {
			uibutton_props = assign(uibutton_props, uibutton_spread_levels[i]);
		}

		uibutton = new Ui_button({ props: uibutton_props });

		return {
			c() {
				create_component(uibutton.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibutton_changes = (dirty & /*ACTIONS*/ 262144)
				? get_spread_update(uibutton_spread_levels, [get_spread_object(/*ACTIONS*/ ctx[18].add)])
				: {};

				uibutton.$set(uibutton_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibutton, detaching);
			}
		};
	}

	function create_fragment$1q(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$T, create_if_block_1$I];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*state*/ ctx[15] === "hidden") return 0;
			if (/*state*/ ctx[15] == "show") return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						} else {
							if_block.p(ctx, dirty);
						}

						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}
			}
		};
	}

	let loaded$1 = false;

	function instance$1p($$self, $$props, $$invalidate) {
		let disabled;
		const dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value } = $$props;
		let { variants = [] } = $$props;
		let { placeholder = "empty select item" } = $$props;
		let { fieldname = "selectFromModel" } = $$props;
		let { modelName = "" } = $$props;
		let { actionName = "" } = $$props;
		let { actionFilter = {} } = $$props;
		let { actionSorter = {} } = $$props;
		let { actionPager = {} } = $$props;
		let { actionSearch = undefined } = $$props;
		let { optionId = ":_id" } = $$props;
		let { optionTitle = ":title" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { multiple = false } = $$props;
		let { size = 8 } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function argumentsSetProvided() {
			return modelName && actionName && actionFilter;
		}

		let state = "hidden";
		let resultsList = [];

		onMount(async () => {
			if (argumentsSetProvided()) {
				const notApp = notCommon$2.getApp();
				const Model = notApp.getModel(modelName).setFilter(actionFilter).setSorter(actionSorter).setPager(actionPager).setSearch(actionSearch);
				const response = await Model[`$` + actionName]();

				if (response.status === DEFAULT_STATUS_SUCCESS) {
					resultsList = response.result;

					$$invalidate(0, variants = resultsList.map(item => {
						return {
							id: notPath$1.get(optionId, item),
							title: notPath$1.get(optionTitle, item)
						};
					}));
				} else {
					$$invalidate(1, errors = result.errors || [result.message]);
				}
			}
		});

		let resolvedValue;

		function onModelChanged({ detail }) {
			resolvedValue = resultsList.find(item => notPath$1.get(optionId, item) === detail.value);
		}

		const ACTIONS = {
			add: {
				color: "primary",
				icon: "plus",
				action() {
					$$invalidate(15, state = "show");
				}
			},
			resolve: {
				icon: "check",
				color: "primary",
				action() {
					$$invalidate(15, state = "hidden");
					dispatch("resolve", resolvedValue);
				}
			},
			reject: {
				icon: "close",
				color: "danger",
				action() {
					$$invalidate(15, state = "hidden");
					dispatch("reject");
				}
			}
		};

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(2, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(3, value = $$props.value);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(5, fieldname = $$props.fieldname);
			if ('modelName' in $$props) $$invalidate(19, modelName = $$props.modelName);
			if ('actionName' in $$props) $$invalidate(20, actionName = $$props.actionName);
			if ('actionFilter' in $$props) $$invalidate(21, actionFilter = $$props.actionFilter);
			if ('actionSorter' in $$props) $$invalidate(22, actionSorter = $$props.actionSorter);
			if ('actionPager' in $$props) $$invalidate(23, actionPager = $$props.actionPager);
			if ('actionSearch' in $$props) $$invalidate(24, actionSearch = $$props.actionSearch);
			if ('optionId' in $$props) $$invalidate(25, optionId = $$props.optionId);
			if ('optionTitle' in $$props) $$invalidate(26, optionTitle = $$props.optionTitle);
			if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(7, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(8, readonly = $$props.readonly);
			if ('multiple' in $$props) $$invalidate(9, multiple = $$props.multiple);
			if ('size' in $$props) $$invalidate(10, size = $$props.size);
			if ('valid' in $$props) $$invalidate(11, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(12, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(1, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(13, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(14, formLevelError = $$props.formLevelError);
		};

		$$invalidate(16, disabled = !loaded$1);

		return [
			variants,
			errors,
			inputStarted,
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			multiple,
			size,
			valid,
			validated,
			formErrors,
			formLevelError,
			state,
			disabled,
			onModelChanged,
			ACTIONS,
			modelName,
			actionName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch,
			optionId,
			optionTitle
		];
	}

	class Ui_select_from_model_on_demand_inline extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1p, create_fragment$1q, safe_not_equal, {
				inputStarted: 2,
				value: 3,
				variants: 0,
				placeholder: 4,
				fieldname: 5,
				modelName: 19,
				actionName: 20,
				actionFilter: 21,
				actionSorter: 22,
				actionPager: 23,
				actionSearch: 24,
				optionId: 25,
				optionTitle: 26,
				icon: 6,
				required: 7,
				readonly: 8,
				multiple: 9,
				size: 10,
				valid: 11,
				validated: 12,
				errors: 1,
				formErrors: 13,
				formLevelError: 14
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.select.from.model.with.search.modal.svelte generated by Svelte v4.2.19 */

	function create_fragment$1p(ctx) {
		let div;
		let uibuttons;
		let current;

		uibuttons = new Ui_buttons({
				props: {
					values: /*VISIBLE_BUTTONS*/ ctx[0],
					classes: "is-no-flex-wrap"
				}
			});

		return {
			c() {
				div = element("div");
				create_component(uibuttons.$$.fragment);
				attr(div, "class", "control");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uibuttons, div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibuttons_changes = {};
				if (dirty & /*VISIBLE_BUTTONS*/ 1) uibuttons_changes.values = /*VISIBLE_BUTTONS*/ ctx[0];
				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uibuttons);
			}
		};
	}

	function instance$1o($$self, $$props, $$invalidate) {
		let dispatch = createEventDispatcher();
		let { value } = $$props;
		let { inputStarted = false } = $$props;
		let { icon = false } = $$props;
		let { fieldname = "" } = $$props;
		let { readonly = false } = $$props;
		let { serviceName = "" } = $$props;
		let { serviceOpenSelectorMethod = "openSelector" } = $$props;
		let { serviceLoadDataMethod = "loadData" } = $$props;
		let { modelData = null } = $$props;
		let { loading = false } = $$props;
		let { selectedModelTitleFormatter = data => `${data._id}` } = $$props;
		let { loadingLabel = "not-node:loading_label" } = $$props;
		let { isEmptyLabel = "not-node:field_value_is_empty_placeholder" } = $$props;

		function getService() {
			if (!serviceName) throw new Error("serviceName is not set");
			return notCommon$2.getApp().getService(serviceName);
		}

		function openModelSearchAndSelect() {
			if (!serviceOpenSelectorMethod) {
				throw new Error("serviceOpenSelectorMethod is not set");
			}

			getService()[serviceOpenSelectorMethod]().then(results => {
				$$invalidate(1, value = results._id);
				$$invalidate(3, modelData = results);
				return value;
			}).then(value => {
				$$invalidate(2, inputStarted = true);
				dispatch("change", { field: fieldname, value });
			}).catch(e => {
				notCommon$2.report(e);
			});
		}

		function resetSelectedModel() {
			$$invalidate(1, value = undefined);
			$$invalidate(3, modelData = null);
			dispatch("change", { field: fieldname, value });
		}

		async function loadModelData() {
			try {
				if (value) {
					$$invalidate(4, loading = true);
					$$invalidate(3, modelData = await getService()[serviceLoadDataMethod](value));
				}
			} catch(e) {
				notCommon$2.report(e);
			} finally {
				$$invalidate(4, loading = false);
			}
		}

		onMount(() => {
			loadModelData();
		});

		const AVAILABLE_BUTTONS = [
			{
				id: 1,
				action: openModelSearchAndSelect,
				icon,
				color: "warning"
			},
			{
				id: 2,
				action: resetSelectedModel,
				icon: "times",
				color: "danger"
			}
		];

		function getModelButton() {
			if (loading) {
				return {
					disabled: true,
					loading,
					title: loadingLabel
				};
			} else {
				if (modelData) {
					return {
						disabled: readonly,
						action: openModelSearchAndSelect,
						title: selectedModelTitleFormatter(modelData)
					};
				} else {
					return { disabled: true, title: isEmptyLabel };
				}
			}
		}

		let VISIBLE_BUTTONS = [];

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(1, value = $$props.value);
			if ('inputStarted' in $$props) $$invalidate(2, inputStarted = $$props.inputStarted);
			if ('icon' in $$props) $$invalidate(5, icon = $$props.icon);
			if ('fieldname' in $$props) $$invalidate(6, fieldname = $$props.fieldname);
			if ('readonly' in $$props) $$invalidate(7, readonly = $$props.readonly);
			if ('serviceName' in $$props) $$invalidate(8, serviceName = $$props.serviceName);
			if ('serviceOpenSelectorMethod' in $$props) $$invalidate(9, serviceOpenSelectorMethod = $$props.serviceOpenSelectorMethod);
			if ('serviceLoadDataMethod' in $$props) $$invalidate(10, serviceLoadDataMethod = $$props.serviceLoadDataMethod);
			if ('modelData' in $$props) $$invalidate(3, modelData = $$props.modelData);
			if ('loading' in $$props) $$invalidate(4, loading = $$props.loading);
			if ('selectedModelTitleFormatter' in $$props) $$invalidate(11, selectedModelTitleFormatter = $$props.selectedModelTitleFormatter);
			if ('loadingLabel' in $$props) $$invalidate(12, loadingLabel = $$props.loadingLabel);
			if ('isEmptyLabel' in $$props) $$invalidate(13, isEmptyLabel = $$props.isEmptyLabel);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value, readonly*/ 130) {
				{
					if (value) {
						$$invalidate(0, VISIBLE_BUTTONS = [getModelButton(), ...readonly ? [] : AVAILABLE_BUTTONS]);
					} else {
						$$invalidate(0, VISIBLE_BUTTONS = [getModelButton(), ...readonly ? [] : [AVAILABLE_BUTTONS[0]]]);
					}
				}
			}
		};

		return [
			VISIBLE_BUTTONS,
			value,
			inputStarted,
			modelData,
			loading,
			icon,
			fieldname,
			readonly,
			serviceName,
			serviceOpenSelectorMethod,
			serviceLoadDataMethod,
			selectedModelTitleFormatter,
			loadingLabel,
			isEmptyLabel
		];
	}

	class Ui_select_from_model_with_search_modal extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1o, create_fragment$1p, safe_not_equal, {
				value: 1,
				inputStarted: 2,
				icon: 5,
				fieldname: 6,
				readonly: 7,
				serviceName: 8,
				serviceOpenSelectorMethod: 9,
				serviceLoadDataMethod: 10,
				modelData: 3,
				loading: 4,
				selectedModelTitleFormatter: 11,
				loadingLabel: 12,
				isEmptyLabel: 13
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.progress.svelte generated by Svelte v4.2.19 */

	function create_fragment$1o(ctx) {
		let progress;
		let t0;
		let t1;
		let progress_class_value;

		return {
			c() {
				progress = element("progress");
				t0 = text(/*value*/ ctx[0]);
				t1 = text("%");
				attr(progress, "class", progress_class_value = "progress " + /*classes*/ ctx[4] + " " + (/*color*/ ctx[2] ? `is-${/*color*/ ctx[2]}` : '') + " " + (/*size*/ ctx[3] ? `is-${/*size*/ ctx[3]}` : ''));
				progress.value = /*value*/ ctx[0];
				attr(progress, "max", /*max*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, progress, anchor);
				append(progress, t0);
				append(progress, t1);
			},
			p(ctx, [dirty]) {
				if (dirty & /*value*/ 1) set_data(t0, /*value*/ ctx[0]);

				if (dirty & /*classes, color, size*/ 28 && progress_class_value !== (progress_class_value = "progress " + /*classes*/ ctx[4] + " " + (/*color*/ ctx[2] ? `is-${/*color*/ ctx[2]}` : '') + " " + (/*size*/ ctx[3] ? `is-${/*size*/ ctx[3]}` : ''))) {
					attr(progress, "class", progress_class_value);
				}

				if (dirty & /*value*/ 1) {
					progress.value = /*value*/ ctx[0];
				}

				if (dirty & /*max*/ 2) {
					attr(progress, "max", /*max*/ ctx[1]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(progress);
				}
			}
		};
	}

	function instance$1n($$self, $$props, $$invalidate) {
		let { value } = $$props;
		let { max = 100 } = $$props;
		let { color = "" } = $$props;
		let { size = "" } = $$props;
		let { classes = "" } = $$props;

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('max' in $$props) $$invalidate(1, max = $$props.max);
			if ('color' in $$props) $$invalidate(2, color = $$props.color);
			if ('size' in $$props) $$invalidate(3, size = $$props.size);
			if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
		};

		return [value, max, color, size, classes];
	}

	class Ui_progress extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1n, create_fragment$1o, safe_not_equal, {
				value: 0,
				max: 1,
				color: 2,
				size: 3,
				classes: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.show.one.from.list.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$H(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		var switch_value = /*UIPlaceholder*/ ctx[2];

		function switch_props(ctx, dirty) {
			return {};
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props());
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*UIPlaceholder*/ 4 && switch_value !== (switch_value = /*UIPlaceholder*/ ctx[2])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props());
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (17:0) {#if active}
	function create_if_block$S(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*active*/ ctx[0]];
		var switch_value = /*UIComponent*/ ctx[1];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*active*/ 1) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*active*/ ctx[0])]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*UIComponent*/ 2 && switch_value !== (switch_value = /*UIComponent*/ ctx[1])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*active*/ 1)
					? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*active*/ ctx[0])])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1n(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$S, create_if_block_1$H];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*active*/ ctx[0]) return 0;
			if (/*UIPlaceholder*/ ctx[2]) return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						} else {
							if_block.p(ctx, dirty);
						}

						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}
			}
		};
	}

	function instance$1m($$self, $$props, $$invalidate) {
		const defaultFilter = value => value[idFieldName] === id;
		let { values = [] } = $$props;
		let { id } = $$props;
		let { UIComponent } = $$props;
		let { UIPlaceholder } = $$props;
		let { active } = $$props;
		let { idFieldName = "_id" } = $$props;
		let { filter = defaultFilter } = $$props;

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(3, values = $$props.values);
			if ('id' in $$props) $$invalidate(4, id = $$props.id);
			if ('UIComponent' in $$props) $$invalidate(1, UIComponent = $$props.UIComponent);
			if ('UIPlaceholder' in $$props) $$invalidate(2, UIPlaceholder = $$props.UIPlaceholder);
			if ('active' in $$props) $$invalidate(0, active = $$props.active);
			if ('idFieldName' in $$props) $$invalidate(5, idFieldName = $$props.idFieldName);
			if ('filter' in $$props) $$invalidate(6, filter = $$props.filter);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*values, id, filter*/ 88) {
				$$invalidate(0, active = Array.isArray(values) && values.length && typeof id !== "undefined"
				? values.find(filter || defaultFilter)
				: undefined);
			}
		};

		return [active, UIComponent, UIPlaceholder, values, id, idFieldName, filter];
	}

	class Ui_show_one_from_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1m, create_fragment$1n, safe_not_equal, {
				values: 3,
				id: 4,
				UIComponent: 1,
				UIPlaceholder: 2,
				active: 0,
				idFieldName: 5,
				filter: 6
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.tag.value.svelte generated by Svelte v4.2.19 */

	function create_if_block_2$u(ctx) {
		let uitag;
		let current;
		const uitag_spread_levels = [/*title*/ ctx[1]];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitag_changes = (dirty & /*title*/ 2)
				? get_spread_update(uitag_spread_levels, [get_spread_object(/*title*/ ctx[1])])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	// (18:4) {#if value}
	function create_if_block_1$G(ctx) {
		let uitag;
		let current;
		const uitag_spread_levels = [/*value*/ ctx[2]];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitag_changes = (dirty & /*value*/ 4)
				? get_spread_update(uitag_spread_levels, [get_spread_object(/*value*/ ctx[2])])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	// (19:4) {#if !readonly && actions && actions.length}
	function create_if_block$R(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ values: /*actions*/ ctx[3] }, /*actionsGroupProps*/ ctx[6]];
		var switch_value = /*actionsGroupContructor*/ ctx[5];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*actions, actionsGroupProps*/ 72) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*actions*/ 8 && { values: /*actions*/ ctx[3] },
					dirty & /*actionsGroupProps*/ 64 && get_spread_object(/*actionsGroupProps*/ ctx[6])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*actionsGroupContructor*/ 32 && switch_value !== (switch_value = /*actionsGroupContructor*/ ctx[5])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*actions, actionsGroupProps*/ 72)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*actions*/ 8 && { values: /*actions*/ ctx[3] },
							dirty & /*actionsGroupProps*/ 64 && get_spread_object(/*actionsGroupProps*/ ctx[6])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1m(ctx) {
		let div;
		let t0;
		let t1;
		let div_class_value;
		let current;
		let if_block0 = /*title*/ ctx[1] && create_if_block_2$u(ctx);
		let if_block1 = /*value*/ ctx[2] && create_if_block_1$G(ctx);
		let if_block2 = !/*readonly*/ ctx[7] && /*actions*/ ctx[3] && /*actions*/ ctx[3].length && create_if_block$R(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(div, "class", div_class_value = "tags has-addons " + /*classes*/ ctx[4]);
				attr(div, "id", /*id*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				if (if_block1) if_block1.m(div, null);
				append(div, t1);
				if (if_block2) if_block2.m(div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*title*/ ctx[1]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*title*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$u(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*value*/ ctx[2]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*value*/ 4) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$G(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!/*readonly*/ ctx[7] && /*actions*/ ctx[3] && /*actions*/ ctx[3].length) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*readonly, actions*/ 136) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block$R(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*classes*/ 16 && div_class_value !== (div_class_value = "tags has-addons " + /*classes*/ ctx[4])) {
					attr(div, "class", div_class_value);
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	function instance$1l($$self, $$props, $$invalidate) {
		let { id = "taggedValueId" } = $$props;
		let { title } = $$props;
		let { value } = $$props;
		let { actions = [] } = $$props;
		let { classes = "" } = $$props;
		let { actionsGroupContructor = Ui_buttons } = $$props;
		let { actionsGroupProps = {} } = $$props;
		let { readonly = false } = $$props;

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('value' in $$props) $$invalidate(2, value = $$props.value);
			if ('actions' in $$props) $$invalidate(3, actions = $$props.actions);
			if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
			if ('actionsGroupContructor' in $$props) $$invalidate(5, actionsGroupContructor = $$props.actionsGroupContructor);
			if ('actionsGroupProps' in $$props) $$invalidate(6, actionsGroupProps = $$props.actionsGroupProps);
			if ('readonly' in $$props) $$invalidate(7, readonly = $$props.readonly);
		};

		return [
			id,
			title,
			value,
			actions,
			classes,
			actionsGroupContructor,
			actionsGroupProps,
			readonly
		];
	}

	class Ui_tag_value extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1l, create_fragment$1m, safe_not_equal, {
				id: 0,
				title: 1,
				value: 2,
				actions: 3,
				classes: 4,
				actionsGroupContructor: 5,
				actionsGroupProps: 6,
				readonly: 7
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.title.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$F(ctx) {
		let html_tag;
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(/*resultTitle*/ ctx[3], target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*resultTitle*/ 8) html_tag.p(/*resultTitle*/ ctx[3]);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	// (35:0) {#if subtitle}
	function create_if_block$Q(ctx) {
		let html_tag;
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(/*resultSubtitle*/ ctx[2], target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*resultSubtitle*/ 4) html_tag.p(/*resultSubtitle*/ ctx[2]);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	function create_fragment$1l(ctx) {
		let t;
		let if_block1_anchor;
		let if_block0 = /*title*/ ctx[0] && create_if_block_1$F(ctx);
		let if_block1 = /*subtitle*/ ctx[1] && create_if_block$Q(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*title*/ ctx[0]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$F(ctx);
						if_block0.c();
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*subtitle*/ ctx[1]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$Q(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	function instance$1k($$self, $$props, $$invalidate) {
		let spacedStyle;
		let resultTitle;
		let resultSubtitle;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(12, $LOCALE = $$value));
		let { id = `title-${Math.random()}` } = $$props;
		let { title = "" } = $$props;
		let { subtitle } = $$props;
		let { size = 1 } = $$props;
		let { subsize } = $$props;
		let { spaced = false } = $$props;
		let { align = "left" } = $$props;

		const scrollToTop = (options = UICommon.SCROLL_OPTIONS) => {
			setTimeout(
				() => {
					document.getElementById(id).scrollIntoView(options);
				},
				100
			);
		};

		let size2;

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(4, id = $$props.id);
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('subtitle' in $$props) $$invalidate(1, subtitle = $$props.subtitle);
			if ('size' in $$props) $$invalidate(5, size = $$props.size);
			if ('subsize' in $$props) $$invalidate(6, subsize = $$props.subsize);
			if ('spaced' in $$props) $$invalidate(7, spaced = $$props.spaced);
			if ('align' in $$props) $$invalidate(8, align = $$props.align);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*subsize, size*/ 96) {
				$$invalidate(10, size2 = subsize
				? subsize
				: parseInt(size) < 6 ? parseInt(size) + 1 : size);
			}

			if ($$self.$$.dirty & /*spaced*/ 128) {
				$$invalidate(11, spacedStyle = spaced ? "is-spaced" : "");
			}

			if ($$self.$$.dirty & /*size, id, align, spacedStyle, $LOCALE, title*/ 6449) {
				$$invalidate(3, resultTitle = `<h${size} id="${id}" style="text-align: ${align};" class="title ${spacedStyle} is-${size}">${$LOCALE[title]}</h${size}>`);
			}

			if ($$self.$$.dirty & /*size2, id, align, $LOCALE, subtitle*/ 5394) {
				$$invalidate(2, resultSubtitle = `<h${size2} id="${id}" style="text-align: ${align};" class="subtitle is-${size2}">${$LOCALE[subtitle]}</h${size2}>`);
			}
		};

		return [
			title,
			subtitle,
			resultSubtitle,
			resultTitle,
			id,
			size,
			subsize,
			spaced,
			align,
			scrollToTop,
			size2,
			spacedStyle,
			$LOCALE
		];
	}

	class Ui_title extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1k, create_fragment$1l, safe_not_equal, {
				id: 4,
				title: 0,
				subtitle: 1,
				size: 5,
				subsize: 6,
				spaced: 7,
				align: 8,
				scrollToTop: 9
			});
		}

		get scrollToTop() {
			return this.$$.ctx[9];
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.user.card.svelte generated by Svelte v4.2.19 */

	function create_fragment$1k(ctx) {
		let article;
		let figure;
		let p0;
		let img;
		let img_src_value;
		let t0;
		let div1;
		let div0;
		let p1;
		let strong0;
		let t1;
		let t2;
		let small;
		let t4;
		let strong1;
		let t5;

		return {
			c() {
				article = element("article");
				figure = element("figure");
				p0 = element("p");
				img = element("img");
				t0 = space();
				div1 = element("div");
				div0 = element("div");
				p1 = element("p");
				strong0 = element("strong");
				t1 = text(/*username*/ ctx[0]);
				t2 = space();
				small = element("small");
				small.textContent = "@";
				t4 = space();
				strong1 = element("strong");
				t5 = text(/*role*/ ctx[1]);
				if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[2])) attr(img, "src", img_src_value);
				attr(img, "alt", /*username*/ ctx[0]);
				attr(p0, "class", "image is-32x32");
				attr(figure, "class", "media-left");
				attr(div0, "class", "content");
				attr(div1, "class", "media-content");
				attr(article, "id", /*getCompId*/ ctx[3]());
				attr(article, "class", "media");
			},
			m(target, anchor) {
				insert(target, article, anchor);
				append(article, figure);
				append(figure, p0);
				append(p0, img);
				append(article, t0);
				append(article, div1);
				append(div1, div0);
				append(div0, p1);
				append(p1, strong0);
				append(strong0, t1);
				append(p1, t2);
				append(p1, small);
				append(p1, t4);
				append(p1, strong1);
				append(strong1, t5);
			},
			p(ctx, [dirty]) {
				if (dirty & /*image*/ 4 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[2])) {
					attr(img, "src", img_src_value);
				}

				if (dirty & /*username*/ 1) {
					attr(img, "alt", /*username*/ ctx[0]);
				}

				if (dirty & /*username*/ 1) set_data(t1, /*username*/ ctx[0]);
				if (dirty & /*role*/ 2) set_data(t5, /*role*/ ctx[1]);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(article);
				}
			}
		};
	}

	function instance$1j($$self, $$props, $$invalidate) {
		let { id = "userCard" } = $$props;
		let { image = "https://bulma.io/images/placeholders/32x32.png" } = $$props;
		let { username = "John Doe" } = $$props;
		let { role = "admin" } = $$props;
		let { events = {} } = $$props;
		let { register = notCommon$2.registerWidgetEvents } = $$props;

		let { onUpdate = data => {
			if (Object.hasOwn(data, "username")) {
				$$invalidate(0, username = data.username);
			}

			if (Object.hasOwn(data, "role")) {
				$$invalidate(1, role = data.role);
			}
		} } = $$props;

		function getCompId() {
			return `usercard-${id}`;
		}

		function getStandartUpdateEventName() {
			let compId = getCompId();
			return `${compId}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events, getStandartUpdateEventName())) {
				$$invalidate(4, events[getStandartUpdateEventName()] = onUpdate, events);
			}

			register(events);
		});

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(5, id = $$props.id);
			if ('image' in $$props) $$invalidate(2, image = $$props.image);
			if ('username' in $$props) $$invalidate(0, username = $$props.username);
			if ('role' in $$props) $$invalidate(1, role = $$props.role);
			if ('events' in $$props) $$invalidate(4, events = $$props.events);
			if ('register' in $$props) $$invalidate(6, register = $$props.register);
			if ('onUpdate' in $$props) $$invalidate(7, onUpdate = $$props.onUpdate);
		};

		return [username, role, image, getCompId, events, id, register, onUpdate];
	}

	class Ui_user_card extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1j, create_fragment$1k, safe_not_equal, {
				id: 5,
				image: 2,
				username: 0,
				role: 1,
				events: 4,
				register: 6,
				onUpdate: 7
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.textfield.svelte generated by Svelte v4.2.19 */

	function create_else_block$z(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4$g(ctx);
		let if_block1 = /*validated*/ ctx[8] === true && create_if_block_1$E(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-textfield-" + /*fieldname*/ ctx[2]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[9]);
				attr(input, "type", "text");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[10]);
				input.disabled = /*disabled*/ ctx[5];
				input.required = /*required*/ ctx[4];
				input.readOnly = /*readonly*/ ctx[6];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[21]),
						listen(input, "change", /*onBlur*/ ctx[15]),
						listen(input, "input", /*onInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-textfield-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty & /*disabled*/ 32) {
					input.disabled = /*disabled*/ ctx[5];
				}

				if (dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (dirty & /*readonly*/ 64) {
					input.readOnly = /*readonly*/ ctx[6];
				}

				if (dirty & /*$LOCALE, placeholder*/ 16386 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$g(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[8] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$E(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (56:4) {#if readonly}
	function create_if_block$P(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (76:8) {#if icon}
	function create_if_block_4$g(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (81:8) {#if validated === true}
	function create_if_block_1$E(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[7] === true) return create_if_block_2$t;
			if (/*valid*/ ctx[7] === false) return create_if_block_3$n;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (85:42) 
	function create_if_block_3$n(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (83:16) {#if valid === true}
	function create_if_block_2$t(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$1j(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return create_if_block$P;
			return create_else_block$z;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$1i($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(14, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "input some text here, please" } = $$props;
		let { fieldname = "textfield" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur() /*ev*/ {
			let data = { field: fieldname, value };
			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(8, validated)), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(7, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(8, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 786432) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131456) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 1048704) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131200) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_textfield extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1i, create_fragment$1j, safe_not_equal, {
				inputStarted: 17,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				disabled: 5,
				readonly: 6,
				valid: 7,
				validated: 8,
				errors: 18,
				formErrors: 19,
				formLevelError: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.simple.search.input.svelte generated by Svelte v4.2.19 */

	function create_fragment$1i(ctx) {
		let div2;
		let div1;
		let div0;
		let uitextfield;
		let updating_value;
		let current;

		function uitextfield_value_binding(value) {
			/*uitextfield_value_binding*/ ctx[3](value);
		}

		let uitextfield_props = {
			placeholder: /*placeholder*/ ctx[1],
			fieldname: "searchTermInput",
			icon: "magnifying-glass"
		};

		if (/*term*/ ctx[0] !== void 0) {
			uitextfield_props.value = /*term*/ ctx[0];
		}

		uitextfield = new Ui_textfield({ props: uitextfield_props });
		binding_callbacks.push(() => bind(uitextfield, 'value', uitextfield_value_binding));
		uitextfield.$on("change", /*onChange*/ ctx[2]);

		return {
			c() {
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				create_component(uitextfield.$$.fragment);
				attr(div0, "class", "field");
				attr(div1, "class", "column");
				attr(div2, "class", "columns");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				append(div1, div0);
				mount_component(uitextfield, div0, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uitextfield_changes = {};
				if (dirty & /*placeholder*/ 2) uitextfield_changes.placeholder = /*placeholder*/ ctx[1];

				if (!updating_value && dirty & /*term*/ 1) {
					updating_value = true;
					uitextfield_changes.value = /*term*/ ctx[0];
					add_flush_callback(() => updating_value = false);
				}

				uitextfield.$set(uitextfield_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitextfield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitextfield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				destroy_component(uitextfield);
			}
		};
	}

	function instance$1h($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(4, $LOCALE = $$value));
		const dispatch = createEventDispatcher();
		let { placeholder = $LOCALE['not-node:field_search_placeholder'] } = $$props;
		let { term = '' } = $$props;

		function onChange({ detail }) {
			dispatch('termChange', detail);
		}

		function uitextfield_value_binding(value) {
			term = value;
			$$invalidate(0, term);
		}

		$$self.$$set = $$props => {
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('term' in $$props) $$invalidate(0, term = $$props.term);
		};

		return [term, placeholder, onChange, uitextfield_value_binding];
	}

	class Ui_simple_search_input extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1h, create_fragment$1i, safe_not_equal, { placeholder: 1, term: 0 });
		}
	}

	var index$9 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBoolean: Ui_boolean,
		UIBooleanLabeled: Ui_boolean_labeled,
		UIBooleans: Ui_booleans,
		UICensored: Ui_censored,
		UIErrorsList: Ui_errors_list,
		UIIndicator: Ui_indicator,
		UILoader: Ui_loader,
		UIProgress: Ui_progress,
		UISelectFromModelOnDemandInline: Ui_select_from_model_on_demand_inline,
		UISelectFromModelWithSearchModal: Ui_select_from_model_with_search_modal,
		UIShowOneFromList: Ui_show_one_from_list,
		UISimpleSearchInput: Ui_simple_search_input,
		UITag: Ui_tag,
		UITagValue: Ui_tag_value,
		UITitle: Ui_title,
		UIUserCard: Ui_user_card
	});

	/*
	Adapted from https://github.com/mattdesl
	Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
	*/

	/**
	 * https://svelte.dev/docs/svelte-easing
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicOut(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	/**
	 * The flip function calculates the start and end position of an element and animates between them, translating the x and y values.
	 * `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/).
	 *
	 * https://svelte.dev/docs/svelte-animate#flip
	 * @param {Element} node
	 * @param {{ from: DOMRect; to: DOMRect }} fromTo
	 * @param {import('./public.js').FlipParams} params
	 * @returns {import('./public.js').AnimationConfig}
	 */
	function flip(node, { from, to }, params = {}) {
		const style = getComputedStyle(node);
		const transform = style.transform === 'none' ? '' : style.transform;
		const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
		const dx = from.left + (from.width * ox) / to.width - (to.left + ox);
		const dy = from.top + (from.height * oy) / to.height - (to.top + oy);
		const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
		return {
			delay,
			duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
			easing,
			css: (t, u) => {
				const x = u * dx;
				const y = u * dy;
				const sx = t + (u * from.width) / to.width;
				const sy = t + (u * from.height) / to.height;
				return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
			}
		};
	}

	/**
	 * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.
	 *
	 * https://svelte.dev/docs/svelte-transition#fade
	 * @param {Element} node
	 * @param {import('./public').FadeParams} [params]
	 * @returns {import('./public').TransitionConfig}
	 */
	function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
		const o = +getComputedStyle(node).opacity;
		return {
			delay,
			duration,
			easing,
			css: (t) => `opacity: ${t * o}`
		};
	}

	/* node_modules/simple-svelte-autocomplete/src/SimpleAutocomplete.svelte generated by Svelte v4.2.19 */

	const { window: window_1 } = globals;

	const get_no_results_slot_changes = dirty => ({
		noResultsText: dirty[0] & /*noResultsText*/ 1024
	});

	const get_no_results_slot_context = ctx => ({ noResultsText: /*noResultsText*/ ctx[10] });

	const get_create_slot_changes = dirty => ({
		createText: dirty[0] & /*createText*/ 8192
	});

	const get_create_slot_context = ctx => ({ createText: /*createText*/ ctx[13] });

	const get_loading_slot_changes = dirty => ({
		loadingText: dirty[0] & /*loadingText*/ 2048
	});

	const get_loading_slot_context = ctx => ({ loadingText: /*loadingText*/ ctx[11] });

	const get_dropdown_footer_slot_changes = dirty => ({
		nbItems: dirty[1] & /*filteredListItems*/ 1,
		maxItemsToShowInList: dirty[0] & /*maxItemsToShowInList*/ 16
	});

	const get_dropdown_footer_slot_context = ctx => ({
		nbItems: /*filteredListItems*/ ctx[31].length,
		maxItemsToShowInList: /*maxItemsToShowInList*/ ctx[4]
	});

	function get_each_context$k(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[144] = list[i];
		child_ctx[146] = i;
		return child_ctx;
	}

	const get_item_slot_changes = dirty => ({
		item: dirty[1] & /*filteredListItems*/ 1,
		label: dirty[1] & /*filteredListItems*/ 1
	});

	const get_item_slot_context = ctx => ({
		item: /*listItem*/ ctx[144].item,
		label: /*listItem*/ ctx[144].highlighted
		? /*listItem*/ ctx[144].highlighted
		: /*listItem*/ ctx[144].label
	});

	const get_dropdown_header_slot_changes = dirty => ({
		nbItems: dirty[1] & /*filteredListItems*/ 1,
		maxItemsToShowInList: dirty[0] & /*maxItemsToShowInList*/ 16
	});

	const get_dropdown_header_slot_context = ctx => ({
		nbItems: /*filteredListItems*/ ctx[31].length,
		maxItemsToShowInList: /*maxItemsToShowInList*/ ctx[4]
	});

	function get_each_context_1$7(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[147] = list[i];
		child_ctx[146] = i;
		return child_ctx;
	}

	const get_tag_slot_changes = dirty => ({
		label: dirty[0] & /*selectedItem*/ 2,
		item: dirty[0] & /*selectedItem*/ 2
	});

	const get_tag_slot_context = ctx => ({
		label: /*safeLabelFunction*/ ctx[43](/*tagItem*/ ctx[147]),
		item: /*tagItem*/ ctx[147],
		unselectItem: /*unselectItem*/ ctx[50]
	});

	function get_each_context_2$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[146] = list[i];
		return child_ctx;
	}

	// (1125:39) 
	function create_if_block_11$2(ctx) {
		let each_1_anchor;
		let each_value_2 = ensure_array_like(/*selectedItem*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*valueFunction, selectedItem*/ 10 | dirty[1] & /*safeLabelFunction*/ 4096) {
					each_value_2 = ensure_array_like(/*selectedItem*/ ctx[1]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block_2$4(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value_2.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (1121:4) {#if !multiple && hasSelection}
	function create_if_block_10$2(ctx) {
		let option;
		let t_value = /*safeLabelFunction*/ ctx[43](/*selectedItem*/ ctx[1]) + "";
		let t;
		let option_value_value;

		return {
			c() {
				option = element("option");
				t = text(t_value);
				option.__value = option_value_value = /*valueFunction*/ ctx[3](/*selectedItem*/ ctx[1], true);
				set_input_value(option, option.__value);
				option.selected = true;
				attr(option, "class", "svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, option, anchor);
				append(option, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectedItem*/ 2 && t_value !== (t_value = /*safeLabelFunction*/ ctx[43](/*selectedItem*/ ctx[1]) + "")) set_data(t, t_value);

				if (dirty[0] & /*valueFunction, selectedItem*/ 10 && option_value_value !== (option_value_value = /*valueFunction*/ ctx[3](/*selectedItem*/ ctx[1], true))) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	// (1126:6) {#each selectedItem as i}
	function create_each_block_2$4(ctx) {
		let option;
		let t0_value = /*safeLabelFunction*/ ctx[43](/*i*/ ctx[146]) + "";
		let t0;
		let t1;
		let option_value_value;

		return {
			c() {
				option = element("option");
				t0 = text(t0_value);
				t1 = space();
				option.__value = option_value_value = /*valueFunction*/ ctx[3](/*i*/ ctx[146], true);
				set_input_value(option, option.__value);
				option.selected = true;
				attr(option, "class", "svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, option, anchor);
				append(option, t0);
				append(option, t1);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectedItem*/ 2 && t0_value !== (t0_value = /*safeLabelFunction*/ ctx[43](/*i*/ ctx[146]) + "")) set_data(t0, t0_value);

				if (dirty[0] & /*valueFunction, selectedItem*/ 10 && option_value_value !== (option_value_value = /*valueFunction*/ ctx[3](/*i*/ ctx[146], true))) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	// (1134:4) {#if multiple && hasSelection}
	function create_if_block_9$2(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let current;
		let each_value_1 = ensure_array_like(/*selectedItem*/ ctx[1]);
		const get_key = ctx => /*valueFunction*/ ctx[3](/*tagItem*/ ctx[147], true);

		for (let i = 0; i < each_value_1.length; i += 1) {
			let child_ctx = get_each_context_1$7(ctx, each_value_1, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block_1$7(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectedItem, valueFunction*/ 10 | dirty[1] & /*draggingOver, dragstart, dragover, dragleave, drop, unselectItem, safeLabelFunction*/ 503844992 | dirty[3] & /*$$scope*/ 8) {
					each_value_1 = ensure_array_like(/*selectedItem*/ ctx[1]);
					group_outros();
					for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block_1$7, each_1_anchor, get_each_context_1$7);
					for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	// (1146:92)              
	function fallback_block_5(ctx) {
		let div;
		let span0;
		let t0_value = /*safeLabelFunction*/ ctx[43](/*tagItem*/ ctx[147]) + "";
		let t0;
		let t1;
		let span1;
		let mounted;
		let dispose;

		function keypress_handler(...args) {
			return /*keypress_handler*/ ctx[99](/*tagItem*/ ctx[147], ...args);
		}

		return {
			c() {
				div = element("div");
				span0 = element("span");
				t0 = text(t0_value);
				t1 = space();
				span1 = element("span");
				attr(span0, "class", "tag svelte-75ckfb");
				attr(span1, "class", "tag is-delete svelte-75ckfb");
				attr(div, "class", "tags has-addons svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span0);
				append(span0, t0);
				append(div, t1);
				append(div, span1);

				if (!mounted) {
					dispose = [
						listen(span1, "click", prevent_default(function () {
							if (is_function(/*unselectItem*/ ctx[50](/*tagItem*/ ctx[147]))) /*unselectItem*/ ctx[50](/*tagItem*/ ctx[147]).apply(this, arguments);
						})),
						listen(span1, "keypress", prevent_default(keypress_handler))
					];

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty[0] & /*selectedItem*/ 2 && t0_value !== (t0_value = /*safeLabelFunction*/ ctx[43](/*tagItem*/ ctx[147]) + "")) set_data(t0, t0_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1135:6) {#each selectedItem as tagItem, i (valueFunction(tagItem, true))}
	function create_each_block_1$7(key_1, ctx) {
		let div;
		let t;
		let div_transition;
		let rect;
		let stop_animation = noop$1;
		let current;
		let mounted;
		let dispose;
		const tag_slot_template = /*#slots*/ ctx[97].tag;
		const tag_slot = create_slot(tag_slot_template, ctx, /*$$scope*/ ctx[96], get_tag_slot_context);
		const tag_slot_or_fallback = tag_slot || fallback_block_5(ctx);

		function dragstart_handler(...args) {
			return /*dragstart_handler*/ ctx[100](/*i*/ ctx[146], ...args);
		}

		function dragover_handler(...args) {
			return /*dragover_handler*/ ctx[101](/*i*/ ctx[146], ...args);
		}

		function dragleave_handler(...args) {
			return /*dragleave_handler*/ ctx[102](/*i*/ ctx[146], ...args);
		}

		function drop_handler(...args) {
			return /*drop_handler*/ ctx[103](/*i*/ ctx[146], ...args);
		}

		return {
			key: key_1,
			first: null,
			c() {
				div = element("div");
				if (tag_slot_or_fallback) tag_slot_or_fallback.c();
				t = space();
				attr(div, "draggable", true);
				attr(div, "class", "svelte-75ckfb");
				toggle_class(div, "is-active", /*draggingOver*/ ctx[38] === /*i*/ ctx[146]);
				this.first = div;
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (tag_slot_or_fallback) {
					tag_slot_or_fallback.m(div, null);
				}

				append(div, t);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "dragstart", dragstart_handler),
						listen(div, "dragover", dragover_handler),
						listen(div, "dragleave", dragleave_handler),
						listen(div, "drop", drop_handler)
					];

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (tag_slot) {
					if (tag_slot.p && (!current || dirty[0] & /*selectedItem*/ 2 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							tag_slot,
							tag_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(tag_slot_template, /*$$scope*/ ctx[96], dirty, get_tag_slot_changes),
							get_tag_slot_context
						);
					}
				} else {
					if (tag_slot_or_fallback && tag_slot_or_fallback.p && (!current || dirty[0] & /*selectedItem*/ 2)) {
						tag_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}

				if (!current || dirty[0] & /*selectedItem*/ 2 | dirty[1] & /*draggingOver*/ 128) {
					toggle_class(div, "is-active", /*draggingOver*/ ctx[38] === /*i*/ ctx[146]);
				}
			},
			r() {
				rect = div.getBoundingClientRect();
			},
			f() {
				fix_position(div);
				stop_animation();
				add_transform(div, rect);
			},
			a() {
				stop_animation();
				stop_animation = create_animation(div, rect, flip, { duration: 200 });
			},
			i(local) {
				if (current) return;
				transition_in(tag_slot_or_fallback, local);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 200 }, true);
						div_transition.run(1);
					});
				}

				current = true;
			},
			o(local) {
				transition_out(tag_slot_or_fallback, local);

				if (local) {
					if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 200 }, false);
					div_transition.run(0);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (tag_slot_or_fallback) tag_slot_or_fallback.d(detaching);
				if (detaching && div_transition) div_transition.end();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1185:4) {#if clearable}
	function create_if_block_8$2(ctx) {
		let span;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				attr(span, "class", "autocomplete-clear-button svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				span.innerHTML = /*clearText*/ ctx[8];

				if (!mounted) {
					dispose = [
						listen(span, "click", /*clear*/ ctx[54]),
						listen(span, "keypress", /*keypress_handler_1*/ ctx[108])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*clearText*/ 256) span.innerHTML = /*clearText*/ ctx[8];		},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1250:28) 
	function create_if_block_7$4(ctx) {
		let div;
		let current;
		const no_results_slot_template = /*#slots*/ ctx[97]["no-results"];
		const no_results_slot = create_slot(no_results_slot_template, ctx, /*$$scope*/ ctx[96], get_no_results_slot_context);
		const no_results_slot_or_fallback = no_results_slot || fallback_block_4(ctx);

		return {
			c() {
				div = element("div");
				if (no_results_slot_or_fallback) no_results_slot_or_fallback.c();
				attr(div, "class", "autocomplete-list-item-no-results svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (no_results_slot_or_fallback) {
					no_results_slot_or_fallback.m(div, null);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (no_results_slot) {
					if (no_results_slot.p && (!current || dirty[0] & /*noResultsText*/ 1024 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							no_results_slot,
							no_results_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(no_results_slot_template, /*$$scope*/ ctx[96], dirty, get_no_results_slot_changes),
							get_no_results_slot_context
						);
					}
				} else {
					if (no_results_slot_or_fallback && no_results_slot_or_fallback.p && (!current || dirty[0] & /*noResultsText*/ 1024)) {
						no_results_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(no_results_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(no_results_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (no_results_slot_or_fallback) no_results_slot_or_fallback.d(detaching);
			}
		};
	}

	// (1242:21) 
	function create_if_block_6$4(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const create_slot_template = /*#slots*/ ctx[97].create;
		const create_slot_1 = create_slot(create_slot_template, ctx, /*$$scope*/ ctx[96], get_create_slot_context);
		const create_slot_or_fallback = create_slot_1 || fallback_block_3(ctx);

		return {
			c() {
				div = element("div");
				if (create_slot_or_fallback) create_slot_or_fallback.c();
				attr(div, "class", "autocomplete-list-item-create svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (create_slot_or_fallback) {
					create_slot_or_fallback.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*selectItem*/ ctx[44]),
						listen(div, "keypress", /*keypress_handler_3*/ ctx[113])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (create_slot_1) {
					if (create_slot_1.p && (!current || dirty[0] & /*createText*/ 8192 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							create_slot_1,
							create_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(create_slot_template, /*$$scope*/ ctx[96], dirty, get_create_slot_changes),
							get_create_slot_context
						);
					}
				} else {
					if (create_slot_or_fallback && create_slot_or_fallback.p && (!current || dirty[0] & /*createText*/ 8192)) {
						create_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(create_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(create_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (create_slot_or_fallback) create_slot_or_fallback.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1238:37) 
	function create_if_block_5$7(ctx) {
		let div;
		let current;
		const loading_slot_template = /*#slots*/ ctx[97].loading;
		const loading_slot = create_slot(loading_slot_template, ctx, /*$$scope*/ ctx[96], get_loading_slot_context);
		const loading_slot_or_fallback = loading_slot || fallback_block_2(ctx);

		return {
			c() {
				div = element("div");
				if (loading_slot_or_fallback) loading_slot_or_fallback.c();
				attr(div, "class", "autocomplete-list-item-loading svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (loading_slot_or_fallback) {
					loading_slot_or_fallback.m(div, null);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (loading_slot) {
					if (loading_slot.p && (!current || dirty[0] & /*loadingText*/ 2048 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							loading_slot,
							loading_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(loading_slot_template, /*$$scope*/ ctx[96], dirty, get_loading_slot_changes),
							get_loading_slot_context
						);
					}
				} else {
					if (loading_slot_or_fallback && loading_slot_or_fallback.p && (!current || dirty[0] & /*loadingText*/ 2048)) {
						loading_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(loading_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(loading_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (loading_slot_or_fallback) loading_slot_or_fallback.d(detaching);
			}
		};
	}

	// (1198:4) {#if filteredListItems && filteredListItems.length > 0}
	function create_if_block$O(ctx) {
		let t0;
		let t1;
		let current;
		const dropdown_header_slot_template = /*#slots*/ ctx[97]["dropdown-header"];
		const dropdown_header_slot = create_slot(dropdown_header_slot_template, ctx, /*$$scope*/ ctx[96], get_dropdown_header_slot_context);
		let each_value = ensure_array_like(/*filteredListItems*/ ctx[31]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const dropdown_footer_slot_template = /*#slots*/ ctx[97]["dropdown-footer"];
		const dropdown_footer_slot = create_slot(dropdown_footer_slot_template, ctx, /*$$scope*/ ctx[96], get_dropdown_footer_slot_context);
		const dropdown_footer_slot_or_fallback = dropdown_footer_slot || fallback_block(ctx);

		return {
			c() {
				if (dropdown_header_slot) dropdown_header_slot.c();
				t0 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t1 = space();
				if (dropdown_footer_slot_or_fallback) dropdown_footer_slot_or_fallback.c();
			},
			m(target, anchor) {
				if (dropdown_header_slot) {
					dropdown_header_slot.m(target, anchor);
				}

				insert(target, t0, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, t1, anchor);

				if (dropdown_footer_slot_or_fallback) {
					dropdown_footer_slot_or_fallback.m(target, anchor);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dropdown_header_slot) {
					if (dropdown_header_slot.p && (!current || dirty[0] & /*maxItemsToShowInList*/ 16 | dirty[1] & /*filteredListItems*/ 1 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							dropdown_header_slot,
							dropdown_header_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(dropdown_header_slot_template, /*$$scope*/ ctx[96], dirty, get_dropdown_header_slot_changes),
							get_dropdown_header_slot_context
						);
					}
				}

				if (dirty[0] & /*highlightIndex, maxItemsToShowInList*/ 1073741840 | dirty[1] & /*isConfirmed, filteredListItems, onListItemClick*/ 16793601 | dirty[3] & /*$$scope*/ 8) {
					each_value = ensure_array_like(/*filteredListItems*/ ctx[31]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$k(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$k(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(t1.parentNode, t1);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (dropdown_footer_slot) {
					if (dropdown_footer_slot.p && (!current || dirty[0] & /*maxItemsToShowInList*/ 16 | dirty[1] & /*filteredListItems*/ 1 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							dropdown_footer_slot,
							dropdown_footer_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(dropdown_footer_slot_template, /*$$scope*/ ctx[96], dirty, get_dropdown_footer_slot_changes),
							get_dropdown_footer_slot_context
						);
					}
				} else {
					if (dropdown_footer_slot_or_fallback && dropdown_footer_slot_or_fallback.p && (!current || dirty[0] & /*moreItemsText, maxItemsToShowInList*/ 4112 | dirty[1] & /*filteredListItems*/ 1)) {
						dropdown_footer_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(dropdown_header_slot, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(dropdown_footer_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(dropdown_header_slot, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(dropdown_footer_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
				}

				if (dropdown_header_slot) dropdown_header_slot.d(detaching);
				destroy_each(each_blocks, detaching);
				if (dropdown_footer_slot_or_fallback) dropdown_footer_slot_or_fallback.d(detaching);
			}
		};
	}

	// (1252:48) {noResultsText}
	function fallback_block_4(ctx) {
		let t;

		return {
			c() {
				t = text(/*noResultsText*/ ctx[10]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*noResultsText*/ 1024) set_data(t, /*noResultsText*/ ctx[10]);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (1248:41) {createText}
	function fallback_block_3(ctx) {
		let t;

		return {
			c() {
				t = text(/*createText*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*createText*/ 8192) set_data(t, /*createText*/ ctx[13]);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (1240:43) {loadingText}
	function fallback_block_2(ctx) {
		let t;

		return {
			c() {
				t = text(/*loadingText*/ ctx[11]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*loadingText*/ 2048) set_data(t, /*loadingText*/ ctx[11]);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (1202:8) {#if listItem && (maxItemsToShowInList <= 0 || i < maxItemsToShowInList)}
	function create_if_block_3$m(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const item_slot_template = /*#slots*/ ctx[97].item;
		const item_slot = create_slot(item_slot_template, ctx, /*$$scope*/ ctx[96], get_item_slot_context);
		const item_slot_or_fallback = item_slot || fallback_block_1(ctx);

		function click_handler() {
			return /*click_handler*/ ctx[110](/*listItem*/ ctx[144]);
		}

		function keypress_handler_2(...args) {
			return /*keypress_handler_2*/ ctx[111](/*listItem*/ ctx[144], ...args);
		}

		function pointerenter_handler() {
			return /*pointerenter_handler*/ ctx[112](/*i*/ ctx[146]);
		}

		return {
			c() {
				div = element("div");
				if (item_slot_or_fallback) item_slot_or_fallback.c();
				attr(div, "class", "autocomplete-list-item svelte-75ckfb");
				toggle_class(div, "selected", /*i*/ ctx[146] === /*highlightIndex*/ ctx[30]);
				toggle_class(div, "confirmed", /*isConfirmed*/ ctx[55](/*listItem*/ ctx[144].item));
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (item_slot_or_fallback) {
					item_slot_or_fallback.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", click_handler),
						listen(div, "keypress", keypress_handler_2),
						listen(div, "pointerenter", pointerenter_handler)
					];

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (item_slot) {
					if (item_slot.p && (!current || dirty[1] & /*filteredListItems*/ 1 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							item_slot,
							item_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(item_slot_template, /*$$scope*/ ctx[96], dirty, get_item_slot_changes),
							get_item_slot_context
						);
					}
				} else {
					if (item_slot_or_fallback && item_slot_or_fallback.p && (!current || dirty[1] & /*filteredListItems*/ 1)) {
						item_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}

				if (!current || dirty[0] & /*highlightIndex*/ 1073741824) {
					toggle_class(div, "selected", /*i*/ ctx[146] === /*highlightIndex*/ ctx[30]);
				}

				if (!current || dirty[1] & /*isConfirmed, filteredListItems*/ 16777217) {
					toggle_class(div, "confirmed", /*isConfirmed*/ ctx[55](/*listItem*/ ctx[144].item));
				}
			},
			i(local) {
				if (current) return;
				transition_in(item_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(item_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1220:14) {:else}
	function create_else_block$y(ctx) {
		let html_tag;
		let raw_value = /*listItem*/ ctx[144].label + "";
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(raw_value, target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[1] & /*filteredListItems*/ 1 && raw_value !== (raw_value = /*listItem*/ ctx[144].label + "")) html_tag.p(raw_value);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	// (1218:14) {#if listItem.highlighted}
	function create_if_block_4$f(ctx) {
		let html_tag;
		let raw_value = /*listItem*/ ctx[144].highlighted + "";
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(raw_value, target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[1] & /*filteredListItems*/ 1 && raw_value !== (raw_value = /*listItem*/ ctx[144].highlighted + "")) html_tag.p(raw_value);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	// (1217:13)                
	function fallback_block_1(ctx) {
		let if_block_anchor;

		function select_block_type_2(ctx, dirty) {
			if (/*listItem*/ ctx[144].highlighted) return create_if_block_4$f;
			return create_else_block$y;
		}

		let current_block_type = select_block_type_2(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	// (1201:6) {#each filteredListItems as listItem, i}
	function create_each_block$k(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*listItem*/ ctx[144] && (/*maxItemsToShowInList*/ ctx[4] <= 0 || /*i*/ ctx[146] < /*maxItemsToShowInList*/ ctx[4]) && create_if_block_3$m(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*listItem*/ ctx[144] && (/*maxItemsToShowInList*/ ctx[4] <= 0 || /*i*/ ctx[146] < /*maxItemsToShowInList*/ ctx[4])) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*maxItemsToShowInList*/ 16 | dirty[1] & /*filteredListItems*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$m(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (1229:8) {#if maxItemsToShowInList > 0 && filteredListItems.length > maxItemsToShowInList}
	function create_if_block_1$D(ctx) {
		let if_block_anchor;
		let if_block = /*moreItemsText*/ ctx[12] && create_if_block_2$s(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*moreItemsText*/ ctx[12]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_2$s(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (1230:10) {#if moreItemsText}
	function create_if_block_2$s(ctx) {
		let div;
		let t0;
		let t1_value = /*filteredListItems*/ ctx[31].length - /*maxItemsToShowInList*/ ctx[4] + "";
		let t1;
		let t2;
		let t3;

		return {
			c() {
				div = element("div");
				t0 = text("...");
				t1 = text(t1_value);
				t2 = space();
				t3 = text(/*moreItemsText*/ ctx[12]);
				attr(div, "class", "autocomplete-list-item-no-results svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, t2);
				append(div, t3);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*maxItemsToShowInList*/ 16 | dirty[1] & /*filteredListItems*/ 1 && t1_value !== (t1_value = /*filteredListItems*/ ctx[31].length - /*maxItemsToShowInList*/ ctx[4] + "")) set_data(t1, t1_value);
				if (dirty[0] & /*moreItemsText*/ 4096) set_data(t3, /*moreItemsText*/ ctx[12]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (1228:93)          
	function fallback_block(ctx) {
		let if_block_anchor;
		let if_block = /*maxItemsToShowInList*/ ctx[4] > 0 && /*filteredListItems*/ ctx[31].length > /*maxItemsToShowInList*/ ctx[4] && create_if_block_1$D(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*maxItemsToShowInList*/ ctx[4] > 0 && /*filteredListItems*/ ctx[31].length > /*maxItemsToShowInList*/ ctx[4]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$D(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function create_fragment$1h(ctx) {
		let div2;
		let select;
		let t0;
		let div0;
		let t1;
		let input_1;
		let input_1_class_value;
		let input_1_id_value;
		let input_1_autocomplete_value;
		let input_1_readonly_value;
		let t2;
		let t3;
		let div1;
		let current_block_type_index;
		let if_block3;
		let div1_class_value;
		let div2_class_value;
		let current;
		let mounted;
		let dispose;

		function select_block_type(ctx, dirty) {
			if (!/*multiple*/ ctx[5] && /*hasSelection*/ ctx[32]) return create_if_block_10$2;
			if (/*multiple*/ ctx[5] && /*hasSelection*/ ctx[32]) return create_if_block_11$2;
		}

		let current_block_type = select_block_type(ctx);
		let if_block0 = current_block_type && current_block_type(ctx);
		let if_block1 = /*multiple*/ ctx[5] && /*hasSelection*/ ctx[32] && create_if_block_9$2(ctx);

		let input_1_levels = [
			{ type: "text" },
			{
				class: input_1_class_value = "" + ((/*inputClassName*/ ctx[16]
				? /*inputClassName*/ ctx[16]
				: '') + " " + (/*noInputStyles*/ ctx[27]
				? ''
				: 'input autocomplete-input'))
			},
			{
				id: input_1_id_value = /*inputId*/ ctx[17] ? /*inputId*/ ctx[17] : ""
			},
			{
				autocomplete: input_1_autocomplete_value = /*html5autocomplete*/ ctx[22]
				? "on"
				: /*autocompleteOffValue*/ ctx[23]
			},
			{ placeholder: /*placeholder*/ ctx[14] },
			{ name: /*name*/ ctx[18] },
			{ disabled: /*disabled*/ ctx[26] },
			{ required: /*required*/ ctx[28] },
			{ title: /*title*/ ctx[21] },
			{
				readOnly: input_1_readonly_value = /*readonly*/ ctx[24] || /*locked*/ ctx[39]
			},
			{ tabindex: /*tabindex*/ ctx[29] },
			/*$$restProps*/ ctx[60]
		];

		let input_data = {};

		for (let i = 0; i < input_1_levels.length; i += 1) {
			input_data = assign(input_data, input_1_levels[i]);
		}

		let if_block2 = /*clearable*/ ctx[40] && create_if_block_8$2(ctx);
		const if_block_creators = [create_if_block$O, create_if_block_5$7, create_if_block_6$4, create_if_block_7$4];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*filteredListItems*/ ctx[31] && /*filteredListItems*/ ctx[31].length > 0) return 0;
			if (/*loading*/ ctx[36] && /*loadingText*/ ctx[11]) return 1;
			if (/*create*/ ctx[6]) return 2;
			if (/*noResultsText*/ ctx[10]) return 3;
			return -1;
		}

		if (~(current_block_type_index = select_block_type_1(ctx))) {
			if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				div2 = element("div");
				select = element("select");
				if (if_block0) if_block0.c();
				t0 = space();
				div0 = element("div");
				if (if_block1) if_block1.c();
				t1 = space();
				input_1 = element("input");
				t2 = space();
				if (if_block2) if_block2.c();
				t3 = space();
				div1 = element("div");
				if (if_block3) if_block3.c();
				attr(select, "name", /*selectName*/ ctx[19]);
				attr(select, "id", /*selectId*/ ctx[20]);
				select.multiple = /*multiple*/ ctx[5];
				attr(select, "class", "svelte-75ckfb");
				set_attributes(input_1, input_data);
				toggle_class(input_1, "svelte-75ckfb", true);
				attr(div0, "class", "input-container svelte-75ckfb");

				attr(div1, "class", div1_class_value = "" + ((/*dropdownClassName*/ ctx[25]
				? /*dropdownClassName*/ ctx[25]
				: '') + " autocomplete-list " + (/*showList*/ ctx[41] ? '' : 'hidden') + " is-fullwidth" + " svelte-75ckfb"));

				attr(div2, "class", div2_class_value = "" + ((/*className*/ ctx[15] ? /*className*/ ctx[15] : '') + " autocomplete select is-fullwidth " + /*uniqueId*/ ctx[42] + " svelte-75ckfb"));
				toggle_class(div2, "hide-arrow", /*hideArrow*/ ctx[7] || !/*items*/ ctx[0].length);
				toggle_class(div2, "is-multiple", /*multiple*/ ctx[5]);
				toggle_class(div2, "show-clear", /*clearable*/ ctx[40]);
				toggle_class(div2, "is-loading", /*showLoadingIndicator*/ ctx[9] && /*loading*/ ctx[36]);
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, select);
				if (if_block0) if_block0.m(select, null);
				append(div2, t0);
				append(div2, div0);
				if (if_block1) if_block1.m(div0, null);
				append(div0, t1);
				append(div0, input_1);
				if (input_1.autofocus) input_1.focus();
				/*input_1_binding*/ ctx[104](input_1);
				set_input_value(input_1, /*text*/ ctx[2]);
				append(div0, t2);
				if (if_block2) if_block2.m(div0, null);
				/*div0_binding*/ ctx[109](div0);
				append(div2, t3);
				append(div2, div1);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(div1, null);
				}

				/*div1_binding*/ ctx[114](div1);
				current = true;

				if (!mounted) {
					dispose = [
						listen(window_1, "click", /*onDocumentClick*/ ctx[46]),
						listen(window_1, "scroll", /*scroll_handler*/ ctx[98]),
						listen(input_1, "input", /*input_1_input_handler*/ ctx[105]),
						listen(input_1, "input", /*onInput*/ ctx[49]),
						listen(input_1, "focus", /*onFocusInternal*/ ctx[52]),
						listen(input_1, "blur", /*onBlurInternal*/ ctx[53]),
						listen(input_1, "keydown", /*onKeyDown*/ ctx[47]),
						listen(input_1, "click", /*onInputClick*/ ctx[51]),
						listen(input_1, "keypress", /*onKeyPress*/ ctx[48]),
						listen(input_1, "dragover", /*dragover_handler_1*/ ctx[106]),
						listen(input_1, "drop", /*drop_handler_1*/ ctx[107])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if (if_block0) if_block0.d(1);
					if_block0 = current_block_type && current_block_type(ctx);

					if (if_block0) {
						if_block0.c();
						if_block0.m(select, null);
					}
				}

				if (!current || dirty[0] & /*selectName*/ 524288) {
					attr(select, "name", /*selectName*/ ctx[19]);
				}

				if (!current || dirty[0] & /*selectId*/ 1048576) {
					attr(select, "id", /*selectId*/ ctx[20]);
				}

				if (!current || dirty[0] & /*multiple*/ 32) {
					select.multiple = /*multiple*/ ctx[5];
				}

				if (/*multiple*/ ctx[5] && /*hasSelection*/ ctx[32]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*multiple*/ 32 | dirty[1] & /*hasSelection*/ 2) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_9$2(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div0, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
					{ type: "text" },
					(!current || dirty[0] & /*inputClassName, noInputStyles*/ 134283264 && input_1_class_value !== (input_1_class_value = "" + ((/*inputClassName*/ ctx[16]
					? /*inputClassName*/ ctx[16]
					: '') + " " + (/*noInputStyles*/ ctx[27]
					? ''
					: 'input autocomplete-input')))) && { class: input_1_class_value },
					(!current || dirty[0] & /*inputId*/ 131072 && input_1_id_value !== (input_1_id_value = /*inputId*/ ctx[17] ? /*inputId*/ ctx[17] : "")) && { id: input_1_id_value },
					(!current || dirty[0] & /*html5autocomplete, autocompleteOffValue*/ 12582912 && input_1_autocomplete_value !== (input_1_autocomplete_value = /*html5autocomplete*/ ctx[22]
					? "on"
					: /*autocompleteOffValue*/ ctx[23])) && { autocomplete: input_1_autocomplete_value },
					(!current || dirty[0] & /*placeholder*/ 16384) && { placeholder: /*placeholder*/ ctx[14] },
					(!current || dirty[0] & /*name*/ 262144) && { name: /*name*/ ctx[18] },
					(!current || dirty[0] & /*disabled*/ 67108864) && { disabled: /*disabled*/ ctx[26] },
					(!current || dirty[0] & /*required*/ 268435456) && { required: /*required*/ ctx[28] },
					(!current || dirty[0] & /*title*/ 2097152) && { title: /*title*/ ctx[21] },
					(!current || dirty[0] & /*readonly*/ 16777216 | dirty[1] & /*locked*/ 256 && input_1_readonly_value !== (input_1_readonly_value = /*readonly*/ ctx[24] || /*locked*/ ctx[39])) && { readOnly: input_1_readonly_value },
					(!current || dirty[0] & /*tabindex*/ 536870912) && { tabindex: /*tabindex*/ ctx[29] },
					dirty[1] & /*$$restProps*/ 536870912 && /*$$restProps*/ ctx[60]
				]));

				if (dirty[0] & /*text*/ 4 && input_1.value !== /*text*/ ctx[2]) {
					set_input_value(input_1, /*text*/ ctx[2]);
				}

				toggle_class(input_1, "svelte-75ckfb", true);

				if (/*clearable*/ ctx[40]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_8$2(ctx);
						if_block2.c();
						if_block2.m(div0, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block3) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block3 = if_blocks[current_block_type_index];

						if (!if_block3) {
							if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block3.c();
						} else {
							if_block3.p(ctx, dirty);
						}

						transition_in(if_block3, 1);
						if_block3.m(div1, null);
					} else {
						if_block3 = null;
					}
				}

				if (!current || dirty[0] & /*dropdownClassName*/ 33554432 | dirty[1] & /*showList*/ 1024 && div1_class_value !== (div1_class_value = "" + ((/*dropdownClassName*/ ctx[25]
				? /*dropdownClassName*/ ctx[25]
				: '') + " autocomplete-list " + (/*showList*/ ctx[41] ? '' : 'hidden') + " is-fullwidth" + " svelte-75ckfb"))) {
					attr(div1, "class", div1_class_value);
				}

				if (!current || dirty[0] & /*className*/ 32768 && div2_class_value !== (div2_class_value = "" + ((/*className*/ ctx[15] ? /*className*/ ctx[15] : '') + " autocomplete select is-fullwidth " + /*uniqueId*/ ctx[42] + " svelte-75ckfb"))) {
					attr(div2, "class", div2_class_value);
				}

				if (!current || dirty[0] & /*className, hideArrow, items*/ 32897) {
					toggle_class(div2, "hide-arrow", /*hideArrow*/ ctx[7] || !/*items*/ ctx[0].length);
				}

				if (!current || dirty[0] & /*className, multiple*/ 32800) {
					toggle_class(div2, "is-multiple", /*multiple*/ ctx[5]);
				}

				if (!current || dirty[0] & /*className*/ 32768 | dirty[1] & /*clearable*/ 512) {
					toggle_class(div2, "show-clear", /*clearable*/ ctx[40]);
				}

				if (!current || dirty[0] & /*className, showLoadingIndicator*/ 33280 | dirty[1] & /*loading*/ 32) {
					toggle_class(div2, "is-loading", /*showLoadingIndicator*/ ctx[9] && /*loading*/ ctx[36]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				transition_in(if_block3);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				transition_out(if_block3);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				if (if_block0) {
					if_block0.d();
				}

				if (if_block1) if_block1.d();
				/*input_1_binding*/ ctx[104](null);
				if (if_block2) if_block2.d();
				/*div0_binding*/ ctx[109](null);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d();
				}

				/*div1_binding*/ ctx[114](null);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function safeFunction(theFunction, argument) {
		if (typeof theFunction !== "function") {
			console.error("Not a function: " + theFunction + ", argument: " + argument);
			return undefined;
		}

		let result;

		try {
			result = theFunction(argument);
		} catch(error) {
			console.warn("Error executing Autocomplete function on value: " + argument + " function: " + theFunction);
		}

		return result;
	}

	function safeStringFunction(theFunction, argument) {
		let result = safeFunction(theFunction, argument);

		if (result === undefined || result === null) {
			result = "";
		}

		if (typeof result !== "string") {
			result = result.toString();
		}

		return result;
	}

	function numberOfMatches(listItem, searchWords) {
		if (!listItem) {
			return 0;
		}

		const itemKeywords = listItem.keywords;
		let matches = 0;

		searchWords.forEach(searchWord => {
			if (itemKeywords.includes(searchWord)) {
				matches++;
			}
		});

		return matches;
	}

	function defaultItemSortFunction(obj1, obj2, searchWords) {
		return numberOfMatches(obj2, searchWords) - numberOfMatches(obj1, searchWords);
	}

	function removeAccents(str) {
		return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
	}

	function instance$1g($$self, $$props, $$invalidate) {
		let showList;
		let hasSelection;
		let clearable;
		let locked;

		const omit_props_names = [
			"items","searchFunction","labelFieldName","keywordsFieldName","valueFieldName","labelFunction","keywordsFunction","valueFunction","keywordsCleanFunction","textCleanFunction","beforeChange","onChange","onFocus","onBlur","onCreate","selectFirstIfEmpty","minCharactersToSearch","maxItemsToShowInList","multiple","create","ignoreAccents","matchAllKeywords","sortByMatchedKeywords","itemFilterFunction","itemSortFunction","lock","delay","localFiltering","localSorting","cleanUserText","lowercaseKeywords","closeOnBlur","orderableSelection","hideArrow","showClear","clearText","showLoadingIndicator","noResultsText","loadingText","moreItemsText","createText","placeholder","className","inputClassName","inputId","name","selectName","selectId","title","html5autocomplete","autocompleteOffValue","readonly","dropdownClassName","disabled","noInputStyles","required","debug","tabindex","selectedItem","value","highlightedItem","text","highlightFilter"
		];

		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		let { items = [] } = $$props;
		let { searchFunction = false } = $$props;
		let { labelFieldName = undefined } = $$props;
		let { keywordsFieldName = labelFieldName } = $$props;
		let { valueFieldName = undefined } = $$props;

		let { labelFunction = function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return labelFieldName ? item[labelFieldName] : item;
		} } = $$props;

		let { keywordsFunction = function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return keywordsFieldName
			? item[keywordsFieldName]
			: labelFunction(item);
		} } = $$props;

		let { valueFunction = function (item, forceSingle = false) {
			if (item === undefined || item === null) {
				return item;
			}

			if (!multiple || forceSingle) {
				return valueFieldName ? item[valueFieldName] : item;
			} else {
				return item.map(i => valueFieldName ? i[valueFieldName] : i);
			}
		} } = $$props;

		let { keywordsCleanFunction = function (keywords) {
			return keywords;
		} } = $$props;

		let { textCleanFunction = function (userEnteredText) {
			return userEnteredText;
		} } = $$props;

		let { beforeChange = function (oldSelectedItem, newSelectedItem) {
			return true;
		} } = $$props;

		let { onChange = function (newSelectedItem) {
			
		} } = $$props;

		let { onFocus = function () {
			
		} } = $$props;

		let { onBlur = function () {
			
		} } = $$props;

		let { onCreate = function (text) {
			if (debug) {
				console.log("onCreate: " + text);
			}
		} } = $$props;

		let { selectFirstIfEmpty = false } = $$props;
		let { minCharactersToSearch = 1 } = $$props;
		let { maxItemsToShowInList = 0 } = $$props;
		let { multiple = false } = $$props;
		let { create = false } = $$props;
		let { ignoreAccents = true } = $$props;
		let { matchAllKeywords = true } = $$props;
		let { sortByMatchedKeywords = false } = $$props;
		let { itemFilterFunction = undefined } = $$props;
		let { itemSortFunction = undefined } = $$props;
		let { lock = false } = $$props;
		let { delay = 0 } = $$props;
		let { localFiltering = true } = $$props;
		let { localSorting = true } = $$props;
		let { cleanUserText = true } = $$props;
		let { lowercaseKeywords = true } = $$props;
		let { closeOnBlur = false } = $$props;
		let { orderableSelection = false } = $$props;
		let { hideArrow = false } = $$props;
		let { showClear = false } = $$props;
		let { clearText = "&#10006;" } = $$props;
		let { showLoadingIndicator = false } = $$props;
		let { noResultsText = "No results found" } = $$props;
		let { loadingText = "Loading results..." } = $$props;
		let { moreItemsText = "items not shown" } = $$props;
		let { createText = "Not found, add anyway?" } = $$props;
		let { placeholder = undefined } = $$props;
		let { className = undefined } = $$props;
		let { inputClassName = undefined } = $$props;
		let { inputId = undefined } = $$props;
		let { name = undefined } = $$props;
		let { selectName = undefined } = $$props;
		let { selectId = undefined } = $$props;
		let { title = undefined } = $$props;
		let { html5autocomplete = undefined } = $$props;
		let { autocompleteOffValue = "off" } = $$props;
		let { readonly = undefined } = $$props;
		let { dropdownClassName = undefined } = $$props;
		let { disabled = false } = $$props;
		let { noInputStyles = false } = $$props;
		let { required = null } = $$props;
		let { debug = false } = $$props;
		let { tabindex = 0 } = $$props;
		let { selectedItem = multiple ? [] : undefined } = $$props;
		let { value = undefined } = $$props;
		let { highlightedItem = undefined } = $$props;

		// --- Internal State ----
		const uniqueId = "sautocomplete-" + Math.floor(Math.random() * 1000);

		// HTML elements
		let input;

		let list;
		let inputContainer;

		// UI state
		let opened = false;

		let loading = false;
		let highlightIndex = -1;
		let { text = undefined } = $$props;
		let filteredTextLength = 0;

		// view model
		let filteredListItems;

		let listItems = [];

		// requests/responses counters
		let lastRequestId = 0;

		let lastResponseId = 0;

		// other state
		let inputDelayTimeout;

		let setPositionOnNextUpdate = false;

		// --- Lifecycle events ---
		afterUpdate(() => {
			if (setPositionOnNextUpdate) {
				setScrollAwareListPosition();
			}

			$$invalidate(37, setPositionOnNextUpdate = false);
		});

		function safeLabelFunction(item) {
			// console.log("labelFunction: " + labelFunction);
			// console.log("safeLabelFunction, item: " + item);
			return safeStringFunction(labelFunction, item);
		}

		function safeKeywordsFunction(item) {
			// console.log("safeKeywordsFunction");
			const keywords = safeStringFunction(keywordsFunction, item);

			let result = safeStringFunction(keywordsCleanFunction, keywords);
			result = lowercaseKeywords ? result.toLowerCase().trim() : result;

			if (ignoreAccents) {
				result = removeAccents(result);
			}

			if (debug) {
				console.log("Extracted keywords: '" + result + "' from item: " + JSON.stringify(item));
			}

			return result;
		}

		function prepareListItems() {
			let timerId;

			if (debug) {
				timerId = `Autocomplete prepare list ${inputId ? `(id: ${inputId})` : ""}`;
				console.time(timerId);
				console.log("Prepare items to search");
				console.log("items: " + JSON.stringify(items));
			}

			if (!Array.isArray(items)) {
				console.warn("Autocomplete items / search function did not return array but", items);
				$$invalidate(0, items = []);
			}

			const length = items ? items.length : 0;
			listItems = new Array(length);

			if (length > 0) {
				items.forEach((item, i) => {
					const listItem = getListItem(item);

					if (listItem === undefined) {
						console.log("Undefined item for: ", item);
					}

					listItems[i] = listItem;
				});
			}

			$$invalidate(31, filteredListItems = listItems);

			if (debug) {
				console.log(listItems.length + " items to search");
				console.timeEnd(timerId);
			}
		}

		function getListItem(item) {
			return {
				// keywords representation of the item
				keywords: localFiltering ? safeKeywordsFunction(item) : [],
				// item label
				label: safeLabelFunction(item),
				// store reference to the origial item
				item
			};
		}

		function onSelectedItemChanged() {
			$$invalidate(61, value = valueFunction(selectedItem));

			if (selectedItem && !multiple) {
				$$invalidate(2, text = safeLabelFunction(selectedItem));
			}

			$$invalidate(31, filteredListItems = listItems);
			onChange(selectedItem);
		}

		function prepareUserEnteredText(userEnteredText) {
			if (userEnteredText === undefined || userEnteredText === null) {
				return "";
			}

			if (!cleanUserText) {
				return userEnteredText;
			}

			const textFiltered = userEnteredText.replace(/[&/\\#,+()$~%.'":*?<>{}]/g, " ").trim();
			const cleanUserEnteredText = safeStringFunction(textCleanFunction, textFiltered);

			const textTrimmed = lowercaseKeywords
			? cleanUserEnteredText.toLowerCase().trim()
			: cleanUserEnteredText.trim();

			return textTrimmed;
		}

		async function search() {
			let timerId;

			if (debug) {
				timerId = `Autocomplete search ${inputId ? `(id: ${inputId})` : ""}`;
				console.time(timerId);
				console.log("Searching user entered text: '" + text + "'");
			}

			let textFiltered = prepareUserEnteredText(text);

			if (minCharactersToSearch > 1 && textFiltered.length < minCharactersToSearch) {
				textFiltered = "";
			}

			$$invalidate(95, filteredTextLength = textFiltered.length);

			if (debug) {
				console.log("Changed user entered text '" + text + "' into '" + textFiltered + "'");
			}

			// if no search text load all items
			if (textFiltered === "") {
				if (searchFunction) {
					// we will need to rerun the search
					$$invalidate(0, items = []);

					if (debug) {
						console.log("User entered text is empty clear list of items");
					}
				} else {
					$$invalidate(31, filteredListItems = listItems);

					if (debug) {
						console.log("User entered text is empty set the list of items to all items");
					}
				}

				if (closeIfMinCharsToSearchReached()) {
					if (debug) {
						console.timeEnd(timerId);
					}

					return;
				}
			}

			if (!searchFunction) {
				// internal search
				processListItems(textFiltered);
			} else {
				// external search which provides items
				lastRequestId = lastRequestId + 1;

				const currentRequestId = lastRequestId;
				$$invalidate(36, loading = true);

				// searchFunction is a generator
				if (searchFunction.constructor.name === "AsyncGeneratorFunction") {
					for await (const chunk of searchFunction(textFiltered, maxItemsToShowInList)) {
						// a chunk of an old response: throw it away
						if (currentRequestId < lastResponseId) {
							return false;
						}

						// a chunk for a new response: reset the item list
						if (currentRequestId > lastResponseId) {
							$$invalidate(0, items = []);
						}

						lastResponseId = currentRequestId;
						$$invalidate(0, items = [...items, ...chunk]);
						processListItems(textFiltered);
					}

					// there was nothing in the chunk
					if (lastResponseId < currentRequestId) {
						lastResponseId = currentRequestId;
						$$invalidate(0, items = []);
						processListItems(textFiltered);
					}
				} else // searchFunction is a regular function
				{
					let result = await searchFunction(textFiltered, maxItemsToShowInList);

					// If a response to a newer request has been received
					// while responses to this request were being loaded,
					// then we can just throw away this outdated results.
					if (currentRequestId < lastResponseId) {
						return false;
					}

					lastResponseId = currentRequestId;
					$$invalidate(0, items = result);
					processListItems(textFiltered);
				}

				$$invalidate(36, loading = false);
			}

			if (debug) {
				console.timeEnd(timerId);
				console.log("Search found " + filteredListItems.length + " items");
			}
		}

		function defaultItemFilterFunction(listItem, searchWords) {
			const matches = numberOfMatches(listItem, searchWords);

			if (matchAllKeywords) {
				return matches >= searchWords.length;
			} else {
				return matches > 0;
			}
		}

		function processListItems(textFiltered) {
			// cleans, filters, orders, and highlights the list items
			prepareListItems();

			const textFilteredWithoutAccents = ignoreAccents
			? removeAccents(textFiltered)
			: textFiltered;

			const searchWords = textFilteredWithoutAccents.split(/\s+/g).filter(word => word !== "");

			// local search
			let tempfilteredListItems;

			if (localFiltering) {
				if (itemFilterFunction) {
					tempfilteredListItems = listItems.filter(item => itemFilterFunction(item.item, searchWords));
				} else {
					tempfilteredListItems = listItems.filter(item => defaultItemFilterFunction(item, searchWords));
				}

				if (localSorting) {
					if (itemSortFunction) {
						tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => itemSortFunction(item1.item, item2.item, searchWords));
					} else {
						if (sortByMatchedKeywords) {
							tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => defaultItemSortFunction(item1, item2, searchWords));
						}
					}
				}
			} else {
				tempfilteredListItems = listItems;
			}

			const hlfilter = highlightFilter(searchWords, "label");
			$$invalidate(31, filteredListItems = tempfilteredListItems.map(hlfilter));
			closeIfMinCharsToSearchReached();
			return true;
		}

		// $: text, search();
		function afterCreate(createdItem) {
			let listItem;

			if (debug) {
				console.log("createdItem", createdItem);
			}

			if ("undefined" !== typeof createdItem) {
				prepareListItems();
				$$invalidate(31, filteredListItems = listItems);
				let index = findItemIndex(createdItem, filteredListItems);

				// if the items array was not updated, add the created item manually
				if (index <= 0) {
					$$invalidate(0, items = [createdItem]);
					prepareListItems();
					$$invalidate(31, filteredListItems = listItems);
					index = 0;
				}

				if (index >= 0) {
					$$invalidate(30, highlightIndex = index);
					listItem = filteredListItems[highlightIndex];
				}
			}

			return listItem;
		}

		function selectListItem(listItem) {
			if (debug) {
				console.log("selectListItem", listItem);
			}

			if ("undefined" === typeof listItem && create) {
				// allow undefined items if create is enabled
				const createdItem = onCreate(text);

				if ("undefined" !== typeof createdItem) {
					if (typeof createdItem.then === "function") {
						createdItem.then(newItem => {
							if ("undefined" !== typeof newItem) {
								const newListItem = afterCreate(newItem);

								if ("undefined" !== typeof newListItem) {
									selectListItem(newListItem);
								}
							}
						});

						return true;
					} else {
						listItem = afterCreate(createdItem);
					}
				}
			}

			if ("undefined" === typeof listItem) {
				if (debug) {
					console.log(`listItem is undefined. Can not select.`);
				}

				return false;
			}

			if (locked) {
				return true;
			}

			const newSelectedItem = listItem.item;

			if (beforeChange(selectedItem, newSelectedItem)) {
				// simple selection
				if (!multiple) {
					$$invalidate(1, selectedItem = undefined); // triggers change even if the the same item is selected
					$$invalidate(1, selectedItem = newSelectedItem);
				} else // first selection of multiple ones
				if (!selectedItem) {
					$$invalidate(1, selectedItem = [newSelectedItem]);
				} else // selecting something already selected => unselect it
				if (selectedItem.includes(newSelectedItem)) {
					$$invalidate(1, selectedItem = selectedItem.filter(i => i !== newSelectedItem));
				} else // adds the element to the selection
				{
					$$invalidate(1, selectedItem = [...selectedItem, newSelectedItem]);
				}
			}

			return true;
		}

		function selectItem() {
			if (debug) {
				console.log("selectItem", highlightIndex);
			}

			const listItem = filteredListItems[highlightIndex];

			if (selectListItem(listItem)) {
				if (debug) {
					console.log("selectListItem true, closing");
				}

				close();

				if (multiple) {
					$$invalidate(2, text = "");
					input.focus();
				}
			} else {
				if (debug) {
					console.log("selectListItem false, not closing");
				}
			}
		}

		function up() {
			if (debug) {
				console.log("up");
			}

			open();

			if (highlightIndex > 0) {
				$$invalidate(30, highlightIndex--, highlightIndex);
			}

			highlight();
		}

		function down() {
			if (debug) {
				console.log("down");
			}

			open();

			if (highlightIndex < filteredListItems.length - 1) {
				$$invalidate(30, highlightIndex++, highlightIndex);
			}

			highlight();
		}

		function highlight() {
			if (debug) {
				console.log("highlight");
			}

			const query = ".selected";

			if (debug) {
				console.log("Seaching DOM element: " + query + " in " + list);
			}

			/**
	 * @param {Element} el
	 */
			const el = list && list.querySelector(query);

			if (el) {
				if (typeof el.scrollIntoViewIfNeeded === "function") {
					if (debug) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoViewIfNeeded();
				} else if (el.scrollIntoView === "function") {
					if (debug) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoView();
				} else {
					if (debug) {
						console.warn("Could not scroll selected item into view, scrollIntoViewIfNeeded not supported");
					}
				}
			} else {
				if (debug) {
					console.warn("Selected item not found to scroll into view");
				}
			}
		}

		function onListItemClick(listItem) {
			if (debug) {
				console.log("onListItemClick");
			}

			if (selectListItem(listItem)) {
				close();

				if (multiple) {
					$$invalidate(2, text = "");
					input.focus();
				}
			}
		}

		function onDocumentClick(e) {
			if (debug) {
				console.log("onDocumentClick");
			}

			if (e.composedPath().some(path => path.classList && path.classList.contains(uniqueId))) {
				if (debug) {
					console.log("onDocumentClick inside");
				}

				// resetListToAllItemsAndOpen();
				highlight();
			} else {
				if (debug) {
					console.log("onDocumentClick outside");
				}

				close();
			}
		}

		function onKeyDown(e) {
			if (debug) {
				console.log("onKeyDown");
			}

			let key = e.key;
			if (key === "Tab" && e.shiftKey) key = "ShiftTab";

			const fnmap = {
				Tab: opened ? close : null,
				ShiftTab: opened ? close : null,
				ArrowDown: down.bind(this),
				ArrowUp: up.bind(this),
				Escape: onEsc.bind(this),
				Backspace: multiple && hasSelection && !text
				? onBackspace.bind(this)
				: null
			};

			const fn = fnmap[key];

			if (typeof fn === "function") {
				fn(e);
			}
		}

		function onKeyPress(e) {
			if (debug) {
				console.log("onKeyPress");
			}

			if (e.key === "Enter") {
				onEnter(e);
			}
		}

		function onEnter(e) {
			if (opened) {
				e.preventDefault();
				selectItem();
			}
		}

		function onInput(e) {
			if (debug) {
				console.log("onInput");
			}

			$$invalidate(2, text = e.target.value);

			if (inputDelayTimeout) {
				clearTimeout(inputDelayTimeout);
			}

			if (delay) {
				inputDelayTimeout = setTimeout(processInput, delay);
			} else {
				processInput();
			}
		}

		function unselectItem(tag) {
			if (debug) {
				console.log("unselectItem", tag);
			}

			$$invalidate(1, selectedItem = selectedItem.filter(i => i !== tag));
			input.focus();
		}

		function processInput() {
			if (search()) {
				$$invalidate(30, highlightIndex = 0);
				open();
			}
		}

		function onInputClick() {
			if (debug) {
				console.log("onInputClick");
			}

			resetListToAllItemsAndOpen();
		}

		function onEsc(e) {
			if (debug) {
				console.log("onEsc");
			}

			//if (text) return clear();
			e.stopPropagation();

			if (opened) {
				input.focus();
				close();
			}
		}

		function onBackspace(e) {
			if (debug) {
				console.log("onBackspace");
			}

			unselectItem(selectedItem[selectedItem.length - 1]);
		}

		function onFocusInternal() {
			if (debug) {
				console.log("onFocus");
			}

			onFocus();
			resetListToAllItemsAndOpen();
		}

		function onBlurInternal() {
			if (debug) {
				console.log("onBlur");
			}

			if (closeOnBlur) {
				close();
			}

			onBlur();
		}

		function resetListToAllItemsAndOpen() {
			if (debug) {
				console.log("resetListToAllItemsAndOpen");
			}

			if (searchFunction && !listItems.length) {
				search();
			} else if (!text) {
				$$invalidate(31, filteredListItems = listItems);
			}

			open();

			// find selected item
			if (selectedItem) {
				if (debug) {
					console.log("Searching currently selected item: " + JSON.stringify(selectedItem));
				}

				const index = findItemIndex(selectedItem, filteredListItems);

				if (index >= 0) {
					$$invalidate(30, highlightIndex = index);
					highlight();
				}
			}
		}

		function findItemIndex(item, items) {
			if (debug) {
				console.log("Finding index for item", item);
			}

			let index = -1;

			for (let i = 0; i < items.length; i++) {
				const listItem = items[i];

				if ("undefined" === typeof listItem) {
					if (debug) {
						console.log(`listItem ${i} is undefined. Skipping.`);
					}

					continue;
				}

				if (debug) {
					console.log("Item " + i + ": " + JSON.stringify(listItem));
				}

				if (item === listItem.item) {
					index = i;
					break;
				}
			}

			if (debug) {
				if (index >= 0) {
					console.log("Found index for item: " + index);
				} else {
					console.warn("Not found index for item: " + item);
				}
			}

			return index;
		}

		function open() {
			if (debug) {
				console.log("open");
			}

			// check if the search text has more than the min chars required
			if (locked || notEnoughSearchText()) {
				return;
			}

			$$invalidate(37, setPositionOnNextUpdate = true);
			$$invalidate(94, opened = true);
		}

		function close() {
			if (debug) {
				console.log("close");
			}

			$$invalidate(94, opened = false);
			$$invalidate(36, loading = false);

			if (!text && selectFirstIfEmpty) {
				$$invalidate(30, highlightIndex = 0);
				selectItem();
			}
		}

		function notEnoughSearchText() {
			return minCharactersToSearch > 0 && filteredTextLength < minCharactersToSearch && (// When no searchFunction is defined, the menu should always open when the input is focused
			searchFunction || filteredTextLength > 0);
		}

		function closeIfMinCharsToSearchReached() {
			if (notEnoughSearchText()) {
				close();
				return true;
			}

			return false;
		}

		function clear() {
			if (debug) {
				console.log("clear");
			}

			$$invalidate(2, text = "");
			$$invalidate(1, selectedItem = multiple ? [] : undefined);

			setTimeout(() => {
				input.focus();
			});
		}

		function highlightFilter(keywords, field) {
			return item => {
				let label = item[field];
				const newItem = Object.assign({ highlighted: undefined }, item);
				newItem.highlighted = label;
				const labelLowercase = label.toLowerCase();

				const labelLowercaseNoAc = ignoreAccents
				? removeAccents(labelLowercase)
				: labelLowercase;

				if (keywords && keywords.length) {
					const positions = [];

					for (let i = 0; i < keywords.length; i++) {
						let keyword = keywords[i];

						if (ignoreAccents) {
							keyword = removeAccents(keyword);
						}

						const keywordLen = keyword.length;
						let pos1 = 0;

						do {
							pos1 = labelLowercaseNoAc.indexOf(keyword, pos1);

							if (pos1 >= 0) {
								let pos2 = pos1 + keywordLen;
								positions.push([pos1, pos2]);
								pos1 = pos2;
							}
						} while (pos1 !== -1);
					}

					if (positions.length > 0) {
						const keywordPatterns = new Set();

						for (let i = 0; i < positions.length; i++) {
							const pair = positions[i];
							const pos1 = pair[0];
							const pos2 = pair[1];
							const keywordPattern = labelLowercase.substring(pos1, pos2);
							keywordPatterns.add(keywordPattern);
						}

						for (let keywordPattern of keywordPatterns) {
							// FIXME pst: workarond for wrong replacement <b> tags
							if (keywordPattern === "b") {
								continue;
							}

							const reg = new RegExp("(" + keywordPattern + ")", "ig");
							const newHighlighted = newItem.highlighted.replace(reg, "<b>$1</b>");
							newItem.highlighted = newHighlighted;
						}
					}
				}

				return newItem;
			};
		}

		function isConfirmed(listItem) {
			if (!selectedItem) {
				return false;
			}

			if (multiple) {
				return selectedItem.includes(listItem);
			} else {
				return listItem === selectedItem;
			}
		}

		let draggingOver = false;

		function dragstart(event, index) {
			if (orderableSelection) {
				event.dataTransfer.setData("source", index);
			}
		}

		function dragover(event, index) {
			if (orderableSelection) {
				event.preventDefault();
				$$invalidate(38, draggingOver = index);
			}
		}

		function dragleave(event, index) {
			if (orderableSelection) {
				$$invalidate(38, draggingOver = false);
			}
		}

		function drop(event, index) {
			if (orderableSelection) {
				event.preventDefault();
				$$invalidate(38, draggingOver = false);
				let from = parseInt(event.dataTransfer.getData("source"));
				let to = index;

				if (from != to) {
					moveSelectedItem(from, to);
				}
			}
		}

		function moveSelectedItem(from, to) {
			let newSelection = [...selectedItem];

			if (from < to) {
				newSelection.splice(to + 1, 0, newSelection[from]);
				newSelection.splice(from, 1);
			} else {
				newSelection.splice(to, 0, newSelection[from]);
				newSelection.splice(from + 1, 1);
			}

			$$invalidate(1, selectedItem = newSelection);
		}

		function setScrollAwareListPosition() {
			const { height: viewPortHeight } = window.visualViewport;
			const { bottom: inputButtom, height: inputHeight } = inputContainer.getBoundingClientRect();
			const { height: listHeight } = list.getBoundingClientRect();

			if (inputButtom + listHeight > viewPortHeight) {
				$$invalidate(34, list.style.top = `-${inputHeight + listHeight}px`, list);
			} else {
				$$invalidate(34, list.style.top = "0px", list);
			}
		}

		const scroll_handler = () => $$invalidate(37, setPositionOnNextUpdate = true);

		const keypress_handler = (tagItem, e) => {
			e.key == "Enter" && unselectItem(tagItem);
		};

		const dragstart_handler = (i, event) => dragstart(event, i);
		const dragover_handler = (i, event) => dragover(event, i);
		const dragleave_handler = (i, event) => dragleave();
		const drop_handler = (i, event) => drop(event, i);

		function input_1_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				input = $$value;
				$$invalidate(33, input);
			});
		}

		function input_1_input_handler() {
			text = this.value;
			$$invalidate(2, text);
		}

		const dragover_handler_1 = event => dragover(event, selectedItem.length - 1);
		const drop_handler_1 = event => drop(event, selectedItem.length - 1);

		const keypress_handler_1 = e => {
			e.key == "Enter" && clear();
		};

		function div0_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				inputContainer = $$value;
				$$invalidate(35, inputContainer);
			});
		}

		const click_handler = listItem => onListItemClick(listItem);

		const keypress_handler_2 = (listItem, e) => {
			e.key == "Enter" && onListItemClick(listItem);
		};

		const pointerenter_handler = i => {
			$$invalidate(30, highlightIndex = i);
		};

		const keypress_handler_3 = e => {
			e.key == "Enter" && selectItem();
		};

		function div1_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				list = $$value;
				$$invalidate(34, list);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(60, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('items' in $$new_props) $$invalidate(0, items = $$new_props.items);
			if ('searchFunction' in $$new_props) $$invalidate(63, searchFunction = $$new_props.searchFunction);
			if ('labelFieldName' in $$new_props) $$invalidate(64, labelFieldName = $$new_props.labelFieldName);
			if ('keywordsFieldName' in $$new_props) $$invalidate(65, keywordsFieldName = $$new_props.keywordsFieldName);
			if ('valueFieldName' in $$new_props) $$invalidate(66, valueFieldName = $$new_props.valueFieldName);
			if ('labelFunction' in $$new_props) $$invalidate(67, labelFunction = $$new_props.labelFunction);
			if ('keywordsFunction' in $$new_props) $$invalidate(68, keywordsFunction = $$new_props.keywordsFunction);
			if ('valueFunction' in $$new_props) $$invalidate(3, valueFunction = $$new_props.valueFunction);
			if ('keywordsCleanFunction' in $$new_props) $$invalidate(69, keywordsCleanFunction = $$new_props.keywordsCleanFunction);
			if ('textCleanFunction' in $$new_props) $$invalidate(70, textCleanFunction = $$new_props.textCleanFunction);
			if ('beforeChange' in $$new_props) $$invalidate(71, beforeChange = $$new_props.beforeChange);
			if ('onChange' in $$new_props) $$invalidate(72, onChange = $$new_props.onChange);
			if ('onFocus' in $$new_props) $$invalidate(73, onFocus = $$new_props.onFocus);
			if ('onBlur' in $$new_props) $$invalidate(74, onBlur = $$new_props.onBlur);
			if ('onCreate' in $$new_props) $$invalidate(75, onCreate = $$new_props.onCreate);
			if ('selectFirstIfEmpty' in $$new_props) $$invalidate(76, selectFirstIfEmpty = $$new_props.selectFirstIfEmpty);
			if ('minCharactersToSearch' in $$new_props) $$invalidate(77, minCharactersToSearch = $$new_props.minCharactersToSearch);
			if ('maxItemsToShowInList' in $$new_props) $$invalidate(4, maxItemsToShowInList = $$new_props.maxItemsToShowInList);
			if ('multiple' in $$new_props) $$invalidate(5, multiple = $$new_props.multiple);
			if ('create' in $$new_props) $$invalidate(6, create = $$new_props.create);
			if ('ignoreAccents' in $$new_props) $$invalidate(78, ignoreAccents = $$new_props.ignoreAccents);
			if ('matchAllKeywords' in $$new_props) $$invalidate(79, matchAllKeywords = $$new_props.matchAllKeywords);
			if ('sortByMatchedKeywords' in $$new_props) $$invalidate(80, sortByMatchedKeywords = $$new_props.sortByMatchedKeywords);
			if ('itemFilterFunction' in $$new_props) $$invalidate(81, itemFilterFunction = $$new_props.itemFilterFunction);
			if ('itemSortFunction' in $$new_props) $$invalidate(82, itemSortFunction = $$new_props.itemSortFunction);
			if ('lock' in $$new_props) $$invalidate(83, lock = $$new_props.lock);
			if ('delay' in $$new_props) $$invalidate(84, delay = $$new_props.delay);
			if ('localFiltering' in $$new_props) $$invalidate(85, localFiltering = $$new_props.localFiltering);
			if ('localSorting' in $$new_props) $$invalidate(86, localSorting = $$new_props.localSorting);
			if ('cleanUserText' in $$new_props) $$invalidate(87, cleanUserText = $$new_props.cleanUserText);
			if ('lowercaseKeywords' in $$new_props) $$invalidate(88, lowercaseKeywords = $$new_props.lowercaseKeywords);
			if ('closeOnBlur' in $$new_props) $$invalidate(89, closeOnBlur = $$new_props.closeOnBlur);
			if ('orderableSelection' in $$new_props) $$invalidate(90, orderableSelection = $$new_props.orderableSelection);
			if ('hideArrow' in $$new_props) $$invalidate(7, hideArrow = $$new_props.hideArrow);
			if ('showClear' in $$new_props) $$invalidate(91, showClear = $$new_props.showClear);
			if ('clearText' in $$new_props) $$invalidate(8, clearText = $$new_props.clearText);
			if ('showLoadingIndicator' in $$new_props) $$invalidate(9, showLoadingIndicator = $$new_props.showLoadingIndicator);
			if ('noResultsText' in $$new_props) $$invalidate(10, noResultsText = $$new_props.noResultsText);
			if ('loadingText' in $$new_props) $$invalidate(11, loadingText = $$new_props.loadingText);
			if ('moreItemsText' in $$new_props) $$invalidate(12, moreItemsText = $$new_props.moreItemsText);
			if ('createText' in $$new_props) $$invalidate(13, createText = $$new_props.createText);
			if ('placeholder' in $$new_props) $$invalidate(14, placeholder = $$new_props.placeholder);
			if ('className' in $$new_props) $$invalidate(15, className = $$new_props.className);
			if ('inputClassName' in $$new_props) $$invalidate(16, inputClassName = $$new_props.inputClassName);
			if ('inputId' in $$new_props) $$invalidate(17, inputId = $$new_props.inputId);
			if ('name' in $$new_props) $$invalidate(18, name = $$new_props.name);
			if ('selectName' in $$new_props) $$invalidate(19, selectName = $$new_props.selectName);
			if ('selectId' in $$new_props) $$invalidate(20, selectId = $$new_props.selectId);
			if ('title' in $$new_props) $$invalidate(21, title = $$new_props.title);
			if ('html5autocomplete' in $$new_props) $$invalidate(22, html5autocomplete = $$new_props.html5autocomplete);
			if ('autocompleteOffValue' in $$new_props) $$invalidate(23, autocompleteOffValue = $$new_props.autocompleteOffValue);
			if ('readonly' in $$new_props) $$invalidate(24, readonly = $$new_props.readonly);
			if ('dropdownClassName' in $$new_props) $$invalidate(25, dropdownClassName = $$new_props.dropdownClassName);
			if ('disabled' in $$new_props) $$invalidate(26, disabled = $$new_props.disabled);
			if ('noInputStyles' in $$new_props) $$invalidate(27, noInputStyles = $$new_props.noInputStyles);
			if ('required' in $$new_props) $$invalidate(28, required = $$new_props.required);
			if ('debug' in $$new_props) $$invalidate(92, debug = $$new_props.debug);
			if ('tabindex' in $$new_props) $$invalidate(29, tabindex = $$new_props.tabindex);
			if ('selectedItem' in $$new_props) $$invalidate(1, selectedItem = $$new_props.selectedItem);
			if ('value' in $$new_props) $$invalidate(61, value = $$new_props.value);
			if ('highlightedItem' in $$new_props) $$invalidate(62, highlightedItem = $$new_props.highlightedItem);
			if ('text' in $$new_props) $$invalidate(2, text = $$new_props.text);
			if ('$$scope' in $$new_props) $$invalidate(96, $$scope = $$new_props.$$scope);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*items*/ 1 | $$self.$$.dirty[2] & /*searchFunction*/ 2) {
				// -- Reactivity --
				(searchFunction || prepareListItems());
			}

			if ($$self.$$.dirty[0] & /*selectedItem*/ 2) {
				(onSelectedItemChanged());
			}

			if ($$self.$$.dirty[0] & /*highlightIndex*/ 1073741824 | $$self.$$.dirty[1] & /*filteredListItems*/ 1) {
				$$invalidate(62, highlightedItem = filteredListItems && highlightIndex && highlightIndex >= 0 && highlightIndex < filteredListItems.length
				? filteredListItems[highlightIndex].item
				: null);
			}

			if ($$self.$$.dirty[0] & /*items*/ 1 | $$self.$$.dirty[3] & /*opened, filteredTextLength*/ 6) {
				$$invalidate(41, showList = opened && (items && items.length > 0 || filteredTextLength > 0));
			}

			if ($$self.$$.dirty[0] & /*multiple, selectedItem*/ 34) {
				$$invalidate(32, hasSelection = multiple && selectedItem && selectedItem.length > 0 || !multiple && selectedItem);
			}

			if ($$self.$$.dirty[0] & /*multiple*/ 32 | $$self.$$.dirty[1] & /*hasSelection*/ 2 | $$self.$$.dirty[2] & /*showClear, lock*/ 538968064) {
				$$invalidate(40, clearable = showClear || (lock || multiple) && hasSelection);
			}

			if ($$self.$$.dirty[1] & /*hasSelection*/ 2 | $$self.$$.dirty[2] & /*lock*/ 2097152) {
				$$invalidate(39, locked = lock && hasSelection);
			}
		};

		return [
			items,
			selectedItem,
			text,
			valueFunction,
			maxItemsToShowInList,
			multiple,
			create,
			hideArrow,
			clearText,
			showLoadingIndicator,
			noResultsText,
			loadingText,
			moreItemsText,
			createText,
			placeholder,
			className,
			inputClassName,
			inputId,
			name,
			selectName,
			selectId,
			title,
			html5autocomplete,
			autocompleteOffValue,
			readonly,
			dropdownClassName,
			disabled,
			noInputStyles,
			required,
			tabindex,
			highlightIndex,
			filteredListItems,
			hasSelection,
			input,
			list,
			inputContainer,
			loading,
			setPositionOnNextUpdate,
			draggingOver,
			locked,
			clearable,
			showList,
			uniqueId,
			safeLabelFunction,
			selectItem,
			onListItemClick,
			onDocumentClick,
			onKeyDown,
			onKeyPress,
			onInput,
			unselectItem,
			onInputClick,
			onFocusInternal,
			onBlurInternal,
			clear,
			isConfirmed,
			dragstart,
			dragover,
			dragleave,
			drop,
			$$restProps,
			value,
			highlightedItem,
			searchFunction,
			labelFieldName,
			keywordsFieldName,
			valueFieldName,
			labelFunction,
			keywordsFunction,
			keywordsCleanFunction,
			textCleanFunction,
			beforeChange,
			onChange,
			onFocus,
			onBlur,
			onCreate,
			selectFirstIfEmpty,
			minCharactersToSearch,
			ignoreAccents,
			matchAllKeywords,
			sortByMatchedKeywords,
			itemFilterFunction,
			itemSortFunction,
			lock,
			delay,
			localFiltering,
			localSorting,
			cleanUserText,
			lowercaseKeywords,
			closeOnBlur,
			orderableSelection,
			showClear,
			debug,
			highlightFilter,
			opened,
			filteredTextLength,
			$$scope,
			slots,
			scroll_handler,
			keypress_handler,
			dragstart_handler,
			dragover_handler,
			dragleave_handler,
			drop_handler,
			input_1_binding,
			input_1_input_handler,
			dragover_handler_1,
			drop_handler_1,
			keypress_handler_1,
			div0_binding,
			click_handler,
			keypress_handler_2,
			pointerenter_handler,
			keypress_handler_3,
			div1_binding
		];
	}

	class SimpleAutocomplete extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$1g,
				create_fragment$1h,
				safe_not_equal,
				{
					items: 0,
					searchFunction: 63,
					labelFieldName: 64,
					keywordsFieldName: 65,
					valueFieldName: 66,
					labelFunction: 67,
					keywordsFunction: 68,
					valueFunction: 3,
					keywordsCleanFunction: 69,
					textCleanFunction: 70,
					beforeChange: 71,
					onChange: 72,
					onFocus: 73,
					onBlur: 74,
					onCreate: 75,
					selectFirstIfEmpty: 76,
					minCharactersToSearch: 77,
					maxItemsToShowInList: 4,
					multiple: 5,
					create: 6,
					ignoreAccents: 78,
					matchAllKeywords: 79,
					sortByMatchedKeywords: 80,
					itemFilterFunction: 81,
					itemSortFunction: 82,
					lock: 83,
					delay: 84,
					localFiltering: 85,
					localSorting: 86,
					cleanUserText: 87,
					lowercaseKeywords: 88,
					closeOnBlur: 89,
					orderableSelection: 90,
					hideArrow: 7,
					showClear: 91,
					clearText: 8,
					showLoadingIndicator: 9,
					noResultsText: 10,
					loadingText: 11,
					moreItemsText: 12,
					createText: 13,
					placeholder: 14,
					className: 15,
					inputClassName: 16,
					inputId: 17,
					name: 18,
					selectName: 19,
					selectId: 20,
					title: 21,
					html5autocomplete: 22,
					autocompleteOffValue: 23,
					readonly: 24,
					dropdownClassName: 25,
					disabled: 26,
					noInputStyles: 27,
					required: 28,
					debug: 92,
					tabindex: 29,
					selectedItem: 1,
					value: 61,
					highlightedItem: 62,
					text: 2,
					highlightFilter: 93
				},
				null,
				[-1, -1, -1, -1, -1]
			);
		}

		get highlightFilter() {
			return this.$$.ctx[93];
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.autocomplete.svelte generated by Svelte v4.2.19 */

	function create_else_block$x(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		const if_block_creators = [create_if_block_1$C, create_else_block_1$6];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*readonly*/ ctx[11]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[26](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[27](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[28](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[9]
		};

		if (/*allErrors*/ ctx[16] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[16];
		}

		if (/*showErrors*/ ctx[15] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[15];
		}

		if (/*validationClasses*/ ctx[14] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[14];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", "control");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 512) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[9];

				if (!updating_errors && dirty[0] & /*allErrors*/ 65536) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[16];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 32768) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[15];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 16384) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[14];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	// (63:0) {#if readonly}
	function create_if_block$N(ctx) {
		let uitextfield;
		let current;

		uitextfield = new Ui_textfield({
				props: {
					value: /*value*/ ctx[0] ? /*value*/ ctx[0].title : "",
					fieldname: /*fieldname*/ ctx[9],
					placeholder: /*placeholder*/ ctx[8],
					icon: /*icon*/ ctx[12]
				}
			});

		return {
			c() {
				create_component(uitextfield.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitextfield, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitextfield_changes = {};
				if (dirty[0] & /*value*/ 1) uitextfield_changes.value = /*value*/ ctx[0] ? /*value*/ ctx[0].title : "";
				if (dirty[0] & /*fieldname*/ 512) uitextfield_changes.fieldname = /*fieldname*/ ctx[9];
				if (dirty[0] & /*placeholder*/ 256) uitextfield_changes.placeholder = /*placeholder*/ ctx[8];
				if (dirty[0] & /*icon*/ 4096) uitextfield_changes.icon = /*icon*/ ctx[12];
				uitextfield.$set(uitextfield_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitextfield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitextfield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitextfield, detaching);
			}
		};
	}

	// (74:8) {:else}
	function create_else_block_1$6(ctx) {
		let autocomplete;
		let updating_selectedItem;
		let current;

		function autocomplete_selectedItem_binding(value) {
			/*autocomplete_selectedItem_binding*/ ctx[25](value);
		}

		let autocomplete_props = {
			showClear: /*showClear*/ ctx[7],
			disabled: /*disabled*/ ctx[10],
			placeholder: /*placeholder*/ ctx[8],
			noResultsText: /*noResultsText*/ ctx[6],
			onChange: /*onChange*/ ctx[18],
			searchFunction: /*searchFunction*/ ctx[13],
			hideArrow: true,
			labelFieldName: /*labelField*/ ctx[2],
			valueFieldName: /*idField*/ ctx[1],
			minCharactersToSearch: /*minCharactersToSearch*/ ctx[3],
			selectFirstIfEmpty: /*selectFirstIfEmpty*/ ctx[4],
			maxItemsToShowInList: /*maxItemsToShowInList*/ ctx[5]
		};

		if (/*value*/ ctx[0] !== void 0) {
			autocomplete_props.selectedItem = /*value*/ ctx[0];
		}

		autocomplete = new SimpleAutocomplete({ props: autocomplete_props });
		binding_callbacks.push(() => bind(autocomplete, 'selectedItem', autocomplete_selectedItem_binding));

		return {
			c() {
				create_component(autocomplete.$$.fragment);
			},
			m(target, anchor) {
				mount_component(autocomplete, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const autocomplete_changes = {};
				if (dirty[0] & /*showClear*/ 128) autocomplete_changes.showClear = /*showClear*/ ctx[7];
				if (dirty[0] & /*disabled*/ 1024) autocomplete_changes.disabled = /*disabled*/ ctx[10];
				if (dirty[0] & /*placeholder*/ 256) autocomplete_changes.placeholder = /*placeholder*/ ctx[8];
				if (dirty[0] & /*noResultsText*/ 64) autocomplete_changes.noResultsText = /*noResultsText*/ ctx[6];
				if (dirty[0] & /*searchFunction*/ 8192) autocomplete_changes.searchFunction = /*searchFunction*/ ctx[13];
				if (dirty[0] & /*labelField*/ 4) autocomplete_changes.labelFieldName = /*labelField*/ ctx[2];
				if (dirty[0] & /*idField*/ 2) autocomplete_changes.valueFieldName = /*idField*/ ctx[1];
				if (dirty[0] & /*minCharactersToSearch*/ 8) autocomplete_changes.minCharactersToSearch = /*minCharactersToSearch*/ ctx[3];
				if (dirty[0] & /*selectFirstIfEmpty*/ 16) autocomplete_changes.selectFirstIfEmpty = /*selectFirstIfEmpty*/ ctx[4];
				if (dirty[0] & /*maxItemsToShowInList*/ 32) autocomplete_changes.maxItemsToShowInList = /*maxItemsToShowInList*/ ctx[5];

				if (!updating_selectedItem && dirty[0] & /*value*/ 1) {
					updating_selectedItem = true;
					autocomplete_changes.selectedItem = /*value*/ ctx[0];
					add_flush_callback(() => updating_selectedItem = false);
				}

				autocomplete.$set(autocomplete_changes);
			},
			i(local) {
				if (current) return;
				transition_in(autocomplete.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(autocomplete.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(autocomplete, detaching);
			}
		};
	}

	// (72:8) {#if readonly}
	function create_if_block_1$C(ctx) {
		let p;
		let t_value = /*$LOCALE*/ ctx[17][/*value*/ ctx[0]] + "";
		let t;

		return {
			c() {
				p = element("p");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, value*/ 131073 && t_value !== (t_value = /*$LOCALE*/ ctx[17][/*value*/ ctx[0]] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	function create_fragment$1g(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$N, create_else_block$x];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[11]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$1f($$self, $$props, $$invalidate) {
		let allErrors;
		let showErrors;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(17, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { idField = "_id" } = $$props;
		let { labelField = "title" } = $$props;
		let { minCharactersToSearch = 3 } = $$props;
		let { selectFirstIfEmpty = false } = $$props;
		let { maxItemsToShowInList = 20 } = $$props;
		let { noResultsText = "Ничего не найдено" } = $$props;
		let { showClear = true } = $$props;
		let { value } = $$props;
		let { placeholder = "" } = $$props;
		let { fieldname = "checkbox-list" } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { icon = false } = $$props;
		let { inputStarted = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		let { searchFunction = () => /*term*/ {
			return [];
		} } = $$props;

		function onChange() {
			let data = { field: fieldname, value };
			$$invalidate(19, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function autocomplete_selectedItem_binding(value$1) {
			value = value$1;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(16, allErrors), $$invalidate(22, errors)), $$invalidate(23, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(15, showErrors), $$invalidate(21, validated)), $$invalidate(20, valid)), $$invalidate(19, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(14, validationClasses), $$invalidate(20, valid)), $$invalidate(19, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('idField' in $$props) $$invalidate(1, idField = $$props.idField);
			if ('labelField' in $$props) $$invalidate(2, labelField = $$props.labelField);
			if ('minCharactersToSearch' in $$props) $$invalidate(3, minCharactersToSearch = $$props.minCharactersToSearch);
			if ('selectFirstIfEmpty' in $$props) $$invalidate(4, selectFirstIfEmpty = $$props.selectFirstIfEmpty);
			if ('maxItemsToShowInList' in $$props) $$invalidate(5, maxItemsToShowInList = $$props.maxItemsToShowInList);
			if ('noResultsText' in $$props) $$invalidate(6, noResultsText = $$props.noResultsText);
			if ('showClear' in $$props) $$invalidate(7, showClear = $$props.showClear);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(8, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(9, fieldname = $$props.fieldname);
			if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(11, readonly = $$props.readonly);
			if ('icon' in $$props) $$invalidate(12, icon = $$props.icon);
			if ('inputStarted' in $$props) $$invalidate(19, inputStarted = $$props.inputStarted);
			if ('valid' in $$props) $$invalidate(20, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(21, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(22, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(23, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(24, formLevelError = $$props.formLevelError);
			if ('searchFunction' in $$props) $$invalidate(13, searchFunction = $$props.searchFunction);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 4096) ;

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 12582912) {
				$$invalidate(16, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 3670016) {
				$$invalidate(15, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 17825792) ;

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 1572864) {
				$$invalidate(14, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			idField,
			labelField,
			minCharactersToSearch,
			selectFirstIfEmpty,
			maxItemsToShowInList,
			noResultsText,
			showClear,
			placeholder,
			fieldname,
			disabled,
			readonly,
			icon,
			searchFunction,
			validationClasses,
			showErrors,
			allErrors,
			$LOCALE,
			onChange,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			autocomplete_selectedItem_binding,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_autocomplete extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$1f,
				create_fragment$1g,
				safe_not_equal,
				{
					idField: 1,
					labelField: 2,
					minCharactersToSearch: 3,
					selectFirstIfEmpty: 4,
					maxItemsToShowInList: 5,
					noResultsText: 6,
					showClear: 7,
					value: 0,
					placeholder: 8,
					fieldname: 9,
					disabled: 10,
					readonly: 11,
					icon: 12,
					inputStarted: 19,
					valid: 20,
					validated: 21,
					errors: 22,
					formErrors: 23,
					formLevelError: 24,
					searchFunction: 13
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.checkbox.svelte generated by Svelte v4.2.19 */

	function create_else_block$w(ctx) {
		let input;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1_value = /*$LOCALE*/ ctx[12][/*label*/ ctx[1]] + "";
		let t1;
		let mounted;
		let dispose;

		return {
			c() {
				input = element("input");
				t0 = space();
				t1 = text(t1_value);
				attr(input, "type", "checkbox");
				attr(input, "id", input_id_value = "form-field-checkbox-" + /*fieldname*/ ctx[3]);
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[12][/*placeholder*/ ctx[2]]);
				attr(input, "name", /*fieldname*/ ctx[3]);
				input.required = /*required*/ ctx[4];
				input.readOnly = /*readonly*/ ctx[5];
				attr(input, "invalid", /*invalid*/ ctx[8]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[3]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[3]);
				input.disabled = /*disabled*/ ctx[6];
			},
			m(target, anchor) {
				insert(target, input, anchor);
				input.checked = /*value*/ ctx[0];
				insert(target, t0, anchor);
				insert(target, t1, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[22]),
						listen(input, "change", /*onBlur*/ ctx[13]),
						listen(input, "input", /*onInput*/ ctx[14])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 8 && input_id_value !== (input_id_value = "form-field-checkbox-" + /*fieldname*/ ctx[3])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*$LOCALE, placeholder*/ 4100 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[12][/*placeholder*/ ctx[2]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 8) {
					attr(input, "name", /*fieldname*/ ctx[3]);
				}

				if (dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (dirty & /*invalid*/ 256) {
					attr(input, "invalid", /*invalid*/ ctx[8]);
				}

				if (dirty & /*fieldname*/ 8 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[3])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[3])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*disabled*/ 64) {
					input.disabled = /*disabled*/ ctx[6];
				}

				if (dirty & /*value*/ 1) {
					input.checked = /*value*/ ctx[0];
				}

				if (dirty & /*$LOCALE, label*/ 4098 && t1_value !== (t1_value = /*$LOCALE*/ ctx[12][/*label*/ ctx[1]] + "")) set_data(t1, t1_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (66:8) {#if readonly}
	function create_if_block$M(ctx) {
		let uibooleans;
		let current;

		uibooleans = new Ui_booleans({
				props: {
					LC_TRUE: /*label*/ ctx[1],
					LC_FALSE: /*label*/ ctx[1],
					values: [{ value: /*value*/ ctx[0] }]
				}
			});

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibooleans_changes = {};
				if (dirty & /*label*/ 2) uibooleans_changes.LC_TRUE = /*label*/ ctx[1];
				if (dirty & /*label*/ 2) uibooleans_changes.LC_FALSE = /*label*/ ctx[1];
				if (dirty & /*value*/ 1) uibooleans_changes.values = [{ value: /*value*/ ctx[0] }];
				uibooleans.$set(uibooleans_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	function create_fragment$1f(ctx) {
		let div;
		let label_1;
		let current_block_type_index;
		let if_block;
		let label_1_for_value;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		const if_block_creators = [create_if_block$M, create_else_block$w];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[5]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[23](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[24](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[25](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[3]
		};

		if (/*allErrors*/ ctx[10] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[10];
		}

		if (/*showErrors*/ ctx[9] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[9];
		}

		if (/*validationClasses*/ ctx[7] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[7];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				label_1 = element("label");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(label_1, "class", "checkbox");
				attr(label_1, "disabled", /*disabled*/ ctx[6]);
				attr(label_1, "for", label_1_for_value = "form-field-checkbox-" + /*fieldname*/ ctx[3]);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[11]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, label_1);
				if_blocks[current_block_type_index].m(label_1, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(label_1, null);
				}

				if (!current || dirty & /*disabled*/ 64) {
					attr(label_1, "disabled", /*disabled*/ ctx[6]);
				}

				if (!current || dirty & /*fieldname*/ 8 && label_1_for_value !== (label_1_for_value = "form-field-checkbox-" + /*fieldname*/ ctx[3])) {
					attr(label_1, "for", label_1_for_value);
				}

				if (!current || dirty & /*iconClasses*/ 2048 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[11])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 8) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[3];

				if (!updating_errors && dirty & /*allErrors*/ 1024) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[10];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 512) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[9];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 128) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[7];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$1e($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(12, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = false } = $$props;
		let { label = "checkbox" } = $$props;
		let { placeholder = "checkbox placeholder" } = $$props;
		let { fieldname = "checkbox" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.type === "checkbox"
				? ev.currentTarget.checked
				: value
			};

			$$invalidate(15, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.type === "checkbox"
				? ev.currentTarget.checked
				: value
			};

			$$invalidate(15, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_change_handler() {
			value = this.checked;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(10, allErrors), $$invalidate(19, errors)), $$invalidate(20, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(9, showErrors), $$invalidate(18, validated)), $$invalidate(17, valid)), $$invalidate(15, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(7, validationClasses), $$invalidate(17, valid)), $$invalidate(15, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(15, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
			if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(3, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(16, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(6, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(17, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(18, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(19, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(20, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(21, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 65536) {
				$$invalidate(11, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 1572864) {
				$$invalidate(10, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 425984) {
				$$invalidate(9, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 2228224) {
				$$invalidate(8, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 163840) {
				$$invalidate(7, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			label,
			placeholder,
			fieldname,
			required,
			readonly,
			disabled,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			icon,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_checkbox extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1e, create_fragment$1f, safe_not_equal, {
				inputStarted: 15,
				value: 0,
				label: 1,
				placeholder: 2,
				fieldname: 3,
				icon: 16,
				required: 4,
				readonly: 5,
				disabled: 6,
				valid: 17,
				validated: 18,
				errors: 19,
				formErrors: 20,
				formLevelError: 21
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.checkbox.list.svelte generated by Svelte v4.2.19 */

	function get_each_context$j(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[22] = list[i];
		child_ctx[23] = list;
		child_ctx[24] = i;
		return child_ctx;
	}

	// (62:4) {#each value as item (item.id)}
	function create_each_block$j(key_1, ctx) {
		let label;
		let input;
		let input_data_id_value;
		let input_id_value;
		let input_placeholder_value;
		let input_name_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let input_disabled_value;
		let t0;
		let t1_value = /*$LOCALE*/ ctx[8][/*item*/ ctx[22].label] + "";
		let t1;
		let t2;
		let label_disabled_value;
		let label_for_value;
		let mounted;
		let dispose;

		function input_change_handler() {
			/*input_change_handler*/ ctx[17].call(input, /*each_value*/ ctx[23], /*item_index*/ ctx[24]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				label = element("label");
				input = element("input");
				t0 = space();
				t1 = text(t1_value);
				t2 = space();
				attr(input, "data-id", input_data_id_value = /*item*/ ctx[22].id);
				attr(input, "id", input_id_value = "form-field-checkboxlist-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id));
				attr(input, "type", "checkbox");
				attr(input, "placeholder", input_placeholder_value = LOCALE[/*item*/ ctx[22].placeholder]);
				attr(input, "name", input_name_value = /*fieldname*/ ctx[1] + "_" + /*item*/ ctx[22].id);
				input.readOnly = /*readonly*/ ctx[2];
				attr(input, "invalid", /*invalid*/ ctx[5]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id));
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id));
				input.disabled = input_disabled_value = /*disabled*/ ctx[3] || /*item*/ ctx[22].disabled;
				attr(label, "class", "checkbox pr-2");
				attr(label, "disabled", label_disabled_value = /*disabled*/ ctx[3] || /*item*/ ctx[22].disabled);
				attr(label, "for", label_for_value = "form-field-checkbox-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id));
				this.first = label;
			},
			m(target, anchor) {
				insert(target, label, anchor);
				append(label, input);
				input.checked = /*item*/ ctx[22].value;
				append(label, t0);
				append(label, t1);
				append(label, t2);

				if (!mounted) {
					dispose = [
						listen(input, "change", input_change_handler),
						listen(input, "change", /*onBlur*/ ctx[9]),
						listen(input, "input", /*onInput*/ ctx[10])
					];

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*value*/ 1 && input_data_id_value !== (input_data_id_value = /*item*/ ctx[22].id)) {
					attr(input, "data-id", input_data_id_value);
				}

				if (dirty & /*fieldname, value*/ 3 && input_id_value !== (input_id_value = "form-field-checkboxlist-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id))) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*value*/ 1 && input_placeholder_value !== (input_placeholder_value = LOCALE[/*item*/ ctx[22].placeholder])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname, value*/ 3 && input_name_value !== (input_name_value = /*fieldname*/ ctx[1] + "_" + /*item*/ ctx[22].id)) {
					attr(input, "name", input_name_value);
				}

				if (dirty & /*readonly*/ 4) {
					input.readOnly = /*readonly*/ ctx[2];
				}

				if (dirty & /*invalid*/ 32) {
					attr(input, "invalid", /*invalid*/ ctx[5]);
				}

				if (dirty & /*fieldname, value*/ 3 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id))) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname, value*/ 3 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id))) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*disabled, value*/ 9 && input_disabled_value !== (input_disabled_value = /*disabled*/ ctx[3] || /*item*/ ctx[22].disabled)) {
					input.disabled = input_disabled_value;
				}

				if (dirty & /*value*/ 1) {
					input.checked = /*item*/ ctx[22].value;
				}

				if (dirty & /*$LOCALE, value*/ 257 && t1_value !== (t1_value = /*$LOCALE*/ ctx[8][/*item*/ ctx[22].label] + "")) set_data(t1, t1_value);

				if (dirty & /*disabled, value*/ 9 && label_disabled_value !== (label_disabled_value = /*disabled*/ ctx[3] || /*item*/ ctx[22].disabled)) {
					attr(label, "disabled", label_disabled_value);
				}

				if (dirty & /*fieldname, value*/ 3 && label_for_value !== (label_for_value = "form-field-checkbox-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id))) {
					attr(label, "for", label_for_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(label);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	function create_fragment$1e(ctx) {
		let div;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		let each_value = ensure_array_like(/*value*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[22].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$j(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$j(key, child_ctx));
		}

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[18](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[19](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[20](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[1]
		};

		if (/*allErrors*/ ctx[7] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[7];
		}

		if (/*showErrors*/ ctx[6] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[6];
		}

		if (/*validationClasses*/ ctx[4] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[4];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", "control");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*disabled, value, fieldname, $LOCALE, readonly, invalid, onBlur, onInput*/ 1839) {
					each_value = ensure_array_like(/*value*/ ctx[0]);
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, destroy_block, create_each_block$j, null, get_each_context$j);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 2) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[1];

				if (!updating_errors && dirty & /*allErrors*/ 128) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[7];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 64) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[6];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 16) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[4];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}

				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$1d($$self, $$props, $$invalidate) {
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(8, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = [] } = $$props;
		let { fieldname = "checkbox-list" } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let id = parseInt(ev.currentTarget.dataset.id);
			let copy = [...value];
			copy.find(itm => itm.id == id).value = ev.currentTarget.checked;
			let data = { id, field: fieldname, value: copy };
			$$invalidate(11, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let id = parseInt(ev.currentTarget.dataset.id);
			let copy = [...value];
			copy.find(itm => itm.id === id).value = ev.currentTarget.checked;
			let data = { id, field: fieldname, value: copy };
			$$invalidate(11, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_change_handler(each_value, item_index) {
			each_value[item_index].value = this.checked;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(7, allErrors), $$invalidate(14, errors)), $$invalidate(15, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(6, showErrors), $$invalidate(13, validated)), $$invalidate(12, valid)), $$invalidate(11, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(4, validationClasses), $$invalidate(12, valid)), $$invalidate(11, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(11, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('readonly' in $$props) $$invalidate(2, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(12, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(13, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(14, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(15, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(16, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*errors, formErrors*/ 49152) {
				$$invalidate(7, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 14336) {
				$$invalidate(6, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 69632) {
				$$invalidate(5, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 6144) {
				$$invalidate(4, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			fieldname,
			readonly,
			disabled,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_checkbox_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1d, create_fragment$1e, safe_not_equal, {
				inputStarted: 11,
				value: 0,
				fieldname: 1,
				readonly: 2,
				disabled: 3,
				valid: 12,
				validated: 13,
				errors: 14,
				formErrors: 15,
				formLevelError: 16
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.color.svelte generated by Svelte v4.2.19 */

	function create_if_block_3$l(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (74:4) {#if validated === true}
	function create_if_block$L(ctx) {
		let span;

		function select_block_type(ctx, dirty) {
			if (/*valid*/ ctx[6] === true) return create_if_block_1$B;
			if (/*valid*/ ctx[6] === false) return create_if_block_2$r;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (78:38) 
	function create_if_block_2$r(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (76:12) {#if valid === true}
	function create_if_block_1$B(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$1d(ctx) {
		let div;
		let input;
		let input_id_value;
		let input_class_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let div_class_value;
		let t2;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_3$l(ctx);
		let if_block1 = /*validated*/ ctx[7] === true && create_if_block$L(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[21](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[22](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[23](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[11] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[11];
		}

		if (/*showErrors*/ ctx[10] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[10];
		}

		if (/*validationClasses*/ ctx[8] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[8];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				t2 = space();
				create_component(errorslist.$$.fragment);
				attr(input, "id", input_id_value = "form-field-color-" + /*fieldname*/ ctx[2]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[8]);
				attr(input, "type", "color");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[9]);
				input.required = /*required*/ ctx[4];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				input.readOnly = /*readonly*/ ctx[5];
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[12]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, input);
				set_input_value(input, /*value*/ ctx[0]);
				append(div, t0);
				if (if_block0) if_block0.m(div, null);
				append(div, t1);
				if (if_block1) if_block1.m(div, null);
				insert(target, t2, anchor);
				mount_component(errorslist, target, anchor);
				current = true;

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[20]),
						listen(input, "change", /*onBlur*/ ctx[14]),
						listen(input, "input", /*onInput*/ ctx[15])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-color-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (!current || dirty & /*validationClasses*/ 256 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[8])) {
					attr(input, "class", input_class_value);
				}

				if (!current || dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (!current || dirty & /*invalid*/ 512) {
					attr(input, "invalid", /*invalid*/ ctx[9]);
				}

				if (!current || dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (!current || dirty & /*$LOCALE, placeholder*/ 8194 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (!current || dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (!current || dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (!current || dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (!current || dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$l(ctx);
						if_block0.c();
						if_block0.m(div, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[7] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$L(ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (!current || dirty & /*iconClasses*/ 4096 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[12])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 2048) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[11];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 1024) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[10];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 256) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[8];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				destroy_component(errorslist, detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$1c($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "Select you favorite color" } = $$props;
		let { fieldname = "color" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(11, allErrors), $$invalidate(17, errors)), $$invalidate(18, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(10, showErrors), $$invalidate(7, validated)), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(8, validationClasses), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(16, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(7, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(17, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(18, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(19, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(12, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 393216) {
				$$invalidate(11, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 65728) {
				$$invalidate(10, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 524352) {
				$$invalidate(9, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 65600) {
				$$invalidate(8, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_color extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1c, create_fragment$1d, safe_not_equal, {
				inputStarted: 16,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				readonly: 5,
				valid: 6,
				validated: 7,
				errors: 17,
				formErrors: 18,
				formLevelError: 19
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.control.svelte generated by Svelte v4.2.19 */

	function create_fragment$1c(ctx) {
		let div;
		let div_class_value;
		let current;
		const default_slot_template = /*#slots*/ ctx[2].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "class", div_class_value = "control " + /*classes*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[1],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*classes*/ 1 && div_class_value !== (div_class_value = "control " + /*classes*/ ctx[0])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$1b($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { classes = "" } = $$props;

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
		};

		return [classes, $$scope, slots];
	}

	class Ui_control extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1b, create_fragment$1c, safe_not_equal, { classes: 0 });
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.date.svelte generated by Svelte v4.2.19 */

	function create_else_block$v(ctx) {
		let input;
		let input_class_value;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[4] && create_if_block_4$e(ctx);
		let if_block1 = /*validated*/ ctx[8] === true && create_if_block_1$A(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[9]);
				attr(input, "id", input_id_value = "form-field-date-" + /*fieldname*/ ctx[2]);
				attr(input, "type", "date");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[11]);
				input.required = /*required*/ ctx[5];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]]);
				attr(input, "pattern", /*pattern*/ ctx[3]);
				input.readOnly = /*readonly*/ ctx[6];
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[21]),
						listen(input, "change", /*onBlur*/ ctx[15]),
						listen(input, "input", /*onInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-date-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*invalid*/ 2048) {
					attr(input, "invalid", /*invalid*/ ctx[11]);
				}

				if (dirty & /*required*/ 32) {
					input.required = /*required*/ ctx[5];
				}

				if (dirty & /*$LOCALE, placeholder*/ 16386 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*pattern*/ 8) {
					attr(input, "pattern", /*pattern*/ ctx[3]);
				}

				if (dirty & /*readonly*/ 64) {
					input.readOnly = /*readonly*/ ctx[6];
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[4]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$e(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[8] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$A(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (66:4) {#if readonly}
	function create_if_block$K(ctx) {
		let p;
		let time;
		let t_value = UICommon.tryFormatLocaleDateTime(/*value*/ ctx[0]) + "";
		let t;

		return {
			c() {
				p = element("p");
				time = element("time");
				t = text(t_value);
				attr(time, "datetime", /*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, time);
				append(time, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1 && t_value !== (t_value = UICommon.tryFormatLocaleDateTime(/*value*/ ctx[0]) + "")) set_data(t, t_value);

				if (dirty & /*value*/ 1) {
					attr(time, "datetime", /*value*/ ctx[0]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (90:8) {#if icon}
	function create_if_block_4$e(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[4]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 16 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[4])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (95:8) {#if validated === true}
	function create_if_block_1$A(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[7] === true) return create_if_block_2$q;
			if (/*valid*/ ctx[7] === false) return create_if_block_3$k;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (99:42) 
	function create_if_block_3$k(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (97:16) {#if valid === true}
	function create_if_block_2$q(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$1b(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return create_if_block$K;
			return create_else_block$v;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[10] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[10];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 1024) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[10];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$1a($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let invalid;
		let showErrors;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(14, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = new Date() } = $$props;
		let { placeholder = "Date and time of event" } = $$props;
		let { fieldname = "datetime" } = $$props;
		let { pattern = "d{4}-d{2}-d{2}" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		onMount(() => {
			if (value instanceof Date) {
				$$invalidate(0, value = value.toISOString().split("T")[0]);
			} else if (value.indexOf("T") > 0) {
				$$invalidate(0, value = value.split("T")[0]);
			}
		});

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(10, showErrors), $$invalidate(8, validated)), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('pattern' in $$props) $$invalidate(3, pattern = $$props.pattern);
			if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(7, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(8, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 16) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 786432) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 1048704) {
				$$invalidate(11, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131456) {
				$$invalidate(10, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131200) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			pattern,
			icon,
			required,
			readonly,
			valid,
			validated,
			validationClasses,
			showErrors,
			invalid,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_date extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1a, create_fragment$1b, safe_not_equal, {
				inputStarted: 17,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				pattern: 3,
				icon: 4,
				required: 5,
				readonly: 6,
				valid: 7,
				validated: 8,
				errors: 18,
				formErrors: 19,
				formLevelError: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.datetime.in.tz.svelte generated by Svelte v4.2.19 */

	function create_if_block$J(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[4]) return create_if_block_1$z;
			return create_else_block$u;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[0]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty[0] & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 1) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[0];

				if (!updating_errors && dirty[0] & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	// (128:8) {:else}
	function create_else_block$u(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[1] && create_if_block_5$6(ctx);
		let if_block1 = /*validated*/ ctx[6] === true && create_if_block_2$p(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-datetime-in-timezone-" + /*fieldname*/ ctx[0]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[9]);
				attr(input, "type", "datetime-local");
				attr(input, "name", /*fieldname*/ ctx[0]);
				attr(input, "invalid", /*invalid*/ ctx[10]);
				input.disabled = /*disabled*/ ctx[3];
				input.required = /*required*/ ctx[2];
				input.readOnly = /*readonly*/ ctx[4];
				attr(input, "autocomplete", /*fieldname*/ ctx[0]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[0]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*shiftedValue*/ ctx[7]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[21]),
						listen(input, "change", /*onChange*/ ctx[14]),
						listen(input, "blur", /*onChange*/ ctx[14]),
						listen(input, "input", /*onChange*/ ctx[14])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fieldname*/ 1 && input_id_value !== (input_id_value = "form-field-datetime-in-timezone-" + /*fieldname*/ ctx[0])) {
					attr(input, "id", input_id_value);
				}

				if (dirty[0] & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty[0] & /*fieldname*/ 1) {
					attr(input, "name", /*fieldname*/ ctx[0]);
				}

				if (dirty[0] & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty[0] & /*disabled*/ 8) {
					input.disabled = /*disabled*/ ctx[3];
				}

				if (dirty[0] & /*required*/ 4) {
					input.required = /*required*/ ctx[2];
				}

				if (dirty[0] & /*readonly*/ 16) {
					input.readOnly = /*readonly*/ ctx[4];
				}

				if (dirty[0] & /*fieldname*/ 1) {
					attr(input, "autocomplete", /*fieldname*/ ctx[0]);
				}

				if (dirty[0] & /*fieldname*/ 1 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[0])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty[0] & /*fieldname*/ 1 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[0])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty[0] & /*shiftedValue*/ 128) {
					set_input_value(input, /*shiftedValue*/ ctx[7]);
				}

				if (/*icon*/ ctx[1]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_5$6(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[6] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$p(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (126:8) {#if readonly}
	function create_if_block_1$z(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*shiftedValue*/ ctx[7]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*shiftedValue*/ 128) set_data(t, /*shiftedValue*/ ctx[7]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (146:12) {#if icon}
	function create_if_block_5$6(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[1]);
				attr(span, "class", "icon is-small is-left");
				attr(span, "title", /*GMTMark*/ ctx[8]);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*icon*/ 2 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[1])) {
					attr(i, "class", i_class_value);
				}

				if (dirty[0] & /*GMTMark*/ 256) {
					attr(span, "title", /*GMTMark*/ ctx[8]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (151:12) {#if validated === true}
	function create_if_block_2$p(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[5] === true) return create_if_block_3$j;
			if (/*valid*/ ctx[5] === false) return create_if_block_4$d;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (155:46) 
	function create_if_block_4$d(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (153:20) {#if valid === true}
	function create_if_block_3$j(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$1a(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*shiftedValue*/ ctx[7] && create_if_block$J(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*shiftedValue*/ ctx[7]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*shiftedValue*/ 128) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$J(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function removeMsFromDate(isoDate, markAsZULU = false) {
		return isoDate.split(".")[0] + (markAsZULU ? "" : "Z");
	}

	function markAsZULU(dateString) {
		return dateString && dateString.at(-1) !== "Z"
		? dateString + "Z"
		: dateString;
	}

	function instance$19($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let dispatch = createEventDispatcher();

		function shiftDatetime(isoDate, shift) {
			try {
				const dateUtc = new Date(markAsZULU(isoDate)).getTime();
				const offset = shift * -60000;

				if (dateIsValid(dateUtc + offset)) {
					const newDate = new Date(dateUtc + offset);
					const newIsoDate = newDate.toISOString();
					return removeMsFromDate(newIsoDate, true);
				}
			} catch(e) {
				return;
			}
		}

		let { inputStarted = false } = $$props;
		let { fieldname = "datetime" } = $$props;
		let { value = removeMsFromDate(new Date().toISOString()) } = $$props;
		let { timezoneOffset = 0 } = $$props;
		let { icon = false } = $$props;
		let { required = false } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let shiftedValue, prevShiftedValue;

		const setShifted = val => {
			if (dateIsValid(val)) {
				prevShiftedValue = shiftedValue;
				$$invalidate(7, shiftedValue = val);
			}
		};

		const resetShiftedValue = () => {
			$$invalidate(7, shiftedValue = prevShiftedValue);
		};

		onMount(() => {
			setShifted(shiftDatetime(value, timezoneOffset));
		});

		const dateIsValid = date => {
			try {
				new Date(date);
				return true;
			} catch(e) {
				return false;
			}
		};

		let GMTMark;
		const changed = () => value !== shiftDatetime(shiftedValue, -timezoneOffset);

		const dispatchChange = () => {
			setShifted(shiftedValue);
			$$invalidate(16, value = markAsZULU(shiftDatetime(shiftedValue, -timezoneOffset)));
			let data = { field: fieldname, value };
			$$invalidate(15, inputStarted = true);
			dispatch("change", data);
		};

		function onChange(ev) {
			if (ev.currentTarget.value && shiftedValue && dateIsValid(shiftedValue)) {
				if (changed()) {
					dispatchChange();
				}

				return true;
			} else {
				resetShiftedValue();
			}

			return false;
		}

		function input_input_handler() {
			shiftedValue = this.value;
			$$invalidate(7, shiftedValue);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(6, validated)), $$invalidate(5, valid)), $$invalidate(15, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(5, valid)), $$invalidate(15, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(15, inputStarted = $$props.inputStarted);
			if ('fieldname' in $$props) $$invalidate(0, fieldname = $$props.fieldname);
			if ('value' in $$props) $$invalidate(16, value = $$props.value);
			if ('timezoneOffset' in $$props) $$invalidate(17, timezoneOffset = $$props.timezoneOffset);
			if ('icon' in $$props) $$invalidate(1, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(2, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(4, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(5, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(6, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 2) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 786432) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 32864) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 1048608) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 32800) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}

			if ($$self.$$.dirty[0] & /*timezoneOffset*/ 131072) {
				{
					$$invalidate(8, GMTMark = isNaN(timezoneOffset)
					? ""
					: (timezoneOffset > 0 ? "" : "+") + (timezoneOffset / -60).toFixed(1));
				}
			}
		};

		return [
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			valid,
			validated,
			shiftedValue,
			GMTMark,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			onChange,
			inputStarted,
			value,
			timezoneOffset,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_datetime_in_tz extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$19,
				create_fragment$1a,
				safe_not_equal,
				{
					inputStarted: 15,
					fieldname: 0,
					value: 16,
					timezoneOffset: 17,
					icon: 1,
					required: 2,
					disabled: 3,
					readonly: 4,
					valid: 5,
					validated: 6,
					errors: 18,
					formErrors: 19,
					formLevelError: 20
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.email.svelte generated by Svelte v4.2.19 */

	function create_else_block$t(ctx) {
		let input;
		let input_class_value;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4$c(ctx);
		let if_block1 = /*validated*/ ctx[8] === true && create_if_block_1$y(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[9]);
				attr(input, "id", input_id_value = "form-field-email-" + /*fieldname*/ ctx[2]);
				attr(input, "type", "email");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[10]);
				input.required = /*required*/ ctx[4];
				input.readOnly = /*readonly*/ ctx[5];
				input.disabled = /*disabled*/ ctx[6];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[21]),
						listen(input, "change", /*onBlur*/ ctx[15]),
						listen(input, "input", /*onInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-email-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (dirty & /*disabled*/ 64) {
					input.disabled = /*disabled*/ ctx[6];
				}

				if (dirty & /*$LOCALE, placeholder*/ 16386 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$c(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[8] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$y(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (57:4) {#if readonly}
	function create_if_block$I(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (77:8) {#if icon}
	function create_if_block_4$c(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (82:8) {#if validated === true}
	function create_if_block_1$y(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[7] === true) return create_if_block_2$o;
			if (/*valid*/ ctx[7] === false) return create_if_block_3$i;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (86:42) 
	function create_if_block_3$i(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (84:16) {#if valid === true}
	function create_if_block_2$o(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$19(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[5]) return create_if_block$I;
			return create_else_block$t;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$18($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(14, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "" } = $$props;
		let { fieldname = "email" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(8, validated)), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(6, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(7, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(8, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 786432) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131456) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 1048704) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131200) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			disabled,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_email extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$18, create_fragment$19, safe_not_equal, {
				inputStarted: 17,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				readonly: 5,
				disabled: 6,
				valid: 7,
				validated: 8,
				errors: 18,
				formErrors: 19,
				formLevelError: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.hidden.svelte generated by Svelte v4.2.19 */

	function create_fragment$18(ctx) {
		let input;
		let mounted;
		let dispose;

		return {
			c() {
				input = element("input");
				attr(input, "type", "hidden");
				input.required = /*required*/ ctx[2];
				input.readOnly = /*readonly*/ ctx[3];
				attr(input, "name", /*fieldname*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);

				if (!mounted) {
					dispose = listen(input, "input", /*input_input_handler*/ ctx[4]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*required*/ 4) {
					input.required = /*required*/ ctx[2];
				}

				if (dirty & /*readonly*/ 8) {
					input.readOnly = /*readonly*/ ctx[3];
				}

				if (dirty & /*fieldname*/ 2) {
					attr(input, "name", /*fieldname*/ ctx[1]);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(input);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function instance$17($$self, $$props, $$invalidate) {
		let { value = "" } = $$props;
		let { fieldname = "hidden" } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('required' in $$props) $$invalidate(2, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(3, readonly = $$props.readonly);
		};

		return [value, fieldname, required, readonly, input_input_handler];
	}

	class Ui_hidden extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$17, create_fragment$18, safe_not_equal, {
				value: 0,
				fieldname: 1,
				required: 2,
				readonly: 3
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.label.svelte generated by Svelte v4.2.19 */

	function create_fragment$17(ctx) {
		let label_1;
		let t_value = /*$LOCALE*/ ctx[2][/*label*/ ctx[1]] + "";
		let t;

		return {
			c() {
				label_1 = element("label");
				t = text(t_value);
				attr(label_1, "class", "label");
				attr(label_1, "for", /*id*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, label_1, anchor);
				append(label_1, t);
			},
			p(ctx, [dirty]) {
				if (dirty & /*$LOCALE, label*/ 6 && t_value !== (t_value = /*$LOCALE*/ ctx[2][/*label*/ ctx[1]] + "")) set_data(t, t_value);

				if (dirty & /*id*/ 1) {
					attr(label_1, "for", /*id*/ ctx[0]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(label_1);
				}
			}
		};
	}

	function instance$16($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		let { id } = $$props;
		let { label = "label" } = $$props;

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
		};

		return [id, label, $LOCALE];
	}

	class Ui_label extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$16, create_fragment$17, safe_not_equal, { id: 0, label: 1 });
		}
	}

	class Lib {
	    #lib = {};

	    constructor(seedLib) {
	        if (seedLib instanceof Lib) {
	            this.import(seedLib.getContent());
	        }
	    }

	    /**
	     *
	     * @params {string}  mode what to do if element exists [replace|add|skip]
	     */
	    add(name, comp, mode = "replace") {
	        if (this.contains(name)) {
	            if (mode === "replace") {
	                this.#lib[name] = comp;
	            } else if (mode === "add") {
	                this.#lib[name] = Object.assign(this.#lib[name], comp);
	            }
	        } else {
	            this.#lib[name] = comp;
	        }
	    }

	    get(name) {
	        return this.#lib[name];
	    }

	    contains(name) {
	        return Object.hasOwn(this.#lib, name);
	    }

	    import(bulk, mode = "replace") {
	        for (let f in bulk) {
	            this.add(f, bulk[f], mode);
	        }
	    }

	    isEmpty() {
	        return Object.keys(this.#lib).length === 0;
	    }

	    getContent() {
	        return {
	            ...this.#lib,
	        };
	    }
	}

	/*
	 * Библиотека UI конструкторов
	 */


	const COMPONENTS$2 = new Lib();
	const FIELDS$2 = new Lib();
	const VARIANTS$1 = new Lib();

	/* node_modules/not-bulma/src/elements/list/ui.list.empty.placeholder.svelte generated by Svelte v4.2.19 */

	function create_fragment$16(ctx) {
		let uititle;
		let current;

		uititle = new Ui_title({
				props: {
					title: "not-node:empty_list_placeholder",
					size: 4,
					align: "center"
				}
			});

		return {
			c() {
				create_component(uititle.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uititle, target, anchor);
				current = true;
			},
			p: noop$1,
			i(local) {
				if (current) return;
				transition_in(uititle.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uititle.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uititle, detaching);
			}
		};
	}

	class Ui_list_empty_placeholder extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, null, create_fragment$16, safe_not_equal, {});
		}
	}

	/* node_modules/not-bulma/src/elements/link/ui.link.svelte generated by Svelte v4.2.19 */

	function create_else_block$s(ctx) {
		let t0_value = /*$LOCALE*/ ctx[19][/*title*/ ctx[1]] + "";
		let t0;
		let t1;
		let current;
		const default_slot_template = /*#slots*/ ctx[22].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

		return {
			c() {
				t0 = text(t0_value);
				t1 = space();
				if (default_slot) default_slot.c();
			},
			m(target, anchor) {
				insert(target, t0, anchor);
				insert(target, t1, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p(ctx, dirty) {
				if ((!current || dirty & /*$LOCALE, title*/ 524290) && t0_value !== (t0_value = /*$LOCALE*/ ctx[19][/*title*/ ctx[1]] + "")) set_data(t0, t0_value);

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[21],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
							null
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (57:4) {#if icon}
	function create_if_block$H(ctx) {
		let t0;
		let t1;
		let t2;
		let if_block2_anchor;
		let current;
		let if_block0 = /*iconSide*/ ctx[17] === "left" && create_if_block_3$h(ctx);
		let if_block1 = /*title*/ ctx[1] && create_if_block_2$n(ctx);
		const default_slot_template = /*#slots*/ ctx[22].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
		let if_block2 = /*iconSide*/ ctx[17] === "right" && create_if_block_1$x(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (default_slot) default_slot.c();
				t2 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				insert(target, t2, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*iconSide*/ ctx[17] === "left") {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$h(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*title*/ ctx[1]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$n(ctx);
						if_block1.c();
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[21],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
							null
						);
					}
				}

				if (/*iconSide*/ ctx[17] === "right") {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_1$x(ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(if_block2_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (default_slot) default_slot.d(detaching);
				if (if_block2) if_block2.d(detaching);
			}
		};
	}

	// (58:8) {#if iconSide === "left"}
	function create_if_block_3$h(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[16] + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : ''));
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon, size*/ 98304 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[16] + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : ''))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (63:8) {#if title}
	function create_if_block_2$n(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[19][/*title*/ ctx[1]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, title*/ 524290 && t_value !== (t_value = /*$LOCALE*/ ctx[19][/*title*/ ctx[1]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (67:8) {#if iconSide === "right"}
	function create_if_block_1$x(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[16] + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : ''));
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon, size*/ 98304 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[16] + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : ''))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$15(ctx) {
		let a;
		let current_block_type_index;
		let if_block;
		let a_class_value;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block$H, create_else_block$s];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*icon*/ ctx[16]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				a = element("a");
				if_block.c();
				attr(a, "target", /*target*/ ctx[4]);
				attr(a, "href", /*url*/ ctx[2]);
				attr(a, "download", /*download*/ ctx[3]);
				attr(a, "rel", /*rel*/ ctx[5]);
				attr(a, "class", a_class_value = "" + (/*classes*/ ctx[0] + " " + (/*state*/ ctx[12] ? `is-${/*state*/ ctx[12]}` : '') + " " + (/*inverted*/ ctx[10] ? `is-inverted` : '') + " " + (/*outlined*/ ctx[9] ? `is-outlined` : '') + " " + (/*raised*/ ctx[8] ? `is-raised` : '') + " " + (/*rounded*/ ctx[11] ? `is-rounded` : '') + " " + (/*light*/ ctx[6] ? `is-light` : '') + " " + (/*loading*/ ctx[7] ? `is-loading` : '') + " " + (/*color*/ ctx[14] ? `is-${/*color*/ ctx[14]}` : '') + " " + (/*type*/ ctx[13] ? `is-${/*type*/ ctx[13]}` : '') + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : '')));
			},
			m(target, anchor) {
				insert(target, a, anchor);
				if_blocks[current_block_type_index].m(a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", function () {
						if (is_function(/*action*/ ctx[18])) /*action*/ ctx[18].apply(this, arguments);
					});

					mounted = true;
				}
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(a, null);
				}

				if (!current || dirty & /*target*/ 16) {
					attr(a, "target", /*target*/ ctx[4]);
				}

				if (!current || dirty & /*url*/ 4) {
					attr(a, "href", /*url*/ ctx[2]);
				}

				if (!current || dirty & /*download*/ 8) {
					attr(a, "download", /*download*/ ctx[3]);
				}

				if (!current || dirty & /*rel*/ 32) {
					attr(a, "rel", /*rel*/ ctx[5]);
				}

				if (!current || dirty & /*classes, state, inverted, outlined, raised, rounded, light, loading, color, type, size*/ 65473 && a_class_value !== (a_class_value = "" + (/*classes*/ ctx[0] + " " + (/*state*/ ctx[12] ? `is-${/*state*/ ctx[12]}` : '') + " " + (/*inverted*/ ctx[10] ? `is-inverted` : '') + " " + (/*outlined*/ ctx[9] ? `is-outlined` : '') + " " + (/*raised*/ ctx[8] ? `is-raised` : '') + " " + (/*rounded*/ ctx[11] ? `is-rounded` : '') + " " + (/*light*/ ctx[6] ? `is-light` : '') + " " + (/*loading*/ ctx[7] ? `is-loading` : '') + " " + (/*color*/ ctx[14] ? `is-${/*color*/ ctx[14]}` : '') + " " + (/*type*/ ctx[13] ? `is-${/*type*/ ctx[13]}` : '') + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : '')))) {
					attr(a, "class", a_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};
	}

	function instance$15($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(19, $LOCALE = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		let { title = "" } = $$props;
		let { url = "" } = $$props;
		let { download } = $$props;
		let { target = "_blank" } = $$props;
		let { rel } = $$props;
		let { light = false } = $$props;
		let { loading = false } = $$props;
		let { raised = false } = $$props;
		let { outlined = false } = $$props;
		let { inverted = false } = $$props;
		let { rounded = false } = $$props;
		let { button = true } = $$props;
		let { state = "" } = $$props;
		let { type = "" } = $$props;
		let { color = "" } = $$props;
		let { size = "" } = $$props;
		let { classes = "" } = $$props;
		let { icon = false } = $$props;
		let { iconSide = "right" } = $$props;

		let { action = () => {
			return true;
		} } = $$props;

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('url' in $$props) $$invalidate(2, url = $$props.url);
			if ('download' in $$props) $$invalidate(3, download = $$props.download);
			if ('target' in $$props) $$invalidate(4, target = $$props.target);
			if ('rel' in $$props) $$invalidate(5, rel = $$props.rel);
			if ('light' in $$props) $$invalidate(6, light = $$props.light);
			if ('loading' in $$props) $$invalidate(7, loading = $$props.loading);
			if ('raised' in $$props) $$invalidate(8, raised = $$props.raised);
			if ('outlined' in $$props) $$invalidate(9, outlined = $$props.outlined);
			if ('inverted' in $$props) $$invalidate(10, inverted = $$props.inverted);
			if ('rounded' in $$props) $$invalidate(11, rounded = $$props.rounded);
			if ('button' in $$props) $$invalidate(20, button = $$props.button);
			if ('state' in $$props) $$invalidate(12, state = $$props.state);
			if ('type' in $$props) $$invalidate(13, type = $$props.type);
			if ('color' in $$props) $$invalidate(14, color = $$props.color);
			if ('size' in $$props) $$invalidate(15, size = $$props.size);
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('icon' in $$props) $$invalidate(16, icon = $$props.icon);
			if ('iconSide' in $$props) $$invalidate(17, iconSide = $$props.iconSide);
			if ('action' in $$props) $$invalidate(18, action = $$props.action);
			if ('$$scope' in $$props) $$invalidate(21, $$scope = $$props.$$scope);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*button, state, light, type, size*/ 1093696) {
				{
					$$invalidate(0, classes = (button ? "button " : "") + (state && state.length > 0 ? ` is-${state} ` : "") + (light ? ` is-light ` : "") + (type && type.length > 0 ? ` is-${type} ` : "") + (size && size.length > 0 ? ` is-${size} ` : ""));
				}
			}
		};

		return [
			classes,
			title,
			url,
			download,
			target,
			rel,
			light,
			loading,
			raised,
			outlined,
			inverted,
			rounded,
			state,
			type,
			color,
			size,
			icon,
			iconSide,
			action,
			$LOCALE,
			button,
			$$scope,
			slots
		];
	}

	class Ui_link extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$15, create_fragment$15, safe_not_equal, {
				title: 1,
				url: 2,
				download: 3,
				target: 4,
				rel: 5,
				light: 6,
				loading: 7,
				raised: 8,
				outlined: 9,
				inverted: 10,
				rounded: 11,
				button: 20,
				state: 12,
				type: 13,
				color: 14,
				size: 15,
				classes: 0,
				icon: 16,
				iconSide: 17,
				action: 18
			});
		}
	}

	/* node_modules/not-bulma/src/elements/link/ui.links.svelte generated by Svelte v4.2.19 */

	function get_each_context_1$6(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	function get_each_context$i(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	// (22:0) {:else}
	function create_else_block$r(ctx) {
		let div;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div_class_value;
		let current;
		let each_value_1 = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[5].id;

		for (let i = 0; i < each_value_1.length; i += 1) {
			let child_ctx = get_each_context_1$6(ctx, each_value_1, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block_1$6(key, child_ctx));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", div_class_value = "buttons " + (/*centered*/ ctx[2] ? 'is-centered' : '') + " " + (/*right*/ ctx[3] ? 'is-right' : '') + " " + /*classes*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1) {
					each_value_1 = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1$6, null, get_each_context_1$6);
					check_outros();
				}

				if (!current || dirty & /*centered, right, classes*/ 14 && div_class_value !== (div_class_value = "buttons " + (/*centered*/ ctx[2] ? 'is-centered' : '') + " " + (/*right*/ ctx[3] ? 'is-right' : '') + " " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	// (10:0) {#if joined}
	function create_if_block$G(ctx) {
		let div;
		let p;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div_class_value;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[5].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$i(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$i(key, child_ctx));
		}

		return {
			c() {
				div = element("div");
				p = element("p");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(p, "class", "control");
				attr(div, "class", div_class_value = "field has-addons " + (/*centered*/ ctx[2] ? 'is-centered' : '') + " " + (/*right*/ ctx[3] ? 'is-right' : '') + " " + /*classes*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, p);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(p, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, p, outro_and_destroy_block, create_each_block$i, null, get_each_context$i);
					check_outros();
				}

				if (!current || dirty & /*centered, right, classes*/ 14 && div_class_value !== (div_class_value = "field has-addons " + (/*centered*/ ctx[2] ? 'is-centered' : '') + " " + (/*right*/ ctx[3] ? 'is-right' : '') + " " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	// (28:8) {#each values as item (item.id)}
	function create_each_block_1$6(key_1, ctx) {
		let first;
		let uilink;
		let current;
		const uilink_spread_levels = [/*item*/ ctx[5]];
		let uilink_props = {};

		for (let i = 0; i < uilink_spread_levels.length; i += 1) {
			uilink_props = assign(uilink_props, uilink_spread_levels[i]);
		}

		uilink = new Ui_link({ props: uilink_props });

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uilink.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uilink, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				const uilink_changes = (dirty & /*values*/ 1)
				? get_spread_update(uilink_spread_levels, [get_spread_object(/*item*/ ctx[5])])
				: {};

				uilink.$set(uilink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uilink, detaching);
			}
		};
	}

	// (17:12) {#each values as item (item.id)}
	function create_each_block$i(key_1, ctx) {
		let first;
		let uilink;
		let current;
		const uilink_spread_levels = [/*item*/ ctx[5]];
		let uilink_props = {};

		for (let i = 0; i < uilink_spread_levels.length; i += 1) {
			uilink_props = assign(uilink_props, uilink_spread_levels[i]);
		}

		uilink = new Ui_link({ props: uilink_props });

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uilink.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uilink, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				const uilink_changes = (dirty & /*values*/ 1)
				? get_spread_update(uilink_spread_levels, [get_spread_object(/*item*/ ctx[5])])
				: {};

				uilink.$set(uilink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uilink, detaching);
			}
		};
	}

	function create_fragment$14(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$G, create_else_block$r];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*joined*/ ctx[4]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$14($$self, $$props, $$invalidate) {
		let { values = [] } = $$props;
		let { classes = "" } = $$props;
		let { centered = false } = $$props;
		let { right = false } = $$props;
		let { joined = true } = $$props;

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('centered' in $$props) $$invalidate(2, centered = $$props.centered);
			if ('right' in $$props) $$invalidate(3, right = $$props.right);
			if ('joined' in $$props) $$invalidate(4, joined = $$props.joined);
		};

		return [values, classes, centered, right, joined];
	}

	class Ui_links extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$14, create_fragment$14, safe_not_equal, {
				values: 0,
				classes: 1,
				centered: 2,
				right: 3,
				joined: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.item.svelte generated by Svelte v4.2.19 */

	function create_if_block_9$1(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_10$1, create_else_block_5];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*imageComponent*/ ctx[13]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div = element("div");
				if_block.c();
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				attr(div, "class", "list-item-image");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "keyup", prevent_default(/*keyup_handler*/ ctx[23])),
						listen(div, "click", prevent_default(/*click_handler_2*/ ctx[24]))
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (95:12) {:else}
	function create_else_block_5(ctx) {
		let figure;
		let img;
		let img_src_value;

		return {
			c() {
				figure = element("figure");
				img = element("img");
				attr(img, "class", "is-rounded");
				if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[4])) attr(img, "src", img_src_value);
				attr(img, "alt", /*title*/ ctx[0]);
				attr(figure, "class", "image is-64x64");
			},
			m(target, anchor) {
				insert(target, figure, anchor);
				append(figure, img);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*image*/ 16 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[4])) {
					attr(img, "src", img_src_value);
				}

				if (dirty[0] & /*title*/ 1) {
					attr(img, "alt", /*title*/ ctx[0]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(figure);
				}
			}
		};
	}

	// (81:12) {#if imageComponent}
	function create_if_block_10$1(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_11$1, create_else_block_4];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (typeof /*image*/ ctx[4] === "string") return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (88:16) {:else}
	function create_else_block_4(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*image*/ ctx[4], /*imageComponentProps*/ ctx[14]];
		var switch_value = /*imageComponent*/ ctx[13];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*image, imageComponentProps*/ 16400) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*image*/ 16 && get_spread_object(/*image*/ ctx[4]),
					dirty[0] & /*imageComponentProps*/ 16384 && get_spread_object(/*imageComponentProps*/ ctx[14])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*imageComponent*/ 8192 && switch_value !== (switch_value = /*imageComponent*/ ctx[13])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*image, imageComponentProps*/ 16400)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*image*/ 16 && get_spread_object(/*image*/ ctx[4]),
							dirty[0] & /*imageComponentProps*/ 16384 && get_spread_object(/*imageComponentProps*/ ctx[14])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (82:16) {#if typeof image === "string"}
	function create_if_block_11$1(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ value: /*image*/ ctx[4] }, /*imageComponentProps*/ ctx[14]];
		var switch_value = /*imageComponent*/ ctx[13];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*image, imageComponentProps*/ 16400) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*image*/ 16 && { value: /*image*/ ctx[4] },
					dirty[0] & /*imageComponentProps*/ 16384 && get_spread_object(/*imageComponentProps*/ ctx[14])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*imageComponent*/ 8192 && switch_value !== (switch_value = /*imageComponent*/ ctx[13])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*image, imageComponentProps*/ 16400)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*image*/ 16 && { value: /*image*/ ctx[4] },
							dirty[0] & /*imageComponentProps*/ 16384 && get_spread_object(/*imageComponentProps*/ ctx[14])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (117:8) {#if title}
	function create_if_block_6$3(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_7$3, create_else_block_3];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*titleComponent*/ ctx[9]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div = element("div");
				if_block.c();
				attr(div, "class", "list-item-title");
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "keyup", prevent_default(/*keyup_handler_1*/ ctx[27])),
						listen(div, "click", prevent_default(/*click_handler_3*/ ctx[28]))
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (149:16) {:else}
	function create_else_block_3(ctx) {
		let t;

		return {
			c() {
				t = text(/*title*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*title*/ 1) set_data(t, /*title*/ ctx[0]);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (133:16) {#if titleComponent}
	function create_if_block_7$3(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_8$1, create_else_block_2$4];
		const if_blocks = [];

		function select_block_type_3(ctx, dirty) {
			if (typeof /*title*/ ctx[0] === "string") return 0;
			return 1;
		}

		current_block_type_index = select_block_type_3(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_3(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (141:20) {:else}
	function create_else_block_2$4(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*title*/ ctx[0], /*titleComponentProps*/ ctx[10]];
		var switch_value = /*titleComponent*/ ctx[9];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*title, titleComponentProps*/ 1025) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*title*/ 1 && get_spread_object(/*title*/ ctx[0]),
					dirty[0] & /*titleComponentProps*/ 1024 && get_spread_object(/*titleComponentProps*/ ctx[10])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*change_handler_1*/ ctx[26]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*titleComponent*/ 512 && switch_value !== (switch_value = /*titleComponent*/ ctx[9])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*change_handler_1*/ ctx[26]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*title, titleComponentProps*/ 1025)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*title*/ 1 && get_spread_object(/*title*/ ctx[0]),
							dirty[0] & /*titleComponentProps*/ 1024 && get_spread_object(/*titleComponentProps*/ ctx[10])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (134:20) {#if typeof title === "string"}
	function create_if_block_8$1(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ title: /*title*/ ctx[0] }, /*titleComponentProps*/ ctx[10]];
		var switch_value = /*titleComponent*/ ctx[9];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*title, titleComponentProps*/ 1025) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*title*/ 1 && { title: /*title*/ ctx[0] },
					dirty[0] & /*titleComponentProps*/ 1024 && get_spread_object(/*titleComponentProps*/ ctx[10])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*change_handler*/ ctx[25]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*titleComponent*/ 512 && switch_value !== (switch_value = /*titleComponent*/ ctx[9])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*change_handler*/ ctx[25]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*title, titleComponentProps*/ 1025)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*title*/ 1 && { title: /*title*/ ctx[0] },
							dirty[0] & /*titleComponentProps*/ 1024 && get_spread_object(/*titleComponentProps*/ ctx[10])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (154:8) {#if description}
	function create_if_block_3$g(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_4$b, create_else_block_1$5];
		const if_blocks = [];

		function select_block_type_4(ctx, dirty) {
			if (/*descriptionComponent*/ ctx[11]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_4(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div = element("div");
				if_block.c();
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				attr(div, "class", "list-item-description");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "keyup", prevent_default(/*keyup_handler_2*/ ctx[33])),
						listen(div, "click", prevent_default(/*click_handler_4*/ ctx[34]))
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_4(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (188:16) {:else}
	function create_else_block_1$5(ctx) {
		let t;

		return {
			c() {
				t = text(/*description*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*description*/ 2) set_data(t, /*description*/ ctx[1]);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (170:16) {#if descriptionComponent}
	function create_if_block_4$b(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_5$5, create_else_block$q];
		const if_blocks = [];

		function select_block_type_5(ctx, dirty) {
			if (typeof /*description*/ ctx[1] === "string") return 0;
			return 1;
		}

		current_block_type_index = select_block_type_5(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_5(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (179:20) {:else}
	function create_else_block$q(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*description*/ ctx[1], /*descriptionComponentProps*/ ctx[12]];
		var switch_value = /*descriptionComponent*/ ctx[11];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*description, descriptionComponentProps*/ 4098) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*description*/ 2 && get_spread_object(/*description*/ ctx[1]),
					dirty[0] & /*descriptionComponentProps*/ 4096 && get_spread_object(/*descriptionComponentProps*/ ctx[12])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*change_handler_3*/ ctx[31]);
			switch_instance.$on("click", /*click_handler_1*/ ctx[32]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*descriptionComponent*/ 2048 && switch_value !== (switch_value = /*descriptionComponent*/ ctx[11])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*change_handler_3*/ ctx[31]);
						switch_instance.$on("click", /*click_handler_1*/ ctx[32]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*description, descriptionComponentProps*/ 4098)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*description*/ 2 && get_spread_object(/*description*/ ctx[1]),
							dirty[0] & /*descriptionComponentProps*/ 4096 && get_spread_object(/*descriptionComponentProps*/ ctx[12])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (171:20) {#if typeof description === "string"}
	function create_if_block_5$5(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ value: /*description*/ ctx[1] }, /*descriptionComponentProps*/ ctx[12]];
		var switch_value = /*descriptionComponent*/ ctx[11];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*description, descriptionComponentProps*/ 4098) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*description*/ 2 && { value: /*description*/ ctx[1] },
					dirty[0] & /*descriptionComponentProps*/ 4096 && get_spread_object(/*descriptionComponentProps*/ ctx[12])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*change_handler_2*/ ctx[29]);
			switch_instance.$on("click", /*click_handler*/ ctx[30]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*descriptionComponent*/ 2048 && switch_value !== (switch_value = /*descriptionComponent*/ ctx[11])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*change_handler_2*/ ctx[29]);
						switch_instance.$on("click", /*click_handler*/ ctx[30]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*description, descriptionComponentProps*/ 4098)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*description*/ 2 && { value: /*description*/ ctx[1] },
							dirty[0] & /*descriptionComponentProps*/ 4096 && get_spread_object(/*descriptionComponentProps*/ ctx[12])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (195:4) {#if (allActions && allActions.length) || (allLinks && allLinks.length)}
	function create_if_block$F(ctx) {
		let div;
		let t;
		let current;
		let if_block0 = /*allActions*/ ctx[15] && /*allActions*/ ctx[15].length && create_if_block_2$m(ctx);
		let if_block1 = /*allLinks*/ ctx[16] && /*allLinks*/ ctx[16].length && create_if_block_1$w(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				attr(div, "class", "list-item-controls");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},
			p(ctx, dirty) {
				if (/*allActions*/ ctx[15] && /*allActions*/ ctx[15].length) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*allActions*/ 32768) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$m(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*allLinks*/ ctx[16] && /*allLinks*/ ctx[16].length) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*allLinks*/ 65536) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$w(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (197:12) {#if allActions && allActions.length}
	function create_if_block_2$m(ctx) {
		let uibuttons;
		let current;

		uibuttons = new Ui_buttons({
				props: {
					values: /*allActions*/ ctx[15],
					right: true
				}
			});

		return {
			c() {
				create_component(uibuttons.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttons, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttons_changes = {};
				if (dirty[0] & /*allActions*/ 32768) uibuttons_changes.values = /*allActions*/ ctx[15];
				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttons, detaching);
			}
		};
	}

	// (200:12) {#if allLinks && allLinks.length}
	function create_if_block_1$w(ctx) {
		let uilinks;
		let current;

		uilinks = new Ui_links({
				props: {
					values: /*allLinks*/ ctx[16],
					right: true
				}
			});

		return {
			c() {
				create_component(uilinks.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uilinks, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uilinks_changes = {};
				if (dirty[0] & /*allLinks*/ 65536) uilinks_changes.values = /*allLinks*/ ctx[16];
				uilinks.$set(uilinks_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilinks.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilinks.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uilinks, detaching);
			}
		};
	}

	function create_fragment$13(ctx) {
		let div1;
		let t0;
		let div0;
		let t1;
		let t2;
		let div1_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*image*/ ctx[4] && create_if_block_9$1(ctx);
		let if_block1 = /*title*/ ctx[0] && create_if_block_6$3(ctx);
		let if_block2 = /*description*/ ctx[1] && create_if_block_3$g(ctx);
		let if_block3 = (/*allActions*/ ctx[15] && /*allActions*/ ctx[15].length || /*allLinks*/ ctx[16] && /*allLinks*/ ctx[16].length) && create_if_block$F(ctx);

		return {
			c() {
				div1 = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				div0 = element("div");
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				if (if_block3) if_block3.c();
				attr(div0, "role", "button");
				attr(div0, "tabindex", "0");
				attr(div0, "class", "list-item-content");
				attr(div1, "role", "button");
				attr(div1, "tabindex", "0");
				attr(div1, "class", div1_class_value = "list-item " + /*classes*/ ctx[2] + " " + /*commonClasses*/ ctx[3] + " " + (/*last*/ ctx[8] ? 'list-item-last' : '') + " " + (/*first*/ ctx[7] ? 'list-item-first' : '') + " " + `list-item-at-${/*index*/ ctx[6]}` + " " + (`list-item-` + (/*index*/ ctx[6] % 2 ? 'odd' : 'even')));
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				if (if_block0) if_block0.m(div1, null);
				append(div1, t0);
				append(div1, div0);
				if (if_block1) if_block1.m(div0, null);
				append(div0, t1);
				if (if_block2) if_block2.m(div0, null);
				append(div1, t2);
				if (if_block3) if_block3.m(div1, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div0, "click", prevent_default(/*click_handler_5*/ ctx[35])),
						listen(div0, "keyup", prevent_default(/*keyup_handler_3*/ ctx[36])),
						listen(div1, "click", /*onClick*/ ctx[18]),
						listen(div1, "keyup", /*keyup_handler_4*/ ctx[37])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (/*image*/ ctx[4]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*image*/ 16) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_9$1(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div1, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*title*/ ctx[0]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*title*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_6$3(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div0, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*description*/ ctx[1]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*description*/ 2) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_3$g(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div0, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*allActions*/ ctx[15] && /*allActions*/ ctx[15].length || /*allLinks*/ ctx[16] && /*allLinks*/ ctx[16].length) {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty[0] & /*allActions, allLinks*/ 98304) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block$F(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(div1, null);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				if (!current || dirty[0] & /*classes, commonClasses, last, first, index*/ 460 && div1_class_value !== (div1_class_value = "list-item " + /*classes*/ ctx[2] + " " + /*commonClasses*/ ctx[3] + " " + (/*last*/ ctx[8] ? 'list-item-last' : '') + " " + (/*first*/ ctx[7] ? 'list-item-first' : '') + " " + `list-item-at-${/*index*/ ctx[6]}` + " " + (`list-item-` + (/*index*/ ctx[6] % 2 ? 'odd' : 'even')))) {
					attr(div1, "class", div1_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$13($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { title } = $$props;
		let { description } = $$props;
		let { actions = [] } = $$props;
		let { links = [] } = $$props;
		let { listActions = [] } = $$props;
		let { listLinks = [] } = $$props;
		let { classes = "" } = $$props;
		let { commonClasses = "" } = $$props;
		let { image = "" } = $$props;
		let { value } = $$props;
		let { index = -1 } = $$props;
		let { first = false } = $$props;
		let { last = false } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 6 } } = $$props;
		let { descriptionComponent } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { imageComponent } = $$props;
		let { imageComponentProps = {} } = $$props;

		function onClick() {
			dispatch("click", value);
		}

		let allActions = [];
		let allLinks = [];

		const keyup_handler = e => {
			if (e && e.key == "Enter") {
				onClick();
				dispatch("clickImage", value);
			}
		};

		const click_handler_2 = () => {
			onClick();
			dispatch("clickImage", value);
		};

		function change_handler(event) {
			bubble.call(this, $$self, event);
		}

		function change_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler_1 = e => {
			if (e && e.key == "Enter") {
				onClick();
				dispatch("clickTitle", value);
			}
		};

		const click_handler_3 = () => {
			onClick();
			dispatch("clickTitle", value);
		};

		function change_handler_2(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function change_handler_3(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler_2 = e => {
			if (e && e.key == "Enter") {
				onClick();
				dispatch("clickDescription", value);
			}
		};

		const click_handler_4 = () => {
			onClick();
			dispatch("clickDescription", value);
		};

		const click_handler_5 = () => {
			onClick();
			dispatch("clickContent", value);
		};

		const keyup_handler_3 = e => {
			if (e && e.key == "Enter") {
				onClick();
				dispatch("clickContent", value);
			}
		};

		const keyup_handler_4 = e => {
			if (e && e.key == "Enter") {
				onClick();
			}
		};

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('description' in $$props) $$invalidate(1, description = $$props.description);
			if ('actions' in $$props) $$invalidate(19, actions = $$props.actions);
			if ('links' in $$props) $$invalidate(20, links = $$props.links);
			if ('listActions' in $$props) $$invalidate(21, listActions = $$props.listActions);
			if ('listLinks' in $$props) $$invalidate(22, listLinks = $$props.listLinks);
			if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
			if ('commonClasses' in $$props) $$invalidate(3, commonClasses = $$props.commonClasses);
			if ('image' in $$props) $$invalidate(4, image = $$props.image);
			if ('value' in $$props) $$invalidate(5, value = $$props.value);
			if ('index' in $$props) $$invalidate(6, index = $$props.index);
			if ('first' in $$props) $$invalidate(7, first = $$props.first);
			if ('last' in $$props) $$invalidate(8, last = $$props.last);
			if ('titleComponent' in $$props) $$invalidate(9, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(10, titleComponentProps = $$props.titleComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(11, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(12, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('imageComponent' in $$props) $$invalidate(13, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(14, imageComponentProps = $$props.imageComponentProps);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*actions, listActions, value*/ 2621472) {
				$$invalidate(15, allActions = [...actions, ...listActions].map(btn => {
					return { ...btn, action: () => btn.action(value) };
				}));
			}

			if ($$self.$$.dirty[0] & /*links, listLinks*/ 5242880) {
				$$invalidate(16, allLinks = [...links, ...listLinks]);
			}
		};

		return [
			title,
			description,
			classes,
			commonClasses,
			image,
			value,
			index,
			first,
			last,
			titleComponent,
			titleComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			imageComponent,
			imageComponentProps,
			allActions,
			allLinks,
			dispatch,
			onClick,
			actions,
			links,
			listActions,
			listLinks,
			keyup_handler,
			click_handler_2,
			change_handler,
			change_handler_1,
			keyup_handler_1,
			click_handler_3,
			change_handler_2,
			click_handler,
			change_handler_3,
			click_handler_1,
			keyup_handler_2,
			click_handler_4,
			click_handler_5,
			keyup_handler_3,
			keyup_handler_4
		];
	}

	class Ui_list_item extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$13,
				create_fragment$13,
				safe_not_equal,
				{
					title: 0,
					description: 1,
					actions: 19,
					links: 20,
					listActions: 21,
					listLinks: 22,
					classes: 2,
					commonClasses: 3,
					image: 4,
					value: 5,
					index: 6,
					first: 7,
					last: 8,
					titleComponent: 9,
					titleComponentProps: 10,
					descriptionComponent: 11,
					descriptionComponentProps: 12,
					imageComponent: 13,
					imageComponentProps: 14
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.block.svelte generated by Svelte v4.2.19 */

	function get_each_context$h(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[19] = list[i];
		child_ctx[20] = list;
		child_ctx[21] = i;
		return child_ctx;
	}

	// (22:0) {#each items as item, index (item[idFieldName])}
	function create_each_block$h(key_1, ctx) {
		let first;
		let switch_instance;
		let updating_value;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*listItemComponentProps*/ ctx[6],
			{
				titleComponent: /*titleComponent*/ ctx[7]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[8]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[9]
			},
			{
				descriptionComponentProps: /*descriptionComponentProps*/ ctx[10]
			},
			{
				imageComponent: /*imageComponent*/ ctx[11]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[12]
			},
			/*item*/ ctx[19],
			{ listActions: /*actions*/ ctx[2] },
			{ listLinks: /*links*/ ctx[3] },
			{ commonClasses: /*itemClasses*/ ctx[4] },
			{ index: /*index*/ ctx[21] },
			{ first: /*index*/ ctx[21] === 0 },
			{
				last: /*index*/ ctx[21] === /*items*/ ctx[0].length - 1
			}
		];

		function switch_instance_value_binding(value) {
			/*switch_instance_value_binding*/ ctx[13](value, /*item*/ ctx[19], /*each_value*/ ctx[20], /*index*/ ctx[21]);
		}

		var switch_value = /*listItemComponent*/ ctx[5];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listItemComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, imageComponent, imageComponentProps, items, actions, links, itemClasses*/ 8157) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listItemComponentProps*/ 64 && get_spread_object(/*listItemComponentProps*/ ctx[6]),
					dirty & /*titleComponent*/ 128 && {
						titleComponent: /*titleComponent*/ ctx[7]
					},
					dirty & /*titleComponentProps*/ 256 && {
						titleComponentProps: /*titleComponentProps*/ ctx[8]
					},
					dirty & /*descriptionComponent*/ 512 && {
						descriptionComponent: /*descriptionComponent*/ ctx[9]
					},
					dirty & /*descriptionComponentProps*/ 1024 && {
						descriptionComponentProps: /*descriptionComponentProps*/ ctx[10]
					},
					dirty & /*imageComponent*/ 2048 && {
						imageComponent: /*imageComponent*/ ctx[11]
					},
					dirty & /*imageComponentProps*/ 4096 && {
						imageComponentProps: /*imageComponentProps*/ ctx[12]
					},
					dirty & /*items*/ 1 && get_spread_object(/*item*/ ctx[19]),
					dirty & /*actions*/ 4 && { listActions: /*actions*/ ctx[2] },
					dirty & /*links*/ 8 && { listLinks: /*links*/ ctx[3] },
					dirty & /*itemClasses*/ 16 && { commonClasses: /*itemClasses*/ ctx[4] },
					dirty & /*items*/ 1 && { index: /*index*/ ctx[21] },
					dirty & /*items*/ 1 && { first: /*index*/ ctx[21] === 0 },
					dirty & /*items*/ 1 && {
						last: /*index*/ ctx[21] === /*items*/ ctx[0].length - 1
					}
				]));
			}

			if (/*item*/ ctx[19] !== void 0) {
				switch_instance_props.value = /*item*/ ctx[19];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
			switch_instance.$on("click", /*click_handler*/ ctx[14]);
			switch_instance.$on("clickContent", /*clickContent_handler*/ ctx[15]);
			switch_instance.$on("clickDescription", /*clickDescription_handler*/ ctx[16]);
			switch_instance.$on("clickImage", /*clickImage_handler*/ ctx[17]);
			switch_instance.$on("clickTitle", /*clickTitle_handler*/ ctx[18]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*listItemComponent*/ 32 && switch_value !== (switch_value = /*listItemComponent*/ ctx[5])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
						switch_instance.$on("click", /*click_handler*/ ctx[14]);
						switch_instance.$on("clickContent", /*clickContent_handler*/ ctx[15]);
						switch_instance.$on("clickDescription", /*clickDescription_handler*/ ctx[16]);
						switch_instance.$on("clickImage", /*clickImage_handler*/ ctx[17]);
						switch_instance.$on("clickTitle", /*clickTitle_handler*/ ctx[18]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listItemComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, imageComponent, imageComponentProps, items, actions, links, itemClasses*/ 8157)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listItemComponentProps*/ 64 && get_spread_object(/*listItemComponentProps*/ ctx[6]),
							dirty & /*titleComponent*/ 128 && {
								titleComponent: /*titleComponent*/ ctx[7]
							},
							dirty & /*titleComponentProps*/ 256 && {
								titleComponentProps: /*titleComponentProps*/ ctx[8]
							},
							dirty & /*descriptionComponent*/ 512 && {
								descriptionComponent: /*descriptionComponent*/ ctx[9]
							},
							dirty & /*descriptionComponentProps*/ 1024 && {
								descriptionComponentProps: /*descriptionComponentProps*/ ctx[10]
							},
							dirty & /*imageComponent*/ 2048 && {
								imageComponent: /*imageComponent*/ ctx[11]
							},
							dirty & /*imageComponentProps*/ 4096 && {
								imageComponentProps: /*imageComponentProps*/ ctx[12]
							},
							dirty & /*items*/ 1 && get_spread_object(/*item*/ ctx[19]),
							dirty & /*actions*/ 4 && { listActions: /*actions*/ ctx[2] },
							dirty & /*links*/ 8 && { listLinks: /*links*/ ctx[3] },
							dirty & /*itemClasses*/ 16 && { commonClasses: /*itemClasses*/ ctx[4] },
							dirty & /*items*/ 1 && { index: /*index*/ ctx[21] },
							dirty & /*items*/ 1 && { first: /*index*/ ctx[21] === 0 },
							dirty & /*items*/ 1 && {
								last: /*index*/ ctx[21] === /*items*/ ctx[0].length - 1
							}
						])
					: {};

					if (!updating_value && dirty & /*items*/ 1) {
						updating_value = true;
						switch_instance_changes.value = /*item*/ ctx[19];
						add_flush_callback(() => updating_value = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$12(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*items*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[19][/*idFieldName*/ ctx[1]];

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$h(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$h(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*listItemComponent, listItemComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, imageComponent, imageComponentProps, items, actions, links, itemClasses, idFieldName*/ 8191) {
					each_value = ensure_array_like(/*items*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$h, each_1_anchor, get_each_context$h);
					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	function instance$12($$self, $$props, $$invalidate) {
		let { idFieldName = "id" } = $$props;
		let { items = [] } = $$props;
		let { actions = [] } = $$props;
		let { links = [] } = $$props;
		let { itemClasses = "" } = $$props;
		let { listItemComponent = Ui_list_item } = $$props;
		let { listItemComponentProps = {} } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 6 } } = $$props;
		let { descriptionComponent } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { imageComponent } = $$props;
		let { imageComponentProps = {} } = $$props;

		function switch_instance_value_binding(value, item, each_value, index) {
			each_value[index] = value;
			$$invalidate(0, items);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickContent_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickDescription_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickImage_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickTitle_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('idFieldName' in $$props) $$invalidate(1, idFieldName = $$props.idFieldName);
			if ('items' in $$props) $$invalidate(0, items = $$props.items);
			if ('actions' in $$props) $$invalidate(2, actions = $$props.actions);
			if ('links' in $$props) $$invalidate(3, links = $$props.links);
			if ('itemClasses' in $$props) $$invalidate(4, itemClasses = $$props.itemClasses);
			if ('listItemComponent' in $$props) $$invalidate(5, listItemComponent = $$props.listItemComponent);
			if ('listItemComponentProps' in $$props) $$invalidate(6, listItemComponentProps = $$props.listItemComponentProps);
			if ('titleComponent' in $$props) $$invalidate(7, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(8, titleComponentProps = $$props.titleComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(9, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(10, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('imageComponent' in $$props) $$invalidate(11, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(12, imageComponentProps = $$props.imageComponentProps);
		};

		return [
			items,
			idFieldName,
			actions,
			links,
			itemClasses,
			listItemComponent,
			listItemComponentProps,
			titleComponent,
			titleComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			imageComponent,
			imageComponentProps,
			switch_instance_value_binding,
			click_handler,
			clickContent_handler,
			clickDescription_handler,
			clickImage_handler,
			clickTitle_handler
		];
	}

	class Ui_list_block extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$12, create_fragment$12, safe_not_equal, {
				idFieldName: 1,
				items: 0,
				actions: 2,
				links: 3,
				itemClasses: 4,
				listItemComponent: 5,
				listItemComponentProps: 6,
				titleComponent: 7,
				titleComponentProps: 8,
				descriptionComponent: 9,
				descriptionComponentProps: 10,
				imageComponent: 11,
				imageComponentProps: 12
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.svelte generated by Svelte v4.2.19 */

	function create_else_block$p(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*emptyListPlaceholderComponentProps*/ ctx[12]];
		var switch_value = /*emptyListPlaceholderComponent*/ ctx[11];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*emptyListPlaceholderComponentProps*/ 4096) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*emptyListPlaceholderComponentProps*/ ctx[12])]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*emptyListPlaceholderComponent*/ 2048 && switch_value !== (switch_value = /*emptyListPlaceholderComponent*/ ctx[11])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*emptyListPlaceholderComponentProps*/ 4096)
					? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*emptyListPlaceholderComponentProps*/ ctx[12])])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (37:0) {#if items.length}
	function create_if_block$E(ctx) {
		let div;
		let uilistblock;
		let updating_items;
		let div_style_value;
		let div_class_value;
		let current;

		function uilistblock_items_binding(value) {
			/*uilistblock_items_binding*/ ctx[21](value);
		}

		let uilistblock_props = {
			itemClasses: /*itemClasses*/ ctx[8],
			listItemComponent: /*listItemComponent*/ ctx[13],
			listItemComponentProps: /*listItemComponentProps*/ ctx[14],
			idFieldName: /*idFieldName*/ ctx[10],
			titleComponent: /*titleComponent*/ ctx[15],
			titleComponentProps: /*titleComponentProps*/ ctx[16],
			descriptionComponent: /*descriptionComponent*/ ctx[17],
			descriptionComponentProps: /*descriptionComponentProps*/ ctx[18],
			imageComponent: /*imageComponent*/ ctx[19],
			imageComponentProps: /*imageComponentProps*/ ctx[20],
			actions: /*actions*/ ctx[2],
			links: /*links*/ ctx[3]
		};

		if (/*items*/ ctx[0] !== void 0) {
			uilistblock_props.items = /*items*/ ctx[0];
		}

		uilistblock = new Ui_list_block({ props: uilistblock_props });
		binding_callbacks.push(() => bind(uilistblock, 'items', uilistblock_items_binding));
		uilistblock.$on("change", /*change_handler*/ ctx[22]);
		uilistblock.$on("click", /*click_handler*/ ctx[23]);
		uilistblock.$on("clickContent", /*clickContent_handler*/ ctx[24]);
		uilistblock.$on("clickDescription", /*clickDescription_handler*/ ctx[25]);
		uilistblock.$on("clickImage", /*clickImage_handler*/ ctx[26]);
		uilistblock.$on("clickTitle", /*clickTitle_handler*/ ctx[27]);

		return {
			c() {
				div = element("div");
				create_component(uilistblock.$$.fragment);

				attr(div, "style", div_style_value = /*itemLength*/ ctx[9]
				? `--length: ${/*itemLength*/ ctx[9]};`
				: "");

				attr(div, "class", div_class_value = "list " + /*classes*/ ctx[1] + " " + (/*actionsVisible*/ ctx[4]
				? 'has-visible-pointer-controls'
				: '') + " " + (/*itemsHoverable*/ ctx[5]
				? 'has-hoverable-list-items'
				: '') + " " + (/*overflowEllipsis*/ ctx[6]
				? 'has-overflow-ellipsis'
				: '') + " " + (/*hiddenImages*/ ctx[7] ? 'has-hidden-images' : ''));
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uilistblock, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const uilistblock_changes = {};
				if (dirty & /*itemClasses*/ 256) uilistblock_changes.itemClasses = /*itemClasses*/ ctx[8];
				if (dirty & /*listItemComponent*/ 8192) uilistblock_changes.listItemComponent = /*listItemComponent*/ ctx[13];
				if (dirty & /*listItemComponentProps*/ 16384) uilistblock_changes.listItemComponentProps = /*listItemComponentProps*/ ctx[14];
				if (dirty & /*idFieldName*/ 1024) uilistblock_changes.idFieldName = /*idFieldName*/ ctx[10];
				if (dirty & /*titleComponent*/ 32768) uilistblock_changes.titleComponent = /*titleComponent*/ ctx[15];
				if (dirty & /*titleComponentProps*/ 65536) uilistblock_changes.titleComponentProps = /*titleComponentProps*/ ctx[16];
				if (dirty & /*descriptionComponent*/ 131072) uilistblock_changes.descriptionComponent = /*descriptionComponent*/ ctx[17];
				if (dirty & /*descriptionComponentProps*/ 262144) uilistblock_changes.descriptionComponentProps = /*descriptionComponentProps*/ ctx[18];
				if (dirty & /*imageComponent*/ 524288) uilistblock_changes.imageComponent = /*imageComponent*/ ctx[19];
				if (dirty & /*imageComponentProps*/ 1048576) uilistblock_changes.imageComponentProps = /*imageComponentProps*/ ctx[20];
				if (dirty & /*actions*/ 4) uilistblock_changes.actions = /*actions*/ ctx[2];
				if (dirty & /*links*/ 8) uilistblock_changes.links = /*links*/ ctx[3];

				if (!updating_items && dirty & /*items*/ 1) {
					updating_items = true;
					uilistblock_changes.items = /*items*/ ctx[0];
					add_flush_callback(() => updating_items = false);
				}

				uilistblock.$set(uilistblock_changes);

				if (!current || dirty & /*itemLength*/ 512 && div_style_value !== (div_style_value = /*itemLength*/ ctx[9]
				? `--length: ${/*itemLength*/ ctx[9]};`
				: "")) {
					attr(div, "style", div_style_value);
				}

				if (!current || dirty & /*classes, actionsVisible, itemsHoverable, overflowEllipsis, hiddenImages*/ 242 && div_class_value !== (div_class_value = "list " + /*classes*/ ctx[1] + " " + (/*actionsVisible*/ ctx[4]
				? 'has-visible-pointer-controls'
				: '') + " " + (/*itemsHoverable*/ ctx[5]
				? 'has-hoverable-list-items'
				: '') + " " + (/*overflowEllipsis*/ ctx[6]
				? 'has-overflow-ellipsis'
				: '') + " " + (/*hiddenImages*/ ctx[7] ? 'has-hidden-images' : ''))) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uilistblock.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilistblock.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uilistblock);
			}
		};
	}

	function create_fragment$11(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$E, create_else_block$p];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*items*/ ctx[0].length) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$11($$self, $$props, $$invalidate) {
		let { classes = "" } = $$props;
		let { items = [] } = $$props;
		let { actions = [] } = $$props;
		let { links = [] } = $$props;
		let { actionsVisible = false } = $$props;
		let { itemsHoverable = false } = $$props;
		let { overflowEllipsis = false } = $$props;
		let { hiddenImages = false } = $$props;
		let { itemClasses = "" } = $$props;
		let { itemLength } = $$props;
		let { idFieldName = "id" } = $$props;
		let { emptyListPlaceholderComponent = Ui_list_empty_placeholder } = $$props;
		let { emptyListPlaceholderComponentProps = {} } = $$props;
		let { listItemComponent = Ui_list_item } = $$props;
		let { listItemComponentProps = {} } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 6 } } = $$props;
		let { descriptionComponent } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { imageComponent } = $$props;
		let { imageComponentProps = {} } = $$props;

		function uilistblock_items_binding(value) {
			items = value;
			$$invalidate(0, items);
		}

		function change_handler(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickContent_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickDescription_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickImage_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickTitle_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('items' in $$props) $$invalidate(0, items = $$props.items);
			if ('actions' in $$props) $$invalidate(2, actions = $$props.actions);
			if ('links' in $$props) $$invalidate(3, links = $$props.links);
			if ('actionsVisible' in $$props) $$invalidate(4, actionsVisible = $$props.actionsVisible);
			if ('itemsHoverable' in $$props) $$invalidate(5, itemsHoverable = $$props.itemsHoverable);
			if ('overflowEllipsis' in $$props) $$invalidate(6, overflowEllipsis = $$props.overflowEllipsis);
			if ('hiddenImages' in $$props) $$invalidate(7, hiddenImages = $$props.hiddenImages);
			if ('itemClasses' in $$props) $$invalidate(8, itemClasses = $$props.itemClasses);
			if ('itemLength' in $$props) $$invalidate(9, itemLength = $$props.itemLength);
			if ('idFieldName' in $$props) $$invalidate(10, idFieldName = $$props.idFieldName);
			if ('emptyListPlaceholderComponent' in $$props) $$invalidate(11, emptyListPlaceholderComponent = $$props.emptyListPlaceholderComponent);
			if ('emptyListPlaceholderComponentProps' in $$props) $$invalidate(12, emptyListPlaceholderComponentProps = $$props.emptyListPlaceholderComponentProps);
			if ('listItemComponent' in $$props) $$invalidate(13, listItemComponent = $$props.listItemComponent);
			if ('listItemComponentProps' in $$props) $$invalidate(14, listItemComponentProps = $$props.listItemComponentProps);
			if ('titleComponent' in $$props) $$invalidate(15, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(16, titleComponentProps = $$props.titleComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(17, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(18, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('imageComponent' in $$props) $$invalidate(19, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(20, imageComponentProps = $$props.imageComponentProps);
		};

		return [
			items,
			classes,
			actions,
			links,
			actionsVisible,
			itemsHoverable,
			overflowEllipsis,
			hiddenImages,
			itemClasses,
			itemLength,
			idFieldName,
			emptyListPlaceholderComponent,
			emptyListPlaceholderComponentProps,
			listItemComponent,
			listItemComponentProps,
			titleComponent,
			titleComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			imageComponent,
			imageComponentProps,
			uilistblock_items_binding,
			change_handler,
			click_handler,
			clickContent_handler,
			clickDescription_handler,
			clickImage_handler,
			clickTitle_handler
		];
	}

	class Ui_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$11, create_fragment$11, safe_not_equal, {
				classes: 1,
				items: 0,
				actions: 2,
				links: 3,
				actionsVisible: 4,
				itemsHoverable: 5,
				overflowEllipsis: 6,
				hiddenImages: 7,
				itemClasses: 8,
				itemLength: 9,
				idFieldName: 10,
				emptyListPlaceholderComponent: 11,
				emptyListPlaceholderComponentProps: 12,
				listItemComponent: 13,
				listItemComponentProps: 14,
				titleComponent: 15,
				titleComponentProps: 16,
				descriptionComponent: 17,
				descriptionComponentProps: 18,
				imageComponent: 19,
				imageComponentProps: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.list.of.models.svelte generated by Svelte v4.2.19 */

	function create_if_block$D(ctx) {
		let switch_instance;
		let updating_placeholder;
		let updating_fieldname;
		let updating_required;
		let updating_multiple;
		let updating_size;
		let updating_valid;
		let updating_validated;
		let updating_errors;
		let updating_formErrors;
		let updating_formLevelError;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*selectorUIProps*/ ctx[20],
			{ modelName: /*modelName*/ ctx[11] },
			{ actionName: /*actionName*/ ctx[12] },
			{ actionFilter: /*actionFilter*/ ctx[13] },
			{ actionSorter: /*actionSorter*/ ctx[14] },
			{ actionPager: /*actionPager*/ ctx[15] },
			{ actionSearch: /*actionSearch*/ ctx[16] },
			{ optionId: /*optionId*/ ctx[17] },
			{ optionTitle: /*optionTitle*/ ctx[18] }
		];

		function switch_instance_placeholder_binding(value) {
			/*switch_instance_placeholder_binding*/ ctx[29](value);
		}

		function switch_instance_fieldname_binding(value) {
			/*switch_instance_fieldname_binding*/ ctx[30](value);
		}

		function switch_instance_required_binding(value) {
			/*switch_instance_required_binding*/ ctx[31](value);
		}

		function switch_instance_multiple_binding(value) {
			/*switch_instance_multiple_binding*/ ctx[32](value);
		}

		function switch_instance_size_binding(value) {
			/*switch_instance_size_binding*/ ctx[33](value);
		}

		function switch_instance_valid_binding(value) {
			/*switch_instance_valid_binding*/ ctx[34](value);
		}

		function switch_instance_validated_binding(value) {
			/*switch_instance_validated_binding*/ ctx[35](value);
		}

		function switch_instance_errors_binding(value) {
			/*switch_instance_errors_binding*/ ctx[36](value);
		}

		function switch_instance_formErrors_binding(value) {
			/*switch_instance_formErrors_binding*/ ctx[37](value);
		}

		function switch_instance_formLevelError_binding(value) {
			/*switch_instance_formLevelError_binding*/ ctx[38](value);
		}

		var switch_value = COMPONENTS$2.get(/*selectorUI*/ ctx[19]);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*selectorUIProps, modelName, actionName, actionFilter, actionSorter, actionPager, actionSearch, optionId, optionTitle*/ 1570816) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*selectorUIProps*/ 1048576 && get_spread_object(/*selectorUIProps*/ ctx[20]),
					dirty[0] & /*modelName*/ 2048 && { modelName: /*modelName*/ ctx[11] },
					dirty[0] & /*actionName*/ 4096 && { actionName: /*actionName*/ ctx[12] },
					dirty[0] & /*actionFilter*/ 8192 && { actionFilter: /*actionFilter*/ ctx[13] },
					dirty[0] & /*actionSorter*/ 16384 && { actionSorter: /*actionSorter*/ ctx[14] },
					dirty[0] & /*actionPager*/ 32768 && { actionPager: /*actionPager*/ ctx[15] },
					dirty[0] & /*actionSearch*/ 65536 && { actionSearch: /*actionSearch*/ ctx[16] },
					dirty[0] & /*optionId*/ 131072 && { optionId: /*optionId*/ ctx[17] },
					dirty[0] & /*optionTitle*/ 262144 && { optionTitle: /*optionTitle*/ ctx[18] }
				]));
			}

			if (/*placeholder*/ ctx[0] !== void 0) {
				switch_instance_props.placeholder = /*placeholder*/ ctx[0];
			}

			if (/*fieldname*/ ctx[1] !== void 0) {
				switch_instance_props.fieldname = /*fieldname*/ ctx[1];
			}

			if (/*required*/ ctx[2] !== void 0) {
				switch_instance_props.required = /*required*/ ctx[2];
			}

			if (/*multiple*/ ctx[3] !== void 0) {
				switch_instance_props.multiple = /*multiple*/ ctx[3];
			}

			if (/*size*/ ctx[4] !== void 0) {
				switch_instance_props.size = /*size*/ ctx[4];
			}

			if (/*valid*/ ctx[5] !== void 0) {
				switch_instance_props.valid = /*valid*/ ctx[5];
			}

			if (/*validated*/ ctx[6] !== void 0) {
				switch_instance_props.validated = /*validated*/ ctx[6];
			}

			if (/*errors*/ ctx[7] !== void 0) {
				switch_instance_props.errors = /*errors*/ ctx[7];
			}

			if (/*formErrors*/ ctx[8] !== void 0) {
				switch_instance_props.formErrors = /*formErrors*/ ctx[8];
			}

			if (/*formLevelError*/ ctx[9] !== void 0) {
				switch_instance_props.formLevelError = /*formLevelError*/ ctx[9];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'placeholder', switch_instance_placeholder_binding));
			binding_callbacks.push(() => bind(switch_instance, 'fieldname', switch_instance_fieldname_binding));
			binding_callbacks.push(() => bind(switch_instance, 'required', switch_instance_required_binding));
			binding_callbacks.push(() => bind(switch_instance, 'multiple', switch_instance_multiple_binding));
			binding_callbacks.push(() => bind(switch_instance, 'size', switch_instance_size_binding));
			binding_callbacks.push(() => bind(switch_instance, 'valid', switch_instance_valid_binding));
			binding_callbacks.push(() => bind(switch_instance, 'validated', switch_instance_validated_binding));
			binding_callbacks.push(() => bind(switch_instance, 'errors', switch_instance_errors_binding));
			binding_callbacks.push(() => bind(switch_instance, 'formErrors', switch_instance_formErrors_binding));
			binding_callbacks.push(() => bind(switch_instance, 'formLevelError', switch_instance_formLevelError_binding));
			switch_instance.$on("resolve", /*resolve_handler*/ ctx[39]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectorUI*/ 524288 && switch_value !== (switch_value = COMPONENTS$2.get(/*selectorUI*/ ctx[19]))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'placeholder', switch_instance_placeholder_binding));
						binding_callbacks.push(() => bind(switch_instance, 'fieldname', switch_instance_fieldname_binding));
						binding_callbacks.push(() => bind(switch_instance, 'required', switch_instance_required_binding));
						binding_callbacks.push(() => bind(switch_instance, 'multiple', switch_instance_multiple_binding));
						binding_callbacks.push(() => bind(switch_instance, 'size', switch_instance_size_binding));
						binding_callbacks.push(() => bind(switch_instance, 'valid', switch_instance_valid_binding));
						binding_callbacks.push(() => bind(switch_instance, 'validated', switch_instance_validated_binding));
						binding_callbacks.push(() => bind(switch_instance, 'errors', switch_instance_errors_binding));
						binding_callbacks.push(() => bind(switch_instance, 'formErrors', switch_instance_formErrors_binding));
						binding_callbacks.push(() => bind(switch_instance, 'formLevelError', switch_instance_formLevelError_binding));
						switch_instance.$on("resolve", /*resolve_handler*/ ctx[39]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*selectorUIProps, modelName, actionName, actionFilter, actionSorter, actionPager, actionSearch, optionId, optionTitle*/ 1570816)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*selectorUIProps*/ 1048576 && get_spread_object(/*selectorUIProps*/ ctx[20]),
							dirty[0] & /*modelName*/ 2048 && { modelName: /*modelName*/ ctx[11] },
							dirty[0] & /*actionName*/ 4096 && { actionName: /*actionName*/ ctx[12] },
							dirty[0] & /*actionFilter*/ 8192 && { actionFilter: /*actionFilter*/ ctx[13] },
							dirty[0] & /*actionSorter*/ 16384 && { actionSorter: /*actionSorter*/ ctx[14] },
							dirty[0] & /*actionPager*/ 32768 && { actionPager: /*actionPager*/ ctx[15] },
							dirty[0] & /*actionSearch*/ 65536 && { actionSearch: /*actionSearch*/ ctx[16] },
							dirty[0] & /*optionId*/ 131072 && { optionId: /*optionId*/ ctx[17] },
							dirty[0] & /*optionTitle*/ 262144 && { optionTitle: /*optionTitle*/ ctx[18] }
						])
					: {};

					if (!updating_placeholder && dirty[0] & /*placeholder*/ 1) {
						updating_placeholder = true;
						switch_instance_changes.placeholder = /*placeholder*/ ctx[0];
						add_flush_callback(() => updating_placeholder = false);
					}

					if (!updating_fieldname && dirty[0] & /*fieldname*/ 2) {
						updating_fieldname = true;
						switch_instance_changes.fieldname = /*fieldname*/ ctx[1];
						add_flush_callback(() => updating_fieldname = false);
					}

					if (!updating_required && dirty[0] & /*required*/ 4) {
						updating_required = true;
						switch_instance_changes.required = /*required*/ ctx[2];
						add_flush_callback(() => updating_required = false);
					}

					if (!updating_multiple && dirty[0] & /*multiple*/ 8) {
						updating_multiple = true;
						switch_instance_changes.multiple = /*multiple*/ ctx[3];
						add_flush_callback(() => updating_multiple = false);
					}

					if (!updating_size && dirty[0] & /*size*/ 16) {
						updating_size = true;
						switch_instance_changes.size = /*size*/ ctx[4];
						add_flush_callback(() => updating_size = false);
					}

					if (!updating_valid && dirty[0] & /*valid*/ 32) {
						updating_valid = true;
						switch_instance_changes.valid = /*valid*/ ctx[5];
						add_flush_callback(() => updating_valid = false);
					}

					if (!updating_validated && dirty[0] & /*validated*/ 64) {
						updating_validated = true;
						switch_instance_changes.validated = /*validated*/ ctx[6];
						add_flush_callback(() => updating_validated = false);
					}

					if (!updating_errors && dirty[0] & /*errors*/ 128) {
						updating_errors = true;
						switch_instance_changes.errors = /*errors*/ ctx[7];
						add_flush_callback(() => updating_errors = false);
					}

					if (!updating_formErrors && dirty[0] & /*formErrors*/ 256) {
						updating_formErrors = true;
						switch_instance_changes.formErrors = /*formErrors*/ ctx[8];
						add_flush_callback(() => updating_formErrors = false);
					}

					if (!updating_formLevelError && dirty[0] & /*formLevelError*/ 512) {
						updating_formLevelError = true;
						switch_instance_changes.formLevelError = /*formLevelError*/ ctx[9];
						add_flush_callback(() => updating_formLevelError = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$10(ctx) {
		let uilist;
		let t;
		let if_block_anchor;
		let current;

		const uilist_spread_levels = [
			{
				listItemComponent: COMPONENTS$2.get(/*itemUI*/ ctx[21])
			},
			/*itemUIProps*/ ctx[22],
			{ items: /*items*/ ctx[23] },
			{ actions: /*ACTIONS*/ ctx[25] }
		];

		let uilist_props = {};

		for (let i = 0; i < uilist_spread_levels.length; i += 1) {
			uilist_props = assign(uilist_props, uilist_spread_levels[i]);
		}

		uilist = new Ui_list({ props: uilist_props });
		let if_block = !/*readonly*/ ctx[10] && create_if_block$D(ctx);

		return {
			c() {
				create_component(uilist.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				mount_component(uilist, target, anchor);
				insert(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uilist_changes = (dirty[0] & /*itemUI, itemUIProps, items, ACTIONS*/ 48234496)
				? get_spread_update(uilist_spread_levels, [
						dirty[0] & /*itemUI*/ 2097152 && {
							listItemComponent: COMPONENTS$2.get(/*itemUI*/ ctx[21])
						},
						dirty[0] & /*itemUIProps*/ 4194304 && get_spread_object(/*itemUIProps*/ ctx[22]),
						dirty[0] & /*items*/ 8388608 && { items: /*items*/ ctx[23] },
						dirty[0] & /*ACTIONS*/ 33554432 && { actions: /*ACTIONS*/ ctx[25] }
					])
				: {};

				uilist.$set(uilist_changes);

				if (!/*readonly*/ ctx[10]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*readonly*/ 1024) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$D(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(uilist.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(uilist.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block_anchor);
				}

				destroy_component(uilist, detaching);
				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$10($$self, $$props, $$invalidate) {
		let items;
		createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = [] } = $$props;
		let { placeholder = "" } = $$props;
		let { fieldname = "selectFromModel" } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { multiple = false } = $$props;
		let { size = 8 } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let { modelName = "" } = $$props;
		let { actionName = "" } = $$props;
		let { actionFilter = {} } = $$props;
		let { actionSorter = {} } = $$props;
		let { actionPager = {} } = $$props;
		let { actionSearch = undefined } = $$props;
		let { optionId = ":_id" } = $$props;
		let { optionTitle = ":title" } = $$props;
		let { selectorUI = "UISelectFromModelOnDemandInline" } = $$props;
		let { selectorUIProps = {} } = $$props;
		let { itemUI = "UIListItem" } = $$props;
		let { itemUIProps = {} } = $$props;

		let { transformValueItemToListItem = item => {
			return item
			? {
					id: item._id,
					title: item.title,
					description: item.description,
					value: item
				}
			: undefined;
		} } = $$props;

		function addItem(item) {
			if (!Array.isArray(value)) {
				$$invalidate(26, value = []);
			}

			value.push(item);
			$$invalidate(26, value);
		}

		const ACTIONS = [
			{
				action(listItem) {
					const val = listItem.value;
					const itemIndex = value.findIndex(valueItem => valueItem === val);

					if (itemIndex > -1) {
						const valCopy = [...value];
						notCommon$2.moveItem(valCopy, itemIndex, itemIndex - 1);
						$$invalidate(26, value = valCopy);
					}
				},
				title: "",
				icon: "arrow-up",
				color: "normal"
			},
			{
				action: listItem => {
					const val = listItem.value;
					const itemIndex = value.findIndex(valueItem => valueItem === val);

					if (itemIndex > -1) {
						const valCopy = [...value];
						notCommon$2.moveItem(valCopy, itemIndex, itemIndex + 1);
						$$invalidate(26, value = valCopy);
					}
				},
				title: "",
				icon: "arrow-down",
				color: "normal"
			},
			{
				action: listItem => {
					const val = listItem.value;
					const itemIndex = value.findIndex(valueItem => valueItem === val);

					if (itemIndex > -1) {
						value.splice(itemIndex, 1);
						$$invalidate(26, value);
					}
				},
				title: "",
				icon: "trash",
				color: "danger"
			}
		];

		function switch_instance_placeholder_binding(value) {
			placeholder = value;
			$$invalidate(0, placeholder);
		}

		function switch_instance_fieldname_binding(value) {
			fieldname = value;
			$$invalidate(1, fieldname);
		}

		function switch_instance_required_binding(value) {
			required = value;
			$$invalidate(2, required);
		}

		function switch_instance_multiple_binding(value) {
			multiple = value;
			$$invalidate(3, multiple);
		}

		function switch_instance_size_binding(value) {
			size = value;
			$$invalidate(4, size);
		}

		function switch_instance_valid_binding(value) {
			valid = value;
			$$invalidate(5, valid);
		}

		function switch_instance_validated_binding(value) {
			validated = value;
			$$invalidate(6, validated);
		}

		function switch_instance_errors_binding(value) {
			errors = value;
			$$invalidate(7, errors);
		}

		function switch_instance_formErrors_binding(value) {
			formErrors = value;
			$$invalidate(8, formErrors);
		}

		function switch_instance_formLevelError_binding(value) {
			formLevelError = value;
			$$invalidate(9, formLevelError);
		}

		const resolve_handler = e => addItem(e.detail);

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(27, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(26, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(0, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('required' in $$props) $$invalidate(2, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(10, readonly = $$props.readonly);
			if ('multiple' in $$props) $$invalidate(3, multiple = $$props.multiple);
			if ('size' in $$props) $$invalidate(4, size = $$props.size);
			if ('valid' in $$props) $$invalidate(5, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(6, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(7, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(8, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(9, formLevelError = $$props.formLevelError);
			if ('modelName' in $$props) $$invalidate(11, modelName = $$props.modelName);
			if ('actionName' in $$props) $$invalidate(12, actionName = $$props.actionName);
			if ('actionFilter' in $$props) $$invalidate(13, actionFilter = $$props.actionFilter);
			if ('actionSorter' in $$props) $$invalidate(14, actionSorter = $$props.actionSorter);
			if ('actionPager' in $$props) $$invalidate(15, actionPager = $$props.actionPager);
			if ('actionSearch' in $$props) $$invalidate(16, actionSearch = $$props.actionSearch);
			if ('optionId' in $$props) $$invalidate(17, optionId = $$props.optionId);
			if ('optionTitle' in $$props) $$invalidate(18, optionTitle = $$props.optionTitle);
			if ('selectorUI' in $$props) $$invalidate(19, selectorUI = $$props.selectorUI);
			if ('selectorUIProps' in $$props) $$invalidate(20, selectorUIProps = $$props.selectorUIProps);
			if ('itemUI' in $$props) $$invalidate(21, itemUI = $$props.itemUI);
			if ('itemUIProps' in $$props) $$invalidate(22, itemUIProps = $$props.itemUIProps);
			if ('transformValueItemToListItem' in $$props) $$invalidate(28, transformValueItemToListItem = $$props.transformValueItemToListItem);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*value, transformValueItemToListItem*/ 335544320) {
				$$invalidate(23, items = value.map ? value.map(transformValueItemToListItem) : []);
			}
		};

		return [
			placeholder,
			fieldname,
			required,
			multiple,
			size,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			readonly,
			modelName,
			actionName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch,
			optionId,
			optionTitle,
			selectorUI,
			selectorUIProps,
			itemUI,
			itemUIProps,
			items,
			addItem,
			ACTIONS,
			value,
			inputStarted,
			transformValueItemToListItem,
			switch_instance_placeholder_binding,
			switch_instance_fieldname_binding,
			switch_instance_required_binding,
			switch_instance_multiple_binding,
			switch_instance_size_binding,
			switch_instance_valid_binding,
			switch_instance_validated_binding,
			switch_instance_errors_binding,
			switch_instance_formErrors_binding,
			switch_instance_formLevelError_binding,
			resolve_handler
		];
	}

	class Ui_list_of_models extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$10,
				create_fragment$10,
				safe_not_equal,
				{
					inputStarted: 27,
					value: 26,
					placeholder: 0,
					fieldname: 1,
					required: 2,
					readonly: 10,
					multiple: 3,
					size: 4,
					valid: 5,
					validated: 6,
					errors: 7,
					formErrors: 8,
					formLevelError: 9,
					modelName: 11,
					actionName: 12,
					actionFilter: 13,
					actionSorter: 14,
					actionPager: 15,
					actionSearch: 16,
					optionId: 17,
					optionTitle: 18,
					selectorUI: 19,
					selectorUIProps: 20,
					itemUI: 21,
					itemUIProps: 22,
					transformValueItemToListItem: 28
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.column.svelte generated by Svelte v4.2.19 */

	function create_fragment$$(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "title", /*title*/ ctx[1]);
				attr(div, "class", div_class_value = "column " + /*classes*/ ctx[0] + " " + (/*narrow*/ ctx[2] ? 'is-narrow' : ''));
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[5]),
						listen(div, "keyup", /*keyup_handler*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*title*/ 2) {
					attr(div, "title", /*title*/ ctx[1]);
				}

				if (!current || dirty & /*classes, narrow*/ 5 && div_class_value !== (div_class_value = "column " + /*classes*/ ctx[0] + " " + (/*narrow*/ ctx[2] ? 'is-narrow' : ''))) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$$($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { classes = "" } = $$props;
		let { title = "" } = $$props;
		let { narrow = false } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('narrow' in $$props) $$invalidate(2, narrow = $$props.narrow);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		return [classes, title, narrow, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_column extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$$, create_fragment$$, safe_not_equal, { classes: 0, title: 1, narrow: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.columns.svelte generated by Svelte v4.2.19 */

	function create_fragment$_(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[2].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "class", div_class_value = "columns " + /*classes*/ ctx[0]);
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[3]),
						listen(div, "keyup", /*keyup_handler*/ ctx[4])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[1],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*classes*/ 1 && div_class_value !== (div_class_value = "columns " + /*classes*/ ctx[0])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$_($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
		};

		return [classes, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_columns extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$_, create_fragment$_, safe_not_equal, { classes: 0 });
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.container.svelte generated by Svelte v4.2.19 */

	function create_fragment$Z(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[8].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "id", /*id*/ ctx[0]);
				attr(div, "class", div_class_value = "container " + /*classes*/ ctx[1]);
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				toggle_class(div, "is-widescreen", /*widescreen*/ ctx[2]);
				toggle_class(div, "is-fullhd", /*fullhd*/ ctx[3]);
				toggle_class(div, "is-max-desktop", /*maxDesktop*/ ctx[4]);
				toggle_class(div, "is-max-widescreen", /*maxWidescreen*/ ctx[5]);
				toggle_class(div, "is-fluid", /*fluid*/ ctx[6]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[9]),
						listen(div, "keyup", /*keyup_handler*/ ctx[10])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && div_class_value !== (div_class_value = "container " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}

				if (!current || dirty & /*classes, widescreen*/ 6) {
					toggle_class(div, "is-widescreen", /*widescreen*/ ctx[2]);
				}

				if (!current || dirty & /*classes, fullhd*/ 10) {
					toggle_class(div, "is-fullhd", /*fullhd*/ ctx[3]);
				}

				if (!current || dirty & /*classes, maxDesktop*/ 18) {
					toggle_class(div, "is-max-desktop", /*maxDesktop*/ ctx[4]);
				}

				if (!current || dirty & /*classes, maxWidescreen*/ 34) {
					toggle_class(div, "is-max-widescreen", /*maxWidescreen*/ ctx[5]);
				}

				if (!current || dirty & /*classes, fluid*/ 66) {
					toggle_class(div, "is-fluid", /*fluid*/ ctx[6]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$Z($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { id = "" } = $$props;
		let { classes = "" } = $$props;
		let { widescreen = false } = $$props;
		let { fullhd = false } = $$props;
		let { maxDesktop = false } = $$props;
		let { maxWidescreen = false } = $$props;
		let { fluid = false } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('widescreen' in $$props) $$invalidate(2, widescreen = $$props.widescreen);
			if ('fullhd' in $$props) $$invalidate(3, fullhd = $$props.fullhd);
			if ('maxDesktop' in $$props) $$invalidate(4, maxDesktop = $$props.maxDesktop);
			if ('maxWidescreen' in $$props) $$invalidate(5, maxWidescreen = $$props.maxWidescreen);
			if ('fluid' in $$props) $$invalidate(6, fluid = $$props.fluid);
			if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
		};

		return [
			id,
			classes,
			widescreen,
			fullhd,
			maxDesktop,
			maxWidescreen,
			fluid,
			$$scope,
			slots,
			click_handler,
			keyup_handler
		];
	}

	class Ui_container extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
				id: 0,
				classes: 1,
				widescreen: 2,
				fullhd: 3,
				maxDesktop: 4,
				maxWidescreen: 5,
				fluid: 6
			});
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.footer.svelte generated by Svelte v4.2.19 */

	function create_fragment$Y(ctx) {
		let footer;
		let footer_class_value;
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		return {
			c() {
				footer = element("footer");
				if (default_slot) default_slot.c();
				attr(footer, "id", /*id*/ ctx[0]);
				attr(footer, "class", footer_class_value = "footer " + /*classes*/ ctx[1] + "");
			},
			m(target, anchor) {
				insert(target, footer, anchor);

				if (default_slot) {
					default_slot.m(footer, null);
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(footer, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && footer_class_value !== (footer_class_value = "footer " + /*classes*/ ctx[1] + "")) {
					attr(footer, "class", footer_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(footer);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$Y($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { id = '' } = $$props;
		let { classes = '' } = $$props;

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
		};

		return [id, classes, $$scope, slots];
	}

	class Ui_footer extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$Y, create_fragment$Y, safe_not_equal, { id: 0, classes: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.section.svelte generated by Svelte v4.2.19 */

	function create_fragment$X(ctx) {
		let section;
		let section_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[5].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

		return {
			c() {
				section = element("section");
				if (default_slot) default_slot.c();
				attr(section, "id", /*id*/ ctx[0]);
				attr(section, "class", section_class_value = "section " + (/*size*/ ctx[1] ? 'is-' + /*size*/ ctx[1] : '') + " " + /*classes*/ ctx[2]);
				attr(section, "role", "button");
				attr(section, "tabindex", /*tabindex*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, section, anchor);

				if (default_slot) {
					default_slot.m(section, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(section, "click", /*click_handler*/ ctx[6]),
						listen(section, "keyup", /*keyup_handler*/ ctx[7])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[4],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(section, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*size, classes*/ 6 && section_class_value !== (section_class_value = "section " + (/*size*/ ctx[1] ? 'is-' + /*size*/ ctx[1] : '') + " " + /*classes*/ ctx[2])) {
					attr(section, "class", section_class_value);
				}

				if (!current || dirty & /*tabindex*/ 8) {
					attr(section, "tabindex", /*tabindex*/ ctx[3]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(section);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$X($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { id = "" } = $$props;
		let { size } = $$props;
		let { classes = "" } = $$props;
		let { tabindex = 0 } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
			if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
			if ('tabindex' in $$props) $$invalidate(3, tabindex = $$props.tabindex);
			if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
		};

		return [id, size, classes, tabindex, $$scope, slots, click_handler, keyup_handler];
	}

	let Ui_section$2 = class Ui_section extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$X, create_fragment$X, safe_not_equal, { id: 0, size: 1, classes: 2, tabindex: 3 });
		}
	};

	/* node_modules/not-bulma/src/elements/layout/ui.level.item.svelte generated by Svelte v4.2.19 */

	function create_dynamic_element(ctx) {
		let svelte_element;
		let current;
		const default_slot_template = /*#slots*/ ctx[2].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

		return {
			c() {
				svelte_element = element(/*tag*/ ctx[0]);
				if (default_slot) default_slot.c();
			},
			m(target, anchor) {
				insert(target, svelte_element, anchor);

				if (default_slot) {
					default_slot.m(svelte_element, null);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[1],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
							null
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(svelte_element);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function create_fragment$W(ctx) {
		let previous_tag = /*tag*/ ctx[0];
		let svelte_element_anchor;
		let current;
		let svelte_element = /*tag*/ ctx[0] && create_dynamic_element(ctx);

		return {
			c() {
				if (svelte_element) svelte_element.c();
				svelte_element_anchor = empty();
			},
			m(target, anchor) {
				if (svelte_element) svelte_element.m(target, anchor);
				insert(target, svelte_element_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*tag*/ ctx[0]) {
					if (!previous_tag) {
						svelte_element = create_dynamic_element(ctx);
						previous_tag = /*tag*/ ctx[0];
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else if (safe_not_equal(previous_tag, /*tag*/ ctx[0])) {
						svelte_element.d(1);
						svelte_element = create_dynamic_element(ctx);
						previous_tag = /*tag*/ ctx[0];
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else {
						svelte_element.p(ctx, dirty);
					}
				} else if (previous_tag) {
					svelte_element.d(1);
					svelte_element = null;
					previous_tag = /*tag*/ ctx[0];
				}
			},
			i(local) {
				if (current) return;
				transition_in(svelte_element, local);
				current = true;
			},
			o(local) {
				transition_out(svelte_element, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(svelte_element_anchor);
				}

				if (svelte_element) svelte_element.d(detaching);
			}
		};
	}

	function instance$W($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { tag = "div" } = $$props;

		$$self.$$set = $$props => {
			if ('tag' in $$props) $$invalidate(0, tag = $$props.tag);
			if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
		};

		return [tag, $$scope, slots];
	}

	class Ui_level_item extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$W, create_fragment$W, safe_not_equal, { tag: 0 });
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.level.svelte generated by Svelte v4.2.19 */
	const get_right_slot_changes = dirty => ({});
	const get_right_slot_context = ctx => ({});
	const get_left_slot_changes = dirty => ({});
	const get_left_slot_context = ctx => ({});

	function create_fragment$V(ctx) {
		let nav;
		let div0;
		let t;
		let div1;
		let current;
		const left_slot_template = /*#slots*/ ctx[1].left;
		const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[0], get_left_slot_context);
		const right_slot_template = /*#slots*/ ctx[1].right;
		const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[0], get_right_slot_context);

		return {
			c() {
				nav = element("nav");
				div0 = element("div");
				if (left_slot) left_slot.c();
				t = space();
				div1 = element("div");
				if (right_slot) right_slot.c();
				attr(div0, "class", "level-left");
				attr(div1, "class", "level-right");
				attr(nav, "class", "level");
			},
			m(target, anchor) {
				insert(target, nav, anchor);
				append(nav, div0);

				if (left_slot) {
					left_slot.m(div0, null);
				}

				append(nav, t);
				append(nav, div1);

				if (right_slot) {
					right_slot.m(div1, null);
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (left_slot) {
					if (left_slot.p && (!current || dirty & /*$$scope*/ 1)) {
						update_slot_base(
							left_slot,
							left_slot_template,
							ctx,
							/*$$scope*/ ctx[0],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
							: get_slot_changes(left_slot_template, /*$$scope*/ ctx[0], dirty, get_left_slot_changes),
							get_left_slot_context
						);
					}
				}

				if (right_slot) {
					if (right_slot.p && (!current || dirty & /*$$scope*/ 1)) {
						update_slot_base(
							right_slot,
							right_slot_template,
							ctx,
							/*$$scope*/ ctx[0],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
							: get_slot_changes(right_slot_template, /*$$scope*/ ctx[0], dirty, get_right_slot_changes),
							get_right_slot_context
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(left_slot, local);
				transition_in(right_slot, local);
				current = true;
			},
			o(local) {
				transition_out(left_slot, local);
				transition_out(right_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(nav);
				}

				if (left_slot) left_slot.d(detaching);
				if (right_slot) right_slot.d(detaching);
			}
		};
	}

	function instance$V($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;

		$$self.$$set = $$props => {
			if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
		};

		return [$$scope, slots];
	}

	class Ui_level extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$V, create_fragment$V, safe_not_equal, {});
		}
	}

	var index$8 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIColumn: Ui_column,
		UIColumns: Ui_columns,
		UIContainer: Ui_container,
		UIFooter: Ui_footer,
		UILevel: Ui_level,
		UILevelItem: Ui_level_item,
		UISection: Ui_section$2
	});

	/* node_modules/not-bulma/src/elements/form/ui.number.svelte generated by Svelte v4.2.19 */

	function create_else_block$o(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[6] && create_if_block_4$a(ctx);
		let if_block1 = /*validated*/ ctx[11] === true && create_if_block_1$v(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-textfield-" + /*fieldname*/ ctx[5]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[12]);
				attr(input, "type", "number");
				attr(input, "min", /*min*/ ctx[2]);
				attr(input, "max", /*max*/ ctx[3]);
				attr(input, "step", /*step*/ ctx[4]);
				attr(input, "name", /*fieldname*/ ctx[5]);
				attr(input, "invalid", /*invalid*/ ctx[13]);
				input.disabled = /*disabled*/ ctx[8];
				input.required = /*required*/ ctx[7];
				input.readOnly = /*readonly*/ ctx[9];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[17][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[5]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[5]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[5]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[24]),
						listen(input, "change", /*onBlur*/ ctx[18]),
						listen(input, "input", /*onInput*/ ctx[19])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 32 && input_id_value !== (input_id_value = "form-field-textfield-" + /*fieldname*/ ctx[5])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*validationClasses*/ 4096 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[12])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*min*/ 4) {
					attr(input, "min", /*min*/ ctx[2]);
				}

				if (dirty & /*max*/ 8) {
					attr(input, "max", /*max*/ ctx[3]);
				}

				if (dirty & /*step*/ 16) {
					attr(input, "step", /*step*/ ctx[4]);
				}

				if (dirty & /*fieldname*/ 32) {
					attr(input, "name", /*fieldname*/ ctx[5]);
				}

				if (dirty & /*invalid*/ 8192) {
					attr(input, "invalid", /*invalid*/ ctx[13]);
				}

				if (dirty & /*disabled*/ 256) {
					input.disabled = /*disabled*/ ctx[8];
				}

				if (dirty & /*required*/ 128) {
					input.required = /*required*/ ctx[7];
				}

				if (dirty & /*readonly*/ 512) {
					input.readOnly = /*readonly*/ ctx[9];
				}

				if (dirty & /*$LOCALE, placeholder*/ 131074 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[17][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 32) {
					attr(input, "autocomplete", /*fieldname*/ ctx[5]);
				}

				if (dirty & /*fieldname*/ 32 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[5])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 32 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[5])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1 && to_number(input.value) !== /*value*/ ctx[0]) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[6]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$a(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[11] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$v(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (59:4) {#if readonly}
	function create_if_block$C(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (82:8) {#if icon}
	function create_if_block_4$a(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[6]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 64 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[6])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (87:8) {#if validated === true}
	function create_if_block_1$v(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[10] === true) return create_if_block_2$l;
			if (/*valid*/ ctx[10] === false) return create_if_block_3$f;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (91:42) 
	function create_if_block_3$f(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (89:16) {#if valid === true}
	function create_if_block_2$l(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$U(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[9]) return create_if_block$C;
			return create_else_block$o;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[25](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[26](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[27](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[5]
		};

		if (/*allErrors*/ ctx[15] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[15];
		}

		if (/*showErrors*/ ctx[14] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[14];
		}

		if (/*validationClasses*/ ctx[12] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[12];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[16]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 65536 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[16])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 32) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[5];

				if (!updating_errors && dirty & /*allErrors*/ 32768) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[15];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 16384) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[14];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 4096) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[12];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$U($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(17, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = 0 } = $$props;
		let { placeholder = "0.0" } = $$props;
		let { min = 0 } = $$props;
		let { max = 100 } = $$props;
		let { step = 1 } = $$props;
		let { fieldname = "number" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur() /*ev*/ {
			let data = { field: fieldname, value };
			$$invalidate(20, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(20, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = to_number(this.value);
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(15, allErrors), $$invalidate(21, errors)), $$invalidate(22, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(14, showErrors), $$invalidate(11, validated)), $$invalidate(10, valid)), $$invalidate(20, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(12, validationClasses), $$invalidate(10, valid)), $$invalidate(20, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(20, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('min' in $$props) $$invalidate(2, min = $$props.min);
			if ('max' in $$props) $$invalidate(3, max = $$props.max);
			if ('step' in $$props) $$invalidate(4, step = $$props.step);
			if ('fieldname' in $$props) $$invalidate(5, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(7, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(8, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(9, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(10, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(11, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(21, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(22, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(23, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 64) {
				$$invalidate(16, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 6291456) {
				$$invalidate(15, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 1051648) {
				$$invalidate(14, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 8389632) {
				$$invalidate(13, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 1049600) {
				$$invalidate(12, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			min,
			max,
			step,
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_number extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$U, create_fragment$U, safe_not_equal, {
				inputStarted: 20,
				value: 0,
				placeholder: 1,
				min: 2,
				max: 3,
				step: 4,
				fieldname: 5,
				icon: 6,
				required: 7,
				disabled: 8,
				readonly: 9,
				valid: 10,
				validated: 11,
				errors: 21,
				formErrors: 22,
				formLevelError: 23
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.named.numbers.list.svelte generated by Svelte v4.2.19 */

	function get_each_context$g(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[27] = list[i];
		return child_ctx;
	}

	// (74:8) <UIColumn classes="is-6">
	function create_default_slot_7(ctx) {
		let t_value = /*item*/ ctx[27].title + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*list*/ 256 && t_value !== (t_value = /*item*/ ctx[27].title + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (77:8) <UIColumn classes="is-4">
	function create_default_slot_6(ctx) {
		let t_value = /*item*/ ctx[27].number + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*list*/ 256 && t_value !== (t_value = /*item*/ ctx[27].number + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (80:8) {#if !readonly}
	function create_if_block_1$u(ctx) {
		let uicolumn;
		let current;

		uicolumn = new Ui_column({
				props: {
					classes: "is-2",
					$$slots: { default: [create_default_slot_5] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uicolumn.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uicolumn, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uicolumn_changes = {};

				if (dirty & /*$$scope, list*/ 1073742080) {
					uicolumn_changes.$$scope = { dirty, ctx };
				}

				uicolumn.$set(uicolumn_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uicolumn.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uicolumn.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uicolumn, detaching);
			}
		};
	}

	// (81:12) <UIColumn classes="is-2">
	function create_default_slot_5(ctx) {
		let uibutton;
		let current;

		function func() {
			return /*func*/ ctx[17](/*item*/ ctx[27]);
		}

		uibutton = new Ui_button({ props: { icon: "minus", action: func } });

		return {
			c() {
				create_component(uibutton.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const uibutton_changes = {};
				if (dirty & /*list*/ 256) uibutton_changes.action = func;
				uibutton.$set(uibutton_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibutton, detaching);
			}
		};
	}

	// (73:4) <UIColumns>
	function create_default_slot_4(ctx) {
		let uicolumn0;
		let t0;
		let uicolumn1;
		let t1;
		let if_block_anchor;
		let current;

		uicolumn0 = new Ui_column({
				props: {
					classes: "is-6",
					$$slots: { default: [create_default_slot_7] },
					$$scope: { ctx }
				}
			});

		uicolumn1 = new Ui_column({
				props: {
					classes: "is-4",
					$$slots: { default: [create_default_slot_6] },
					$$scope: { ctx }
				}
			});

		let if_block = !/*readonly*/ ctx[3] && create_if_block_1$u(ctx);

		return {
			c() {
				create_component(uicolumn0.$$.fragment);
				t0 = space();
				create_component(uicolumn1.$$.fragment);
				t1 = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				mount_component(uicolumn0, target, anchor);
				insert(target, t0, anchor);
				mount_component(uicolumn1, target, anchor);
				insert(target, t1, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uicolumn0_changes = {};

				if (dirty & /*$$scope, list*/ 1073742080) {
					uicolumn0_changes.$$scope = { dirty, ctx };
				}

				uicolumn0.$set(uicolumn0_changes);
				const uicolumn1_changes = {};

				if (dirty & /*$$scope, list*/ 1073742080) {
					uicolumn1_changes.$$scope = { dirty, ctx };
				}

				uicolumn1.$set(uicolumn1_changes);

				if (!/*readonly*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*readonly*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_1$u(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(uicolumn0.$$.fragment, local);
				transition_in(uicolumn1.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(uicolumn0.$$.fragment, local);
				transition_out(uicolumn1.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(if_block_anchor);
				}

				destroy_component(uicolumn0, detaching);
				destroy_component(uicolumn1, detaching);
				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (72:0) {#each list as item (item.id)}
	function create_each_block$g(key_1, ctx) {
		let first;
		let uicolumns;
		let current;

		uicolumns = new Ui_columns({
				props: {
					$$slots: { default: [create_default_slot_4] },
					$$scope: { ctx }
				}
			});

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uicolumns.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uicolumns, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const uicolumns_changes = {};

				if (dirty & /*$$scope, list, readonly*/ 1073742088) {
					uicolumns_changes.$$scope = { dirty, ctx };
				}

				uicolumns.$set(uicolumns_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uicolumns.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uicolumns.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uicolumns, detaching);
			}
		};
	}

	// (87:0) {#if !readonly}
	function create_if_block$B(ctx) {
		let uicolumns;
		let current;

		uicolumns = new Ui_columns({
				props: {
					$$slots: { default: [create_default_slot$6] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uicolumns.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uicolumns, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uicolumns_changes = {};

				if (dirty & /*$$scope, newVal, placeholder*/ 1073741841) {
					uicolumns_changes.$$scope = { dirty, ctx };
				}

				uicolumns.$set(uicolumns_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uicolumns.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uicolumns.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uicolumns, detaching);
			}
		};
	}

	// (89:8) <UIColumn classes="is-6">
	function create_default_slot_3(ctx) {
		let uitextfield;
		let updating_value;
		let updating_placeholder;
		let current;

		function uitextfield_value_binding(value) {
			/*uitextfield_value_binding*/ ctx[18](value);
		}

		function uitextfield_placeholder_binding(value) {
			/*uitextfield_placeholder_binding*/ ctx[19](value);
		}

		let uitextfield_props = {};

		if (/*newVal*/ ctx[4].id !== void 0) {
			uitextfield_props.value = /*newVal*/ ctx[4].id;
		}

		if (/*placeholder*/ ctx[0] !== void 0) {
			uitextfield_props.placeholder = /*placeholder*/ ctx[0];
		}

		uitextfield = new Ui_textfield({ props: uitextfield_props });
		binding_callbacks.push(() => bind(uitextfield, 'value', uitextfield_value_binding));
		binding_callbacks.push(() => bind(uitextfield, 'placeholder', uitextfield_placeholder_binding));

		return {
			c() {
				create_component(uitextfield.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitextfield, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitextfield_changes = {};

				if (!updating_value && dirty & /*newVal*/ 16) {
					updating_value = true;
					uitextfield_changes.value = /*newVal*/ ctx[4].id;
					add_flush_callback(() => updating_value = false);
				}

				if (!updating_placeholder && dirty & /*placeholder*/ 1) {
					updating_placeholder = true;
					uitextfield_changes.placeholder = /*placeholder*/ ctx[0];
					add_flush_callback(() => updating_placeholder = false);
				}

				uitextfield.$set(uitextfield_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitextfield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitextfield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitextfield, detaching);
			}
		};
	}

	// (92:8) <UIColumn classes="is-4">
	function create_default_slot_2$2(ctx) {
		let uinumber;
		let updating_value;
		let current;

		function uinumber_value_binding(value) {
			/*uinumber_value_binding*/ ctx[20](value);
		}

		let uinumber_props = {};

		if (/*newVal*/ ctx[4].number !== void 0) {
			uinumber_props.value = /*newVal*/ ctx[4].number;
		}

		uinumber = new Ui_number({ props: uinumber_props });
		binding_callbacks.push(() => bind(uinumber, 'value', uinumber_value_binding));

		return {
			c() {
				create_component(uinumber.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinumber, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinumber_changes = {};

				if (!updating_value && dirty & /*newVal*/ 16) {
					updating_value = true;
					uinumber_changes.value = /*newVal*/ ctx[4].number;
					add_flush_callback(() => updating_value = false);
				}

				uinumber.$set(uinumber_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinumber.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinumber.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinumber, detaching);
			}
		};
	}

	// (95:8) <UIColumn classes="is-2">
	function create_default_slot_1$4(ctx) {
		let uibutton;
		let current;

		uibutton = new Ui_button({
				props: { icon: "plus", action: /*func_1*/ ctx[21] }
			});

		return {
			c() {
				create_component(uibutton.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				current = true;
			},
			p: noop$1,
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibutton, detaching);
			}
		};
	}

	// (88:4) <UIColumns>
	function create_default_slot$6(ctx) {
		let uicolumn0;
		let t0;
		let uicolumn1;
		let t1;
		let uicolumn2;
		let current;

		uicolumn0 = new Ui_column({
				props: {
					classes: "is-6",
					$$slots: { default: [create_default_slot_3] },
					$$scope: { ctx }
				}
			});

		uicolumn1 = new Ui_column({
				props: {
					classes: "is-4",
					$$slots: { default: [create_default_slot_2$2] },
					$$scope: { ctx }
				}
			});

		uicolumn2 = new Ui_column({
				props: {
					classes: "is-2",
					$$slots: { default: [create_default_slot_1$4] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uicolumn0.$$.fragment);
				t0 = space();
				create_component(uicolumn1.$$.fragment);
				t1 = space();
				create_component(uicolumn2.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uicolumn0, target, anchor);
				insert(target, t0, anchor);
				mount_component(uicolumn1, target, anchor);
				insert(target, t1, anchor);
				mount_component(uicolumn2, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uicolumn0_changes = {};

				if (dirty & /*$$scope, newVal, placeholder*/ 1073741841) {
					uicolumn0_changes.$$scope = { dirty, ctx };
				}

				uicolumn0.$set(uicolumn0_changes);
				const uicolumn1_changes = {};

				if (dirty & /*$$scope, newVal*/ 1073741840) {
					uicolumn1_changes.$$scope = { dirty, ctx };
				}

				uicolumn1.$set(uicolumn1_changes);
				const uicolumn2_changes = {};

				if (dirty & /*$$scope*/ 1073741824) {
					uicolumn2_changes.$$scope = { dirty, ctx };
				}

				uicolumn2.$set(uicolumn2_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uicolumn0.$$.fragment, local);
				transition_in(uicolumn1.$$.fragment, local);
				transition_in(uicolumn2.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uicolumn0.$$.fragment, local);
				transition_out(uicolumn1.$$.fragment, local);
				transition_out(uicolumn2.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
				}

				destroy_component(uicolumn0, detaching);
				destroy_component(uicolumn1, detaching);
				destroy_component(uicolumn2, detaching);
			}
		};
	}

	function create_fragment$T(ctx) {
		let uititle;
		let t0;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let t1;
		let t2;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		uititle = new Ui_title({
				props: { title: /*label*/ ctx[2], size: 5 }
			});

		let each_value = ensure_array_like(/*list*/ ctx[8]);
		const get_key = ctx => /*item*/ ctx[27].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$g(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
		}

		let if_block = !/*readonly*/ ctx[3] && create_if_block$B(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[1]
		};

		if (/*allErrors*/ ctx[7] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[7];
		}

		if (/*showErrors*/ ctx[6] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[6];
		}

		if (/*validationClasses*/ ctx[5] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[5];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				create_component(uititle.$$.fragment);
				t0 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t1 = space();
				if (if_block) if_block.c();
				t2 = space();
				create_component(errorslist.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uititle, target, anchor);
				insert(target, t0, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, t1, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, t2, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uititle_changes = {};
				if (dirty & /*label*/ 4) uititle_changes.title = /*label*/ ctx[2];
				uititle.$set(uititle_changes);

				if (dirty & /*remove, list, readonly*/ 776) {
					each_value = ensure_array_like(/*list*/ ctx[8]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, t1.parentNode, outro_and_destroy_block, create_each_block$g, t1, get_each_context$g);
					check_outros();
				}

				if (!/*readonly*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*readonly*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$B(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(t2.parentNode, t2);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 2) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[1];

				if (!updating_errors && dirty & /*allErrors*/ 128) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[7];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 64) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[6];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 32) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[5];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uititle.$$.fragment, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uititle.$$.fragment, local);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
				}

				destroy_component(uititle, detaching);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}

				if (if_block) if_block.d(detaching);
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$T($$self, $$props, $$invalidate) {
		let list;
		let allErrors;
		let showErrors;
		let validationClasses;
		let dispatch = createEventDispatcher();
		let { fieldname = "numbers_list" } = $$props;
		let { value = {} } = $$props;
		let { label = "named numbers list" } = $$props;
		let { inputStarted = false } = $$props;
		let { placeholder = "new item" } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;

		function remove(id) {
			if (notCommon$2.objHas(value, id)) {
				delete value[id];
				$$invalidate(11, value);
				dispatch("change", { value, field: fieldname });
			}
		}

		function add() {
			const id = newVal.id.trim();
			const number = parseInt(newVal.number);

			if (id && id !== "" && !isNaN(number) && !notCommon$2.objHas(value, id)) {
				$$invalidate(11, value[id] = number, value);
			}

			dispatch("change", { value, field: fieldname });
		}

		const createNewVal = () => {
			return { id: "", number: 0 };
		};

		let newVal = createNewVal();
		const func = item => remove(item.id);

		function uitextfield_value_binding(value) {
			if ($$self.$$.not_equal(newVal.id, value)) {
				newVal.id = value;
				$$invalidate(4, newVal);
			}
		}

		function uitextfield_placeholder_binding(value) {
			placeholder = value;
			$$invalidate(0, placeholder);
		}

		function uinumber_value_binding(value) {
			if ($$self.$$.not_equal(newVal.number, value)) {
				newVal.number = value;
				$$invalidate(4, newVal);
			}
		}

		const func_1 = () => add();

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(7, allErrors), $$invalidate(15, errors)), $$invalidate(16, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(6, showErrors), $$invalidate(14, validated)), $$invalidate(13, valid)), $$invalidate(12, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(5, validationClasses), $$invalidate(13, valid)), $$invalidate(12, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('value' in $$props) $$invalidate(11, value = $$props.value);
			if ('label' in $$props) $$invalidate(2, label = $$props.label);
			if ('inputStarted' in $$props) $$invalidate(12, inputStarted = $$props.inputStarted);
			if ('placeholder' in $$props) $$invalidate(0, placeholder = $$props.placeholder);
			if ('readonly' in $$props) $$invalidate(3, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(13, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(14, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(15, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(16, formErrors = $$props.formErrors);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value*/ 2048) {
				$$invalidate(8, list = Object.keys(value).map(name => {
					return {
						id: name,
						title: name,
						number: value[name]
					};
				}));
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 98304) {
				$$invalidate(7, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 28672) {
				$$invalidate(6, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 12288) {
				$$invalidate(5, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			placeholder,
			fieldname,
			label,
			readonly,
			newVal,
			validationClasses,
			showErrors,
			allErrors,
			list,
			remove,
			add,
			value,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			func,
			uitextfield_value_binding,
			uitextfield_placeholder_binding,
			uinumber_value_binding,
			func_1,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_named_numbers_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$T, create_fragment$T, safe_not_equal, {
				fieldname: 1,
				value: 11,
				label: 2,
				inputStarted: 12,
				placeholder: 0,
				readonly: 3,
				valid: 13,
				validated: 14,
				errors: 15,
				formErrors: 16
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.password.svelte generated by Svelte v4.2.19 */

	function create_if_block_3$e(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (77:4) {#if validated === true}
	function create_if_block$A(ctx) {
		let span;

		function select_block_type(ctx, dirty) {
			if (/*valid*/ ctx[6] === true) return create_if_block_1$t;
			if (/*valid*/ ctx[6] === false) return create_if_block_2$k;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (81:38) 
	function create_if_block_2$k(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (79:12) {#if valid === true}
	function create_if_block_1$t(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$S(ctx) {
		let div;
		let input;
		let input_class_value;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let div_class_value;
		let t2;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_3$e(ctx);
		let if_block1 = /*validated*/ ctx[7] === true && create_if_block$A(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[21](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[22](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[23](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[11] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[11];
		}

		if (/*showErrors*/ ctx[10] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[10];
		}

		if (/*validationClasses*/ ctx[8] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[8];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				t2 = space();
				create_component(errorslist.$$.fragment);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[8]);
				input.readOnly = /*readonly*/ ctx[5];
				attr(input, "id", input_id_value = "form-field-password-" + /*fieldname*/ ctx[2]);
				attr(input, "type", "password");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[9]);
				input.required = /*required*/ ctx[4];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[12]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, input);
				set_input_value(input, /*value*/ ctx[0]);
				append(div, t0);
				if (if_block0) if_block0.m(div, null);
				append(div, t1);
				if (if_block1) if_block1.m(div, null);
				insert(target, t2, anchor);
				mount_component(errorslist, target, anchor);
				current = true;

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[20]),
						listen(input, "change", /*onBlur*/ ctx[14]),
						listen(input, "input", /*onInput*/ ctx[15])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*validationClasses*/ 256 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[8])) {
					attr(input, "class", input_class_value);
				}

				if (!current || dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (!current || dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-password-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (!current || dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (!current || dirty & /*invalid*/ 512) {
					attr(input, "invalid", /*invalid*/ ctx[9]);
				}

				if (!current || dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (!current || dirty & /*$LOCALE, placeholder*/ 8194 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (!current || dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (!current || dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (!current || dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$e(ctx);
						if_block0.c();
						if_block0.m(div, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[7] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$A(ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (!current || dirty & /*iconClasses*/ 4096 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[12])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 2048) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[11];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 1024) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[10];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 256) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[8];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				destroy_component(errorslist, detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$S($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "input some text here, please" } = $$props;
		let { fieldname = "password" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(11, allErrors), $$invalidate(17, errors)), $$invalidate(18, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(10, showErrors), $$invalidate(7, validated)), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(8, validationClasses), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(16, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(7, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(17, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(18, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(19, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(12, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 393216) {
				$$invalidate(11, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 65728) {
				$$invalidate(10, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 524352) {
				$$invalidate(9, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 65600) {
				$$invalidate(8, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_password extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$S, create_fragment$S, safe_not_equal, {
				inputStarted: 16,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				readonly: 5,
				valid: 6,
				validated: 7,
				errors: 17,
				formErrors: 18,
				formLevelError: 19
			});
		}
	}

	/* node_modules/not-bulma/src/elements/image/ui.image.svelte generated by Svelte v4.2.19 */

	function create_else_block$n(ctx) {
		let figure;
		let img;
		let img_src_value;
		let figure_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				figure = element("figure");
				img = element("img");
				attr(img, "class", "");
				attr(img, "alt", /*title*/ ctx[2]);
				if (!src_url_equal(img.src, img_src_value = /*url*/ ctx[1])) attr(img, "src", img_src_value);
				attr(img, "crossorigin", /*cors*/ ctx[3]);
				attr(figure, "class", figure_class_value = "image " + /*sizeStyle*/ ctx[7] + " " + /*containedStyle*/ ctx[6] + " " + /*coveredStyle*/ ctx[5] + " " + /*classes*/ ctx[4]);
				attr(figure, "role", "button");
				attr(figure, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, figure, anchor);
				append(figure, img);

				if (!mounted) {
					dispose = [
						listen(figure, "click", /*click_handler_1*/ ctx[12]),
						listen(figure, "keyup", /*keyup_handler*/ ctx[13])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*title*/ 4) {
					attr(img, "alt", /*title*/ ctx[2]);
				}

				if (dirty & /*url*/ 2 && !src_url_equal(img.src, img_src_value = /*url*/ ctx[1])) {
					attr(img, "src", img_src_value);
				}

				if (dirty & /*cors*/ 8) {
					attr(img, "crossorigin", /*cors*/ ctx[3]);
				}

				if (dirty & /*sizeStyle, containedStyle, coveredStyle, classes*/ 240 && figure_class_value !== (figure_class_value = "image " + /*sizeStyle*/ ctx[7] + " " + /*containedStyle*/ ctx[6] + " " + /*coveredStyle*/ ctx[5] + " " + /*classes*/ ctx[4])) {
					attr(figure, "class", figure_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(figure);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (16:0) {#if urlFull}
	function create_if_block$z(ctx) {
		let a;
		let figure;
		let img;
		let img_src_value;
		let figure_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				a = element("a");
				figure = element("figure");
				img = element("img");
				attr(img, "class", "");
				attr(img, "alt", /*title*/ ctx[2]);
				if (!src_url_equal(img.src, img_src_value = /*url*/ ctx[1])) attr(img, "src", img_src_value);
				attr(img, "crossorigin", /*cors*/ ctx[3]);
				attr(figure, "class", figure_class_value = "image " + /*sizeStyle*/ ctx[7] + " " + /*containedStyle*/ ctx[6] + " " + /*coveredStyle*/ ctx[5] + " " + /*classes*/ ctx[4]);
				attr(a, "href", /*urlFull*/ ctx[0]);
				attr(a, "alt", /*title*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, figure);
				append(figure, img);

				if (!mounted) {
					dispose = listen(a, "click", /*click_handler*/ ctx[11]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*title*/ 4) {
					attr(img, "alt", /*title*/ ctx[2]);
				}

				if (dirty & /*url*/ 2 && !src_url_equal(img.src, img_src_value = /*url*/ ctx[1])) {
					attr(img, "src", img_src_value);
				}

				if (dirty & /*cors*/ 8) {
					attr(img, "crossorigin", /*cors*/ ctx[3]);
				}

				if (dirty & /*sizeStyle, containedStyle, coveredStyle, classes*/ 240 && figure_class_value !== (figure_class_value = "image " + /*sizeStyle*/ ctx[7] + " " + /*containedStyle*/ ctx[6] + " " + /*coveredStyle*/ ctx[5] + " " + /*classes*/ ctx[4])) {
					attr(figure, "class", figure_class_value);
				}

				if (dirty & /*urlFull*/ 1) {
					attr(a, "href", /*urlFull*/ ctx[0]);
				}

				if (dirty & /*title*/ 4) {
					attr(a, "alt", /*title*/ ctx[2]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$R(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*urlFull*/ ctx[0]) return create_if_block$z;
			return create_else_block$n;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function instance$R($$self, $$props, $$invalidate) {
		let sizeStyle;
		let containedStyle;
		let coveredStyle;
		let { urlFull } = $$props;
		let { url } = $$props;
		let { title } = $$props;
		let { cors = "anonymous" } = $$props;
		let { size = 64 } = $$props;
		let { contained = true } = $$props;
		let { covered = true } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('urlFull' in $$props) $$invalidate(0, urlFull = $$props.urlFull);
			if ('url' in $$props) $$invalidate(1, url = $$props.url);
			if ('title' in $$props) $$invalidate(2, title = $$props.title);
			if ('cors' in $$props) $$invalidate(3, cors = $$props.cors);
			if ('size' in $$props) $$invalidate(8, size = $$props.size);
			if ('contained' in $$props) $$invalidate(9, contained = $$props.contained);
			if ('covered' in $$props) $$invalidate(10, covered = $$props.covered);
			if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*size*/ 256) {
				$$invalidate(7, sizeStyle = isNaN(size) ? `is-${size}` : `is-${size}x${size}`);
			}

			if ($$self.$$.dirty & /*contained*/ 512) {
				$$invalidate(6, containedStyle = contained ? "is-contained" : "");
			}

			if ($$self.$$.dirty & /*covered*/ 1024) {
				$$invalidate(5, coveredStyle = covered ? "is-covered" : "");
			}
		};

		return [
			urlFull,
			url,
			title,
			cors,
			classes,
			coveredStyle,
			containedStyle,
			sizeStyle,
			size,
			contained,
			covered,
			click_handler,
			click_handler_1,
			keyup_handler
		];
	}

	class Ui_image extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$R, create_fragment$R, safe_not_equal, {
				urlFull: 0,
				url: 1,
				title: 2,
				cors: 3,
				size: 8,
				contained: 9,
				covered: 10,
				classes: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.radio.buttons.svelte generated by Svelte v4.2.19 */

	function create_fragment$Q(ctx) {
		let switch_instance;
		let updating_items;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*listComponentProps*/ ctx[7],
			{
				titleComponent: /*titleComponent*/ ctx[0]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[1]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[4]
			},
			{
				descriptionComponentProps: {
					.../*descriptionComponentProps*/ ctx[5],
					action: /*func*/ ctx[20]
				}
			},
			{
				imageComponent: /*imageComponent*/ ctx[2]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[3]
			}
		];

		function switch_instance_items_binding(value) {
			/*switch_instance_items_binding*/ ctx[21](value);
		}

		var switch_value = /*listComponent*/ ctx[6];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 703) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listComponentProps*/ 128 && get_spread_object(/*listComponentProps*/ ctx[7]),
					dirty & /*titleComponent*/ 1 && {
						titleComponent: /*titleComponent*/ ctx[0]
					},
					dirty & /*titleComponentProps*/ 2 && {
						titleComponentProps: /*titleComponentProps*/ ctx[1]
					},
					dirty & /*descriptionComponent*/ 16 && {
						descriptionComponent: /*descriptionComponent*/ ctx[4]
					},
					dirty & /*descriptionComponentProps, toggle*/ 544 && {
						descriptionComponentProps: {
							.../*descriptionComponentProps*/ ctx[5],
							action: /*func*/ ctx[20]
						}
					},
					dirty & /*imageComponent*/ 4 && {
						imageComponent: /*imageComponent*/ ctx[2]
					},
					dirty & /*imageComponentProps*/ 8 && {
						imageComponentProps: /*imageComponentProps*/ ctx[3]
					}
				]));
			}

			if (/*listItems*/ ctx[8] !== void 0) {
				switch_instance_props.items = /*listItems*/ ctx[8];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*listComponent*/ 64 && switch_value !== (switch_value = /*listComponent*/ ctx[6])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 703)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listComponentProps*/ 128 && get_spread_object(/*listComponentProps*/ ctx[7]),
							dirty & /*titleComponent*/ 1 && {
								titleComponent: /*titleComponent*/ ctx[0]
							},
							dirty & /*titleComponentProps*/ 2 && {
								titleComponentProps: /*titleComponentProps*/ ctx[1]
							},
							dirty & /*descriptionComponent*/ 16 && {
								descriptionComponent: /*descriptionComponent*/ ctx[4]
							},
							dirty & /*descriptionComponentProps, toggle*/ 544 && {
								descriptionComponentProps: {
									.../*descriptionComponentProps*/ ctx[5],
									action: /*func*/ ctx[20]
								}
							},
							dirty & /*imageComponent*/ 4 && {
								imageComponent: /*imageComponent*/ ctx[2]
							},
							dirty & /*imageComponentProps*/ 8 && {
								imageComponentProps: /*imageComponentProps*/ ctx[3]
							}
						])
					: {};

					if (!updating_items && dirty & /*listItems*/ 256) {
						updating_items = true;
						switch_instance_changes.items = /*listItems*/ ctx[8];
						add_flush_callback(() => updating_items = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$Q($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { fieldname = "radio-buttons" } = $$props;
		let { variants = [] } = $$props;
		let { value } = $$props;
		let { title } = $$props;
		let { image } = $$props;
		let { buttonProps = {} } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 5 } } = $$props;
		let { imageComponent = Ui_image } = $$props;
		let { imageComponentProps = { covered: true } } = $$props;
		let { descriptionComponent = Ui_buttons } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { listComponent = Ui_list } = $$props;
		let { listComponentProps = {} } = $$props;

		let { getUIItem = valueId => {
			return variantsButtons.find(btnVal => btnVal.value === valueId);
		} } = $$props;

		let { getDefaultItemSublime = () => {
			return variants[0].value;
		} } = $$props;

		let { uiOn = item => {
			item.color = "success";
			item.outlined = false;
		} } = $$props;

		let { uiOff = item => {
			item.color = false;
			item.outlined = true;
		} } = $$props;

		onMount(() => {
			initVariantsButton();
			selectDefault();
		});

		let variantsButtons = [], listItems = [];

		function initVariantsButton() {
			variantsButtons = variants.map(variant => {
				return { ...buttonProps, ...variant };
			});

			$$invalidate(8, listItems = [
				{
					id: 0,
					title,
					image,
					description: { values: variantsButtons }
				}
			]);
		}

		//
		function toggle(selectedValue) {
			let ui = { on: undefined, off: undefined };

			//
			if (value) {
				ui.off = value;
				ui.on = selectedValue;
			}

			$$invalidate(10, value = selectedValue);
			updateUI(ui);

			//
			dispatch("change", { field: fieldname, value });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff(getUIItem(changes.off));
			}

			if (changes.on) {
				uiOn(getUIItem(changes.on));
			}

			variantsButtons = variantsButtons;
			$$invalidate(8, listItems);
		}

		//
		function selectDefault() {
			if (variants.length > 0) {
				if (typeof value !== "undefined") {
					updateUI({ on: value });
				} else {
					const defValue = getDefaultItemSublime();
					toggle(defValue);
				}
			}
		}

		const func = function (event, value) {
			toggle(value);
		};

		function switch_instance_items_binding(value) {
			listItems = value;
			$$invalidate(8, listItems);
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(11, fieldname = $$props.fieldname);
			if ('variants' in $$props) $$invalidate(12, variants = $$props.variants);
			if ('value' in $$props) $$invalidate(10, value = $$props.value);
			if ('title' in $$props) $$invalidate(13, title = $$props.title);
			if ('image' in $$props) $$invalidate(14, image = $$props.image);
			if ('buttonProps' in $$props) $$invalidate(15, buttonProps = $$props.buttonProps);
			if ('titleComponent' in $$props) $$invalidate(0, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(1, titleComponentProps = $$props.titleComponentProps);
			if ('imageComponent' in $$props) $$invalidate(2, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(3, imageComponentProps = $$props.imageComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(4, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(5, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('listComponent' in $$props) $$invalidate(6, listComponent = $$props.listComponent);
			if ('listComponentProps' in $$props) $$invalidate(7, listComponentProps = $$props.listComponentProps);
			if ('getUIItem' in $$props) $$invalidate(16, getUIItem = $$props.getUIItem);
			if ('getDefaultItemSublime' in $$props) $$invalidate(17, getDefaultItemSublime = $$props.getDefaultItemSublime);
			if ('uiOn' in $$props) $$invalidate(18, uiOn = $$props.uiOn);
			if ('uiOff' in $$props) $$invalidate(19, uiOff = $$props.uiOff);
		};

		return [
			titleComponent,
			titleComponentProps,
			imageComponent,
			imageComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			listComponent,
			listComponentProps,
			listItems,
			toggle,
			value,
			fieldname,
			variants,
			title,
			image,
			buttonProps,
			getUIItem,
			getDefaultItemSublime,
			uiOn,
			uiOff,
			func,
			switch_instance_items_binding
		];
	}

	class Ui_radio_buttons extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
				fieldname: 11,
				variants: 12,
				value: 10,
				title: 13,
				image: 14,
				buttonProps: 15,
				titleComponent: 0,
				titleComponentProps: 1,
				imageComponent: 2,
				imageComponentProps: 3,
				descriptionComponent: 4,
				descriptionComponentProps: 5,
				listComponent: 6,
				listComponentProps: 7,
				getUIItem: 16,
				getDefaultItemSublime: 17,
				uiOn: 18,
				uiOff: 19
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.range.svelte generated by Svelte v4.2.19 */

	function get_each_context$f(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		return child_ctx;
	}

	// (64:4) {:else}
	function create_else_block$m(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_list_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let output;
		let t1;
		let output_for_value;
		let t2;
		let show_if = Array.isArray(/*tickmarks*/ ctx[4]) && /*tickmarks*/ ctx[4].length;
		let t3;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = show_if && create_if_block_2$j(ctx);
		let if_block1 = /*icon*/ ctx[7] && create_if_block_1$s(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				output = element("output");
				t1 = text(/*value*/ ctx[0]);
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-range-" + /*fieldname*/ ctx[6]);
				attr(input, "class", input_class_value = "input big-number slider has-output is-fullwidth is-success " + /*validationClasses*/ ctx[11]);
				attr(input, "type", "range");
				attr(input, "name", /*fieldname*/ ctx[6]);
				attr(input, "min", /*min*/ ctx[1]);
				attr(input, "max", /*max*/ ctx[2]);
				attr(input, "step", /*step*/ ctx[3]);
				attr(input, "list", input_list_value = "form-field-range-" + /*fieldname*/ ctx[6] + "-tickmarks");
				attr(input, "invalid", /*invalid*/ ctx[12]);
				input.disabled = /*disabled*/ ctx[9];
				input.required = /*required*/ ctx[8];
				input.readOnly = /*readonly*/ ctx[10];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[16][/*placeholder*/ ctx[5]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[6]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[6]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[6]);
				attr(output, "for", output_for_value = "form-field-range-" + /*fieldname*/ ctx[6]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				insert(target, output, anchor);
				append(output, t1);
				insert(target, t2, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t3, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_input_handler*/ ctx[25]),
						listen(input, "input", /*input_change_input_handler*/ ctx[25]),
						listen(input, "change", /*onBlur*/ ctx[17]),
						listen(input, "input", /*onInput*/ ctx[18])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fieldname*/ 64 && input_id_value !== (input_id_value = "form-field-range-" + /*fieldname*/ ctx[6])) {
					attr(input, "id", input_id_value);
				}

				if (dirty[0] & /*validationClasses*/ 2048 && input_class_value !== (input_class_value = "input big-number slider has-output is-fullwidth is-success " + /*validationClasses*/ ctx[11])) {
					attr(input, "class", input_class_value);
				}

				if (dirty[0] & /*fieldname*/ 64) {
					attr(input, "name", /*fieldname*/ ctx[6]);
				}

				if (dirty[0] & /*min*/ 2) {
					attr(input, "min", /*min*/ ctx[1]);
				}

				if (dirty[0] & /*max*/ 4) {
					attr(input, "max", /*max*/ ctx[2]);
				}

				if (dirty[0] & /*step*/ 8) {
					attr(input, "step", /*step*/ ctx[3]);
				}

				if (dirty[0] & /*fieldname*/ 64 && input_list_value !== (input_list_value = "form-field-range-" + /*fieldname*/ ctx[6] + "-tickmarks")) {
					attr(input, "list", input_list_value);
				}

				if (dirty[0] & /*invalid*/ 4096) {
					attr(input, "invalid", /*invalid*/ ctx[12]);
				}

				if (dirty[0] & /*disabled*/ 512) {
					input.disabled = /*disabled*/ ctx[9];
				}

				if (dirty[0] & /*required*/ 256) {
					input.required = /*required*/ ctx[8];
				}

				if (dirty[0] & /*readonly*/ 1024) {
					input.readOnly = /*readonly*/ ctx[10];
				}

				if (dirty[0] & /*$LOCALE, placeholder*/ 65568 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[16][/*placeholder*/ ctx[5]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty[0] & /*fieldname*/ 64) {
					attr(input, "autocomplete", /*fieldname*/ ctx[6]);
				}

				if (dirty[0] & /*fieldname*/ 64 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[6])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty[0] & /*fieldname*/ 64 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[6])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty[0] & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (dirty[0] & /*value*/ 1) set_data(t1, /*value*/ ctx[0]);

				if (dirty[0] & /*fieldname*/ 64 && output_for_value !== (output_for_value = "form-field-range-" + /*fieldname*/ ctx[6])) {
					attr(output, "for", output_for_value);
				}

				if (dirty[0] & /*tickmarks*/ 16) show_if = Array.isArray(/*tickmarks*/ ctx[4]) && /*tickmarks*/ ctx[4].length;

				if (show_if) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_2$j(ctx);
						if_block0.c();
						if_block0.m(t3.parentNode, t3);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*icon*/ ctx[7]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$s(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(output);
					detach(t2);
					detach(t3);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (62:4) {#if readonly}
	function create_if_block$y(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (87:8) {#if Array.isArray(tickmarks) && tickmarks.length}
	function create_if_block_2$j(ctx) {
		let datalist;
		let datalist_id_value;
		let each_value = ensure_array_like(/*tickmarks*/ ctx[4]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
		}

		return {
			c() {
				datalist = element("datalist");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(datalist, "id", datalist_id_value = "form-field-range-" + /*fieldname*/ ctx[6] + "-tickmarks");
			},
			m(target, anchor) {
				insert(target, datalist, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(datalist, null);
					}
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*tickmarks*/ 16) {
					each_value = ensure_array_like(/*tickmarks*/ ctx[4]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$f(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$f(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(datalist, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty[0] & /*fieldname*/ 64 && datalist_id_value !== (datalist_id_value = "form-field-range-" + /*fieldname*/ ctx[6] + "-tickmarks")) {
					attr(datalist, "id", datalist_id_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(datalist);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (89:16) {#each tickmarks as tickmark}
	function create_each_block$f(ctx) {
		let option;
		let option_value_value;
		let option_label_value;

		return {
			c() {
				option = element("option");
				option.__value = option_value_value = /*tickmark*/ ctx[30].value;
				set_input_value(option, option.__value);
				attr(option, "label", option_label_value = /*tickmark*/ ctx[30].label);
			},
			m(target, anchor) {
				insert(target, option, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*tickmarks*/ 16 && option_value_value !== (option_value_value = /*tickmark*/ ctx[30].value)) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}

				if (dirty[0] & /*tickmarks*/ 16 && option_label_value !== (option_label_value = /*tickmark*/ ctx[30].label)) {
					attr(option, "label", option_label_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	// (95:8) {#if icon}
	function create_if_block_1$s(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[7]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*icon*/ 128 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[7])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$P(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[10]) return create_if_block$y;
			return create_else_block$m;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[26](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[27](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[28](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[6]
		};

		if (/*allErrors*/ ctx[14] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[14];
		}

		if (/*showErrors*/ ctx[13] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[13];
		}

		if (/*validationClasses*/ ctx[11] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[11];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[15]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty[0] & /*iconClasses*/ 32768 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[15])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 64) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[6];

				if (!updating_errors && dirty[0] & /*allErrors*/ 16384) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[14];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 8192) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[13];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 2048) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[11];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$P($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(16, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = 10 } = $$props;
		let { min = 0 } = $$props;
		let { max = 100 } = $$props;
		let { step = 1 } = $$props;
		let { tickmarks = false } = $$props;
		let { placeholder = "range placeholder" } = $$props;
		let { fieldname = "range" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur() /*ev*/ {
			let data = { field: fieldname, value };
			$$invalidate(19, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(19, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_change_input_handler() {
			value = to_number(this.value);
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(14, allErrors), $$invalidate(22, errors)), $$invalidate(23, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(13, showErrors), $$invalidate(21, validated)), $$invalidate(20, valid)), $$invalidate(19, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(11, validationClasses), $$invalidate(20, valid)), $$invalidate(19, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(19, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('min' in $$props) $$invalidate(1, min = $$props.min);
			if ('max' in $$props) $$invalidate(2, max = $$props.max);
			if ('step' in $$props) $$invalidate(3, step = $$props.step);
			if ('tickmarks' in $$props) $$invalidate(4, tickmarks = $$props.tickmarks);
			if ('placeholder' in $$props) $$invalidate(5, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(6, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(7, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(8, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(9, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(10, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(20, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(21, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(22, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(23, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(24, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 128) {
				$$invalidate(15, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 12582912) {
				$$invalidate(14, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 3670016) {
				$$invalidate(13, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 17825792) {
				$$invalidate(12, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 1572864) {
				$$invalidate(11, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			min,
			max,
			step,
			tickmarks,
			placeholder,
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_range extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$P,
				create_fragment$P,
				safe_not_equal,
				{
					inputStarted: 19,
					value: 0,
					min: 1,
					max: 2,
					step: 3,
					tickmarks: 4,
					placeholder: 5,
					fieldname: 6,
					icon: 7,
					required: 8,
					disabled: 9,
					readonly: 10,
					valid: 20,
					validated: 21,
					errors: 22,
					formErrors: 23,
					formLevelError: 24
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.range.logarithmic.svelte generated by Svelte v4.2.19 */

	function get_each_context$e(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[40] = list[i];
		return child_ctx;
	}

	// (110:4) {:else}
	function create_else_block$l(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_list_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let output;
		let t1;
		let output_for_value;
		let t2;
		let show_if = Array.isArray(/*tickmarks*/ ctx[1]) && /*tickmarks*/ ctx[1].length;
		let t3;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = show_if && create_if_block_2$i(ctx);
		let if_block1 = /*icon*/ ctx[4] && create_if_block_1$r(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				output = element("output");
				t1 = text(/*value*/ ctx[0]);
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-range-" + /*fieldname*/ ctx[3]);
				attr(input, "class", input_class_value = "input big-number slider has-output is-fullwidth is-success " + /*validationClasses*/ ctx[9]);
				attr(input, "type", "range");
				attr(input, "name", /*fieldname*/ ctx[3]);
				attr(input, "min", /*posMin*/ ctx[17]);
				attr(input, "max", /*posMax*/ ctx[18]);
				attr(input, "step", /*lStep*/ ctx[19]);
				attr(input, "list", input_list_value = "form-field-range-" + /*fieldname*/ ctx[3] + "-tickmarks");
				attr(input, "invalid", /*invalid*/ ctx[10]);
				input.disabled = /*disabled*/ ctx[6];
				input.required = /*required*/ ctx[5];
				input.readOnly = /*readonly*/ ctx[7];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[2]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[3]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[3]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[3]);
				attr(output, "for", output_for_value = "form-field-range-" + /*fieldname*/ ctx[3]);
				attr(output, "editable", "true");
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*posValue*/ ctx[8]);
				insert(target, t0, anchor);
				insert(target, output, anchor);
				append(output, t1);
				insert(target, t2, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t3, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_input_handler*/ ctx[28]),
						listen(input, "input", /*input_change_input_handler*/ ctx[28]),
						listen(input, "change", /*onBlur*/ ctx[15]),
						listen(input, "input", /*onInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fieldname*/ 8 && input_id_value !== (input_id_value = "form-field-range-" + /*fieldname*/ ctx[3])) {
					attr(input, "id", input_id_value);
				}

				if (dirty[0] & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input big-number slider has-output is-fullwidth is-success " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty[0] & /*fieldname*/ 8) {
					attr(input, "name", /*fieldname*/ ctx[3]);
				}

				if (dirty[0] & /*fieldname*/ 8 && input_list_value !== (input_list_value = "form-field-range-" + /*fieldname*/ ctx[3] + "-tickmarks")) {
					attr(input, "list", input_list_value);
				}

				if (dirty[0] & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty[0] & /*disabled*/ 64) {
					input.disabled = /*disabled*/ ctx[6];
				}

				if (dirty[0] & /*required*/ 32) {
					input.required = /*required*/ ctx[5];
				}

				if (dirty[0] & /*readonly*/ 128) {
					input.readOnly = /*readonly*/ ctx[7];
				}

				if (dirty[0] & /*$LOCALE, placeholder*/ 16388 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[2]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty[0] & /*fieldname*/ 8) {
					attr(input, "autocomplete", /*fieldname*/ ctx[3]);
				}

				if (dirty[0] & /*fieldname*/ 8 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[3])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty[0] & /*fieldname*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[3])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty[0] & /*posValue*/ 256) {
					set_input_value(input, /*posValue*/ ctx[8]);
				}

				if (dirty[0] & /*value*/ 1) set_data(t1, /*value*/ ctx[0]);

				if (dirty[0] & /*fieldname*/ 8 && output_for_value !== (output_for_value = "form-field-range-" + /*fieldname*/ ctx[3])) {
					attr(output, "for", output_for_value);
				}

				if (dirty[0] & /*tickmarks*/ 2) show_if = Array.isArray(/*tickmarks*/ ctx[1]) && /*tickmarks*/ ctx[1].length;

				if (show_if) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_2$i(ctx);
						if_block0.c();
						if_block0.m(t3.parentNode, t3);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*icon*/ ctx[4]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$r(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(output);
					detach(t2);
					detach(t3);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (108:4) {#if readonly}
	function create_if_block$x(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (135:8) {#if Array.isArray(tickmarks) && tickmarks.length}
	function create_if_block_2$i(ctx) {
		let datalist;
		let datalist_id_value;
		let each_value = ensure_array_like(/*tickmarks*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
		}

		return {
			c() {
				datalist = element("datalist");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(datalist, "id", datalist_id_value = "form-field-range-" + /*fieldname*/ ctx[3] + "-tickmarks");
			},
			m(target, anchor) {
				insert(target, datalist, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(datalist, null);
					}
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*tickmarks*/ 2) {
					each_value = ensure_array_like(/*tickmarks*/ ctx[1]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$e(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$e(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(datalist, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty[0] & /*fieldname*/ 8 && datalist_id_value !== (datalist_id_value = "form-field-range-" + /*fieldname*/ ctx[3] + "-tickmarks")) {
					attr(datalist, "id", datalist_id_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(datalist);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (137:16) {#each tickmarks as tickmark}
	function create_each_block$e(ctx) {
		let option;
		let option_value_value;
		let option_label_value;

		return {
			c() {
				option = element("option");
				option.__value = option_value_value = /*tickmark*/ ctx[40].value;
				set_input_value(option, option.__value);
				attr(option, "label", option_label_value = /*tickmark*/ ctx[40].label);
			},
			m(target, anchor) {
				insert(target, option, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*tickmarks*/ 2 && option_value_value !== (option_value_value = /*tickmark*/ ctx[40].value)) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}

				if (dirty[0] & /*tickmarks*/ 2 && option_label_value !== (option_label_value = /*tickmark*/ ctx[40].label)) {
					attr(option, "label", option_label_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	// (143:8) {#if icon}
	function create_if_block_1$r(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[4]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[4])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$O(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[7]) return create_if_block$x;
			return create_else_block$l;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[29](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[30](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[31](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[3]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty[0] & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 8) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[3];

				if (!updating_errors && dirty[0] & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$O($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(14, $LOCALE = $$value));
		const MAX = Number.MAX_SAFE_INTEGER;
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = 10 } = $$props;
		let { min = 0 } = $$props;
		let { max = 100 } = $$props;
		let { tickmarks = false } = $$props;
		let { placeholder = "range placeholder" } = $$props;
		let { fieldname = "range" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			const val = getLogarithmicValue(ev.currentTarget.value);
			$$invalidate(0, value = val);
			let data = { field: fieldname, value };
			$$invalidate(20, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			const val = getLogarithmicValue(Math.round(parseInt(ev.currentTarget.value)));
			$$invalidate(0, value = val);
			let data = { field: fieldname, value };
			$$invalidate(20, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		let posMin = 0,
			posMax = 100,
			lMin = 0,
			lMax = 100,
			lScale = 10,
			lStep = 0.01,
			posValue = 1;

		function updateRange() {
			lMin = Math.log(min || 1);
			lMax = Math.log(max || MAX);
			lScale = (lMax - lMin) / (posMax - posMin);

			if (value > max) {
				$$invalidate(0, value = max);
			} else if (value < min) {
				$$invalidate(0, value = min);
			} else {
				$$invalidate(0, value);
			}
		}

		onMount(() => {
			updateRange();
		});

		function getLogarithmicValue(pos) {
			pos = parseInt(pos);
			return Math.round(Math.exp((pos - posMin) * lScale + lMin));
		}

		function input_change_input_handler() {
			posValue = to_number(this.value);
			$$invalidate(8, posValue);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(25, errors)), $$invalidate(26, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(24, validated)), $$invalidate(23, valid)), $$invalidate(20, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(23, valid)), $$invalidate(20, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(20, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('min' in $$props) $$invalidate(21, min = $$props.min);
			if ('max' in $$props) $$invalidate(22, max = $$props.max);
			if ('tickmarks' in $$props) $$invalidate(1, tickmarks = $$props.tickmarks);
			if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(3, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(6, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(7, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(23, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(24, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(25, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(26, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(27, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 16) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 100663296) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 26214400) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 142606336) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 9437184) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}

			if ($$self.$$.dirty[0] & /*min, max*/ 6291456) {
				{
					(updateRange());
				}
			}
		};

		return [
			value,
			tickmarks,
			placeholder,
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			posValue,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			posMin,
			posMax,
			lStep,
			inputStarted,
			min,
			max,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_range_logarithmic extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$O,
				create_fragment$O,
				safe_not_equal,
				{
					inputStarted: 20,
					value: 0,
					min: 21,
					max: 22,
					tickmarks: 1,
					placeholder: 2,
					fieldname: 3,
					icon: 4,
					required: 5,
					disabled: 6,
					readonly: 7,
					valid: 23,
					validated: 24,
					errors: 25,
					formErrors: 26,
					formLevelError: 27
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.select.from.model.svelte generated by Svelte v4.2.19 */

	function create_fragment$N(ctx) {
		let uiselect;
		let updating_variants;
		let current;

		function uiselect_variants_binding(value) {
			/*uiselect_variants_binding*/ ctx[27](value);
		}

		let uiselect_props = {
			inputStarted: /*inputStarted*/ ctx[1],
			value: /*value*/ ctx[2],
			placeholder: /*placeholder*/ ctx[3],
			emptyValueTitle: /*emptyValueTitle*/ ctx[4],
			fieldname: /*fieldname*/ ctx[5],
			icon: /*icon*/ ctx[6],
			required: /*required*/ ctx[7],
			readonly: /*readonly*/ ctx[8],
			disabled: /*disabled*/ ctx[16],
			multiple: /*multiple*/ ctx[9],
			size: /*size*/ ctx[10],
			valid: /*valid*/ ctx[11],
			validated: /*validated*/ ctx[12],
			errors: /*errors*/ ctx[0],
			formErrors: /*formErrors*/ ctx[13],
			formLevelError: /*formLevelError*/ ctx[14]
		};

		if (/*variants*/ ctx[15] !== void 0) {
			uiselect_props.variants = /*variants*/ ctx[15];
		}

		uiselect = new Ui_select({ props: uiselect_props });
		binding_callbacks.push(() => bind(uiselect, 'variants', uiselect_variants_binding));
		uiselect.$on("change", /*onChange*/ ctx[17]);

		return {
			c() {
				create_component(uiselect.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselect, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uiselect_changes = {};
				if (dirty & /*inputStarted*/ 2) uiselect_changes.inputStarted = /*inputStarted*/ ctx[1];
				if (dirty & /*value*/ 4) uiselect_changes.value = /*value*/ ctx[2];
				if (dirty & /*placeholder*/ 8) uiselect_changes.placeholder = /*placeholder*/ ctx[3];
				if (dirty & /*emptyValueTitle*/ 16) uiselect_changes.emptyValueTitle = /*emptyValueTitle*/ ctx[4];
				if (dirty & /*fieldname*/ 32) uiselect_changes.fieldname = /*fieldname*/ ctx[5];
				if (dirty & /*icon*/ 64) uiselect_changes.icon = /*icon*/ ctx[6];
				if (dirty & /*required*/ 128) uiselect_changes.required = /*required*/ ctx[7];
				if (dirty & /*readonly*/ 256) uiselect_changes.readonly = /*readonly*/ ctx[8];
				if (dirty & /*disabled*/ 65536) uiselect_changes.disabled = /*disabled*/ ctx[16];
				if (dirty & /*multiple*/ 512) uiselect_changes.multiple = /*multiple*/ ctx[9];
				if (dirty & /*size*/ 1024) uiselect_changes.size = /*size*/ ctx[10];
				if (dirty & /*valid*/ 2048) uiselect_changes.valid = /*valid*/ ctx[11];
				if (dirty & /*validated*/ 4096) uiselect_changes.validated = /*validated*/ ctx[12];
				if (dirty & /*errors*/ 1) uiselect_changes.errors = /*errors*/ ctx[0];
				if (dirty & /*formErrors*/ 8192) uiselect_changes.formErrors = /*formErrors*/ ctx[13];
				if (dirty & /*formLevelError*/ 16384) uiselect_changes.formLevelError = /*formLevelError*/ ctx[14];

				if (!updating_variants && dirty & /*variants*/ 32768) {
					updating_variants = true;
					uiselect_changes.variants = /*variants*/ ctx[15];
					add_flush_callback(() => updating_variants = false);
				}

				uiselect.$set(uiselect_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselect.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselect.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselect, detaching);
			}
		};
	}

	let loaded = false;

	function instance$N($$self, $$props, $$invalidate) {
		let disabled;
		const dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value } = $$props;
		let { placeholder = "empty select item" } = $$props;
		let { emptyValueTitle = "" } = $$props;
		let { fieldname = "selectFromModel" } = $$props;
		let { modelName = "" } = $$props;
		let { actionName = "" } = $$props;
		let { actionFilter = {} } = $$props;
		let { actionSorter = {} } = $$props;
		let { actionPager = {} } = $$props;
		let { actionSearch = undefined } = $$props;
		let { optionId = ":_id" } = $$props;
		let { optionTitle = ":title" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { multiple = false } = $$props;
		let { size = 8 } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let { returnVariant = false } = $$props;

		function argumentsSetProvided() {
			return modelName && actionName && actionFilter;
		}

		let variants = [];

		onMount(async () => {
			if (argumentsSetProvided()) {
				const notApp = notCommon$2.getApp();
				const Model = notApp.getModel(modelName).setFilter(actionFilter).setSorter(actionSorter).setPager(actionPager).setSearch(actionSearch);
				const response = await Model[`$` + actionName]();

				if (response.status === DEFAULT_STATUS_SUCCESS) {
					const result = response.result;

					$$invalidate(15, variants = result.map(item => {
						return {
							id: notPath$1.get(optionId, item),
							title: notPath$1.get(optionTitle, item)
						};
					}));
				} else {
					$$invalidate(0, errors = result.errors || [result.message]);
				}
			}
		});

		function onChange(e) {
			if (returnVariant) {
				dispatch("change", {
					...e.detail,
					value: variants.find(itm => itm.id === e.detail.value)
				});
			} else {
				dispatch("change", e.detail);
			}
		}

		function uiselect_variants_binding(value) {
			variants = value;
			$$invalidate(15, variants);
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(1, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(2, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(3, placeholder = $$props.placeholder);
			if ('emptyValueTitle' in $$props) $$invalidate(4, emptyValueTitle = $$props.emptyValueTitle);
			if ('fieldname' in $$props) $$invalidate(5, fieldname = $$props.fieldname);
			if ('modelName' in $$props) $$invalidate(18, modelName = $$props.modelName);
			if ('actionName' in $$props) $$invalidate(19, actionName = $$props.actionName);
			if ('actionFilter' in $$props) $$invalidate(20, actionFilter = $$props.actionFilter);
			if ('actionSorter' in $$props) $$invalidate(21, actionSorter = $$props.actionSorter);
			if ('actionPager' in $$props) $$invalidate(22, actionPager = $$props.actionPager);
			if ('actionSearch' in $$props) $$invalidate(23, actionSearch = $$props.actionSearch);
			if ('optionId' in $$props) $$invalidate(24, optionId = $$props.optionId);
			if ('optionTitle' in $$props) $$invalidate(25, optionTitle = $$props.optionTitle);
			if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(7, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(8, readonly = $$props.readonly);
			if ('multiple' in $$props) $$invalidate(9, multiple = $$props.multiple);
			if ('size' in $$props) $$invalidate(10, size = $$props.size);
			if ('valid' in $$props) $$invalidate(11, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(12, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(0, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(13, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(14, formLevelError = $$props.formLevelError);
			if ('returnVariant' in $$props) $$invalidate(26, returnVariant = $$props.returnVariant);
		};

		$$invalidate(16, disabled = !loaded);

		return [
			errors,
			inputStarted,
			value,
			placeholder,
			emptyValueTitle,
			fieldname,
			icon,
			required,
			readonly,
			multiple,
			size,
			valid,
			validated,
			formErrors,
			formLevelError,
			variants,
			disabled,
			onChange,
			modelName,
			actionName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch,
			optionId,
			optionTitle,
			returnVariant,
			uiselect_variants_binding
		];
	}

	class Ui_select_from_model extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$N, create_fragment$N, safe_not_equal, {
				inputStarted: 1,
				value: 2,
				placeholder: 3,
				emptyValueTitle: 4,
				fieldname: 5,
				modelName: 18,
				actionName: 19,
				actionFilter: 20,
				actionSorter: 21,
				actionPager: 22,
				actionSearch: 23,
				optionId: 24,
				optionTitle: 25,
				icon: 6,
				required: 7,
				readonly: 8,
				multiple: 9,
				size: 10,
				valid: 11,
				validated: 12,
				errors: 0,
				formErrors: 13,
				formLevelError: 14,
				returnVariant: 26
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.switch.svelte generated by Svelte v4.2.19 */

	function create_else_block_1$4(ctx) {
		let t0;
		let input;
		let input_class_value;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t1;
		let label_1;
		let label_1_for_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = !/*label*/ ctx[1] && create_if_block_4$9();
		let if_block1 = !/*hideLabel*/ ctx[2] && create_if_block_2$h(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				input = element("input");
				t1 = space();
				label_1 = element("label");
				if (if_block1) if_block1.c();
				attr(input, "type", "checkbox");
				attr(input, "class", input_class_value = "switch " + /*styling*/ ctx[8]);
				attr(input, "id", input_id_value = "form-field-switch-" + /*fieldname*/ ctx[4]);
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[3]]);
				attr(input, "name", /*fieldname*/ ctx[4]);
				input.disabled = /*disabled*/ ctx[7];
				input.required = /*required*/ ctx[5];
				input.readOnly = /*readonly*/ ctx[6];
				attr(input, "invalid", /*invalid*/ ctx[10]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[4]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[4]);
				attr(label_1, "class", "label");
				attr(label_1, "for", label_1_for_value = "form-field-switch-" + /*fieldname*/ ctx[4]);
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				insert(target, input, anchor);
				input.checked = /*value*/ ctx[0];
				insert(target, t1, anchor);
				insert(target, label_1, anchor);
				if (if_block1) if_block1.m(label_1, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[23]),
						listen(input, "blur", /*onBlur*/ ctx[14]),
						listen(input, "input", /*onInput*/ ctx[15])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (!/*label*/ ctx[1]) {
					if (if_block0) {
						if (dirty & /*label*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_4$9();
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*styling*/ 256 && input_class_value !== (input_class_value = "switch " + /*styling*/ ctx[8])) {
					attr(input, "class", input_class_value);
				}

				if (!current || dirty & /*fieldname*/ 16 && input_id_value !== (input_id_value = "form-field-switch-" + /*fieldname*/ ctx[4])) {
					attr(input, "id", input_id_value);
				}

				if (!current || dirty & /*$LOCALE, placeholder*/ 8200 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[3]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (!current || dirty & /*fieldname*/ 16) {
					attr(input, "name", /*fieldname*/ ctx[4]);
				}

				if (!current || dirty & /*disabled*/ 128) {
					input.disabled = /*disabled*/ ctx[7];
				}

				if (!current || dirty & /*required*/ 32) {
					input.required = /*required*/ ctx[5];
				}

				if (!current || dirty & /*readonly*/ 64) {
					input.readOnly = /*readonly*/ ctx[6];
				}

				if (!current || dirty & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (!current || dirty & /*fieldname*/ 16 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[4])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (!current || dirty & /*fieldname*/ 16 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[4])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					input.checked = /*value*/ ctx[0];
				}

				if (!/*hideLabel*/ ctx[2]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*hideLabel*/ 4) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$h(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(label_1, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*fieldname*/ 16 && label_1_for_value !== (label_1_for_value = "form-field-switch-" + /*fieldname*/ ctx[4])) {
					attr(label_1, "for", label_1_for_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(input);
					detach(t1);
					detach(label_1);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (67:4) {#if readonly}
	function create_if_block$w(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_1$q, create_else_block$k];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*value*/ ctx[0]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (74:8) {#if !label}
	function create_if_block_4$9(ctx) {
		let uibooleans;
		let current;
		uibooleans = new Ui_booleans({ props: { values: [{ value: false }] } });

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	// (94:12) {#if !hideLabel}
	function create_if_block_2$h(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_3$d, create_else_block_2$3];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*label*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (97:16) {:else}
	function create_else_block_2$3(ctx) {
		let uibooleans;
		let current;
		uibooleans = new Ui_booleans({ props: { values: [{ value: true }] } });

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			p: noop$1,
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	// (95:16) {#if label}
	function create_if_block_3$d(ctx) {
		let t_value = /*$LOCALE*/ ctx[13][/*label*/ ctx[1]] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, label*/ 8194 && t_value !== (t_value = /*$LOCALE*/ ctx[13][/*label*/ ctx[1]] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (70:8) {:else}
	function create_else_block$k(ctx) {
		let uibooleans;
		let current;
		uibooleans = new Ui_booleans({ props: { values: [{ value: false }] } });

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	// (68:8) {#if value}
	function create_if_block_1$q(ctx) {
		let uibooleans;
		let current;
		uibooleans = new Ui_booleans({ props: { values: [{ value: true }] } });

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	function create_fragment$M(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		const if_block_creators = [create_if_block$w, create_else_block_1$4];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[24](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[25](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[26](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[4]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", "control");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 16) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[4];

				if (!updating_errors && dirty & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$M($$self, $$props, $$invalidate) {
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = false } = $$props;
		let { label = "" } = $$props;
		let { hideLabel = false } = $$props;
		let { placeholder = "input some text here, please" } = $$props;
		let { fieldname = "textfield" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { styling = " is-rounded is-success " } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.type === "checkbox"
				? ev.currentTarget.checked
				: value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.type === "checkbox"
				? ev.currentTarget.checked
				: value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_change_handler() {
			value = this.checked;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(20, errors)), $$invalidate(21, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(19, validated)), $$invalidate(18, valid)), $$invalidate(16, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(18, valid)), $$invalidate(16, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(16, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
			if ('hideLabel' in $$props) $$invalidate(2, hideLabel = $$props.hideLabel);
			if ('placeholder' in $$props) $$invalidate(3, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(4, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(17, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(18, valid = $$props.valid);
			if ('styling' in $$props) $$invalidate(8, styling = $$props.styling);
			if ('validated' in $$props) $$invalidate(19, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(20, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(21, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(22, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 131072) ;

			if ($$self.$$.dirty & /*errors, formErrors*/ 3145728) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 851968) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 4456448) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 327680) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			label,
			hideLabel,
			placeholder,
			fieldname,
			required,
			readonly,
			disabled,
			styling,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			icon,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	let Ui_switch$1 = class Ui_switch extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$M, create_fragment$M, safe_not_equal, {
				inputStarted: 16,
				value: 0,
				label: 1,
				hideLabel: 2,
				placeholder: 3,
				fieldname: 4,
				icon: 17,
				required: 5,
				readonly: 6,
				disabled: 7,
				valid: 18,
				styling: 8,
				validated: 19,
				errors: 20,
				formErrors: 21,
				formLevelError: 22
			});
		}
	};

	/* node_modules/not-bulma/src/elements/form/ui.tag.select.svelte generated by Svelte v4.2.19 */

	function get_each_context$d(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		return child_ctx;
	}

	function get_each_context_1$5(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[33] = list[i];
		return child_ctx;
	}

	// (126:16) {#if !readonly}
	function create_if_block_1$p(ctx) {
		let button;
		let button_data_id_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				attr(button, "data-id", button_data_id_value = /*item*/ ctx[33].id);
				attr(button, "class", "delete is-small");
			},
			m(target, anchor) {
				insert(target, button, anchor);

				if (!mounted) {
					dispose = listen(button, "click", /*remove*/ ctx[8]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*items*/ 64 && button_data_id_value !== (button_data_id_value = /*item*/ ctx[33].id)) {
					attr(button, "data-id", button_data_id_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (123:8) {#each items as item (item.id)}
	function create_each_block_1$5(key_1, ctx) {
		let span;
		let t0_value = /*$LOCALE*/ ctx[7][/*item*/ ctx[33].title] + "";
		let t0;
		let t1;
		let t2;
		let span_class_value;
		let if_block = !/*readonly*/ ctx[2] && create_if_block_1$p(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				if (if_block) if_block.c();
				t2 = space();
				attr(span, "class", span_class_value = "mx-1 tag is-" + /*item*/ ctx[33].type);
				this.first = span;
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t0);
				append(span, t1);
				if (if_block) if_block.m(span, null);
				append(span, t2);
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty[0] & /*$LOCALE, items*/ 192 && t0_value !== (t0_value = /*$LOCALE*/ ctx[7][/*item*/ ctx[33].title] + "")) set_data(t0, t0_value);

				if (!/*readonly*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$p(ctx);
						if_block.c();
						if_block.m(span, t2);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty[0] & /*items*/ 64 && span_class_value !== (span_class_value = "mx-1 tag is-" + /*item*/ ctx[33].type)) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (136:4) {#if !readonly}
	function create_if_block$v(ctx) {
		let div2;
		let div1;
		let div0;
		let select;
		let option;
		let t0_value = /*$LOCALE*/ ctx[7][LC_SELECT_FROM_LIST] + "";
		let t0;
		let t1;
		let button;
		let t2_value = /*$LOCALE*/ ctx[7][LC_ADD] + "";
		let t2;
		let mounted;
		let dispose;
		let each_value = ensure_array_like(/*variants*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
		}

		return {
			c() {
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				select = element("select");
				option = element("option");
				t0 = text(t0_value);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t1 = space();
				button = element("button");
				t2 = text(t2_value);
				option.__value = "-1";
				set_input_value(option, option.__value);
				option.selected = true;
				attr(div0, "class", "select is-small");
				attr(button, "class", "button is-primary is-small");
				attr(div1, "class", "control");
				attr(div2, "class", "column");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				append(div1, div0);
				append(div0, select);
				append(select, option);
				append(option, t0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(select, null);
					}
				}

				append(div1, t1);
				append(div1, button);
				append(button, t2);

				if (!mounted) {
					dispose = listen(button, "click", /*add*/ ctx[9]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE*/ 128 && t0_value !== (t0_value = /*$LOCALE*/ ctx[7][LC_SELECT_FROM_LIST] + "")) set_data(t0, t0_value);

				if (dirty[0] & /*variants, $LOCALE*/ 129) {
					each_value = ensure_array_like(/*variants*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$d(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$d(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(select, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty[0] & /*$LOCALE*/ 128 && t2_value !== (t2_value = /*$LOCALE*/ ctx[7][LC_ADD] + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				destroy_each(each_blocks, detaching);
				mounted = false;
				dispose();
			}
		};
	}

	// (144:24) {#each variants as variant}
	function create_each_block$d(ctx) {
		let option;
		let t_value = /*$LOCALE*/ ctx[7][/*variant*/ ctx[30].title] + "";
		let t;
		let option_value_value;

		return {
			c() {
				option = element("option");
				t = text(t_value);
				option.__value = option_value_value = /*variant*/ ctx[30].id;
				set_input_value(option, option.__value);
			},
			m(target, anchor) {
				insert(target, option, anchor);
				append(option, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, variants*/ 129 && t_value !== (t_value = /*$LOCALE*/ ctx[7][/*variant*/ ctx[30].title] + "")) set_data(t, t_value);

				if (dirty[0] & /*variants*/ 1 && option_value_value !== (option_value_value = /*variant*/ ctx[30].id)) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	function create_fragment$L(ctx) {
		let div1;
		let div0;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div0_class_value;
		let t0;
		let t1;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		let each_value_1 = ensure_array_like(/*items*/ ctx[6]);
		const get_key = ctx => /*item*/ ctx[33].id;

		for (let i = 0; i < each_value_1.length; i += 1) {
			let child_ctx = get_each_context_1$5(ctx, each_value_1, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block_1$5(key, child_ctx));
		}

		let if_block = !/*readonly*/ ctx[2] && create_if_block$v(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[1]
		};

		if (/*allErrors*/ ctx[5] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[5];
		}

		if (/*showErrors*/ ctx[4] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[4];
		}

		if (/*validationClasses*/ ctx[3] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[3];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div1 = element("div");
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t0 = space();
				if (if_block) if_block.c();
				t1 = space();
				create_component(errorslist.$$.fragment);
				attr(div0, "class", div0_class_value = "column " + /*validationClasses*/ ctx[3]);
				attr(div1, "class", "control columns");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				append(div1, t0);
				if (if_block) if_block.m(div1, null);
				insert(target, t1, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*items, remove, readonly, $LOCALE*/ 452) {
					each_value_1 = ensure_array_like(/*items*/ ctx[6]);
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div0, destroy_block, create_each_block_1$5, null, get_each_context_1$5);
				}

				if (!current || dirty[0] & /*validationClasses*/ 8 && div0_class_value !== (div0_class_value = "column " + /*validationClasses*/ ctx[3])) {
					attr(div0, "class", div0_class_value);
				}

				if (!/*readonly*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$v(ctx);
						if_block.c();
						if_block.m(div1, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 2) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[1];

				if (!updating_errors && dirty[0] & /*allErrors*/ 32) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[5];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 16) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[4];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 8) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[3];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
					detach(t1);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}

				if (if_block) if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	const LC_ADD = "not-node:add_label";
	const LC_SELECT_FROM_LIST = "not-node:select_from_list_label";

	function instance$L($$self, $$props, $$invalidate) {
		let items;
		let allErrors;
		let showErrors;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(7, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { value = [] } = $$props;
		let { inputStarted = false } = $$props;
		let { variants = [] } = $$props;
		let { fieldname = "tag" } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		onMount(() => {
			clearValueFromDeadVariants();
		});

		let { beforeAdd = () => /*variant, variants*/
		{
			return true;
		} } = $$props;

		let { getItemId = variant => {
			return variant.id;
		} } = $$props;

		let { getItemTitle = variant => {
			return variant.title;
		} } = $$props;

		let { getItemType = variant => {
			return "info";
		} } = $$props;

		let { buildItem = variant => {
			return {
				id: getItemId(variant),
				title: getItemTitle(variant),
				type: getItemType(variant)
			};
		} } = $$props;

		function variantIdToVariant(id) {
			return variants.find(variant => getItemId(variant) === id);
		}

		function changeEvent() {
			let data = { field: fieldname, value };
			dispatch("change", data);
		}

		function remove(e) {
			e && e.preventDefault();
			let id = e.currentTarget.dataset.id;

			if (value.includes(id)) {
				value.splice(value.indexOf(id), 1);
				$$invalidate(10, value);
				changeEvent();
			}

			return false;
		}

		function add(e) {
			e && e.preventDefault();
			let id = e.currentTarget.parentNode.querySelector("select").value;
			const variant = variantIdToVariant(id);

			if (!variant) {
				return false;
			}

			if (!beforeAdd(variant, variants)) {
				return false;
			}

			if (id && value.indexOf(id) === -1) {
				value.push(id);
				$$invalidate(10, value);
				changeEvent();
			}

			return false;
		}

		function clearValueFromDeadVariants() {
			$$invalidate(10, value = value.filter(id => {
				return variantIdToVariant(id);
			}));

			return value;
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(5, allErrors), $$invalidate(14, errors)), $$invalidate(15, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(4, showErrors), $$invalidate(13, validated)), $$invalidate(12, valid)), $$invalidate(11, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(3, validationClasses), $$invalidate(12, valid)), $$invalidate(11, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(10, value = $$props.value);
			if ('inputStarted' in $$props) $$invalidate(11, inputStarted = $$props.inputStarted);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('readonly' in $$props) $$invalidate(2, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(12, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(13, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(14, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(15, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(16, formLevelError = $$props.formLevelError);
			if ('beforeAdd' in $$props) $$invalidate(17, beforeAdd = $$props.beforeAdd);
			if ('getItemId' in $$props) $$invalidate(18, getItemId = $$props.getItemId);
			if ('getItemTitle' in $$props) $$invalidate(19, getItemTitle = $$props.getItemTitle);
			if ('getItemType' in $$props) $$invalidate(20, getItemType = $$props.getItemType);
			if ('buildItem' in $$props) $$invalidate(21, buildItem = $$props.buildItem);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*value, buildItem*/ 2098176) {
				/*
	item = {
	  id,        //unique
	  title,     //some text
	  type       //for coloring items, usual html template names danger, success, etc
	}
	*/
				$$invalidate(6, items = value.map(variantIdToVariant).filter(variant => variant).map(buildItem));
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 49152) {
				$$invalidate(5, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 14336) {
				$$invalidate(4, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 69632) ;

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 6144) {
				$$invalidate(3, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			variants,
			fieldname,
			readonly,
			validationClasses,
			showErrors,
			allErrors,
			items,
			$LOCALE,
			remove,
			add,
			value,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			beforeAdd,
			getItemId,
			getItemTitle,
			getItemType,
			buildItem,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_tag_select extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$L,
				create_fragment$L,
				safe_not_equal,
				{
					value: 10,
					inputStarted: 11,
					variants: 0,
					fieldname: 1,
					readonly: 2,
					valid: 12,
					validated: 13,
					errors: 14,
					formErrors: 15,
					formLevelError: 16,
					beforeAdd: 17,
					getItemId: 18,
					getItemTitle: 19,
					getItemType: 20,
					buildItem: 21
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.telephone.svelte generated by Svelte v4.2.19 */

	function create_else_block$j(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4$8(ctx);
		let if_block1 = /*validated*/ ctx[7] === true && create_if_block_1$o(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-telephone-" + /*fieldname*/ ctx[2]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[8]);
				attr(input, "type", "tel");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[9]);
				input.required = /*required*/ ctx[4];
				input.readOnly = /*readonly*/ ctx[5];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[20]),
						listen(input, "change", /*onBlur*/ ctx[14]),
						listen(input, "input", /*onInput*/ ctx[15])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-telephone-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*validationClasses*/ 256 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[8])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*invalid*/ 512) {
					attr(input, "invalid", /*invalid*/ ctx[9]);
				}

				if (dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (dirty & /*$LOCALE, placeholder*/ 8194 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$8(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[7] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$o(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (61:4) {#if readonly}
	function create_if_block$u(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (80:8) {#if icon}
	function create_if_block_4$8(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (85:8) {#if validated === true}
	function create_if_block_1$o(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[6] === true) return create_if_block_2$g;
			if (/*valid*/ ctx[6] === false) return create_if_block_3$c;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (89:42) 
	function create_if_block_3$c(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (87:16) {#if valid === true}
	function create_if_block_2$g(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$K(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[5]) return create_if_block$u;
			return create_else_block$j;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[21](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[22](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[23](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[11] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[11];
		}

		if (/*showErrors*/ ctx[10] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[10];
		}

		if (/*validationClasses*/ ctx[8] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[8];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[12]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 4096 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[12])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 2048) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[11];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 1024) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[10];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 256) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[8];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$K($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "+7 (987) 654-32-10" } = $$props;
		let { fieldname = "telephone" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			ev.preventDefault();
			let val = UICommon.formatPhone(ev.currentTarget.value);
			let data = { field: fieldname, value: val };
			$$invalidate(0, value = val);
			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return false;
		}

		function onInput(ev) {
			ev.preventDefault();
			let val = UICommon.formatPhone(ev.currentTarget.value);
			let data = { field: fieldname, value: val };
			$$invalidate(0, value = val);
			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return false;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(11, allErrors), $$invalidate(17, errors)), $$invalidate(18, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(10, showErrors), $$invalidate(7, validated)), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(8, validationClasses), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(16, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(7, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(17, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(18, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(19, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(12, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 393216) {
				$$invalidate(11, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 65728) {
				$$invalidate(10, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 524352) {
				$$invalidate(9, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 65600) {
				$$invalidate(8, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_telephone extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$K, create_fragment$K, safe_not_equal, {
				inputStarted: 16,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				readonly: 5,
				valid: 6,
				validated: 7,
				errors: 17,
				formErrors: 18,
				formLevelError: 19
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.textarea.svelte generated by Svelte v4.2.19 */

	function create_else_block$i(ctx) {
		let textarea;
		let textarea_id_value;
		let textarea_class_value;
		let textarea_placeholder_value;
		let textarea_aria_controls_value;
		let textarea_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4$7(ctx);
		let if_block1 = /*validated*/ ctx[9] === true && create_if_block_1$n(ctx);

		return {
			c() {
				textarea = element("textarea");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(textarea, "id", textarea_id_value = "form-field-textarea-" + /*fieldname*/ ctx[2]);
				attr(textarea, "invalid", /*invalid*/ ctx[11]);
				textarea.disabled = /*disabled*/ ctx[7];
				textarea.required = /*required*/ ctx[5];
				textarea.readOnly = /*readonly*/ ctx[6];
				attr(textarea, "class", textarea_class_value = "textarea " + /*validationClasses*/ ctx[10]);
				attr(textarea, "name", /*fieldname*/ ctx[2]);
				attr(textarea, "placeholder", textarea_placeholder_value = /*$LOCALE*/ ctx[15][/*placeholder*/ ctx[1]]);
				attr(textarea, "rows", /*rows*/ ctx[4]);
				attr(textarea, "aria-controls", textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(textarea, "aria-describedby", textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, textarea, anchor);
				set_input_value(textarea, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(textarea, "blur", /*onBlur*/ ctx[16]),
						listen(textarea, "input", /*textarea_input_handler*/ ctx[21])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 4 && textarea_id_value !== (textarea_id_value = "form-field-textarea-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "id", textarea_id_value);
				}

				if (dirty & /*invalid*/ 2048) {
					attr(textarea, "invalid", /*invalid*/ ctx[11]);
				}

				if (dirty & /*disabled*/ 128) {
					textarea.disabled = /*disabled*/ ctx[7];
				}

				if (dirty & /*required*/ 32) {
					textarea.required = /*required*/ ctx[5];
				}

				if (dirty & /*readonly*/ 64) {
					textarea.readOnly = /*readonly*/ ctx[6];
				}

				if (dirty & /*validationClasses*/ 1024 && textarea_class_value !== (textarea_class_value = "textarea " + /*validationClasses*/ ctx[10])) {
					attr(textarea, "class", textarea_class_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(textarea, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*$LOCALE, placeholder*/ 32770 && textarea_placeholder_value !== (textarea_placeholder_value = /*$LOCALE*/ ctx[15][/*placeholder*/ ctx[1]])) {
					attr(textarea, "placeholder", textarea_placeholder_value);
				}

				if (dirty & /*rows*/ 16) {
					attr(textarea, "rows", /*rows*/ ctx[4]);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_controls_value !== (textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-controls", textarea_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_describedby_value !== (textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-describedby", textarea_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(textarea, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$7(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[9] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$n(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(textarea);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (60:4) {#if readonly}
	function create_if_block$t(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (78:8) {#if icon}
	function create_if_block_4$7(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (83:8) {#if validated === true}
	function create_if_block_1$n(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[8] === true) return create_if_block_2$f;
			if (/*valid*/ ctx[8] === false) return create_if_block_3$b;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (87:42) 
	function create_if_block_3$b(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (85:16) {#if valid === true}
	function create_if_block_2$f(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$J(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return create_if_block$t;
			return create_else_block$i;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[13] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[13];
		}

		if (/*showErrors*/ ctx[12] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[12];
		}

		if (/*validationClasses*/ ctx[10] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[10];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[14]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 16384 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[14])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 8192) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[13];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 4096) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[12];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 1024) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[10];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$J($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(15, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "input some text here, please" } = $$props;
		let { fieldname = "textarea" } = $$props;
		let { icon = false } = $$props;
		let { rows = 10 } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.target.type === "checkbox"
				? ev.target.checked
				: ev.target.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function textarea_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(13, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(12, showErrors), $$invalidate(9, validated)), $$invalidate(8, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(10, validationClasses), $$invalidate(8, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('rows' in $$props) $$invalidate(4, rows = $$props.rows);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(8, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(9, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(14, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 786432) {
				$$invalidate(13, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131840) {
				$$invalidate(12, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 1048832) {
				$$invalidate(11, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131328) {
				$$invalidate(10, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			rows,
			required,
			readonly,
			disabled,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			textarea_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_textarea extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$J, create_fragment$J, safe_not_equal, {
				inputStarted: 17,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				rows: 4,
				required: 5,
				readonly: 6,
				disabled: 7,
				valid: 8,
				validated: 9,
				errors: 18,
				formErrors: 19,
				formLevelError: 20
			});
		}
	}

	var index$7 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIAutocomplete: Ui_autocomplete,
		UICheckbox: Ui_checkbox,
		UICheckboxList: Ui_checkbox_list,
		UIColor: Ui_color,
		UIControl: Ui_control,
		UIDate: Ui_date,
		UIDatetimeInTZ: Ui_datetime_in_tz,
		UIEmail: Ui_email,
		UIHidden: Ui_hidden,
		UILabel: Ui_label,
		UIListOfModels: Ui_list_of_models,
		UINamedNumbersList: Ui_named_numbers_list,
		UINumber: Ui_number,
		UIPassword: Ui_password,
		UIRadioButtons: Ui_radio_buttons,
		UIRange: Ui_range,
		UIRangeLogarithmic: Ui_range_logarithmic,
		UISelect: Ui_select,
		UISelectFromModel: Ui_select_from_model,
		UISwitch: Ui_switch$1,
		UITagSelect: Ui_tag_select,
		UITelephone: Ui_telephone,
		UITextarea: Ui_textarea,
		UITextfield: Ui_textfield
	});

	/* node_modules/not-bulma/src/elements/icon/ui.icon.button.with.tag.svelte generated by Svelte v4.2.19 */

	function create_fragment$I(ctx) {
		let uibutton;
		let t;
		let uitag;
		let current;
		const uibutton_spread_levels = [/*button*/ ctx[0]];
		let uibutton_props = {};

		for (let i = 0; i < uibutton_spread_levels.length; i += 1) {
			uibutton_props = assign(uibutton_props, uibutton_spread_levels[i]);
		}

		uibutton = new Ui_button({ props: uibutton_props });
		const uitag_spread_levels = [/*tag*/ ctx[1], { classes: "is-top-right" }];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uibutton.$$.fragment);
				t = space();
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				insert(target, t, anchor);
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibutton_changes = (dirty & /*button*/ 1)
				? get_spread_update(uibutton_spread_levels, [get_spread_object(/*button*/ ctx[0])])
				: {};

				uibutton.$set(uibutton_changes);

				const uitag_changes = (dirty & /*tag*/ 2)
				? get_spread_update(uitag_spread_levels, [get_spread_object(/*tag*/ ctx[1]), uitag_spread_levels[1]])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}

				destroy_component(uibutton, detaching);
				destroy_component(uitag, detaching);
			}
		};
	}

	function instance$I($$self, $$props, $$invalidate) {
		let { button = {} } = $$props;
		let { tag = {} } = $$props;

		$$self.$$set = $$props => {
			if ('button' in $$props) $$invalidate(0, button = $$props.button);
			if ('tag' in $$props) $$invalidate(1, tag = $$props.tag);
		};

		return [button, tag];
	}

	class Ui_icon_button_with_tag extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$I, create_fragment$I, safe_not_equal, { button: 0, tag: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/icon/ui.icon.floating.svelte generated by Svelte v4.2.19 */

	function create_fragment$H(ctx) {
		let div;
		let uibutton;
		let current;
		const uibutton_spread_levels = [{ action: toggle }, /*trigger*/ ctx[0]];
		let uibutton_props = {};

		for (let i = 0; i < uibutton_spread_levels.length; i += 1) {
			uibutton_props = assign(uibutton_props, uibutton_spread_levels[i]);
		}

		uibutton = new Ui_button({ props: uibutton_props });

		return {
			c() {
				div = element("div");
				create_component(uibutton.$$.fragment);
				attr(div, "class", "is-fab svelte-1haul9u");
				attr(div, "style", /*positionStyle*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uibutton, div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibutton_changes = (dirty & /*toggle, trigger*/ 1)
				? get_spread_update(uibutton_spread_levels, [
						dirty & /*toggle*/ 0 && { action: toggle },
						dirty & /*trigger*/ 1 && get_spread_object(/*trigger*/ ctx[0])
					])
				: {};

				uibutton.$set(uibutton_changes);

				if (!current || dirty & /*positionStyle*/ 2) {
					attr(div, "style", /*positionStyle*/ ctx[1]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uibutton);
			}
		};
	}

	function toggle() {
		
	}

	function instance$H($$self, $$props, $$invalidate) {
		let { trigger = {
			title: 'Click me!',
			icon: 'plus',
			color: 'primary',
			size: 'medium'
		} } = $$props;

		let positionStyle = '';

		onMount(() => {
			$$invalidate(1, positionStyle = '');
		});

		$$self.$$set = $$props => {
			if ('trigger' in $$props) $$invalidate(0, trigger = $$props.trigger);
		};

		return [trigger, positionStyle];
	}

	class Ui_icon_floating extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$H, create_fragment$H, safe_not_equal, { trigger: 0 });
		}
	}

	/* node_modules/not-bulma/src/elements/icon/ui.icon.font.svelte generated by Svelte v4.2.19 */

	function create_else_block$h(ctx) {
		let span;
		let i;
		let i_class_value;
		let span_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*font*/ ctx[1]);
				attr(span, "class", span_class_value = "" + (/*pointable*/ ctx[3] ? 'is-clickable' : '') + " icon " + (/*size*/ ctx[2] ? `is-${/*size*/ ctx[2]}` : '') + " " + (/*size*/ ctx[2] == 'medium' ? 'fa-lg' : '') + " " + (/*size*/ ctx[2] == 'large' ? 'fa-2x' : ''));
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*font*/ 2 && i_class_value !== (i_class_value = "fas fa-" + /*font*/ ctx[1])) {
					attr(i, "class", i_class_value);
				}

				if (dirty & /*pointable, size*/ 12 && span_class_value !== (span_class_value = "" + (/*pointable*/ ctx[3] ? 'is-clickable' : '') + " icon " + (/*size*/ ctx[2] ? `is-${/*size*/ ctx[2]}` : '') + " " + (/*size*/ ctx[2] == 'medium' ? 'fa-lg' : '') + " " + (/*size*/ ctx[2] == 'large' ? 'fa-2x' : ''))) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (21:0) {#if title}
	function create_if_block$s(ctx) {
		let span2;
		let span1;
		let i;
		let i_class_value;
		let t0;
		let span0;
		let t1_value = /*$LOCALE*/ ctx[4][/*title*/ ctx[0]] + "";
		let t1;
		let span1_class_value;
		let span2_class_value;

		return {
			c() {
				span2 = element("span");
				span1 = element("span");
				i = element("i");
				t0 = space();
				span0 = element("span");
				t1 = text(t1_value);
				attr(i, "class", i_class_value = "is-title-icon fas fa-" + /*font*/ ctx[1] + " " + (/*size*/ ctx[2] == 'medium' ? 'fa-lg' : '') + " " + (/*size*/ ctx[2] == 'large' ? 'fa-2x' : '') + "");
				attr(span1, "class", span1_class_value = "icon " + (/*size*/ ctx[2] ? `is-${/*size*/ ctx[2]}` : ''));
				attr(span2, "class", span2_class_value = "icon-text " + (/*pointable*/ ctx[3] ? 'is-clickable' : ''));
			},
			m(target, anchor) {
				insert(target, span2, anchor);
				append(span2, span1);
				append(span1, i);
				append(span1, t0);
				append(span1, span0);
				append(span0, t1);
			},
			p(ctx, dirty) {
				if (dirty & /*font, size*/ 6 && i_class_value !== (i_class_value = "is-title-icon fas fa-" + /*font*/ ctx[1] + " " + (/*size*/ ctx[2] == 'medium' ? 'fa-lg' : '') + " " + (/*size*/ ctx[2] == 'large' ? 'fa-2x' : '') + "")) {
					attr(i, "class", i_class_value);
				}

				if (dirty & /*$LOCALE, title*/ 17 && t1_value !== (t1_value = /*$LOCALE*/ ctx[4][/*title*/ ctx[0]] + "")) set_data(t1, t1_value);

				if (dirty & /*size*/ 4 && span1_class_value !== (span1_class_value = "icon " + (/*size*/ ctx[2] ? `is-${/*size*/ ctx[2]}` : ''))) {
					attr(span1, "class", span1_class_value);
				}

				if (dirty & /*pointable*/ 8 && span2_class_value !== (span2_class_value = "icon-text " + (/*pointable*/ ctx[3] ? 'is-clickable' : ''))) {
					attr(span2, "class", span2_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span2);
				}
			}
		};
	}

	function create_fragment$G(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*title*/ ctx[0]) return create_if_block$s;
			return create_else_block$h;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function instance$G($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(4, $LOCALE = $$value));
		let { title = "" } = $$props;
		let { font = "" } = $$props;
		let { size = "" } = $$props;
		let { pointable = false } = $$props;

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('font' in $$props) $$invalidate(1, font = $$props.font);
			if ('size' in $$props) $$invalidate(2, size = $$props.size);
			if ('pointable' in $$props) $$invalidate(3, pointable = $$props.pointable);
		};

		return [title, font, size, pointable, $LOCALE];
	}

	class Ui_icon_font extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$G, create_fragment$G, safe_not_equal, { title: 0, font: 1, size: 2, pointable: 3 });
		}
	}

	/* node_modules/not-bulma/src/elements/icon/ui.icon.svelte generated by Svelte v4.2.19 */

	function create_if_block_2$e(ctx) {
		let figure;
		let img;
		let img_src_value;
		let figure_class_value;

		return {
			c() {
				figure = element("figure");
				img = element("img");
				if (!src_url_equal(img.src, img_src_value = /*src*/ ctx[4])) attr(img, "src", img_src_value);
				attr(img, "title", /*title*/ ctx[0]);
				attr(img, "alt", /*title*/ ctx[0]);
				attr(img, "width", /*width*/ ctx[5]);
				attr(img, "height", /*height*/ ctx[6]);

				attr(figure, "class", figure_class_value = "image " + (/*width*/ ctx[5] && /*height*/ ctx[6]
				? `is-${/*width*/ ctx[5]}x${/*height*/ ctx[6]}`
				: '') + "");
			},
			m(target, anchor) {
				insert(target, figure, anchor);
				append(figure, img);
			},
			p(ctx, dirty) {
				if (dirty & /*src*/ 16 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[4])) {
					attr(img, "src", img_src_value);
				}

				if (dirty & /*title*/ 1) {
					attr(img, "title", /*title*/ ctx[0]);
				}

				if (dirty & /*title*/ 1) {
					attr(img, "alt", /*title*/ ctx[0]);
				}

				if (dirty & /*width*/ 32) {
					attr(img, "width", /*width*/ ctx[5]);
				}

				if (dirty & /*height*/ 64) {
					attr(img, "height", /*height*/ ctx[6]);
				}

				if (dirty & /*width, height*/ 96 && figure_class_value !== (figure_class_value = "image " + (/*width*/ ctx[5] && /*height*/ ctx[6]
				? `is-${/*width*/ ctx[5]}x${/*height*/ ctx[6]}`
				: '') + "")) {
					attr(figure, "class", figure_class_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(figure);
				}
			}
		};
	}

	// (18:15) 
	function create_if_block_1$m(ctx) {
		let span;

		return {
			c() {
				span = element("span");
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				span.innerHTML = /*svg*/ ctx[3];
			},
			p(ctx, dirty) {
				if (dirty & /*svg*/ 8) span.innerHTML = /*svg*/ ctx[3];		},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (16:0) {#if font }
	function create_if_block$r(ctx) {
		let uiiconfont;
		let current;

		uiiconfont = new Ui_icon_font({
				props: {
					font: /*font*/ ctx[2],
					size: /*size*/ ctx[1],
					title: /*title*/ ctx[0]
				}
			});

		return {
			c() {
				create_component(uiiconfont.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiiconfont, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiiconfont_changes = {};
				if (dirty & /*font*/ 4) uiiconfont_changes.font = /*font*/ ctx[2];
				if (dirty & /*size*/ 2) uiiconfont_changes.size = /*size*/ ctx[1];
				if (dirty & /*title*/ 1) uiiconfont_changes.title = /*title*/ ctx[0];
				uiiconfont.$set(uiiconfont_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiiconfont.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiiconfont.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiiconfont, detaching);
			}
		};
	}

	function create_fragment$F(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$r, create_if_block_1$m, create_if_block_2$e];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*font*/ ctx[2]) return 0;
			if (/*svg*/ ctx[3]) return 1;
			if (/*src*/ ctx[4]) return 2;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						} else {
							if_block.p(ctx, dirty);
						}

						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}
			}
		};
	}

	function instance$F($$self, $$props, $$invalidate) {
		let { title = '' } = $$props;
		let { size = '' } = $$props;
		let { font = '' } = $$props;
		let { svg = '' } = $$props;
		let { src = '' } = $$props;
		let { width } = $$props;
		let { height } = $$props;

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
			if ('font' in $$props) $$invalidate(2, font = $$props.font);
			if ('svg' in $$props) $$invalidate(3, svg = $$props.svg);
			if ('src' in $$props) $$invalidate(4, src = $$props.src);
			if ('width' in $$props) $$invalidate(5, width = $$props.width);
			if ('height' in $$props) $$invalidate(6, height = $$props.height);
		};

		return [title, size, font, svg, src, width, height];
	}

	class Ui_icon extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$F, create_fragment$F, safe_not_equal, {
				title: 0,
				size: 1,
				font: 2,
				svg: 3,
				src: 4,
				width: 5,
				height: 6
			});
		}
	}

	var index$6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIIcon: Ui_icon,
		UIIconButtonWithTag: Ui_icon_button_with_tag,
		UIIconFloating: Ui_icon_floating,
		UIIconFont: Ui_icon_font
	});

	/* node_modules/not-bulma/src/elements/image/ui.images.svelte generated by Svelte v4.2.19 */

	function get_each_context$c(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[2] = list[i];
		return child_ctx;
	}

	// (6:0) {#each values as item (item.url)}
	function create_each_block$c(key_1, ctx) {
		let first;
		let uiimage;
		let current;
		const uiimage_spread_levels = [/*item*/ ctx[2]];
		let uiimage_props = {};

		for (let i = 0; i < uiimage_spread_levels.length; i += 1) {
			uiimage_props = assign(uiimage_props, uiimage_spread_levels[i]);
		}

		uiimage = new Ui_image({ props: uiimage_props });
		uiimage.$on("click", /*click_handler*/ ctx[1]);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uiimage.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uiimage, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				const uiimage_changes = (dirty & /*values*/ 1)
				? get_spread_update(uiimage_spread_levels, [get_spread_object(/*item*/ ctx[2])])
				: {};

				uiimage.$set(uiimage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiimage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiimage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uiimage, detaching);
			}
		};
	}

	function create_fragment$E(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[2].url;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$c(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$c(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*values*/ 1) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$c, each_1_anchor, get_each_context$c);
					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	function instance$E($$self, $$props, $$invalidate) {
		let { values = [] } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
		};

		return [values, click_handler];
	}

	class Ui_images extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$E, create_fragment$E, safe_not_equal, { values: 0 });
		}
	}

	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIImage: Ui_image,
		UIImages: Ui_images
	});

	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UILink: Ui_link,
		UILinks: Ui_links
	});

	/* node_modules/not-bulma/src/elements/list/endless/ui.endless.list.navigation.svelte generated by Svelte v4.2.19 */

	function create_if_block$q(ctx) {
		let div2;
		let div0;
		let t0;
		let t1;
		let div1;
		let current;
		let if_block0 = /*page*/ ctx[0] > 1 && create_if_block_3$a(ctx);
		let if_block1 = /*pages*/ ctx[1] > 1 && create_if_block_2$d(ctx);
		let if_block2 = /*page*/ ctx[0] < /*pages*/ ctx[1] && create_if_block_1$l(ctx);

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				div1 = element("div");
				if (if_block2) if_block2.c();
				attr(div0, "class", "column");
				attr(div1, "class", "column");
				attr(div2, "class", "columns");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				if (if_block0) if_block0.m(div0, null);
				append(div2, t0);
				if (if_block1) if_block1.m(div2, null);
				append(div2, t1);
				append(div2, div1);
				if (if_block2) if_block2.m(div1, null);
				current = true;
			},
			p(ctx, dirty) {
				if (/*page*/ ctx[0] > 1) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*page*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_3$a(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*pages*/ ctx[1] > 1) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$d(ctx);
						if_block1.c();
						if_block1.m(div2, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*page*/ ctx[0] < /*pages*/ ctx[1]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*page, pages*/ 3) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_1$l(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div1, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (21:8) {#if page > 1 }
	function create_if_block_3$a(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*buttonComponentProps*/ ctx[3], { action: /*func*/ ctx[6] }];
		var switch_value = /*buttonComponent*/ ctx[2];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*buttonComponentProps, dispatch*/ 40) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*buttonComponentProps*/ 8 && get_spread_object(/*buttonComponentProps*/ ctx[3]),
					dirty & /*dispatch*/ 32 && { action: /*func*/ ctx[6] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*buttonComponent*/ 4 && switch_value !== (switch_value = /*buttonComponent*/ ctx[2])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*buttonComponentProps, dispatch*/ 40)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*buttonComponentProps*/ 8 && get_spread_object(/*buttonComponentProps*/ ctx[3]),
							dirty & /*dispatch*/ 32 && { action: /*func*/ ctx[6] }
						])
					: {};

					if (dirty & /*$$scope, $LOCALE*/ 272) {
						switch_instance_changes.$$scope = { dirty, ctx };
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (22:8) <svelte:component             this={buttonComponent}                         {...buttonComponentProps}             action={() => dispatch('prev')}             >
	function create_default_slot_1$3(ctx) {
		let t_value = /*$LOCALE*/ ctx[4]['not-node:list_navigation_prev_button_label'] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE*/ 16 && t_value !== (t_value = /*$LOCALE*/ ctx[4]['not-node:list_navigation_prev_button_label'] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (29:4) {#if pages > 1 }
	function create_if_block_2$d(ctx) {
		let div;
		let t0;
		let t1;
		let t2;

		return {
			c() {
				div = element("div");
				t0 = text(/*page*/ ctx[0]);
				t1 = text(" / ");
				t2 = text(/*pages*/ ctx[1]);
				attr(div, "class", "column box");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, t2);
			},
			p(ctx, dirty) {
				if (dirty & /*page*/ 1) set_data(t0, /*page*/ ctx[0]);
				if (dirty & /*pages*/ 2) set_data(t2, /*pages*/ ctx[1]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (35:8) {#if page < pages }
	function create_if_block_1$l(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*buttonComponentProps*/ ctx[3], { action: /*func_1*/ ctx[7] }];
		var switch_value = /*buttonComponent*/ ctx[2];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*buttonComponentProps, dispatch*/ 40) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*buttonComponentProps*/ 8 && get_spread_object(/*buttonComponentProps*/ ctx[3]),
					dirty & /*dispatch*/ 32 && { action: /*func_1*/ ctx[7] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*buttonComponent*/ 4 && switch_value !== (switch_value = /*buttonComponent*/ ctx[2])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*buttonComponentProps, dispatch*/ 40)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*buttonComponentProps*/ 8 && get_spread_object(/*buttonComponentProps*/ ctx[3]),
							dirty & /*dispatch*/ 32 && { action: /*func_1*/ ctx[7] }
						])
					: {};

					if (dirty & /*$$scope, $LOCALE*/ 272) {
						switch_instance_changes.$$scope = { dirty, ctx };
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (36:8) <svelte:component             this={buttonComponent}                         {...buttonComponentProps}             action={() => dispatch('next')}             >
	function create_default_slot$5(ctx) {
		let t_value = /*$LOCALE*/ ctx[4]['not-node:list_navigation_next_button_label'] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE*/ 16 && t_value !== (t_value = /*$LOCALE*/ ctx[4]['not-node:list_navigation_next_button_label'] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	function create_fragment$D(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*pages*/ ctx[1] > 0 && create_if_block$q(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*pages*/ ctx[1] > 0) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*pages*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$q(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$D($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(4, $LOCALE = $$value));
		const dispatch = createEventDispatcher();
		let { page = 0 } = $$props;
		let { pages = 0 } = $$props;
		let { buttonComponent = Ui_button } = $$props;
		let { buttonComponentProps = {} } = $$props;
		const func = () => dispatch('prev');
		const func_1 = () => dispatch('next');

		$$self.$$set = $$props => {
			if ('page' in $$props) $$invalidate(0, page = $$props.page);
			if ('pages' in $$props) $$invalidate(1, pages = $$props.pages);
			if ('buttonComponent' in $$props) $$invalidate(2, buttonComponent = $$props.buttonComponent);
			if ('buttonComponentProps' in $$props) $$invalidate(3, buttonComponentProps = $$props.buttonComponentProps);
		};

		return [
			page,
			pages,
			buttonComponent,
			buttonComponentProps,
			$LOCALE,
			dispatch,
			func,
			func_1
		];
	}

	class Ui_endless_list_navigation extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$D, create_fragment$D, safe_not_equal, {
				page: 0,
				pages: 1,
				buttonComponent: 2,
				buttonComponentProps: 3
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/endless/ui.endless.list.simple.item.svelte generated by Svelte v4.2.19 */

	function create_fragment$C(ctx) {
		let div;
		let span;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				div = element("div");
				span = element("span");
				t = text(/*title*/ ctx[0]);
				attr(div, "class", "box list-item-selectable svelte-ialyiy");
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, t);

				if (!mounted) {
					dispose = [
						listen(div, "click", prevent_default(/*click*/ ctx[1])),
						listen(div, "keyup", /*click*/ ctx[1])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*title*/ 1) set_data(t, /*title*/ ctx[0]);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$C($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { title } = $$props;
		let { id } = $$props;
		let { _id } = $$props;

		function click() {
			dispatch("click", { _id, id, title });
		}

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('id' in $$props) $$invalidate(2, id = $$props.id);
			if ('_id' in $$props) $$invalidate(3, _id = $$props._id);
		};

		return [title, click, id, _id];
	}

	class Ui_endless_list_simple_item extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$C, create_fragment$C, safe_not_equal, { title: 0, id: 2, _id: 3 });
		}
	}

	/* node_modules/not-bulma/src/elements/list/endless/ui.endless.list.svelte generated by Svelte v4.2.19 */

	function get_each_context$b(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[15] = list[i];
		return child_ctx;
	}

	// (41:4) {:else}
	function create_else_block$g(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*emptyListPlaceholderComponentProps*/ ctx[4]];
		var switch_value = /*emptyListPlaceholderComponent*/ ctx[3];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*emptyListPlaceholderComponentProps*/ 16) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*emptyListPlaceholderComponentProps*/ ctx[4])]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*emptyListPlaceholderComponent*/ 8 && switch_value !== (switch_value = /*emptyListPlaceholderComponent*/ ctx[3])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*emptyListPlaceholderComponentProps*/ 16)
					? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*emptyListPlaceholderComponentProps*/ ctx[4])])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (32:4) {#if data.list.length}
	function create_if_block$p(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*data*/ ctx[0].list);
		const get_key = ctx => /*item*/ ctx[15].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$b(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*itemComponent, itemComponentProps, data, select*/ 135) {
					each_value = ensure_array_like(/*data*/ ctx[0].list);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$b, each_1_anchor, get_each_context$b);
					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	// (33:8) {#each data.list as item (item.id)}
	function create_each_block$b(key_1, ctx) {
		let first;
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*itemComponentProps*/ ctx[2], /*item*/ ctx[15]];
		var switch_value = /*itemComponent*/ ctx[1];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*itemComponentProps, data*/ 5) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*itemComponentProps*/ 4 && get_spread_object(/*itemComponentProps*/ ctx[2]),
					dirty & /*data*/ 1 && get_spread_object(/*item*/ ctx[15])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("click", /*select*/ ctx[7]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*itemComponent*/ 2 && switch_value !== (switch_value = /*itemComponent*/ ctx[1])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("click", /*select*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*itemComponentProps, data*/ 5)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*itemComponentProps*/ 4 && get_spread_object(/*itemComponentProps*/ ctx[2]),
							dirty & /*data*/ 1 && get_spread_object(/*item*/ ctx[15])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$B(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let t;
		let switch_instance;
		let updating_page;
		let updating_pages;
		let updating_skip;
		let updating_count;
		let switch_instance_anchor;
		let current;
		const if_block_creators = [create_if_block$p, create_else_block$g];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*data*/ ctx[0].list.length) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		const switch_instance_spread_levels = [/*listNavigationComponentProps*/ ctx[6]];

		function switch_instance_page_binding(value) {
			/*switch_instance_page_binding*/ ctx[8](value);
		}

		function switch_instance_pages_binding(value) {
			/*switch_instance_pages_binding*/ ctx[9](value);
		}

		function switch_instance_skip_binding(value) {
			/*switch_instance_skip_binding*/ ctx[10](value);
		}

		function switch_instance_count_binding(value) {
			/*switch_instance_count_binding*/ ctx[11](value);
		}

		var switch_value = /*listNavigationComponent*/ ctx[5];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listNavigationComponentProps*/ 64) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*listNavigationComponentProps*/ ctx[6])]));
			}

			if (/*data*/ ctx[0].page !== void 0) {
				switch_instance_props.page = /*data*/ ctx[0].page;
			}

			if (/*data*/ ctx[0].pages !== void 0) {
				switch_instance_props.pages = /*data*/ ctx[0].pages;
			}

			if (/*data*/ ctx[0].skip !== void 0) {
				switch_instance_props.skip = /*data*/ ctx[0].skip;
			}

			if (/*data*/ ctx[0].count !== void 0) {
				switch_instance_props.count = /*data*/ ctx[0].count;
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'page', switch_instance_page_binding));
			binding_callbacks.push(() => bind(switch_instance, 'pages', switch_instance_pages_binding));
			binding_callbacks.push(() => bind(switch_instance, 'skip', switch_instance_skip_binding));
			binding_callbacks.push(() => bind(switch_instance, 'count', switch_instance_count_binding));
			switch_instance.$on("prev", /*prev_handler*/ ctx[12]);
			switch_instance.$on("next", /*next_handler*/ ctx[13]);
		}

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				insert(target, t, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}

				if (dirty & /*listNavigationComponent*/ 32 && switch_value !== (switch_value = /*listNavigationComponent*/ ctx[5])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'page', switch_instance_page_binding));
						binding_callbacks.push(() => bind(switch_instance, 'pages', switch_instance_pages_binding));
						binding_callbacks.push(() => bind(switch_instance, 'skip', switch_instance_skip_binding));
						binding_callbacks.push(() => bind(switch_instance, 'count', switch_instance_count_binding));
						switch_instance.$on("prev", /*prev_handler*/ ctx[12]);
						switch_instance.$on("next", /*next_handler*/ ctx[13]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listNavigationComponentProps*/ 64)
					? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*listNavigationComponentProps*/ ctx[6])])
					: {};

					if (!updating_page && dirty & /*data*/ 1) {
						updating_page = true;
						switch_instance_changes.page = /*data*/ ctx[0].page;
						add_flush_callback(() => updating_page = false);
					}

					if (!updating_pages && dirty & /*data*/ 1) {
						updating_pages = true;
						switch_instance_changes.pages = /*data*/ ctx[0].pages;
						add_flush_callback(() => updating_pages = false);
					}

					if (!updating_skip && dirty & /*data*/ 1) {
						updating_skip = true;
						switch_instance_changes.skip = /*data*/ ctx[0].skip;
						add_flush_callback(() => updating_skip = false);
					}

					if (!updating_count && dirty & /*data*/ 1) {
						updating_count = true;
						switch_instance_changes.count = /*data*/ ctx[0].count;
						add_flush_callback(() => updating_count = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
					detach(switch_instance_anchor);
				}

				if_blocks[current_block_type_index].d();
				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$B($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();

		let { data = {
			list: [],
			skip: 0,
			count: 0,
			page: 0,
			pages: 0
		} } = $$props;

		let { itemComponent = Ui_endless_list_simple_item } = $$props;
		let { itemComponentProps = {} } = $$props;
		let { emptyListPlaceholderComponent = Ui_list_empty_placeholder } = $$props;
		let { emptyListPlaceholderComponentProps = {} } = $$props;
		let { listNavigationComponent = Ui_endless_list_navigation } = $$props;
		let { listNavigationComponentProps = {} } = $$props;

		function select({ detail }) {
			dispatch("select", detail);
		}

		function switch_instance_page_binding(value) {
			if ($$self.$$.not_equal(data.page, value)) {
				data.page = value;
				$$invalidate(0, data);
			}
		}

		function switch_instance_pages_binding(value) {
			if ($$self.$$.not_equal(data.pages, value)) {
				data.pages = value;
				$$invalidate(0, data);
			}
		}

		function switch_instance_skip_binding(value) {
			if ($$self.$$.not_equal(data.skip, value)) {
				data.skip = value;
				$$invalidate(0, data);
			}
		}

		function switch_instance_count_binding(value) {
			if ($$self.$$.not_equal(data.count, value)) {
				data.count = value;
				$$invalidate(0, data);
			}
		}

		function prev_handler(event) {
			bubble.call(this, $$self, event);
		}

		function next_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('data' in $$props) $$invalidate(0, data = $$props.data);
			if ('itemComponent' in $$props) $$invalidate(1, itemComponent = $$props.itemComponent);
			if ('itemComponentProps' in $$props) $$invalidate(2, itemComponentProps = $$props.itemComponentProps);
			if ('emptyListPlaceholderComponent' in $$props) $$invalidate(3, emptyListPlaceholderComponent = $$props.emptyListPlaceholderComponent);
			if ('emptyListPlaceholderComponentProps' in $$props) $$invalidate(4, emptyListPlaceholderComponentProps = $$props.emptyListPlaceholderComponentProps);
			if ('listNavigationComponent' in $$props) $$invalidate(5, listNavigationComponent = $$props.listNavigationComponent);
			if ('listNavigationComponentProps' in $$props) $$invalidate(6, listNavigationComponentProps = $$props.listNavigationComponentProps);
		};

		return [
			data,
			itemComponent,
			itemComponentProps,
			emptyListPlaceholderComponent,
			emptyListPlaceholderComponentProps,
			listNavigationComponent,
			listNavigationComponentProps,
			select,
			switch_instance_page_binding,
			switch_instance_pages_binding,
			switch_instance_skip_binding,
			switch_instance_count_binding,
			prev_handler,
			next_handler
		];
	}

	class Ui_endless_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$B, create_fragment$B, safe_not_equal, {
				data: 0,
				itemComponent: 1,
				itemComponentProps: 2,
				emptyListPlaceholderComponent: 3,
				emptyListPlaceholderComponentProps: 4,
				listNavigationComponent: 5,
				listNavigationComponentProps: 6
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.select.svelte generated by Svelte v4.2.19 */

	function create_fragment$A(ctx) {
		let switch_instance;
		let updating_items;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*listComponentProps*/ ctx[8],
			{
				titleComponent: /*titleComponent*/ ctx[1]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[2]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[5]
			},
			{
				descriptionComponentProps: {
					.../*descriptionComponentProps*/ ctx[6],
					action: /*func*/ ctx[21]
				}
			},
			{
				imageComponent: /*imageComponent*/ ctx[3]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[4]
			}
		];

		function switch_instance_items_binding(value) {
			/*switch_instance_items_binding*/ ctx[22](value);
		}

		var switch_value = /*listComponent*/ ctx[7];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 894) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
					dirty & /*titleComponent*/ 2 && {
						titleComponent: /*titleComponent*/ ctx[1]
					},
					dirty & /*titleComponentProps*/ 4 && {
						titleComponentProps: /*titleComponentProps*/ ctx[2]
					},
					dirty & /*descriptionComponent*/ 32 && {
						descriptionComponent: /*descriptionComponent*/ ctx[5]
					},
					dirty & /*descriptionComponentProps, toggle*/ 576 && {
						descriptionComponentProps: {
							.../*descriptionComponentProps*/ ctx[6],
							action: /*func*/ ctx[21]
						}
					},
					dirty & /*imageComponent*/ 8 && {
						imageComponent: /*imageComponent*/ ctx[3]
					},
					dirty & /*imageComponentProps*/ 16 && {
						imageComponentProps: /*imageComponentProps*/ ctx[4]
					}
				]));
			}

			if (/*variants*/ ctx[0] !== void 0) {
				switch_instance_props.items = /*variants*/ ctx[0];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*listComponent*/ 128 && switch_value !== (switch_value = /*listComponent*/ ctx[7])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 894)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
							dirty & /*titleComponent*/ 2 && {
								titleComponent: /*titleComponent*/ ctx[1]
							},
							dirty & /*titleComponentProps*/ 4 && {
								titleComponentProps: /*titleComponentProps*/ ctx[2]
							},
							dirty & /*descriptionComponent*/ 32 && {
								descriptionComponent: /*descriptionComponent*/ ctx[5]
							},
							dirty & /*descriptionComponentProps, toggle*/ 576 && {
								descriptionComponentProps: {
									.../*descriptionComponentProps*/ ctx[6],
									action: /*func*/ ctx[21]
								}
							},
							dirty & /*imageComponent*/ 8 && {
								imageComponent: /*imageComponent*/ ctx[3]
							},
							dirty & /*imageComponentProps*/ 16 && {
								imageComponentProps: /*imageComponentProps*/ ctx[4]
							}
						])
					: {};

					if (!updating_items && dirty & /*variants*/ 1) {
						updating_items = true;
						switch_instance_changes.items = /*variants*/ ctx[0];
						add_flush_callback(() => updating_items = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$A($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { fieldname = "list-select" } = $$props;
		let { multiple = false } = $$props;
		let { atLeastOne = true } = $$props;
		let { variants = [] } = $$props;
		let { value } = $$props;
		let { selectedVariantsIds = [] } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 5 } } = $$props;
		let { imageComponent = Ui_image } = $$props;
		let { imageComponentProps = { covered: true } } = $$props;
		let { descriptionComponent = Ui_buttons } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { listComponent = Ui_list } = $$props;
		let { listComponentProps = {} } = $$props;
		let { sublimeValue = value => value.id } = $$props;

		let { getItem = ({ valueId }) => {
			return variants.find(btnVal => btnVal.value.id === valueId);
		} } = $$props;

		let { getItemValue = ({ valueId }) => {
			return getItem({ valueId }).value;
		} } = $$props;

		let { getDefaultItemSublime = () => {
			return variants[0].id;
		} } = $$props;

		let { uiOn = item => {
			item.color = "success";
			item.outlined = false;
		} } = $$props;

		let { uiOff = item => {
			item.color = false;
			item.outlined = true;
		} } = $$props;

		onMount(() => {
			if (value && Array.isArray(value)) {
				if (atLeastOne && value.length) {
					value.forEach(itemValue => {
						let ui = updateSelected(itemValue);
						updateUI(ui);
					});
				}

				return;
			}

			selectDefault();
		});

		//
		function countOfSelected() {
			return Array.isArray(value) ? selectedVariantsIds.length : 0;
		}

		const notLastOne = () => !(atLeastOne && countOfSelected() === 1);

		//
		function updateSelected(detail) {
			const valueId = sublimeValue(detail);
			let ui = { on: undefined, off: undefined };

			//
			if (!Array.isArray(selectedVariantsIds)) {
				$$invalidate(11, selectedVariantsIds = []);
			}

			if (multiple) {
				if (selectedVariantsIds.includes(valueId)) {
					if (notLastOne()) {
						selectedVariantsIds.splice(selectedVariantsIds.indexOf(valueId), 1);
						ui.off = { valueId };
					}
				} else {
					selectedVariantsIds.push(valueId);
					ui.on = { valueId };
				}
			} else {
				if (atLeastOne) {
					if (!selectedVariantsIds.includes(valueId)) {
						if (countOfSelected() > 0) {
							ui.off = { valueId: selectedVariantsIds.pop() };
						}

						ui.on = { valueId };
						$$invalidate(11, selectedVariantsIds = [valueId]);
					}
				} else {
					if (selectedVariantsIds.includes(valueId)) {
						ui.off = { valueId };
						selectedVariantsIds.splice(selectedVariantsIds.indexOf(valueId), 1);
					} else {
						ui.on = { valueId };
						selectedVariantsIds.push(valueId);
					}
				}
			}

			$$invalidate(11, selectedVariantsIds);
			return ui;
		}

		//
		function toggle(detail) {
			let ui = updateSelected(detail);
			updateUI(ui);

			//
			updateValue();

			//
			dispatch("change", { field: fieldname, value });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff(getItem(changes.off));
			}

			if (changes.on) {
				uiOn(getItem(changes.on));
			}

			$$invalidate(0, variants);
		}

		//
		function updateValue() {
			let newVal = [];

			if (typeof selectedVariantsIds !== "undefined" && Array.isArray(selectedVariantsIds)) {
				newVal = selectedVariantsIds.filter(val => typeof val !== "undefined").map(valueId => getItemValue({ valueId }));
			}

			$$invalidate(10, value = newVal);
		}

		//
		function selectDefault() {
			if (atLeastOne && variants.length > 0) {
				const defValueId = getDefaultItemSublime();
				toggle({ id: defValueId });
			}
		}

		const func = function (event, value) {
			toggle(value);
		};

		function switch_instance_items_binding(value) {
			variants = value;
			$$invalidate(0, variants);
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(12, fieldname = $$props.fieldname);
			if ('multiple' in $$props) $$invalidate(13, multiple = $$props.multiple);
			if ('atLeastOne' in $$props) $$invalidate(14, atLeastOne = $$props.atLeastOne);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('value' in $$props) $$invalidate(10, value = $$props.value);
			if ('selectedVariantsIds' in $$props) $$invalidate(11, selectedVariantsIds = $$props.selectedVariantsIds);
			if ('titleComponent' in $$props) $$invalidate(1, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(2, titleComponentProps = $$props.titleComponentProps);
			if ('imageComponent' in $$props) $$invalidate(3, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(4, imageComponentProps = $$props.imageComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(5, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(6, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('listComponent' in $$props) $$invalidate(7, listComponent = $$props.listComponent);
			if ('listComponentProps' in $$props) $$invalidate(8, listComponentProps = $$props.listComponentProps);
			if ('sublimeValue' in $$props) $$invalidate(15, sublimeValue = $$props.sublimeValue);
			if ('getItem' in $$props) $$invalidate(16, getItem = $$props.getItem);
			if ('getItemValue' in $$props) $$invalidate(17, getItemValue = $$props.getItemValue);
			if ('getDefaultItemSublime' in $$props) $$invalidate(18, getDefaultItemSublime = $$props.getDefaultItemSublime);
			if ('uiOn' in $$props) $$invalidate(19, uiOn = $$props.uiOn);
			if ('uiOff' in $$props) $$invalidate(20, uiOff = $$props.uiOff);
		};

		return [
			variants,
			titleComponent,
			titleComponentProps,
			imageComponent,
			imageComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			listComponent,
			listComponentProps,
			toggle,
			value,
			selectedVariantsIds,
			fieldname,
			multiple,
			atLeastOne,
			sublimeValue,
			getItem,
			getItemValue,
			getDefaultItemSublime,
			uiOn,
			uiOff,
			func,
			switch_instance_items_binding
		];
	}

	class Ui_list_select extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$A, create_fragment$A, safe_not_equal, {
				fieldname: 12,
				multiple: 13,
				atLeastOne: 14,
				variants: 0,
				value: 10,
				selectedVariantsIds: 11,
				titleComponent: 1,
				titleComponentProps: 2,
				imageComponent: 3,
				imageComponentProps: 4,
				descriptionComponent: 5,
				descriptionComponentProps: 6,
				listComponent: 7,
				listComponentProps: 8,
				sublimeValue: 15,
				getItem: 16,
				getItemValue: 17,
				getDefaultItemSublime: 18,
				uiOn: 19,
				uiOff: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.select.with.groups.svelte generated by Svelte v4.2.19 */

	function create_fragment$z(ctx) {
		let switch_instance;
		let updating_items;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*listComponentProps*/ ctx[8],
			{
				titleComponent: /*titleComponent*/ ctx[1]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[2]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[5]
			},
			{
				descriptionComponentProps: {
					.../*descriptionComponentProps*/ ctx[6],
					action: /*func*/ ctx[22]
				}
			},
			{
				imageComponent: /*imageComponent*/ ctx[3]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[4]
			}
		];

		function switch_instance_items_binding(value) {
			/*switch_instance_items_binding*/ ctx[23](value);
		}

		var switch_value = /*listComponent*/ ctx[7];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 894) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
					dirty & /*titleComponent*/ 2 && {
						titleComponent: /*titleComponent*/ ctx[1]
					},
					dirty & /*titleComponentProps*/ 4 && {
						titleComponentProps: /*titleComponentProps*/ ctx[2]
					},
					dirty & /*descriptionComponent*/ 32 && {
						descriptionComponent: /*descriptionComponent*/ ctx[5]
					},
					dirty & /*descriptionComponentProps, toggle*/ 576 && {
						descriptionComponentProps: {
							.../*descriptionComponentProps*/ ctx[6],
							action: /*func*/ ctx[22]
						}
					},
					dirty & /*imageComponent*/ 8 && {
						imageComponent: /*imageComponent*/ ctx[3]
					},
					dirty & /*imageComponentProps*/ 16 && {
						imageComponentProps: /*imageComponentProps*/ ctx[4]
					}
				]));
			}

			if (/*variants*/ ctx[0] !== void 0) {
				switch_instance_props.items = /*variants*/ ctx[0];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*listComponent*/ 128 && switch_value !== (switch_value = /*listComponent*/ ctx[7])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 894)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
							dirty & /*titleComponent*/ 2 && {
								titleComponent: /*titleComponent*/ ctx[1]
							},
							dirty & /*titleComponentProps*/ 4 && {
								titleComponentProps: /*titleComponentProps*/ ctx[2]
							},
							dirty & /*descriptionComponent*/ 32 && {
								descriptionComponent: /*descriptionComponent*/ ctx[5]
							},
							dirty & /*descriptionComponentProps, toggle*/ 576 && {
								descriptionComponentProps: {
									.../*descriptionComponentProps*/ ctx[6],
									action: /*func*/ ctx[22]
								}
							},
							dirty & /*imageComponent*/ 8 && {
								imageComponent: /*imageComponent*/ ctx[3]
							},
							dirty & /*imageComponentProps*/ 16 && {
								imageComponentProps: /*imageComponentProps*/ ctx[4]
							}
						])
					: {};

					if (!updating_items && dirty & /*variants*/ 1) {
						updating_items = true;
						switch_instance_changes.items = /*variants*/ ctx[0];
						add_flush_callback(() => updating_items = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$z($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { fieldname = "list-select-tags" } = $$props;
		let { multiple = false } = $$props;
		let { onlyOneInGroup = true } = $$props;
		let { atLeastOne = true } = $$props;
		let { variants = [] } = $$props;
		let { variantsSelected = {} } = $$props;
		let { value } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 5 } } = $$props;
		let { imageComponent = Ui_image } = $$props;
		let { imageComponentProps = { covered: true } } = $$props;
		let { descriptionComponent = Ui_buttons } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { listComponent = Ui_list } = $$props;
		let { listComponentProps = {} } = $$props;

		let { sublimeValue = value => {
			return { groupId: value.group, valueId: value.id };
		} } = $$props;

		let { getItem = ({ groupId, valueId }) => {
			return variants.find(group => group.id === groupId).description.values.find(btnVal => btnVal.value.id === valueId);
		} } = $$props;

		let { getItemValue = ({ groupId, valueId }) => {
			return getItem({ groupId, valueId }).value;
		} } = $$props;

		let { getDefaultItemSublime = () => {
			return {
				groupId: variants[0].id,
				valueId: variants[0].description.values[0].value.id
			};
		} } = $$props;

		let { uiOn = item => {
			item.color = "success";
			item.outlined = false;
		} } = $$props;

		let { uiOff = item => {
			item.color = false;
			item.outlined = false;
		} } = $$props;

		onMount(() => {
			if (value) {
				if (multiple) {
					if (onlyOneInGroup) {
						for (let t of Object.keys(value)) {
							const itemValue = value[t];
							let ui = updateSelected(itemValue);
							updateUI(ui);
						}
					} else {
						for (let t of Object.keys(value)) {
							value[t].forEach(itemValue => {
								let ui = updateSelected(itemValue);
								updateUI(ui);
							});
						}
					}
				} else {
					let ui = updateSelected(value);
					updateUI(ui);
				}
			} else {
				selectDefault();
			}
		});

		//
		function countOfSelected() {
			let c = 0;

			if (multiple) {
				for (let groupValue of Object.values(variantsSelected)) {
					if (onlyOneInGroup) {
						if (typeof groupValue !== "undefined") {
							c++;
						}
					} else {
						if (typeof groupValue !== "undefined" && Array.isArray(groupValue)) {
							c += groupValue.length;
						}
					}
				}
			} else {
				if (typeof variantsSelected !== "undefined" && typeof variantsSelected.value !== "undefined" && typeof variantsSelected.group !== "undefined") {
					c++;
				}
			}

			return c;
		}

		//
		function updateSelected(detail) {
			const { valueId, groupId } = sublimeValue(detail);
			let ui = { on: undefined, off: undefined };

			//
			if (multiple) {
				if (onlyOneInGroup) {
					if (typeof variantsSelected[groupId] !== "undefined") {
						ui.off = {
							groupId,
							valueId: variantsSelected[groupId]
						};
					}

					$$invalidate(10, variantsSelected[groupId] = valueId, variantsSelected);
					ui.on = { groupId, valueId };
				} else {
					if (!Array.isArray(variantsSelected[groupId])) {
						$$invalidate(10, variantsSelected[groupId] = [], variantsSelected);
					}

					if (variantsSelected[groupId].includes(valueId)) {
						if (countOfSelected() > 1) {
							variantsSelected[groupId].splice(variantsSelected[groupId].indexOf(valueId), 1);
							ui.off = { groupId, valueId };
						}
					} else {
						variantsSelected[groupId].push(valueId);
						ui.on = { groupId, valueId };
					}

					$$invalidate(10, variantsSelected);
				}

				$$invalidate(10, variantsSelected);
			} else {
				if (variantsSelected && variantsSelected.groupId === groupId && variantsSelected.valueId === valueId) {
					if (!atLeastOne) {
						$$invalidate(10, variantsSelected = undefined);
						ui.off = { groupId, valueId };
					}
				} else {
					if (variantsSelected) {
						if (typeof variantsSelected.groupId !== "undefined") {
							ui.off = {
								groupId: variantsSelected.groupId,
								valueId: variantsSelected.valueId
							};
						}
					}

					ui.on = { groupId, valueId };
					$$invalidate(10, variantsSelected = { groupId, valueId });
				}
			}

			return ui;
		}

		//
		function toggle(detail) {
			let ui = updateSelected(detail);
			console.log("image value", value, ui);
			updateUI(ui);

			//
			updateValue();

			//
			dispatch("change", { field: fieldname, value });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff(getItem(changes.off));
			}

			if (changes.on) {
				uiOn(getItem(changes.on));
			}

			$$invalidate(0, variants);
		}

		//
		function updateValue() {
			if (multiple) {
				let newVal = {};

				if (onlyOneInGroup) {
					for (let groupId in variantsSelected) {
						if (typeof variantsSelected[groupId] !== "undefined") {
							newVal[groupId] = getItemValue({
								groupId,
								valueId: variantsSelected[groupId]
							});
						}
					}
				} else {
					for (let groupId in variantsSelected) {
						if (typeof variantsSelected[groupId] !== "undefined" && Array.isArray(variantsSelected[groupId])) {
							newVal[groupId] = variantsSelected[groupId].filter(val => typeof val !== "undefined").map(itemValueId => {
								return getItemValue({ groupId, valueId: itemValueId });
							});
						}
					}
				}

				if (Object.keys(newVal).length == 0) {
					$$invalidate(11, value = undefined);
				} else {
					$$invalidate(11, value = newVal);
				}
			} else {
				if (variantsSelected) {
					$$invalidate(11, value = getItemValue(variantsSelected));
				} else {
					$$invalidate(11, value = undefined);
				}
			}
		}

		//
		function selectDefault() {
			if (atLeastOne && variants.length > 0) {
				const defValue = getDefaultItemSublime();

				toggle({
					id: defValue.valueId,
					group: defValue.groupId
				});
			}
		}

		const func = function (event, value) {
			toggle(value);
		};

		function switch_instance_items_binding(value) {
			variants = value;
			$$invalidate(0, variants);
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(12, fieldname = $$props.fieldname);
			if ('multiple' in $$props) $$invalidate(13, multiple = $$props.multiple);
			if ('onlyOneInGroup' in $$props) $$invalidate(14, onlyOneInGroup = $$props.onlyOneInGroup);
			if ('atLeastOne' in $$props) $$invalidate(15, atLeastOne = $$props.atLeastOne);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('variantsSelected' in $$props) $$invalidate(10, variantsSelected = $$props.variantsSelected);
			if ('value' in $$props) $$invalidate(11, value = $$props.value);
			if ('titleComponent' in $$props) $$invalidate(1, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(2, titleComponentProps = $$props.titleComponentProps);
			if ('imageComponent' in $$props) $$invalidate(3, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(4, imageComponentProps = $$props.imageComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(5, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(6, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('listComponent' in $$props) $$invalidate(7, listComponent = $$props.listComponent);
			if ('listComponentProps' in $$props) $$invalidate(8, listComponentProps = $$props.listComponentProps);
			if ('sublimeValue' in $$props) $$invalidate(16, sublimeValue = $$props.sublimeValue);
			if ('getItem' in $$props) $$invalidate(17, getItem = $$props.getItem);
			if ('getItemValue' in $$props) $$invalidate(18, getItemValue = $$props.getItemValue);
			if ('getDefaultItemSublime' in $$props) $$invalidate(19, getDefaultItemSublime = $$props.getDefaultItemSublime);
			if ('uiOn' in $$props) $$invalidate(20, uiOn = $$props.uiOn);
			if ('uiOff' in $$props) $$invalidate(21, uiOff = $$props.uiOff);
		};

		return [
			variants,
			titleComponent,
			titleComponentProps,
			imageComponent,
			imageComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			listComponent,
			listComponentProps,
			toggle,
			variantsSelected,
			value,
			fieldname,
			multiple,
			onlyOneInGroup,
			atLeastOne,
			sublimeValue,
			getItem,
			getItemValue,
			getDefaultItemSublime,
			uiOn,
			uiOff,
			func,
			switch_instance_items_binding
		];
	}

	class Ui_list_select_with_groups extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$z, create_fragment$z, safe_not_equal, {
				fieldname: 12,
				multiple: 13,
				onlyOneInGroup: 14,
				atLeastOne: 15,
				variants: 0,
				variantsSelected: 10,
				value: 11,
				titleComponent: 1,
				titleComponentProps: 2,
				imageComponent: 3,
				imageComponentProps: 4,
				descriptionComponent: 5,
				descriptionComponentProps: 6,
				listComponent: 7,
				listComponentProps: 8,
				sublimeValue: 16,
				getItem: 17,
				getItemValue: 18,
				getDefaultItemSublime: 19,
				uiOn: 20,
				uiOff: 21
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.select.buttons.with.groups.svelte generated by Svelte v4.2.19 */

	function create_fragment$y(ctx) {
		let uibuttons;
		let t;
		let switch_instance;
		let updating_items;
		let switch_instance_anchor;
		let current;

		uibuttons = new Ui_buttons({
				props: {
					values: /*ACTIONS*/ ctx[9],
					centered: true
				}
			});

		const switch_instance_spread_levels = [
			/*listComponentProps*/ ctx[8],
			{
				titleComponent: /*titleComponent*/ ctx[1]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[2]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[5]
			},
			{
				descriptionComponentProps: {
					action: /*func*/ ctx[23],
					.../*descriptionComponentProps*/ ctx[6]
				}
			},
			{
				imageComponent: /*imageComponent*/ ctx[3]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[4]
			}
		];

		function switch_instance_items_binding(value) {
			/*switch_instance_items_binding*/ ctx[24](value);
		}

		var switch_value = /*listComponent*/ ctx[7];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, setTimeout, triggerChange, descriptionComponentProps, imageComponent, imageComponentProps*/ 1406) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
					dirty & /*titleComponent*/ 2 && {
						titleComponent: /*titleComponent*/ ctx[1]
					},
					dirty & /*titleComponentProps*/ 4 && {
						titleComponentProps: /*titleComponentProps*/ ctx[2]
					},
					dirty & /*descriptionComponent*/ 32 && {
						descriptionComponent: /*descriptionComponent*/ ctx[5]
					},
					dirty & /*setTimeout, triggerChange, descriptionComponentProps*/ 1088 && {
						descriptionComponentProps: {
							action: /*func*/ ctx[23],
							.../*descriptionComponentProps*/ ctx[6]
						}
					},
					dirty & /*imageComponent*/ 8 && {
						imageComponent: /*imageComponent*/ ctx[3]
					},
					dirty & /*imageComponentProps*/ 16 && {
						imageComponentProps: /*imageComponentProps*/ ctx[4]
					}
				]));
			}

			if (/*variants*/ ctx[0] !== void 0) {
				switch_instance_props.items = /*variants*/ ctx[0];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
		}

		return {
			c() {
				create_component(uibuttons.$$.fragment);
				t = space();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				mount_component(uibuttons, target, anchor);
				insert(target, t, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibuttons_changes = {};
				if (dirty & /*ACTIONS*/ 512) uibuttons_changes.values = /*ACTIONS*/ ctx[9];
				uibuttons.$set(uibuttons_changes);

				if (dirty & /*listComponent*/ 128 && switch_value !== (switch_value = /*listComponent*/ ctx[7])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, setTimeout, triggerChange, descriptionComponentProps, imageComponent, imageComponentProps*/ 1406)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
							dirty & /*titleComponent*/ 2 && {
								titleComponent: /*titleComponent*/ ctx[1]
							},
							dirty & /*titleComponentProps*/ 4 && {
								titleComponentProps: /*titleComponentProps*/ ctx[2]
							},
							dirty & /*descriptionComponent*/ 32 && {
								descriptionComponent: /*descriptionComponent*/ ctx[5]
							},
							dirty & /*setTimeout, triggerChange, descriptionComponentProps*/ 1088 && {
								descriptionComponentProps: {
									action: /*func*/ ctx[23],
									.../*descriptionComponentProps*/ ctx[6]
								}
							},
							dirty & /*imageComponent*/ 8 && {
								imageComponent: /*imageComponent*/ ctx[3]
							},
							dirty & /*imageComponentProps*/ 16 && {
								imageComponentProps: /*imageComponentProps*/ ctx[4]
							}
						])
					: {};

					if (!updating_items && dirty & /*variants*/ 1) {
						updating_items = true;
						switch_instance_changes.items = /*variants*/ ctx[0];
						add_flush_callback(() => updating_items = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(switch_instance_anchor);
				}

				destroy_component(uibuttons, detaching);
				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$y($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { fieldname = "list-select-tags" } = $$props;
		let { variants = [] } = $$props;
		let { variantsSelected = {} } = $$props;
		let { value } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 5 } } = $$props;
		let { imageComponent = Ui_image } = $$props;
		let { imageComponentProps = { covered: true } } = $$props;
		let { descriptionComponent = Ui_buttons_switchers } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { listComponent = Ui_list } = $$props;
		let { listComponentProps = {} } = $$props;
		let { actionsList = ["selectAll", "deselectAll"] } = $$props;

		let { sublimeValue = value => {
			return { groupId: value.group, valueId: value.id };
		} } = $$props;

		//
		const AVAILABLE_ACTIONS = {
			selectAll: {
				title: "Выбрать все",
				color: "success",
				action() {
					selectAll();
				}
			},
			deselectAll: {
				title: "Снять выделение со всех",
				color: "",
				action() {
					deselectAll();
				}
			}
		};

		let ACTIONS = [];

		onMount(() => {
			actionsList.forEach(name => {
				Object.hasOwn(AVAILABLE_ACTIONS, name)
				? ACTIONS.push(AVAILABLE_ACTIONS[name])
				: false;
			});

			$$invalidate(9, ACTIONS);
		});

		const selectAll = () => {
			setSelectionOfAll(true);
		};

		const deselectAll = () => {
			setSelectionOfAll(false);
		};

		const selectGroup = groupId => {
			setSelectionOfGroup(groupId, true);
		};

		const deselectGroup = groupId => {
			setSelectionOfGroup(groupId, false);
		};

		const setSelectionOfGroup = (groupId, selection) => {
			variants.forEach(group => {
				if (groupId === group.id) {
					group.description.values.forEach(itm => {
						itm.selected = selection;
					});
				}
			});

			$$invalidate(0, variants);
			triggerChange();
		};

		const setSelectionOfAll = selection => {
			variants.forEach(group => {
				group.description.values.forEach(itm => {
					itm.selected = selection;
				});
			});

			$$invalidate(0, variants);
			triggerChange();
		};

		function getSelectedItems() {
			let result = {};

			variants.forEach(group => {
				if (!Object.hasOwn(result, group.id)) {
					result[group.id] = [];
				}

				group.description.values.forEach(itm => {
					if (itm.selected) {
						result[group.id].push(sublimeValue(itm.value));
					}
				});
			});

			return result;
		}

		function triggerChange() {
			$$invalidate(11, value = getSelectedItems());
			dispatch("change", { fieldname, value });
		}

		const func = function (event, value, selected) {
			setTimeout(triggerChange, 0);
			return !selected;
		};

		function switch_instance_items_binding(value) {
			variants = value;
			$$invalidate(0, variants);
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(12, fieldname = $$props.fieldname);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('variantsSelected' in $$props) $$invalidate(13, variantsSelected = $$props.variantsSelected);
			if ('value' in $$props) $$invalidate(11, value = $$props.value);
			if ('titleComponent' in $$props) $$invalidate(1, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(2, titleComponentProps = $$props.titleComponentProps);
			if ('imageComponent' in $$props) $$invalidate(3, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(4, imageComponentProps = $$props.imageComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(5, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(6, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('listComponent' in $$props) $$invalidate(7, listComponent = $$props.listComponent);
			if ('listComponentProps' in $$props) $$invalidate(8, listComponentProps = $$props.listComponentProps);
			if ('actionsList' in $$props) $$invalidate(14, actionsList = $$props.actionsList);
			if ('sublimeValue' in $$props) $$invalidate(15, sublimeValue = $$props.sublimeValue);
		};

		return [
			variants,
			titleComponent,
			titleComponentProps,
			imageComponent,
			imageComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			listComponent,
			listComponentProps,
			ACTIONS,
			triggerChange,
			value,
			fieldname,
			variantsSelected,
			actionsList,
			sublimeValue,
			selectAll,
			deselectAll,
			selectGroup,
			deselectGroup,
			setSelectionOfGroup,
			setSelectionOfAll,
			getSelectedItems,
			func,
			switch_instance_items_binding
		];
	}

	class Ui_list_select_buttons_with_groups extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$y, create_fragment$y, safe_not_equal, {
				fieldname: 12,
				variants: 0,
				variantsSelected: 13,
				value: 11,
				titleComponent: 1,
				titleComponentProps: 2,
				imageComponent: 3,
				imageComponentProps: 4,
				descriptionComponent: 5,
				descriptionComponentProps: 6,
				listComponent: 7,
				listComponentProps: 8,
				actionsList: 14,
				sublimeValue: 15,
				selectAll: 16,
				deselectAll: 17,
				selectGroup: 18,
				deselectGroup: 19,
				setSelectionOfGroup: 20,
				setSelectionOfAll: 21,
				getSelectedItems: 22
			});
		}

		get selectAll() {
			return this.$$.ctx[16];
		}

		get deselectAll() {
			return this.$$.ctx[17];
		}

		get selectGroup() {
			return this.$$.ctx[18];
		}

		get deselectGroup() {
			return this.$$.ctx[19];
		}

		get setSelectionOfGroup() {
			return this.$$.ctx[20];
		}

		get setSelectionOfAll() {
			return this.$$.ctx[21];
		}

		get getSelectedItems() {
			return this.$$.ctx[22];
		}
	}

	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIEndlessList: Ui_endless_list,
		UIEndlessListNavigation: Ui_endless_list_navigation,
		UIEndlessListSimpleItem: Ui_endless_list_simple_item,
		UIList: Ui_list,
		UIListEmptyPlaceholder: Ui_list_empty_placeholder,
		UIListItem: Ui_list_item,
		UIListSelect: Ui_list_select,
		UIListSelectButtonsWithGroups: Ui_list_select_buttons_with_groups,
		UIListSelectWithGroups: Ui_list_select_with_groups
	});

	/* node_modules/not-bulma/src/elements/modal/ui.overlay.svelte generated by Svelte v4.2.19 */

	function create_if_block$o(ctx) {
		let div;
		let t;
		let div_class_value;
		let div_transition;
		let current;
		let mounted;
		let dispose;
		let if_block = /*closeButton*/ ctx[0] && create_if_block_1$k(ctx);
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

		return {
			c() {
				div = element("div");
				if (if_block) if_block.c();
				t = space();
				if (default_slot) default_slot.c();
				attr(div, "class", div_class_value = "is-overlay not-overlay " + /*classes*/ ctx[4]);
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				set_style(div, "z-index", zIndexStep * /*layer*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
				append(div, t);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*overlayClick*/ ctx[5]),
						listen(div, "keyup", /*overlayClick*/ ctx[5])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (/*closeButton*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$k(ctx);
						if_block.c();
						if_block.m(div, t);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[9],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*classes*/ 16 && div_class_value !== (div_class_value = "is-overlay not-overlay " + /*classes*/ ctx[4])) {
					attr(div, "class", div_class_value);
				}

				if (!current || dirty & /*layer*/ 8) {
					set_style(div, "z-index", zIndexStep * /*layer*/ ctx[3]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
						div_transition.run(1);
					});
				}

				current = true;
			},
			o(local) {
				transition_out(default_slot, local);

				if (local) {
					if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
					div_transition.run(0);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block) if_block.d();
				if (default_slot) default_slot.d(detaching);
				if (detaching && div_transition) div_transition.end();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (76:8) {#if closeButton}
	function create_if_block_1$k(ctx) {
		let button;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				attr(button, "class", button_class_value = "delete is-" + /*closeSize*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, button, anchor);

				if (!mounted) {
					dispose = listen(button, "click", /*closeButtonClick*/ ctx[6]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*closeSize*/ 4 && button_class_value !== (button_class_value = "delete is-" + /*closeSize*/ ctx[2])) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$x(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*show*/ ctx[1] && create_if_block$o(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*show*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*show*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$o(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	const zIndexStep = 1000;

	function instance$x($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let overflowSave = "";
		const dispatch = createEventDispatcher();
		let { closeButton = false } = $$props;
		let { show = true } = $$props;
		let { closeOnClick = true } = $$props;
		let { closeSize = "normal" } = $$props;
		let { layer = 1 } = $$props;
		let { classes = "" } = $$props;

		function overlayClick(e) {
			if (closeOnClick) {
				closeOverlay(e);
			}
		}

		function closeButtonClick() {
			rejectOverlay();
		}

		function closeOverlay(e) {
			try {
				if (e && e.originalTarget) {
					const target = e.originalTarget;

					if (target.classList && target.classList.contains("is-overlay")) {
						rejectOverlay();
					}
				}
			} catch(_) {
				
			}
		}

		function rejectOverlay(data = {}) {
			dispatch("reject", data);
		}

		/*
		function resolveOverlay(data = {}) {
		  dispatch('resolve', data);
		}
	*/
		onMount(() => {
			$$invalidate(8, overflowSave = document.body.style.overflow);
		});

		onDestroy(() => {
			document.body.style.overflow = overflowSave;
		});

		$$self.$$set = $$props => {
			if ('closeButton' in $$props) $$invalidate(0, closeButton = $$props.closeButton);
			if ('show' in $$props) $$invalidate(1, show = $$props.show);
			if ('closeOnClick' in $$props) $$invalidate(7, closeOnClick = $$props.closeOnClick);
			if ('closeSize' in $$props) $$invalidate(2, closeSize = $$props.closeSize);
			if ('layer' in $$props) $$invalidate(3, layer = $$props.layer);
			if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*show, overflowSave*/ 258) {
				if (show) {
					document.body.style.overflow = "hidden";
				} else {
					document.body.style.overflow = overflowSave;
				}
			}
		};

		return [
			closeButton,
			show,
			closeSize,
			layer,
			classes,
			overlayClick,
			closeButtonClick,
			closeOnClick,
			overflowSave,
			$$scope,
			slots
		];
	}

	class Ui_overlay extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$x, create_fragment$x, safe_not_equal, {
				closeButton: 0,
				show: 1,
				closeOnClick: 7,
				closeSize: 2,
				layer: 3,
				classes: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/modal/ui.modal.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$j(ctx) {
		let uibuttonsrow;
		let current;

		uibuttonsrow = new Ui_buttons_row({
				props: {
					left: /*closeButton*/ ctx[1] ? [/*closeButton*/ ctx[1]] : [],
					right: /*applyButton*/ ctx[2] ? [/*applyButton*/ ctx[2]] : []
				}
			});

		return {
			c() {
				create_component(uibuttonsrow.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttonsrow, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttonsrow_changes = {};
				if (dirty & /*closeButton*/ 2) uibuttonsrow_changes.left = /*closeButton*/ ctx[1] ? [/*closeButton*/ ctx[1]] : [];
				if (dirty & /*applyButton*/ 4) uibuttonsrow_changes.right = /*applyButton*/ ctx[2] ? [/*applyButton*/ ctx[2]] : [];
				uibuttonsrow.$set(uibuttonsrow_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttonsrow.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttonsrow.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttonsrow, detaching);
			}
		};
	}

	// (48:12) {#if buttonsPosition === "bottom"}
	function create_if_block$n(ctx) {
		let uibuttonsrow;
		let current;

		uibuttonsrow = new Ui_buttons_row({
				props: {
					left: /*closeButton*/ ctx[1] ? [/*closeButton*/ ctx[1]] : [],
					right: /*applyButton*/ ctx[2] ? [/*applyButton*/ ctx[2]] : []
				}
			});

		return {
			c() {
				create_component(uibuttonsrow.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttonsrow, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttonsrow_changes = {};
				if (dirty & /*closeButton*/ 2) uibuttonsrow_changes.left = /*closeButton*/ ctx[1] ? [/*closeButton*/ ctx[1]] : [];
				if (dirty & /*applyButton*/ 4) uibuttonsrow_changes.right = /*applyButton*/ ctx[2] ? [/*applyButton*/ ctx[2]] : [];
				uibuttonsrow.$set(uibuttonsrow_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttonsrow.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttonsrow.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttonsrow, detaching);
			}
		};
	}

	// (34:8) <UIContent>
	function create_default_slot_2$1(ctx) {
		let div;
		let span;
		let t0_value = /*$LOCALE*/ ctx[10][/*WAITING_TEXT*/ ctx[9]] + "";
		let t0;
		let div_class_value;
		let t1;
		let t2;
		let t3;
		let if_block1_anchor;
		let current;
		let if_block0 = /*buttonsPosition*/ ctx[0] === "top" && create_if_block_1$j(ctx);
		const default_slot_template = /*#slots*/ ctx[11].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
		let if_block1 = /*buttonsPosition*/ ctx[0] === "bottom" && create_if_block$n(ctx);

		return {
			c() {
				div = element("div");
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (default_slot) default_slot.c();
				t3 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(span, "class", "title");
				attr(div, "class", div_class_value = "pageloader " + (/*loading*/ ctx[4] ? 'is-active' : ''));
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, t0);
				insert(target, t1, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t2, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				insert(target, t3, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if ((!current || dirty & /*$LOCALE, WAITING_TEXT*/ 1536) && t0_value !== (t0_value = /*$LOCALE*/ ctx[10][/*WAITING_TEXT*/ ctx[9]] + "")) set_data(t0, t0_value);

				if (!current || dirty & /*loading*/ 16 && div_class_value !== (div_class_value = "pageloader " + (/*loading*/ ctx[4] ? 'is-active' : ''))) {
					attr(div, "class", div_class_value);
				}

				if (/*buttonsPosition*/ ctx[0] === "top") {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*buttonsPosition*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$j(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t2.parentNode, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[12],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
							null
						);
					}
				}

				if (/*buttonsPosition*/ ctx[0] === "bottom") {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*buttonsPosition*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$n(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(default_slot, local);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(default_slot, local);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t1);
					detach(t2);
					detach(t3);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (default_slot) default_slot.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	// (32:4) <UIBox {classes}>
	function create_default_slot_1$2(ctx) {
		let uititle;
		let t;
		let uicontent;
		let current;

		uititle = new Ui_title({
				props: {
					size: "2",
					title: /*$LOCALE*/ ctx[10][/*title*/ ctx[5]],
					subtitle: /*$LOCALE*/ ctx[10][/*subtitle*/ ctx[6]]
				}
			});

		uicontent = new Ui_content({
				props: {
					$$slots: { default: [create_default_slot_2$1] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uititle.$$.fragment);
				t = space();
				create_component(uicontent.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uititle, target, anchor);
				insert(target, t, anchor);
				mount_component(uicontent, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uititle_changes = {};
				if (dirty & /*$LOCALE, title*/ 1056) uititle_changes.title = /*$LOCALE*/ ctx[10][/*title*/ ctx[5]];
				if (dirty & /*$LOCALE, subtitle*/ 1088) uititle_changes.subtitle = /*$LOCALE*/ ctx[10][/*subtitle*/ ctx[6]];
				uititle.$set(uititle_changes);
				const uicontent_changes = {};

				if (dirty & /*$$scope, closeButton, applyButton, buttonsPosition, loading, $LOCALE, WAITING_TEXT*/ 5655) {
					uicontent_changes.$$scope = { dirty, ctx };
				}

				uicontent.$set(uicontent_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uititle.$$.fragment, local);
				transition_in(uicontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uititle.$$.fragment, local);
				transition_out(uicontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}

				destroy_component(uititle, detaching);
				destroy_component(uicontent, detaching);
			}
		};
	}

	// (26:0) <UIOverlay     {show}     closeOnClick={false}     closeButton={false}     classes={overlayClasses} >
	function create_default_slot$4(ctx) {
		let uibox;
		let current;

		uibox = new Ui_box({
				props: {
					classes: /*classes*/ ctx[7],
					$$slots: { default: [create_default_slot_1$2] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uibox.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibox, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibox_changes = {};
				if (dirty & /*classes*/ 128) uibox_changes.classes = /*classes*/ ctx[7];

				if (dirty & /*$$scope, closeButton, applyButton, buttonsPosition, loading, $LOCALE, WAITING_TEXT, title, subtitle*/ 5751) {
					uibox_changes.$$scope = { dirty, ctx };
				}

				uibox.$set(uibox_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibox.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibox.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibox, detaching);
			}
		};
	}

	function create_fragment$w(ctx) {
		let uioverlay;
		let current;

		uioverlay = new Ui_overlay({
				props: {
					show: /*show*/ ctx[3],
					closeOnClick: false,
					closeButton: false,
					classes: /*overlayClasses*/ ctx[8],
					$$slots: { default: [create_default_slot$4] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uioverlay.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uioverlay, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uioverlay_changes = {};
				if (dirty & /*show*/ 8) uioverlay_changes.show = /*show*/ ctx[3];
				if (dirty & /*overlayClasses*/ 256) uioverlay_changes.classes = /*overlayClasses*/ ctx[8];

				if (dirty & /*$$scope, classes, closeButton, applyButton, buttonsPosition, loading, $LOCALE, WAITING_TEXT, title, subtitle*/ 5879) {
					uioverlay_changes.$$scope = { dirty, ctx };
				}

				uioverlay.$set(uioverlay_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uioverlay.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uioverlay.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uioverlay, detaching);
			}
		};
	}

	function instance$w($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(10, $LOCALE = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		let { buttonsPosition = "bottom" } = $$props;
		let { closeButton = false } = $$props;
		let { applyButton = false } = $$props;
		let { show = false } = $$props;
		let { loading = false } = $$props;
		let { title = "Modal window" } = $$props;
		let { subtitle = "" } = $$props;
		let { classes = "" } = $$props;
		let { overlayClasses = "" } = $$props;
		let { WAITING_TEXT = "Обработка" } = $$props;

		$$self.$$set = $$props => {
			if ('buttonsPosition' in $$props) $$invalidate(0, buttonsPosition = $$props.buttonsPosition);
			if ('closeButton' in $$props) $$invalidate(1, closeButton = $$props.closeButton);
			if ('applyButton' in $$props) $$invalidate(2, applyButton = $$props.applyButton);
			if ('show' in $$props) $$invalidate(3, show = $$props.show);
			if ('loading' in $$props) $$invalidate(4, loading = $$props.loading);
			if ('title' in $$props) $$invalidate(5, title = $$props.title);
			if ('subtitle' in $$props) $$invalidate(6, subtitle = $$props.subtitle);
			if ('classes' in $$props) $$invalidate(7, classes = $$props.classes);
			if ('overlayClasses' in $$props) $$invalidate(8, overlayClasses = $$props.overlayClasses);
			if ('WAITING_TEXT' in $$props) $$invalidate(9, WAITING_TEXT = $$props.WAITING_TEXT);
			if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
		};

		return [
			buttonsPosition,
			closeButton,
			applyButton,
			show,
			loading,
			title,
			subtitle,
			classes,
			overlayClasses,
			WAITING_TEXT,
			$LOCALE,
			slots,
			$$scope
		];
	}

	class Ui_modal extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$w, create_fragment$w, safe_not_equal, {
				buttonsPosition: 0,
				closeButton: 1,
				applyButton: 2,
				show: 3,
				loading: 4,
				title: 5,
				subtitle: 6,
				classes: 7,
				overlayClasses: 8,
				WAITING_TEXT: 9
			});
		}
	}

	/* node_modules/not-bulma/src/elements/modal/ui.generic.selector.svelte generated by Svelte v4.2.19 */

	function create_default_slot$3(ctx) {
		let div;
		let switch_instance0;
		let updating_term;
		let t0;
		let switch_instance1;
		let updating_data;
		let t1;
		let uibuttons;
		let div_class_value;
		let current;
		const switch_instance0_spread_levels = [/*inputComponentProps*/ ctx[5]];

		function switch_instance0_term_binding(value) {
			/*switch_instance0_term_binding*/ ctx[11](value);
		}

		var switch_value = /*inputComponent*/ ctx[4];

		function switch_props(ctx, dirty) {
			let switch_instance0_props = {};

			for (let i = 0; i < switch_instance0_spread_levels.length; i += 1) {
				switch_instance0_props = assign(switch_instance0_props, switch_instance0_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*inputComponentProps*/ 32) {
				switch_instance0_props = assign(switch_instance0_props, get_spread_update(switch_instance0_spread_levels, [get_spread_object(/*inputComponentProps*/ ctx[5])]));
			}

			if (/*term*/ ctx[0] !== void 0) {
				switch_instance0_props.term = /*term*/ ctx[0];
			}

			return { props: switch_instance0_props };
		}

		if (switch_value) {
			switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance0, 'term', switch_instance0_term_binding));
			switch_instance0.$on("termChange", /*termChange_handler*/ ctx[12]);
		}

		const switch_instance1_spread_levels = [/*outputComponentProps*/ ctx[7]];

		function switch_instance1_data_binding(value) {
			/*switch_instance1_data_binding*/ ctx[13](value);
		}

		var switch_value_1 = /*outputComponent*/ ctx[6];

		function switch_props_1(ctx, dirty) {
			let switch_instance1_props = {};

			for (let i = 0; i < switch_instance1_spread_levels.length; i += 1) {
				switch_instance1_props = assign(switch_instance1_props, switch_instance1_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*outputComponentProps*/ 128) {
				switch_instance1_props = assign(switch_instance1_props, get_spread_update(switch_instance1_spread_levels, [get_spread_object(/*outputComponentProps*/ ctx[7])]));
			}

			if (/*results*/ ctx[1] !== void 0) {
				switch_instance1_props.data = /*results*/ ctx[1];
			}

			return { props: switch_instance1_props };
		}

		if (switch_value_1) {
			switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
			binding_callbacks.push(() => bind(switch_instance1, 'data', switch_instance1_data_binding));
			switch_instance1.$on("prev", /*prev_handler*/ ctx[14]);
			switch_instance1.$on("next", /*next_handler*/ ctx[15]);
			switch_instance1.$on("select", /*select*/ ctx[10]);
		}

		uibuttons = new Ui_buttons({
				props: {
					values: /*buttons*/ ctx[8],
					centered: true,
					classes: "mt-5"
				}
			});

		return {
			c() {
				div = element("div");
				if (switch_instance0) create_component(switch_instance0.$$.fragment);
				t0 = space();
				if (switch_instance1) create_component(switch_instance1.$$.fragment);
				t1 = space();
				create_component(uibuttons.$$.fragment);
				attr(div, "class", div_class_value = "paper box block " + /*size*/ ctx[3] + " svelte-1gllhdk");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (switch_instance0) mount_component(switch_instance0, div, null);
				append(div, t0);
				if (switch_instance1) mount_component(switch_instance1, div, null);
				append(div, t1);
				mount_component(uibuttons, div, null);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*inputComponent*/ 16 && switch_value !== (switch_value = /*inputComponent*/ ctx[4])) {
					if (switch_instance0) {
						group_outros();
						const old_component = switch_instance0;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance0, 'term', switch_instance0_term_binding));
						switch_instance0.$on("termChange", /*termChange_handler*/ ctx[12]);
						create_component(switch_instance0.$$.fragment);
						transition_in(switch_instance0.$$.fragment, 1);
						mount_component(switch_instance0, div, t0);
					} else {
						switch_instance0 = null;
					}
				} else if (switch_value) {
					const switch_instance0_changes = (dirty & /*inputComponentProps*/ 32)
					? get_spread_update(switch_instance0_spread_levels, [get_spread_object(/*inputComponentProps*/ ctx[5])])
					: {};

					if (!updating_term && dirty & /*term*/ 1) {
						updating_term = true;
						switch_instance0_changes.term = /*term*/ ctx[0];
						add_flush_callback(() => updating_term = false);
					}

					switch_instance0.$set(switch_instance0_changes);
				}

				if (dirty & /*outputComponent*/ 64 && switch_value_1 !== (switch_value_1 = /*outputComponent*/ ctx[6])) {
					if (switch_instance1) {
						group_outros();
						const old_component = switch_instance1;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value_1) {
						switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance1, 'data', switch_instance1_data_binding));
						switch_instance1.$on("prev", /*prev_handler*/ ctx[14]);
						switch_instance1.$on("next", /*next_handler*/ ctx[15]);
						switch_instance1.$on("select", /*select*/ ctx[10]);
						create_component(switch_instance1.$$.fragment);
						transition_in(switch_instance1.$$.fragment, 1);
						mount_component(switch_instance1, div, t1);
					} else {
						switch_instance1 = null;
					}
				} else if (switch_value_1) {
					const switch_instance1_changes = (dirty & /*outputComponentProps*/ 128)
					? get_spread_update(switch_instance1_spread_levels, [get_spread_object(/*outputComponentProps*/ ctx[7])])
					: {};

					if (!updating_data && dirty & /*results*/ 2) {
						updating_data = true;
						switch_instance1_changes.data = /*results*/ ctx[1];
						add_flush_callback(() => updating_data = false);
					}

					switch_instance1.$set(switch_instance1_changes);
				}

				if (!current || dirty & /*size*/ 8 && div_class_value !== (div_class_value = "paper box block " + /*size*/ ctx[3] + " svelte-1gllhdk")) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
				if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
				if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (switch_instance0) destroy_component(switch_instance0);
				if (switch_instance1) destroy_component(switch_instance1);
				destroy_component(uibuttons);
			}
		};
	}

	function create_fragment$v(ctx) {
		let uioverlay;
		let current;

		uioverlay = new Ui_overlay({
				props: {
					show: /*show*/ ctx[2],
					closeOnClick: true,
					closeButton: false,
					$$slots: { default: [create_default_slot$3] },
					$$scope: { ctx }
				}
			});

		uioverlay.$on("reject", /*overlayClosed*/ ctx[9]);

		return {
			c() {
				create_component(uioverlay.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uioverlay, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uioverlay_changes = {};
				if (dirty & /*show*/ 4) uioverlay_changes.show = /*show*/ ctx[2];

				if (dirty & /*$$scope, size, outputComponent, outputComponentProps, results, inputComponent, inputComponentProps, term*/ 524539) {
					uioverlay_changes.$$scope = { dirty, ctx };
				}

				uioverlay.$set(uioverlay_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uioverlay.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uioverlay.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uioverlay, detaching);
			}
		};
	}

	function instance$v($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(16, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { show = true } = $$props;
		let { term = '' } = $$props;
		let { size = 'narrow' } = $$props;
		let { inputComponent = Ui_simple_search_input } = $$props;
		let { inputComponentProps = {} } = $$props;
		let { outputComponent = Ui_endless_list } = $$props;
		let { outputComponentProps = {} } = $$props;

		let { results = {
			list: [],
			page: 0,
			pages: 0,
			skip: 0,
			count: 0
		} } = $$props;

		onMount(() => {
			
		});

		const buttons = [
			{
				title: $LOCALE['not-node:button_cancel_label'],
				action: () => reject()
			}
		];

		function overlayClosed() {
			dispatch('reject');
		}

		function select({ detail }) {
			console.log('selected user', detail);
			dispatch('resolve', detail);
		}

		function reject() {
			dispatch('reject');
		}

		function switch_instance0_term_binding(value) {
			term = value;
			$$invalidate(0, term);
		}

		function termChange_handler(event) {
			bubble.call(this, $$self, event);
		}

		function switch_instance1_data_binding(value) {
			results = value;
			$$invalidate(1, results);
		}

		function prev_handler(event) {
			bubble.call(this, $$self, event);
		}

		function next_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('show' in $$props) $$invalidate(2, show = $$props.show);
			if ('term' in $$props) $$invalidate(0, term = $$props.term);
			if ('size' in $$props) $$invalidate(3, size = $$props.size);
			if ('inputComponent' in $$props) $$invalidate(4, inputComponent = $$props.inputComponent);
			if ('inputComponentProps' in $$props) $$invalidate(5, inputComponentProps = $$props.inputComponentProps);
			if ('outputComponent' in $$props) $$invalidate(6, outputComponent = $$props.outputComponent);
			if ('outputComponentProps' in $$props) $$invalidate(7, outputComponentProps = $$props.outputComponentProps);
			if ('results' in $$props) $$invalidate(1, results = $$props.results);
		};

		return [
			term,
			results,
			show,
			size,
			inputComponent,
			inputComponentProps,
			outputComponent,
			outputComponentProps,
			buttons,
			overlayClosed,
			select,
			switch_instance0_term_binding,
			termChange_handler,
			switch_instance1_data_binding,
			prev_handler,
			next_handler
		];
	}

	class Ui_generic_selector extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$v, create_fragment$v, safe_not_equal, {
				show: 2,
				term: 0,
				size: 3,
				inputComponent: 4,
				inputComponentProps: 5,
				outputComponent: 6,
				outputComponentProps: 7,
				results: 1
			});
		}
	}

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIGenericSelector: Ui_generic_selector,
		UIModal: Ui_modal,
		UIOverlay: Ui_overlay
	});

	/* node_modules/not-bulma/src/elements/notification/ui.error.svelte generated by Svelte v4.2.19 */

	function create_fragment$u(ctx) {
		let article;
		let div0;
		let p;
		let t0_value = /*$LOCALE*/ ctx[2][/*title*/ ctx[1]] + "";
		let t0;
		let t1;
		let div1;
		let t2_value = /*$LOCALE*/ ctx[2][/*message*/ ctx[0]] + "";
		let t2;

		return {
			c() {
				article = element("article");
				div0 = element("div");
				p = element("p");
				t0 = text(t0_value);
				t1 = space();
				div1 = element("div");
				t2 = text(t2_value);
				attr(div0, "class", "message-header");
				attr(div1, "class", "message-body");
				attr(article, "class", "message is-danger");
			},
			m(target, anchor) {
				insert(target, article, anchor);
				append(article, div0);
				append(div0, p);
				append(p, t0);
				append(article, t1);
				append(article, div1);
				append(div1, t2);
			},
			p(ctx, [dirty]) {
				if (dirty & /*$LOCALE, title*/ 6 && t0_value !== (t0_value = /*$LOCALE*/ ctx[2][/*title*/ ctx[1]] + "")) set_data(t0, t0_value);
				if (dirty & /*$LOCALE, message*/ 5 && t2_value !== (t2_value = /*$LOCALE*/ ctx[2][/*message*/ ctx[0]] + "")) set_data(t2, t2_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(article);
				}
			}
		};
	}

	function instance$u($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		let { message } = $$props;
		let { title } = $$props;

		$$self.$$set = $$props => {
			if ('message' in $$props) $$invalidate(0, message = $$props.message);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
		};

		return [message, title, $LOCALE];
	}

	class Ui_error extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$u, create_fragment$u, safe_not_equal, { message: 0, title: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/notification/ui.success.svelte generated by Svelte v4.2.19 */

	function create_fragment$t(ctx) {
		let article;
		let div0;
		let p;
		let t0_value = /*$LOCALE*/ ctx[2][/*title*/ ctx[1]] + "";
		let t0;
		let t1;
		let div1;
		let t2_value = /*$LOCALE*/ ctx[2][/*message*/ ctx[0]] + "";
		let t2;

		return {
			c() {
				article = element("article");
				div0 = element("div");
				p = element("p");
				t0 = text(t0_value);
				t1 = space();
				div1 = element("div");
				t2 = text(t2_value);
				attr(div0, "class", "message-header");
				attr(div1, "class", "message-body");
				attr(article, "class", "message is-success");
			},
			m(target, anchor) {
				insert(target, article, anchor);
				append(article, div0);
				append(div0, p);
				append(p, t0);
				append(article, t1);
				append(article, div1);
				append(div1, t2);
			},
			p(ctx, [dirty]) {
				if (dirty & /*$LOCALE, title*/ 6 && t0_value !== (t0_value = /*$LOCALE*/ ctx[2][/*title*/ ctx[1]] + "")) set_data(t0, t0_value);
				if (dirty & /*$LOCALE, message*/ 5 && t2_value !== (t2_value = /*$LOCALE*/ ctx[2][/*message*/ ctx[0]] + "")) set_data(t2, t2_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(article);
				}
			}
		};
	}

	function instance$t($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		let { message } = $$props;
		let { title } = $$props;

		$$self.$$set = $$props => {
			if ('message' in $$props) $$invalidate(0, message = $$props.message);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
		};

		return [message, title, $LOCALE];
	}

	class Ui_success extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$t, create_fragment$t, safe_not_equal, { message: 0, title: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/notification/ui.cookie.notification.svelte generated by Svelte v4.2.19 */

	function create_if_block$m(ctx) {
		let div;
		let p;
		let t0_value = /*$LOCALE*/ ctx[3][/*message*/ ctx[1]] + "";
		let t0;
		let t1;
		let button;
		let t2_value = /*$LOCALE*/ ctx[3][/*agree*/ ctx[2]] + "";
		let t2;
		let mounted;
		let dispose;

		return {
			c() {
				div = element("div");
				p = element("p");
				t0 = text(t0_value);
				t1 = space();
				button = element("button");
				t2 = text(t2_value);
				attr(p, "class", "svelte-19d5xat");
				attr(button, "class", "button is-success cookie_accept svelte-19d5xat");
				attr(div, "id", "cookie_notification");
				attr(div, "class", "svelte-19d5xat");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, p);
				append(p, t0);
				append(div, t1);
				append(div, button);
				append(button, t2);

				if (!mounted) {
					dispose = listen(button, "click", /*accept*/ ctx[4]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, message*/ 10 && t0_value !== (t0_value = /*$LOCALE*/ ctx[3][/*message*/ ctx[1]] + "")) set_data(t0, t0_value);
				if (dirty & /*$LOCALE, agree*/ 12 && t2_value !== (t2_value = /*$LOCALE*/ ctx[3][/*agree*/ ctx[2]] + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$s(ctx) {
		let if_block_anchor;
		let if_block = /*show*/ ctx[0] && create_if_block$m(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*show*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$m(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$s($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { show = false } = $$props;
		let { message = 'Для улучшения работы сайта и его взаимодействия с пользователями мы используем файлы cookie. Продолжая работу с сайтом, Вы разрешаете использование cookie-файлов. Вы всегда можете отключить файлы cookie в настройках Вашего браузера.' } = $$props;
		let { agree = 'Хорошо' } = $$props;

		onMount(() => {
			let cookieDate = localStorage.getItem('cookie_date');

			if (!cookieDate || +cookieDate + 31536000000 < Date.now()) {
				$$invalidate(0, show = true);
			}
		});

		function accept() {
			localStorage.setItem('cookie_date', Date.now());
			$$invalidate(0, show = false);
		}

		$$self.$$set = $$props => {
			if ('show' in $$props) $$invalidate(0, show = $$props.show);
			if ('message' in $$props) $$invalidate(1, message = $$props.message);
			if ('agree' in $$props) $$invalidate(2, agree = $$props.agree);
		};

		return [show, message, agree, $LOCALE, accept];
	}

	class Ui_cookie_notification extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$s, create_fragment$s, safe_not_equal, { show: 0, message: 1, agree: 2 });
		}
	}

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UICookieNotification: Ui_cookie_notification,
		UIError: Ui_error,
		UISuccess: Ui_success
	});

	//block elements

	var Elements = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Blocks: index$b,
		Buttons: index$a,
		Forms: index$7,
		Icons: index$6,
		Images: index$5,
		Layouts: index$8,
		Links: index$4,
		Lists: index$3,
		Modals: index$2,
		Notifications: index$1,
		UICommon: UICommon,
		Various: index$9
	});

	const META_METHOD_INIT = Symbol("init"),
	    META_DATA = Symbol("data"),
	    META_WORKING = Symbol("working"),
	    META_OPTIONS = Symbol("options");

	let notBase$1 = class notBase extends EventEmitter {
	    constructor(input) {
	        super();
	        this[META_DATA] = {};
	        this[META_WORKING] = {};
	        this[META_OPTIONS] = {};
	        this[META_METHOD_INIT](input);
	        return this;
	    }

	    [META_METHOD_INIT](input) {
	        if (!input) {
	            input = {};
	        }

	        if (Object.hasOwn(input, "data")) {
	            this.setData(input.data);
	        }

	        if (Object.hasOwn(input, "working")) {
	            this.setWorking(input.working);
	        }

	        if (Object.hasOwn(input, "options")) {
	            this.setOptions(input.options);
	        }

	        this.log = notCommon$2.genLogMsg(this.getWorking("name"));
	        this.info = this.log;
	        this.debug = notCommon$2.genLogDebug(this.getWorking("name"));
	        this.error = notCommon$2.genLogError(this.getWorking("name"));
	    }

	    setCommon(what, args) {
	        switch (args.length) {
	            case 1: {
	                /* set collection */
	                what = args[0];
	                break;
	            }
	            case 2: {
	                /* set collection element */
	                notPath$1.set(
	                    args[0] /* path */,
	                    what /* collection */,
	                    undefined /* helpers */,
	                    args[1] /* value */
	                );
	                break;
	            }
	        }
	        return this;
	    }
	    getCommon(what, args) {
	        switch (args.length) {
	            /* if we want get data by path */
	            case 1: {
	                return notPath$1.get(args[0], what);
	            }
	            /* if we want get data by path with default value */
	            case 2: {
	                let res = notPath$1.get(args[0], what);
	                if (res === undefined) {
	                    /* no data, return default value */
	                    return args[1];
	                } else {
	                    /* data, return it */
	                    return res;
	                }
	            }
	            /* return full collection */
	            default: {
	                return what;
	            }
	        }
	    }

	    /*
	    CORE OBJECT
	      DATA - information
	      OPTIONS - how to work
	      WORKING - temporarily generated in proccess
	  */

	    setData() {
	        if (arguments.length === 1) {
	            this[META_DATA] = arguments[0];
	        } else {
	            this.setCommon(this.getData(), arguments);
	        }
	        this.emit("change");
	        return this;
	    }

	    getData() {
	        return this.getCommon(this[META_DATA], arguments);
	    }

	    setOptions() {
	        if (arguments.length === 1) {
	            this[META_OPTIONS] = arguments[0];
	        } else {
	            this.setCommon(this.getOptions(), arguments);
	        }
	        return this;
	    }

	    getOptions() {
	        return this.getCommon(this[META_OPTIONS], arguments);
	    }

	    setWorking() {
	        if (arguments.length === 1) {
	            this[META_WORKING] = arguments[0];
	        } else {
	            this.setCommon(this.getWorking(), arguments);
	        }
	        return this;
	    }

	    getWorking() {
	        return this.getCommon(this[META_WORKING], arguments);
	    }

	    report(e) {
	        if (notCommon$2.report) {
	            notCommon$2.report(e);
	        }
	    }

	    getApp() {
	        return notCommon$2.getApp();
	    }

	    destroy() {
	        this.removeEvent();
	        this.setOptions(null);
	        this.setWorking(null);
	        this.setData(null);
	        this.emit("destroy");
	    }
	};

	const OPT_MODE_HISTORY = Symbol("history"),
	    OPT_MODE_HASH = Symbol("hash"),
	    OPT_DEFAULT_CHECK_INTERVAL = 50;

	class notRouter extends notBase$1 {
	    host = "";
	    constructor() {
	        super({
	            working: {
	                routes: [],
	                mode: OPT_MODE_HISTORY,
	                root: "/", //always in slashes /user/, /, /input/. and no /user or input/level
	                initialized: false,
	                delays: NAVIGATION_DELAYS,
	                delay_default: NAVIGATION_DELAY_DEFAULT,
	            },
	        });
	        return this;
	    }

	    /**
	     * Set object with named delays
	     * @param {Object.<string, number>} delays
	     * @returns {notRouter}
	     */
	    setDelays(delays) {
	        this.setWorking("delays", delays);
	        return this;
	    }

	    /**
	     * Set default navigation delay, provided as name of one of `delays` or in number form
	     * @param {string|number} delay
	     * @returns {notRouter}
	     */
	    setDefaultNavigationDelay(delay) {
	        this.setWorking("delay_default", this.delayAsMs(delay));
	        return this;
	    }

	    /**
	     * Returns number of ms, if not set returns NAVIGATION_DELAY_DEFAULT
	     * @returns {number}
	     */
	    getDefaultNavigationDelay() {
	        return this.getWorking(`delay_default`, NAVIGATION_DELAY_DEFAULT);
	    }

	    /**
	     *  Ensures that delay is in ms, if its provided as name of alias, searches for it and returns, if not found - returns working default_delay
	     * @param {string|number} delay    name of delay alias or number of ms
	     * @returns {number}               delay in ms
	     */
	    delayAsMs(delay) {
	        if (typeof delay === "number") {
	            return delay;
	        } else {
	            if (typeof delay === "string" && delay.length > 0) {
	                return this.getWorking(
	                    `delays.${delay}`,
	                    this.getDefaultNavigationDelay()
	                );
	            } else {
	                return this.getDefaultNavigationDelay();
	            }
	        }
	    }

	    /**
	     *
	     *  @param {string}              url     we go to url
	     *  @param {string|number}       delay   name of delay alias or number of ms
	     *  @returns {NodeJS.Timeout}            timeout identificator
	     */
	    navigateWithDelay(url, delay, doBefore) {
	        return setTimeout(() => {
	            typeof doBefore === "function" && doBefore();
	            this.navigate(url);
	        }, this.delayAsMs(delay));
	    }

	    /**
	     * Use browser History API
	     */
	    history() {
	        this.setWorking("mode", OPT_MODE_HISTORY);
	    }

	    /**
	     * Use hash part as container for location information
	     */
	    hash() {
	        this.setWorking("mode", OPT_MODE_HASH);
	    }

	    /**
	     * root should start and end with
	     * @param {string} root
	     * @returns {notRouter}
	     */
	    setRoot(root) {
	        this.setWorking(
	            "root",
	            root && root !== "/" ? "/" + this.clearSlashes(root) + "/" : "/"
	        );
	        return this;
	    }

	    /**
	     * clear first and last slashes from string
	     * @param {string} path
	     * @returns {string}
	     */
	    clearSlashes(path) {
	        return path.toString().replace(/\/$/, "").replace(/^\//, "");
	    }

	    add(re, handler) {
	        if (typeof re == "function") {
	            handler = re;
	            re = "";
	        }
	        let rule = {
	            re: re,
	            handler: handler,
	        };
	        this.getWorking("routes").push(rule);
	        return this;
	    }

	    addList(list) {
	        for (let t in list) {
	            this.add(t, list[t]);
	        }
	        return this;
	    }

	    remove(param) {
	        for (
	            var i = 0, r;
	            i < this.getWorking("routes").length,
	                (r = this.getWorking("routes")[i]);
	            i++
	        ) {
	            if (r.handler === param || r.re === param) {
	                this.getWorking("routes").splice(i, 1);
	                return this;
	            }
	        }
	        return this;
	    }

	    flush() {
	        this.setWorking({
	            routes: [],
	            mode: OPT_MODE_HISTORY,
	            root: "/",
	        });
	        return this;
	    }

	    isInitialized() {
	        return this.getWorking("initialized");
	    }

	    setInitialized(val = true) {
	        return this.setWorking("initialized", val);
	    }

	    getFragment() {
	        var fragment = "";
	        if (this.getWorking("mode") === OPT_MODE_HISTORY) {
	            if (!location) return "";
	            fragment = this.clearSlashes(
	                decodeURI(location.pathname + location.search)
	            );
	            fragment = fragment.replace(/\?(.*)$/, "");
	            fragment =
	                this.getWorking("root") != "/"
	                    ? fragment.replace(this.getWorking("root"), "")
	                    : fragment;
	        } else {
	            if (!window) return "";
	            var match = window.location.href.match(/#(.*)$/);
	            fragment = match ? match[1] : "";
	        }
	        return this.clearSlashes(fragment);
	    }

	    checkLocation() {
	        let current = this.getWorking("current"),
	            fragment = this.getFragment(),
	            init = this.isInitialized();
	        if (current !== fragment || !init) {
	            this.setWorking("current", fragment);
	            this.check(fragment);
	            this.setInitialized(true);
	        }
	    }

	    hrefClick() {
	        //console.log(...arguments);
	    }

	    getRoot() {
	        return this.getWorking("root");
	    }

	    listen(loopInterval = OPT_DEFAULT_CHECK_INTERVAL) {
	        this.setWorking("current", "notInitialized");
	        clearInterval(this.getWorking("interval"));
	        this.setWorking(
	            "interval",
	            setInterval(this.checkLocation.bind(this), loopInterval)
	        );
	        window.addEventListener("popstate", this.hrefClick.bind(this));
	        return this;
	    }

	    check(f) {
	        let fragment = f || this.getFragment(),
	            failBack = null;
	        for (let i = 0; i < this.getWorking("routes").length; i++) {
	            let path =
	                    this.getWorking("root") + this.getWorking("routes")[i].re,
	                fullRE = this.clearSlashes(decodeURI(path)),
	                match = fragment.match(fullRE);
	            if (match && match.length) {
	                if (fullRE === "") {
	                    match.shift();
	                    failBack = {
	                        route: this.getWorking("routes")[i],
	                        match,
	                    };
	                } else {
	                    match.shift();
	                    this.getWorking("routes")[i].handler.apply(
	                        this.host || {},
	                        match
	                    );
	                    this.emit("afterRoute", this.getWorking("routes")[i]);
	                    return this;
	                }
	            }
	        }
	        if (failBack) {
	            failBack.route.handler.apply(this.host || {}, failBack.match);
	            this.emit("afterRoute", failBack.route);
	        }
	        return this;
	    }

	    /**
	     *  Refreshes page
	     * @param {number} timeout time to wait in ms
	     */
	    refresh(timeout = 0) {
	        if (timeout > 0) {
	            setTimeout(() => this.refresh(), timeout);
	        } else {
	            this.check(this.getWorking("current"));
	        }
	    }

	    /**
	     * Changes locations
	     * @param {string} path
	     * @returns
	     */
	    navigate(path) {
	        path = path ? path : "";
	        switch (this.getWorking("mode")) {
	            case OPT_MODE_HISTORY: {
	                const newRoute = this.getFullRoute(path);
	                if (newRoute === this.lastRoute) {
	                    this.refresh();
	                } else {
	                    this.lastRoute = newRoute;
	                    history.pushState(null, "", this.lastRoute);
	                }
	                break;
	            }
	            case OPT_MODE_HASH: {
	                window.location.href.match(/#(.*)$/);
	                window.location.href =
	                    window.location.href.replace(/#(.*)$/, "") + "#" + path;
	                break;
	            }
	        }
	        return this;
	    }

	    /**
	     *  returns app root + path
	     * @param {string} path
	     * @returns {string}
	     */
	    getFullRoute(path = "") {
	        path = this.clearSlashes(path);
	        const root = this.getWorking("root");
	        if (root !== "/") {
	            if (path.indexOf(root.substring(1)) === 0) {
	                return "/" + path;
	            }
	        }
	        return this.getWorking("root") + this.clearSlashes(path);
	    }

	    /**
	     * Returns all links with n-href attribute
	     * @returns {Array<HTMLAnchorElement>}
	     */
	    getAllLinks() {
	        const allElements = document.body.querySelectorAll("a");
	        let list = [];
	        for (let j = 0; j < allElements.length; j++) {
	            for (
	                let i = 0, atts = allElements[j].attributes, n = atts.length;
	                i < n;
	                i++
	            ) {
	                if (atts[i].nodeName.indexOf("n-href") === 0) {
	                    list.push(allElements[j]);
	                    break;
	                }
	            }
	        }
	        return list;
	    }

	    /**
	     * Reroute all links(anchor tags) with n-href attribute.
	     * Disable navigation to href.
	     * @returns {notRouter}
	     */
	    reRouteExisted() {
	        const list = this.getAllLinks();
	        for (let t = 0; t < list.length; t++) {
	            this.initRerouting(list[t], list[t].getAttribute("n-href"));
	        }
	        return this;
	    }

	    /**
	     * If `el` is not initialized, adds onclick listener to navigate to `link` location.
	     * Disables default navigation to href.
	     * @param {HTMLAnchorElement}   el
	     * @param {string}              link
	     * @returns
	     */
	    initRerouting(el, link) {
	        // @ts-ignore
	        if (!el.notRouterInitialized) {
	            let fullLink = this.getFullRoute(link);
	            el.setAttribute("href", fullLink);
	            el.addEventListener("click", (e) => {
	                e.preventDefault();
	                this.navigate(link);
	                return false;
	            });
	            // @ts-ignore
	            el.notRouterInitialized = true;
	        }
	        return this;
	    }
	}

	var notRouter$1 = new notRouter();

	const LOG_PREFIX$1 = 'APIQuee';

	class notAPIQueue extends notBase$1{
	  static QUEUE_CHECK_INTERVAL    = 100;

	  static MAX_BUSY_TIME = 300;

	  constructor(options = {}){
	    super({
	      working:{
	        name: options.name?options.name:LOG_PREFIX$1
	      },
	      options
	    });
	    this.busy = false;
	    this.queue = [];
	    this.busySince = false;
	    this.afterEmpty = null;
	    this.start();
	    return this;
	  }

	  stop(){
	    if(this.interval){
	      clearInterval(this.interval);
	      this.interval = undefined;
	      this.busy = false;
	      this.busySince = false;
	    }
	  }

	  start(){
	    this.stop();
	    this.interval = setInterval(this.checkQueue.bind(this), this.QUEUE_CHECK_INTERVAL);
	  }

	  checkQueue(){
	    if(!this.isEmpty() && !this.isBusy()){
	      this.setBusy()
	        .runNext()
	        .then(this.setFree.bind(this))
	        .catch((e)=>{
	          this.error(e);
	          this.setFree();
	        });
	    }else {
	      if(!this.isBusy()){
	        if(this.afterEmpty){
	          let t = this.afterEmpty;
	          this.afterEmpty = null;
	          t();
	        }
	      }
	    }
	  }

	  addToQueue(task){
	    this.queue.push(task);
	  }

	  runNext(){
	    let list = this.queue.map(action=>action.title).join(', ');
	    this.debug(`tasks [${list}]` );
	    let task = this.queue.shift();
	    if (!notCommon$2.isFunc(task.action)){
	      this.error('В задании нет исполнимой части, action не функция', task.title);
	      return Promise.resolve();
	    }

	    if (!notCommon$2.isFunc(task.resolve)){
	      this.error('В задании нет возвратной части, resolve не функция', task.title);
	      return task.action();
	    }
	    return task.action().then(task.resolve);
	  }

	  isBusy(){
	    let busy = !!this.busy,
	      now = Date.now() / 1000;
	    if(busy){
	      if(now - this.busySince > this.MAX_BUSY_TIME){
	        this.setFree();
	        return false;
	      }else {
	        return true;
	      }
	    }else {
	      return false;
	    }
	  }

	  setBusy(){
	    this.busy = true;
	    this.busySince = Date.now() / 1000;
	    return this;
	  }

	  setFree(){
	    this.busy = false;
	    this.busySince = false;
	    return this;
	  }

	  isEmpty(){
	    return this.queue.length === 0;
	  }

	  /**
	  * Исполнитель запросов
	  * @param      {function}   action      должна возвращать Promise
	  * @param      {function}   afterEmpty  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	  * @returns    {Promise}  результат функции
	  **/
	  run(action, afterEmpty = null, title = ''){
	    if(afterEmpty && this.afterEmpty === null){
	      this.afterEmpty = afterEmpty;
	    }
	    return new Promise((resolve, reject)=>{
	      try{
	        this.addToQueue({action, resolve, title});
	      }catch(e){
	        this.error(e);
	        reject(e);
	      }
	    });
	  }

	  actionIsQueued(title){
	    return this.queue.some(queued => queued.title == title);
	  }

	  runIfNotQueued(action, afterEmpty = null, title = ''){
	    if(this.actionIsQueued(title)){
	      return Promise.resolve();
	    }else {
	      this.run(action, afterEmpty, title);
	    }
	  }
	}

	let notAPIOptions = {
	  rps: 50,
	  protocol: 'http',
	  host: 'localhost',
	  port: 9000
	};

	const LOG_PREFIX = 'APIConnection';

	class notAPIConnection extends notBase$1{
	  static int;
	  static online;

	  constructor(options) {
	    super({
	      options,
	      working: {
	        name: options.name?options.name:LOG_PREFIX
	      }
	    });
	    this.online = null;
	    this.run();
	    return this;
	  }

	  run() {
	    this.int = window.setInterval(this.check.bind(this), 1000);
	  }

	  pause() {
	    window.clearInterval(this.int);
	  }

	  resume() {
	    this.run();
	  }

	  isOnline(){
	    return window.navigator.onLine;
	  }

	  check() {
	    let t = this.isOnline();
	    if (this.online !== null) {
	      if (this.online !== t) {
	        this.changeState(t);
	      }
	    }
	    this.online = t;
	  }

	  changeState(online = false) {
	    if (online) {
	      this.emit('online');
	    } else {
	      this.emit('offline');
	    }
	  }
	}

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		notAPIConnection: notAPIConnection,
		notAPIOptions: notAPIOptions,
		notAPIQueue: notAPIQueue
	});

	const ALL$1 = {};

	function exist$1(key) {
	    return notCommon$2.objHas(ALL$1, key);
	}

	function get$1(key) {
	    if (exist$1(key)) {
	        return ALL$1[key];
	    } else {
	        return false;
	    }
	}

	function create$1(
	    key,
	    props = {
	        raw: [],
	        filtered: [],
	        selected: {},
	    }
	) {
	    if (!exist$1(key)) {
	        if (Object.keys(props).length > 0) {
	            ALL$1[key] = {};
	            Object.keys(props).forEach((name) => {
	                ALL$1[key][name] = writable(props[name]);
	            });
	        } else {
	            throw new Error("store's props wasn't specified");
	        }
	    }
	    return ALL$1[key];
	}

	/**
	 * Creates object that is fake Store
	 * Some time this is useful when you need to initialize local var,
	 * before you could get actual Stores from central storage by its ID
	 *	@params {mixed} val 	data of type that is actual storage will contain
	 * @returns {Object}
	 */

	function fake(val) {
	    return {
	        subscribe(f) {
	            f(val);
	            return () => {};
	        },
	        set() {},
	    };
	}

	var stores = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$1,
		fake: fake,
		get: get$1
	});

	const //record
	  META_INTERFACE = Symbol('interface'),
	  META_MAP_TO_INTERFACE = [
	    'getActionsCount',
	    'getActions',
	    'setFindBy',
	    'resetFilter',
	    'setFilter',
	    'getFilter',
	    'setSorter',
	    'getSorter',
	    'resetSorter',
	    'setPageNumber',
	    'setPageSize',
	    'setPager',
	    'setReturn',
	    'setSearch',
	    'getSearch',
	    'resetSearch',
	    'resetPager',
	    'getPager',
	    'addFormFieldType',
	    'addFormField',
	    'getFieldTypes',
	    'getActionFormFields'
	  ],
	  DEFAULT_ACTION_PREFIX$1 = '$';

	const OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY = ["_id", "id", "ID"],
	    DEFAULT_FILTER = {},
	    DEFAULT_SEARCH = "",
	    DEFAULT_RETURN = {},
	    DEFAULT_PAGE_NUMBER = 0,
	    DEFAULT_PAGE_SIZE = 10,
	    DEFAULT_ACTION_PREFIX = "$",
	    DEFAULT_WS_ROUTE_ACTION_SPLITTER = "//";

	class notInterface extends notBase$1 {
	    constructor(manifest, options) {
	        super({
	            working: {
	                name:
	                    "network interface for: " +
	                    (manifest.model ? manifest.model : "unknown"),
	                filter: DEFAULT_FILTER,
	                search: DEFAULT_SEARCH,
	                return: DEFAULT_RETURN,
	                pager: {
	                    size: DEFAULT_PAGE_SIZE,
	                    page: DEFAULT_PAGE_NUMBER,
	                },
	            },
	            options,
	        });
	        this.manifest = manifest;
	        this.initActions();
	        return this;
	    }

	    initActions() {
	        if (this.getActionsCount() > 0) {
	            let actions = this.getActions();
	            for (let actionName in actions) {
	                this.initAction(actionName);
	            }
	        }
	    }

	    initAction(actionName) {
	        if (!notCommon$2.objHas(this, DEFAULT_ACTION_PREFIX + actionName)) {
	            this[DEFAULT_ACTION_PREFIX + actionName] = (
	                opts,
	                headers,
	                fileUpload = false,
	                files
	            ) =>
	                this.request(
	                    this,
	                    actionName,
	                    opts,
	                    headers,
	                    fileUpload,
	                    files
	                );
	        }
	    }

	    requestHTTP(
	        record,
	        actionName,
	        params,
	        headers = {},
	        fileUpload = false,
	        files
	    ) {
	        try {
	            let compositeData = Object.assign(
	                {},
	                record.getData && typeof record.getData === "function"
	                    ? record.getData()
	                    : record,
	                params
	            );
	            let actionData = this.getActionData(actionName),
	                requestParams = this.collectRequestData(actionData),
	                requestParamsEncoded = this.encodeRequest(requestParams),
	                //id = this.getID(compositeData, actionData, actionName),
	                apiServerURL = this.getServerURL(),
	                url = this.getURL(compositeData, actionData, actionName),
	                opts = {};
	            if (fileUpload) {
	                url = this.getURL(params, actionData, actionName);
	                const fd = new FormData();
	                fd.append("file", files);
	                opts.body = fd;
	            } else {
	                if (
	                    ["OPTIONS", "GET"].indexOf(
	                        actionData.method.toUpperCase()
	                    ) === -1
	                ) {
	                    opts = {
	                        method: actionData.method,
	                        body: JSON.stringify(
	                            record.getData &&
	                                typeof record.getData === "function"
	                                ? record.getData()
	                                : record
	                        ),
	                        headers: {
	                            Accept: "application/json",
	                            "Content-Type": "application/json",
	                        },
	                    };
	                }
	            }
	            opts.method = actionData.method.toUpperCase();
	            if (headers && Object.keys(headers).length) {
	                opts.headers = headers;
	            }
	            return fetch(apiServerURL + url + requestParamsEncoded, opts).then(
	                (response) => response.json()
	            );
	        } catch (e) {
	            notCommon$2.error(e);
	            notCommon$2.report(e);
	        }
	    }

	    requestWS(record, actionName) {
	        try {
	            let actionData = this.getActionData(actionName),
	                requestParams = this.collectRequestData(actionData);
	            const WS = notCommon$2.getApp().getWSClient();
	            const messageName = this.getWSRequestName(actionName);
	            const payload = Object.assign({}, requestParams, record.getData());
	            if (
	                notCommon$2.objHas(actionData, "type") &&
	                typeof actionData.type === "string" &&
	                actionData.type.length &&
	                actionData.type !== "request"
	            ) {
	                return WS.message(actionData.type, messageName, payload).then(
	                    (response) => response.payload
	                );
	            } else {
	                return WS.request(messageName, payload).then(
	                    (response) => response.payload
	                );
	            }
	        } catch (e) {
	            notCommon$2.error(e);
	            notCommon$2.report(e);
	        }
	    }

	    request() {
	        let actionData = this.getActionData(arguments[1]);
	        switch (this.selectTransport(actionData)) {
	            case "ws":
	                return this.requestWS(...arguments);
	            case "http":
	                return this.requestHTTP(...arguments);
	            default:
	                throw new Error("Offline");
	        }
	    }

	    wsIsUp(actionData) {
	        if (actionData.ws === true) {
	            let client;
	            if (
	                notCommon$2.objHas(actionData, "wsClient") &&
	                actionData.wsClient
	            ) {
	                client = notCommon$2.getApp().getWSClient(actionData.wsClient);
	            } else {
	                client = notCommon$2.getApp().getWSClient();
	            }
	            if (client) {
	                return true;
	            }
	        }
	        return false;
	    }

	    selectTransport(actionData) {
	        if (this.wsIsUp(actionData)) {
	            return "ws"; //for ws/wss
	        }
	        if (notCommon$2.objHas(actionData, "method")) {
	            return "http"; //for http/https
	        }
	        return false; //for offline
	    }

	    getModelName() {
	        return this && this.manifest ? this.manifest.model : null;
	    }

	    getActionData(actionName) {
	        return this.getActions() && this.getActions()[actionName]
	            ? this.getActions()[actionName]
	            : null;
	    }

	    getActionsCount() {
	        return this.getActions() ? Object.keys(this.getActions()).length : 0;
	    }

	    getActions() {
	        return this.manifest && this.manifest.actions
	            ? this.manifest.actions
	            : {};
	    }

	    parseParams(start, end, line, record) {
	        let fieldName = "";
	        let len = start.length;
	        while (line.indexOf(start) > -1) {
	            let ind = line.indexOf(start);
	            let startSlice = ind + len;
	            let endSlice = line.indexOf(end);
	            if (ind > endSlice) {
	                break;
	            }
	            fieldName = line.slice(startSlice, endSlice);
	            if (fieldName == "") break;
	            this.log &&
	                this.log(
	                    start + fieldName + end,
	                    notPath$1.get(fieldName, record)
	                );
	            line = line.replace(
	                start + fieldName + end,
	                notPath$1.get(fieldName, record)
	            );
	        }
	        return line;
	    }

	    parseLine(line, record, actionName) {
	        line = line.replace(":modelName", this.manifest.model);
	        line = line.replace(":actionName", actionName);
	        line = this.parseParams(":record[", "]", line, record);
	        line = this.parseParams(":", "?", line, record);
	        return line;
	    }

	    getURL(record, actionData, actionName) {
	        var line =
	            this.parseLine(this.manifest.url, record, actionName) +
	            (notCommon$2.objHas(actionData, "postFix")
	                ? this.parseLine(actionData.postFix, record, actionName)
	                : "");
	        return line;
	    }

	    getServerURL() {
	        return notCommon$2.getApp()
	            ? notCommon$2.getApp().getOptions("api.server.url", "")
	            : "";
	    }

	    getWSRequestName(actionName) {
	        const modelName = this.manifest.model;
	        return `${modelName}${DEFAULT_WS_ROUTE_ACTION_SPLITTER}${actionName}`;
	    }

	    encodeRequest(data) {
	        let p = "?";
	        for (let t in data) {
	            if (typeof data[t] !== "undefined" && data[t] !== null) {
	                p +=
	                    encodeURIComponent(t) +
	                    "=" +
	                    encodeURIComponent(
	                        data[t].constructor === Object
	                            ? JSON.stringify(data[t])
	                            : data[t]
	                    ) +
	                    "&";
	            }
	        }
	        //for test purpose only, special test server needed
	        if (this.getOptions("test")) {
	            p += "&test=1";
	            if (this.getOptions("test.session")) {
	                p += "&session=" + this.getOptions("test.session");
	            }
	            if (this.getOptions("test.session")) {
	                p += "&role=" + this.getOptions("test.role");
	            }
	        }
	        return p;
	    }

	    collectRequestData(actionData) {
	        let requestData = {};
	        if (
	            notCommon$2.objHas(actionData, "data") &&
	            Array.isArray(actionData.data)
	        ) {
	            for (let i = 0; i < actionData.data.length; i++) {
	                let dataProviderName =
	                    "get" + notCommon$2.capitalizeFirstLetter(actionData.data[i]);
	                if (
	                    this[dataProviderName] &&
	                    typeof this[dataProviderName] === "function"
	                ) {
	                    let data = this[dataProviderName](),
	                        res = {};
	                    if (
	                        [
	                            "pager",
	                            "sorter",
	                            "filter",
	                            "search",
	                            "return",
	                        ].indexOf(actionData.data[i]) > -1
	                    ) {
	                        res[actionData.data[i]] = data;
	                    } else {
	                        res = data;
	                    }
	                    requestData = Object.assign(requestData, res);
	                }
	            }
	        }
	        return requestData;
	    }

	    getID(record, actionData) {
	        let resultId,
	            list = OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY,
	            prefixes = ["", this.manifest.model];
	        if (notCommon$2.objHas(actionData, "index") && actionData.index) {
	            list = [actionData.index].concat(
	                OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY
	            );
	        }
	        for (let pre of prefixes) {
	            for (let t of list) {
	                if (notCommon$2.objHas(record, pre + t)) {
	                    resultId = record[pre + t];
	                    break;
	                }
	            }
	        }
	        return resultId;
	    }

	    setFindBy(key, value) {
	        var obj = {};
	        obj[key] = value;
	        return this.setFilter(obj);
	    }

	    setFilter(filterData = DEFAULT_FILTER) {
	        this.setWorking("filter", filterData);
	        return this;
	    }

	    resetFilter() {
	        return this.setFilter();
	    }

	    getFilter() {
	        return this.getWorking("filter");
	    }

	    setSearch(searchData = DEFAULT_SEARCH) {
	        this.setWorking("search", searchData);
	        return this;
	    }

	    resetSearch() {
	        return this.setSearch();
	    }

	    getSearch() {
	        return this.getWorking("search");
	    }

	    setSorter(sorterData) {
	        this.setWorking("sorter", sorterData);
	        return this;
	    }

	    resetSorter() {
	        return this.setSorter({});
	    }

	    getSorter() {
	        return this.getWorking("sorter");
	    }

	    setReturn(returnData = DEFAULT_RETURN) {
	        this.setWorking("return", returnData);
	        return this;
	    }

	    resetReturn() {
	        return this.setReturn({});
	    }

	    getReturn() {
	        return this.getWorking("return");
	    }

	    setPageNumber(pageNumber) {
	        this.setWorking("pager.page", pageNumber);
	        return this;
	    }

	    setPageSize(pageSize) {
	        this.setWorking("pager.size", pageSize);
	        return this;
	    }

	    //pageSize = DEFAULT_PAGE_SIZE, pageNumber = DEFAULT_PAGE_NUMBER
	    setPager() {
	        if (
	            (arguments.length < 2 ||
	                isNaN(arguments[0]) ||
	                isNaN(arguments[1])) &&
	            arguments[0].constructor === Object &&
	            notCommon$2.objHas(arguments[0], "page") &&
	            notCommon$2.objHas(arguments[0], "size")
	        ) {
	            const pager = arguments[0];
	            this.setWorking("pager", {
	                size: pager.size || DEFAULT_PAGE_SIZE,
	                page: pager.page || DEFAULT_PAGE_NUMBER,
	            });
	        }
	        return this;
	    }

	    resetPager() {
	        return this.setPager();
	    }

	    getPager() {
	        return this.getWorking("pager");
	    }

	    getRecord() {
	        this.getData();
	    }

	    getDefaultAsPlainObject() {
	        if (!this.manifest || !this.manifest.fields) {
	            return {};
	        }
	        const result = {};
	        for (const fieldName of Object.keys(this.manifest.fields)) {
	            if (Object.hasOwn(this.manifest.fields[fieldName], "default")) {
	                result[fieldName] = this.manifest.fields[fieldName].default;
	            }
	        }
	        return result;
	    }
	}

	class notRecord extends notBase$1 {
	    constructor(manifest, item) {
	        super();
	        if (
	            typeof item === "undefined" ||
	            item === null ||
	            typeof item !== "object"
	        ) {
	            return item;
	        }
	        if (item && item.isProxy) {
	            notCommon$2.error("this is Proxy item");
	            return item;
	        }
	        if (item && (item.isRecord || item.isProperty)) {
	            return item;
	        } else {
	            if (Array.isArray(item)) {
	                return this.createCollection(manifest, item);
	            }
	        }
	        this.setOptions({});
	        this[META_INTERFACE] = new notInterface(manifest, {});
	        this.setData(item);
	        this.interfaceUp();
	        this.mapToInterface();
	        this.mapToMethods();
	        return this;
	    }

	    toDefault() {
	        return this.setData(this[META_INTERFACE].getDefaultAsPlainObject());
	    }

	    mapToInterface() {
	        let rec = this;
	        for (let t of META_MAP_TO_INTERFACE) {
	            if (
	                this[META_INTERFACE][t] &&
	                typeof this[META_INTERFACE][t] === "function"
	            ) {
	                this[t] = function () {
	                    let res = rec[META_INTERFACE][t](...arguments);
	                    return res == rec[META_INTERFACE] ? rec : res;
	                };
	            }
	        }
	    }

	    mapToMethods() {
	        let manifest = this[META_INTERFACE].manifest,
	            app = notCommon$2.getApp(),
	            methods = {};
	        if (manifest.methods) {
	            methods = manifest.methods;
	        } else if (app) {
	            methods = app.getOptions(
	                ["models", this[META_INTERFACE].manifest.model].join("."),
	                {}
	            );
	        }
	        if (methods) {
	            for (let t in methods) {
	                if (Object.hasOwn(methods, t)) {
	                    this[t] = methods[t];
	                }
	            }
	        }
	    }

	    createCollection(manifest, items) {
	        var collection = [];
	        for (var i = 0; i < items.length; i++) {
	            collection.push(new notRecord(manifest, items[i]));
	        }
	        return collection;
	    }

	    interfaceUp() {
	        if (this[META_INTERFACE].getActionsCount() > 0) {
	            let actions = this[META_INTERFACE].getActions();
	            for (let i in actions) {
	                this.actionUp(i, actions[i]);
	            }
	        }
	    }

	    actionUp(index) {
	        if (!Object.hasOwn(this, [DEFAULT_ACTION_PREFIX$1 + index])) {
	            this[DEFAULT_ACTION_PREFIX$1 + index] = (...params) =>
	                this[META_INTERFACE].request(this, index, ...params);
	        }
	    }
	    /*
	  -> 'path.to.key', valueOfKey
	  <- ok, with one onChange event triggered
	  */

	    setAttr(key, value) {
	        return this.setData(key, value);
	    }

	    /*
	  ->
	  {
	    'keyPath': value,
	    'key.subPath': value2,
	    'keyPath.0.title': value3
	  }
	  <- ok, with bunch of onChange events triggered
	  */
	    setAttrs(objectPart) {
	        //notCommon.log('setAttrs', objectPart, Object.keys(objectPart));
	        if (
	            objectPart &&
	            typeof objectPart === "object" &&
	            Object.keys(objectPart).length > 0
	        ) {
	            for (let path in objectPart) {
	                //notCommon.log('setAttrs one to go', path);
	                this.setAttr(path, objectPart[path]);
	            }
	        }
	    }

	    /*
	  -> 'pathToKey'
	  <- value1
	  */
	    getAttr(what, plain = false) {
	        let prx = this.getData(what, {});
	        if (plain) {
	            return notCommon$2.stripProxy(prx);
	        } else {
	            return prx;
	        }
	    }

	    /*
	  -> ['pathToKey', 'path.to.key', 'simpleKey',...]
	  <- [value1, value2, value3,...]
	  */
	    getAttrs(what) {
	        let result = [];
	        if (what && what.length > 0) {
	            for (let path of what) {
	                result.push(this.getAttr(path));
	            }
	        }
	        return result;
	    }

	    getManifest() {
	        if (this[META_INTERFACE]) {
	            return this[META_INTERFACE].manifest;
	        } else {
	            return {};
	        }
	    }

	    setItem(item) {
	        this.setData(item);
	        return this;
	    }
	}

	/**
	 * @const {string} [OPT_CONTROLLER_PREFIX = "nc"] controller names prefix nc aka NotController
	 */
	const OPT_CONTROLLER_PREFIX = "nc";
	/**
	 * @const {string} [OPT_RECORD_PREFIX = "nr"] record names prefix nr aka NotRecord
	 */
	const OPT_RECORD_PREFIX = "nr";
	/**
	 * @const {string} [DEFAULT_WS_CLIENT_NAME = "main"] default name of WS client
	 */
	const DEFAULT_WS_CLIENT_NAME = "main";

	/**
	 * Class of application
	 * @class
	 */
	let notApp$1 = class notApp extends notBase$1 {
	    /**
	     *  @static {function} DEFAULT_WS_CLIENT_NAME  function to perform deep merges of objects
	     */
	    static DEFAULT_WS_CLIENT_NAME = DEFAULT_WS_CLIENT_NAME;
	    /**
	     * @class
	     * @param {object} options              application options
	     * @param {string} options.name         name
	     * @param {object} options.controllers  controllers
	     * @param {string}  options.manifestURL URL of network manifest with all available models/actions/fields requests options
	     */
	    constructor(options) {
	        super({
	            working: {
	                name: options.name,
	                interfaces: {},
	                controllers: notCommon$2.objHas(options, "controllers")
	                    ? options.controllers
	                    : {},
	                initController: null,
	                currentController: null,
	                uis: {},
	                wsc: {},
	                wss: {},
	                services: {},
	            },
	            options,
	        });
	        this?.log && this.log("start app");
	        notCommon$2.register("app", this);
	        this.initManifest();
	        return this;
	    }

	    /**
	     * Initializes application according to network manifest, which is retrieved from server
	     */
	    initManifest() {
	        notCommon$2
	            .getJSON(this.getOptions("manifestURL"))
	            .then(this.setInterfaceManifest.bind(this))
	            .catch(notCommon$2.report.bind(this));
	    }

	    /**
	     * One page routing initialization
	     */
	    initRouter() {
	        this.setWorking("router", notRouter$1);
	        this.getWorking("router").setRoot(this.getOptions("router.root"));
	        notRouter$1.reRouteExisted();
	    }

	    /**
	     * Creates all the routes handlers and pushes them into router
	     */
	    execRouter() {
	        var routieInput = {};
	        for (let t = 0; t < this.getOptions("router.manifest").length; t++) {
	            let routeBlock = this.getOptions("router.manifest")[t],
	                paths = routeBlock.paths,
	                schemes = routeBlock.schemes,
	                controller = routeBlock.controller;
	            for (let i = 0; i < paths.length; i++) {
	                let pathScheme =
	                    schemes && Array.isArray(schemes) && schemes.length > i
	                        ? schemes[i]
	                        : false;
	                routieInput[paths[i]] = this.bindController(
	                    controller,
	                    pathScheme
	                );
	            }
	        }
	        this.getWorking("router").addList(routieInput).listen(); //.navigate(this.getOptions('router.index'));
	    }

	    /**
	     * Sets interface manifest option
	     * @param {object}  manifest    interface manifest
	     */
	    setInterfaceManifest(manifest) {
	        this.setOptions("interfaceManifest", manifest);
	        this.initRouter();
	        this.update();
	    }

	    /**
	     * returns constructor of interface model
	     * @param {string}  modelName   model name
	     * @returns {object}    interface model constructor
	     */
	    getInterfaceManifest(modelName) {
	        if (modelName) {
	            return this.getOptions("interfaceManifest")[modelName];
	        } else {
	            return this.getOptions("interfaceManifest");
	        }
	    }

	    /**
	     * Updating Application, reloads interfaces, init controller launched, start again
	     */
	    update() {
	        //нужно инициализировать
	        //модели полученными интерфейсами
	        this.updateInterfaces();
	        //иницилицировать и запустить контроллер инициализации
	        this.initController();
	        this.startApp();
	    }

	    /**
	     * Initialization of services, startup of routing
	     */
	    startApp() {
	        this.initServices();
	        //создать контроллеры
	        //роутер и привязать к нему контроллеры
	        this.execRouter();
	        this.emit("afterStarted", this);
	    }

	    /**
	     *
	     * @param {object} controllerName controller constructor
	     * @param {string[]} controllerPathScheme
	     * @returns {function} function creates new controller instance and pass in notApp instance, arguments from router parser and pathScheme
	     */
	    bindController(controllerName, controllerPathScheme) {
	        let app = this;
	        return function () {
	            new controllerName(app, arguments, controllerPathScheme);
	        };
	    }

	    /**
	     * Initializes 'initialization' controller which is runs once,
	     * to perform custom initializations routines by application code
	     */
	    initController() {
	        if (typeof this.getOptions("initController") !== "undefined") {
	            let initController = this.getOptions("initController");
	            this.setWorking("initController", new initController(this));
	        }
	    }

	    /**
	     * Returns working controller
	     * @returns {object} working controller
	     */
	    getCurrentController() {
	        return this.getWorking("currentController");
	    }

	    /**
	     * Destroyes working controller then sets provided as working
	     * @param {object} ctrl controller instance
	     * @returns {object} notApp instance
	     */
	    setCurrentController(ctrl) {
	        let oldCtrl = this.getCurrentController();
	        if (oldCtrl && oldCtrl.destroy) {
	            oldCtrl.destroy();
	        }
	        this.setWorking("currentController", ctrl);
	        return this;
	    }

	    /**
	     * Clears interfaces, recreates all according to Options.interafaceManifest
	     */
	    updateInterfaces() {
	        this.clearInterfaces();
	        let manifests = this.getOptions("interfaceManifest");
	        if (manifests) {
	            for (let name in manifests) {
	                let recordManifest = manifests[name],
	                    recordMethods = this.getOptions(
	                        ["models", name].join("."),
	                        {}
	                    );
	                recordManifest.methods = recordMethods;
	                this.getWorking("interfaces")[name] = (recordData) =>
	                    new notRecord(recordManifest, recordData);
	                window["nr" + notCommon$2.capitalizeFirstLetter(name)] =
	                    this.getWorking("interfaces")[name];
	            }
	        }
	    }

	    /**
	     * Converts interface name (modelName) to standartizied prefixModelName
	     * @param {string} name interface model name
	     * @returns {string}    not record name
	     */
	    getRecordName(name) {
	        return OPT_RECORD_PREFIX + notCommon$2.capitalizeFirstLetter(name);
	    }

	    /**
	     * Converts controller name (controllerName) to standartizied prefixControllerName
	     * @param {string} name controller name
	     * @returns {string}    not controller name
	     */
	    getControllerName(name) {
	        return OPT_CONTROLLER_PREFIX + notCommon$2.capitalizeFirstLetter(name);
	    }

	    /**
	     * Returns all network interfaces
	     * @returns {object} all network insterfaces
	     */
	    getInterfaces() {
	        return this.getWorking("interfaces");
	    }

	    /**
	     * Sets interfaces list clear
	     * @returns {object} notApp instance
	     */
	    clearInterfaces() {
	        this.setWorking("interfaces", {});
	        return this;
	    }

	    /**
	     * Sets WebSockets client
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME] name of client
	     * @param {object} wsc  notWSClient instance
	     * @returns {object} notApp instance
	     */
	    // @ts-ignore
	    setWSClient(name = DEFAULT_WS_CLIENT_NAME, wsc) {
	        return this.setWorking(`wsc.${name}`, wsc);
	    }

	    /**
	     * Returns web sockets client instance by name
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME]
	     * @returns {object} instance of notWSClient
	     */
	    getWSClient(name = DEFAULT_WS_CLIENT_NAME) {
	        return this.getWorking(`wsc.${name}`);
	    }

	    /**
	     * returns network interface class initializator
	     * @param {string} name name of network interface
	     * @returns {function} interface class initializator
	     */
	    getInterface(name) {
	        return this.getInterfaces()[name];
	    }

	    /**
	     * Returns network interface (model) initialized with provided data
	     * @param {string} name interface(modelName)
	     * @param {object} [data={}]    model data
	     * @returns network interface initializes with provided data
	     */
	    getModel(name, data = {}) {
	        return this.getInterface(name)(data);
	    }

	    /**
	     * Sets service
	     * @param {string} name name of the service
	     * @param {object|function} val service
	     */
	    setService(name, val) {
	        return this.setWorking(`services.${name}`, val);
	    }

	    /**
	     * Returns service
	     * @param {string} name name of the service
	     * @returns {object|function} service
	     */
	    getService(name) {
	        return this.getWorking(`services.${name}`);
	    }

	    /**
	     * Initializes all provided services
	     */
	    initServices() {
	        if (this.getOptions("services")) {
	            for (let servName in this.getOptions("services")) {
	                try {
	                    let serv = this.getOptions(`services.${servName}`);
	                    const servType = notCommon$2.detectType(serv);
	                    switch (servType) {
	                        case "function":
	                        case "class":
	                            this.setService(servName, new serv(this));
	                            break;
	                        default:
	                            this.setService(servName, serv);
	                    }
	                } catch (e) {
	                    this?.error &&
	                        this.error(`Service (${servName}) init error`, e);
	                }
	            }
	        }
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} moduleName   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	    getConfigReaderForModule(moduleName = "") {
	        const modConfPath = ["modules", moduleName].join(".");
	        return {
	            get: (subPath, fallback) => {
	                if (subPath && typeof subPath == "string" && subPath.length) {
	                    return this.getOptions(
	                        [modConfPath, subPath].join("."),
	                        fallback
	                    );
	                } else {
	                    return this.getOptions(modConfPath, fallback);
	                }
	            },
	        };
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} [moduleName='']   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	    moduleConfig(moduleName = "") {
	        return this.getConfigReaderForModule(moduleName);
	    }
	};

	/**
	 * @const {string}  [OPT_DEFAULT_ACTION_NAME = "default"]      default action name
	 */
	const OPT_DEFAULT_ACTION_NAME = "default";

	/**
	 * @const {string}  [OPT_DEFAULT_CONTAINER_SELECTOR = "main.content"]  selector of container HTML
	 *                          element
	 */
	const OPT_DEFAULT_CONTAINER_SELECTOR = "main.content";

	/**
	 * @const {string}  [OPT_DEFAULT_PLURAL_NAME = "Models"]  default plural name of entities
	 */
	const OPT_DEFAULT_PLURAL_NAME = "Models";

	/**
	 * @const {string}  [OPT_DEFAULT_SINGLE_NAME = "Model"]  default single name of entities
	 */
	const OPT_DEFAULT_SINGLE_NAME = "Model";

	/**
	 * @const {string}  [OPT_DEFAULT_MODULE_NAME="main"]  default module name
	 */
	const OPT_DEFAULT_MODULE_NAME = "main";

	/**
	 * @const {boolean}  [OPT_DEFAULT_AUTO_NAME = true]  if shoould be used auto name generator
	 */
	const OPT_DEFAULT_AUTO_NAME = true;

	/*
	 *  Basic class for user controller
	 */
	let notController$2 = class notController extends notBase$1 {
	    /**
	     *  @static {number} PARAMS_LENGTH  number of params in URL path
	     */
	    static PARAMS_LENGTH = 2;
	    /**
	     *  @static {string} MODULE_NAME  name of module
	     */
	    static get MODULE_NAME() {
	        return OPT_DEFAULT_MODULE_NAME;
	    }
	    /**
	     *  @static {string} MODEL_NAME  name of model
	     */
	    static get MODEL_NAME() {
	        return "ModelName";
	    }

	    static get LABELS() {
	        return {
	            plural: `${OPT_DEFAULT_MODULE_NAME}:model_label_plural`,
	            single: `${OPT_DEFAULT_MODULE_NAME}:model_label_single`,
	        };
	    }

	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    els;
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    make;
	    /**
	     *
	     * @type    {null|import('./app.js').default}
	     * @memberof notController
	     */
	    app;
	    /**
	     *  @class
	     *  @param {import('./app.js').default} app
	     *  @param  {string}    name
	     */
	    constructor(app, name) {
	        super({});
	        this.app = app;
	        this.app.setCurrentController(this);
	        this.setWorking({
	            name,
	            ready: false,
	            views: {},
	            libs: {},
	            helpers: {},
	        });
	        this.ui = {};
	        this.els = {};
	        this.setData({});
	        this.setOptions({
	            moduleName: OPT_DEFAULT_MODULE_NAME,
	            containerSelector: OPT_DEFAULT_CONTAINER_SELECTOR,
	            prefix: app.getOptions("paths.module"),
	            names: {
	                plural: OPT_DEFAULT_PLURAL_NAME,
	                single: OPT_DEFAULT_SINGLE_NAME,
	            },
	        });
	        this.setURLPrefix(app.getOptions("router.root"));
	        /*
	      сразу делаем доступными модели notRecord из nc`ControllerName` будут доступны как this.nr`ModelName`
	    */
	        let interfaces = app.getInterfaces();
	        this.make = {};
	        for (let t in interfaces) {
	            if (Object.hasOwn(interfaces, t)) {
	                this.make[t] = interfaces[t];
	            }
	        }
	        this.on("destroy", () => {
	            this.app = null;
	            for (let uiName in this.ui) {
	                this.ui[uiName].destroy && this.ui[uiName].destroy();
	                this.ui[uiName].$destroy && this.ui[uiName].$destroy();
	                this.ui[uiName] = null;
	            }
	            this.els = null;
	            this.make = null;
	        });
	        return this;
	    }

	    /**
	     *  Returns current notApp
	     *  @return {import('./app.js').default}
	     */
	    getApp() {
	        return notCommon$2.getApp();
	    }

	    /**
	     *  Sets default controller model
	     *  @param {import('./record.js')}  model  notRecord interface object
	     *  @return {notController}
	     */
	    setModel(model) {
	        this.setWorking("model", model);
	        return this;
	    }

	    /**
	     *  If zero or one argument provided this modelName instance will be returned
	     *  If two provided and first is a string than instance of name will be returned initialized with second object param or empty object
	     *  @param {string|object}      name    modelName of instance to return or initial data for instance
	     *  @param {object}             data    model data
	     *  @return {import('./record.js')}
	     */
	    getModel(name, data = undefined) {
	        if (typeof name === "string") {
	            const int = this.getInterface(name);
	            return int && int(data || {});
	        } else {
	            const int = this.getInterface();
	            return int && int(name || {});
	        }
	    }

	    getInterface(name = "") {
	        return this.app?.getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	    getModelName() {
	        return this.getWorking("modelName");
	    }
	    /**
	     *  Sets default controller model name
	     *  @param {string}  modelName  notRecord interface object
	     *  @return {notController}
	     */
	    setModelName(modelName) {
	        this.setWorking("modelName", notCommon$2.lowerFirstLetter(modelName));
	        return this;
	    }

	    /**
	     *  Returns current model primary ID field name
	     *  @return {import('./record.js')}
	     */
	    getModelIDFieldName() {
	        return this.getWorking("modelIDFieldName", "_id");
	    }

	    /**
	     *  Sets current model primary ID field name
	     *  @return {notController}
	     */
	    setModelIDFieldName(val = "_id") {
	        return this.setWorking("modelIDFieldName", val);
	    }

	    /**
	     *  Marks this controller as ready
	     *  emits "ready"/"busy" events
	     *  @param {Boolean}  val  true/false
	     */
	    setReady(val = true) {
	        this.setWorking("ready", val);
	        val ? this.emit("ready") : this.emit("busy");
	    }

	    /**
	     *  Sets module URL prefix
	     *  @param {string} val URL prefix
	     *  @return {notController} this
	     */
	    setURLPrefix(val) {
	        this.setOptions("urlPrefix", val);
	        this.updateAutoName();
	        return this;
	    }

	    /**
	     *  Returns module url prefix
	     *  @return  {string} prefix
	     */
	    getURLPrefix() {
	        return this.getOptions("urlPrefix");
	    }

	    /**
	     *  Sets module name
	     *  @param {string} val name of the module
	     *  @return {notController} this
	     */
	    setModuleName(val) {
	        this.setOptions("moduleName", notCommon$2.lowerFirstLetter(val));
	        this.updateAutoName();
	        return this;
	    }
	    /**
	     *  Returns module name
	     *  @return  {string} module name
	     */
	    getModuleName() {
	        return this.getOptions("moduleName");
	    }

	    /**
	     *  Returns this module path prefix
	     *  @return {string}  path to module dir
	     */
	    getModulePrefix() {
	        return [
	            notCommon$2.getApp().getOptions("paths.modules"),
	            this.getModuleName(),
	        ].join("/");
	    }

	    /**
	     *  Returns this model URL with URL prefix
	     *  @return {string}  url path
	     */
	    getModelURL() {
	        return notCommon$2.buildURL({
	            prefix: this.getURLPrefix(),
	            module: this.getModuleName(),
	            model: this.getModelName(),
	        });
	    }

	    /**
	     *  Returns this model action URL with URL prefix
	     * @param  {string}   id       some identificator of model
	     * @param  {string}   action   action name
	     *  @return {string}  url path
	     */
	    getModelActionURL(id, action = "") {
	        return notCommon$2.buildURL({
	            prefix: this.getURLPrefix(),
	            module: this.getModuleName(),
	            model: this.getModelName(),
	            id,
	            action,
	        });
	    }

	    /**
	     * Creates url from value content
	     * @param {object}  val
	     **/
	    buildURL(val) {
	        return notCommon$2.buildURL(val);
	    }

	    /**
	     *  Updates working name
	     *  @return {notController} this
	     */
	    updateAutoName() {
	        if (this.getOptions("autoName", OPT_DEFAULT_AUTO_NAME)) ;
	        return this;
	    }

	    /**
	     *  Sets object name
	     *  @param {string} val name of the object
	     *  @return {notController} this
	     */
	    setName(val) {
	        this.setWorking("name", val);
	        this.setOptions("autoName", false);
	        return this;
	    }

	    /**
	     *  Gets object name
	     *  @return {string}
	     */
	    getName(val) {
	        return this.getWorking("name");
	    }

	    /**
	     *  Preload records from server, using listAll method,
	     *  returns Promise
	     *  @param {object}  list  map of preloaded records
	     *  @return {Promise}
	     */
	    preloadLib(list = {}) {
	        return new Promise((resolve, reject) => {
	            if (typeof list !== "object") {
	                resolve(undefined);
	            } else {
	                this.setWorking("loading", []);
	                for (let t in list) {
	                    this.getWorking("loading").push(list[t]);
	                    this.make[list[t]]({})
	                        .$listAll()
	                        .then((data) => {
	                            if (!this.getOptions("libs")) {
	                                this.setOptions("libs", {});
	                            }
	                            this.getOptions("libs")[t] = data;
	                            if (
	                                this.getWorking("loading").indexOf(list[t]) > -1
	                            ) {
	                                this.getWorking("loading").splice(
	                                    this.getWorking("loading").indexOf(list[t]),
	                                    1
	                                );
	                            }
	                            if (this.getWorking("loading").length === 0) {
	                                resolve(undefined);
	                            }
	                        })
	                        .catch((err) => {
	                            this.report(err);
	                            reject();
	                        });
	                }
	                if (this.getWorking("loading").length === 0) {
	                    resolve(undefined);
	                }
	            }
	        });
	    }

	    /**
	     * emits afterRender event
	     */
	    onAfterRender() {
	        this.emit("afterRender");
	    }

	    /**
	     *  Transform route name in action name
	     *  @param {String}   name tranform action name
	     *  @return {String}
	     */
	    getActionName(name = OPT_DEFAULT_ACTION_NAME) {
	        return "run" + notCommon$2.capitalizeFirstLetter(name);
	    }

	    /**
	     *  Get default controller action name
	     *  @return {String} default action from options
	     */
	    getDefaultActionName() {
	        return this.getActionName(
	            this.getOptions("defaultAction", OPT_DEFAULT_ACTION_NAME)
	        );
	    }

	    /**
	     *  Route params into specific run[Route_name] function
	     *  @param {array}   params   controller input params
	     *  @return {undefined}
	     */
	    route(params) {
	        let [routerName, ...subParams] = params,
	            actionName = this.getActionName(
	                routerName ? routerName : OPT_DEFAULT_ACTION_NAME
	            );
	        if (typeof this[actionName] === "function") {
	            this.setCurrentAction(actionName);
	            this[actionName](subParams);
	        } else if (this[this.getDefaultActionName()]) {
	            this.setCurrentAction(this.getDefaultActionName());
	            this[this.getDefaultActionName()](subParams);
	        } else {
	            this.setCurrentAction(undefined);
	            this.error && this.error("No action in router", params);
	        }
	    }

	    /**
	     * Sets working action
	     * @params {string} actionName current action name
	     */
	    setCurrentAction(actionName) {
	        this.setWorking("action", actionName);
	    }

	    /**
	     * Gets working action
	     * @returns {string} current action name
	     */
	    getCurrentAction() {
	        return this.getWorking("action");
	    }

	    /**
	     *  Return application options
	     *  @return {object}
	     */
	    getAppOptions() {
	        try {
	            return this.getApp().getOptions();
	        } catch (e) {
	            this.error && this.error(e);
	        }
	    }

	    /**
	     *  Returns module options
	     *  @param  {string}   [moduleName]    name of the module which options requested
	     *  @return {object}
	     */

	    getModuleOptions(moduleName) {
	        try {
	            return this.getApp().getOptions(
	                ["modules", moduleName || this.getModuleName()].join(".")
	            );
	        } catch (e) {
	            this.error && this.error(e);
	        }
	    }

	    /**
	     *  Returns module services
	     *  @param  {string}   moduleName    name of the module which services requested
	     *  @return {object}
	     */

	    getServices(moduleName) {
	        try {
	            return this.getApp().getOptions(
	                ["services", moduleName || this.getModuleName()].join(".")
	            );
	        } catch (e) {
	            this.error && this.error(e);
	        }
	    }

	    /**
	     *  Returns module components
	     *  @param  {string}   moduleName    name of the module which components requested
	     *  @return {object}
	     */

	    getComponents(moduleName) {
	        try {
	            return this.getApp().getOptions(
	                ["components", moduleName || this.getModuleName()].join(".")
	            );
	        } catch (e) {
	            this.error && this.error(e);
	        }
	    }

	    /**
	     *  Refreshes current URL, re-run all action
	     *  @param {number} timeout time to wait in ms
	     */
	    refresh(timeout = 0) {
	        this.app?.getWorking("router").refresh(timeout);
	    }

	    /**
	     * Returns path pattern for router
	     * @params {number} [0] paramsCount   number of params
	     * @return {string}  pattern for controller supported url
	     */
	    static getControllerRoute(paramsCount = 0) {
	        let path = [];
	        if (this.MODULE_NAME && this.MODULE_NAME.length > 0) {
	            path.push(notCommon$2.lowerFirstLetter(this.MODULE_NAME));
	        }
	        if (this.MODEL_NAME && this.MODEL_NAME.length > 0) {
	            path.push(notCommon$2.lowerFirstLetter(this.MODEL_NAME));
	        }
	        path = [path.join("/")];
	        for (let i = 0; i < paramsCount; i++) {
	            path.push("/([^/]+)");
	        }
	        return path.join("");
	    }

	    /**
	     * Returns path patterns for router
	     * @params {number} [0] paramsDeep   how many paths with params in the end
	     * @return {string[]}  patterns for controller supported url in order of simplification
	     */
	    static getControllerRoutes(paramsDeep = 0) {
	        let routes = [this.getControllerRoute(0)];
	        for (let i = 0; i < paramsDeep; i++) {
	            routes.unshift(this.getControllerRoute(i + 1));
	        }
	        return routes;
	    }

	    /**
	     * Returns router rule.
	     * @returns {Object} router rule {paths:String[], controller:notController}
	     */
	    static getRoutes() {
	        return {
	            paths: this.getControllerRoutes(this.PARAMS_LENGTH),
	            controller: this,
	        };
	    }

	    /**
	     * Returns Application router
	     * @returns {import('./router.js')}
	     */
	    getRouter() {
	        return this.app?.getWorking("router");
	    }

	    /**
	     * Changes location to `url` after `delay` ms
	     * @param {string} url
	     * @param {number|string}   delay   number in ms or name of delay
	     */
	    navigateWithDelay(
	        url,
	        delay = NAVIGATION_DELAY_DEFAULT,
	        doBefore = () => {}
	    ) {
	        return this.getRouter().navigateWithDelay(url, delay, doBefore);
	    }

	    /**
	     * Changes location to `url`
	     * @param {string} url
	     */
	    navigate(url) {
	        return this.getRouter().navigate(url);
	    }

	    /**
	     *  Navigating to this controller main model `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	    navigateAction(id, action = "", delay = 0, doBefore = () => {}) {
	        return this.navigateModuleAction(
	            this.getModuleName(),
	            this.getModelName(),
	            id,
	            action,
	            delay,
	            doBefore
	        );
	    }

	    /**
	     *  Navigating to this controller module model of `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	    navigateModelAction(
	        modelName,
	        id,
	        action = "",
	        delay = 0,
	        doBefore = () => {}
	    ) {
	        return this.navigateModuleAction(
	            this.getModuleName(),
	            modelName,
	            id,
	            action,
	            delay,
	            doBefore
	        );
	    }

	    /**
	     *  Navigating to `moduleName` `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} moduleName
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	    navigateModuleAction(
	        moduleName,
	        modelName,
	        id,
	        action = "",
	        delay = 0,
	        doBefore = () => {}
	    ) {
	        if (delay) {
	            return this.getRouter().navigateWithDelay(
	                notCommon$2.buildURL({
	                    prefix: this.getURLPrefix(),
	                    module: moduleName,
	                    model: modelName,
	                    id,
	                    action,
	                }),
	                delay,
	                doBefore
	            );
	        } else {
	            return this.getRouter().navigate(
	                notCommon$2.buildURL({
	                    prefix: this.getURLPrefix(),
	                    module: moduleName,
	                    model: modelName,
	                    id,
	                    action,
	                })
	            );
	        }
	    }

	    static getCommonMenu(childConstructor) {
	        return [
	            {
	                section: childConstructor.MODULE_NAME,
	                title: childConstructor.LABELS.plural,
	                url: `/${notCommon$2.lowerFirstLetter(
                    childConstructor.MODULE_NAME
                )}/${notCommon$2.lowerFirstLetter(childConstructor.MODEL_NAME)}`,
	            },
	        ];
	    }

	    static getMenu() {}
	};

	const ALL = {};

	function exist(key) {
	    return Object.hasOwn(ALL, key);
	}

	function get(key) {
	    if (exist(key)) {
	        return ALL[key];
	    } else {
	        return false;
	    }
	}

	function create(
	    key,
	    props = {
	        raw: [],
	        filtered: [],
	        selected: {},
	    }
	) {
	    if (!exist(key)) {
	        if (Object.keys(props).length > 0) {
	            ALL[key] = {};
	            Object.keys(props).forEach((name) => {
	                ALL[key][name] = writable(props[name]);
	            });
	        } else {
	            throw new Error("store's props wasn't specified");
	        }
	    }
	    return ALL[key];
	}

	/* node_modules/not-bulma/src/frame/components/table/controls/ui.switch.svelte generated by Svelte v4.2.19 */

	function create_fragment$r(ctx) {
		let input;
		let input_class_value;
		let input_id_value;
		let t;
		let label;
		let label_for_value;
		let mounted;
		let dispose;

		return {
			c() {
				input = element("input");
				t = space();
				label = element("label");
				attr(input, "type", "checkbox");
				attr(input, "class", input_class_value = "switch " + /*styling*/ ctx[5]);
				attr(input, "id", input_id_value = "edit-table-row-cell-inline-switch-" + /*fieldname*/ ctx[2] + "-" + /*id*/ ctx[1]);
				attr(input, "name", /*fieldname*/ ctx[2]);
				input.readOnly = /*readonly*/ ctx[4];
				input.disabled = /*disabled*/ ctx[3];
				attr(label, "class", "label");
				attr(label, "for", label_for_value = "edit-table-row-cell-inline-switch-" + /*fieldname*/ ctx[2] + "-" + /*id*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				input.checked = /*value*/ ctx[0];
				insert(target, t, anchor);
				insert(target, label, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[7]),
						listen(input, "input", /*onInput*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*styling*/ 32 && input_class_value !== (input_class_value = "switch " + /*styling*/ ctx[5])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname, id*/ 6 && input_id_value !== (input_id_value = "edit-table-row-cell-inline-switch-" + /*fieldname*/ ctx[2] + "-" + /*id*/ ctx[1])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*readonly*/ 16) {
					input.readOnly = /*readonly*/ ctx[4];
				}

				if (dirty & /*disabled*/ 8) {
					input.disabled = /*disabled*/ ctx[3];
				}

				if (dirty & /*value*/ 1) {
					input.checked = /*value*/ ctx[0];
				}

				if (dirty & /*fieldname, id*/ 6 && label_for_value !== (label_for_value = "edit-table-row-cell-inline-switch-" + /*fieldname*/ ctx[2] + "-" + /*id*/ ctx[1])) {
					attr(label, "for", label_for_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t);
					detach(label);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$r($$self, $$props, $$invalidate) {
		let dispatch = createEventDispatcher();
		let { id = '' } = $$props;
		let { value = false } = $$props;
		let { fieldname = 'switch' } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { styling = " is-rounded is-success " } = $$props;

		function onInput(ev) {
			let data = {
				id,
				field: fieldname,
				value: ev.target.type === 'checkbox'
				? ev.target.checked
				: ev.target.value
			};

			dispatch('change', data);
			return true;
		}

		function input_change_handler() {
			value = this.checked;
			$$invalidate(0, value);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(1, id = $$props.id);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(4, readonly = $$props.readonly);
			if ('styling' in $$props) $$invalidate(5, styling = $$props.styling);
		};

		return [
			value,
			id,
			fieldname,
			disabled,
			readonly,
			styling,
			onInput,
			input_change_handler
		];
	}

	class Ui_switch extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$r, create_fragment$r, safe_not_equal, {
				id: 1,
				value: 0,
				fieldname: 2,
				disabled: 3,
				readonly: 4,
				styling: 5
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/table/controls/ui.tags.svelte generated by Svelte v4.2.19 */

	function get_each_context$a(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[1] = list[i];
		return child_ctx;
	}

	// (32:4) {:else}
	function create_else_block_1$3(ctx) {
		let span;
		let t;
		let span_class_value;

		function select_block_type_2(ctx, dirty) {
			if (/*item*/ ctx[1].url) return create_if_block_2$c;
			return create_else_block_2$2;
		}

		let current_block_type = select_block_type_2(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if_block.c();
				t = space();
				attr(span, "class", span_class_value = "mx-1 tag is-" + /*item*/ ctx[1].color + " " + /*item*/ ctx[1].customClasses + " svelte-38rpfk");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if_block.m(span, null);
				append(span, t);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, t);
					}
				}

				if (dirty & /*values*/ 1 && span_class_value !== (span_class_value = "mx-1 tag is-" + /*item*/ ctx[1].color + " " + /*item*/ ctx[1].customClasses + " svelte-38rpfk")) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if_block.d();
			}
		};
	}

	// (19:4) {#if Object.hasOwn(item, "value")}
	function create_if_block$l(ctx) {
		let div;
		let span0;
		let t0_value = /*item*/ ctx[1].title + "";
		let t0;
		let t1;
		let span1;
		let span1_class_value;
		let t2;

		function select_block_type_1(ctx, dirty) {
			if (/*item*/ ctx[1].url) return create_if_block_1$i;
			return create_else_block$f;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				div = element("div");
				span0 = element("span");
				t0 = text(t0_value);
				t1 = space();
				span1 = element("span");
				if_block.c();
				t2 = space();
				attr(span0, "class", "tag");
				attr(span1, "class", span1_class_value = "tag is-" + /*item*/ ctx[1].color + " " + /*item*/ ctx[1].customClasses + " svelte-38rpfk");
				attr(div, "class", "mx-1 tags has-addons svelte-38rpfk");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span0);
				append(span0, t0);
				append(div, t1);
				append(div, span1);
				if_block.m(span1, null);
				append(div, t2);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t0_value !== (t0_value = /*item*/ ctx[1].title + "")) set_data(t0, t0_value);

				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span1, null);
					}
				}

				if (dirty & /*values*/ 1 && span1_class_value !== (span1_class_value = "tag is-" + /*item*/ ctx[1].color + " " + /*item*/ ctx[1].customClasses + " svelte-38rpfk")) {
					attr(span1, "class", span1_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_block.d();
			}
		};
	}

	// (37:12) {:else}
	function create_else_block_2$2(ctx) {
		let t_value = /*item*/ ctx[1].title + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t_value !== (t_value = /*item*/ ctx[1].title + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (34:12) {#if item.url}
	function create_if_block_2$c(ctx) {
		let a;
		let t_value = /*item*/ ctx[1].title + "";
		let t;
		let a_href_value;
		let a_class_value;

		return {
			c() {
				a = element("a");
				t = text(t_value);
				attr(a, "href", a_href_value = /*item*/ ctx[1].url);
				attr(a, "class", a_class_value = "" + (null_to_empty(/*item*/ ctx[1].urlCustomClasses) + " svelte-38rpfk"));
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, t);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t_value !== (t_value = /*item*/ ctx[1].title + "")) set_data(t, t_value);

				if (dirty & /*values*/ 1 && a_href_value !== (a_href_value = /*item*/ ctx[1].url)) {
					attr(a, "href", a_href_value);
				}

				if (dirty & /*values*/ 1 && a_class_value !== (a_class_value = "" + (null_to_empty(/*item*/ ctx[1].urlCustomClasses) + " svelte-38rpfk"))) {
					attr(a, "class", a_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}
			}
		};
	}

	// (27:16) {:else}
	function create_else_block$f(ctx) {
		let t_value = /*item*/ ctx[1].value + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t_value !== (t_value = /*item*/ ctx[1].value + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (23:16) {#if item.url}
	function create_if_block_1$i(ctx) {
		let a;
		let t_value = /*item*/ ctx[1].value + "";
		let t;
		let a_href_value;
		let a_class_value;

		return {
			c() {
				a = element("a");
				t = text(t_value);
				attr(a, "href", a_href_value = /*item*/ ctx[1].url);
				attr(a, "class", a_class_value = "" + (null_to_empty(/*item*/ ctx[1].urlCustomClasses) + " svelte-38rpfk"));
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, t);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t_value !== (t_value = /*item*/ ctx[1].value + "")) set_data(t, t_value);

				if (dirty & /*values*/ 1 && a_href_value !== (a_href_value = /*item*/ ctx[1].url)) {
					attr(a, "href", a_href_value);
				}

				if (dirty & /*values*/ 1 && a_class_value !== (a_class_value = "" + (null_to_empty(/*item*/ ctx[1].urlCustomClasses) + " svelte-38rpfk"))) {
					attr(a, "class", a_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}
			}
		};
	}

	// (18:0) {#each values as item (item.id)}
	function create_each_block$a(key_1, ctx) {
		let first;
		let show_if;
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (dirty & /*values*/ 1) show_if = null;
			if (show_if == null) show_if = !!Object.hasOwn(/*item*/ ctx[1], "value");
			if (show_if) return create_if_block$l;
			return create_else_block_1$3;
		}

		let current_block_type = select_block_type(ctx, -1);
		let if_block = current_block_type(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if_block.c();
				if_block_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function create_fragment$q(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[1].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$a(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (dirty & /*values, Object*/ 1) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$a, each_1_anchor, get_each_context$a);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	function instance$q($$self, $$props, $$invalidate) {
		let { values = [] } = $$props;

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
		};

		return [values];
	}

	class Ui_tags extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$q, create_fragment$q, safe_not_equal, { values: 0 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/table/notTableCell.svelte generated by Svelte v4.2.19 */

	function create_else_block$e(ctx) {
		let t_value = /*$LOCALE*/ ctx[5][notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, field, item, helpers*/ 46 && t_value !== (t_value = /*$LOCALE*/ ctx[5][notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (71:98) 
	function create_if_block_7$2(ctx) {
		let t_value = notCommon$2.strLengthCap(notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]), /*field*/ ctx[1].maxLength) + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*field, item, helpers*/ 14 && t_value !== (t_value = notCommon$2.strLengthCap(notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]), /*field*/ ctx[1].maxLength) + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (60:30) 
	function create_if_block_6$2(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			{
				id: /*getItemId*/ ctx[0](/*item*/ ctx[2])
			},
			{ fieldname: /*field*/ ctx[1].path },
			{ disabled: /*field*/ ctx[1].disabled },
			{ readonly: /*field*/ ctx[1].readonly },
			{
				value: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
			},
			/*field*/ ctx[1].options
		];

		var switch_value = /*field*/ ctx[1].component;

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*getItemId, item, field, helpers*/ 15) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*getItemId, item*/ 5 && {
						id: /*getItemId*/ ctx[0](/*item*/ ctx[2])
					},
					dirty & /*field*/ 2 && { fieldname: /*field*/ ctx[1].path },
					dirty & /*field*/ 2 && { disabled: /*field*/ ctx[1].disabled },
					dirty & /*field*/ 2 && { readonly: /*field*/ ctx[1].readonly },
					dirty & /*field, item, helpers*/ 14 && {
						value: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
					},
					dirty & /*field*/ 2 && get_spread_object(/*field*/ ctx[1].options)
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));

			switch_instance.$on("change", function () {
				if (is_function(/*field*/ ctx[1].onChange)) /*field*/ ctx[1].onChange.apply(this, arguments);
			});
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*field*/ 2 && switch_value !== (switch_value = /*field*/ ctx[1].component)) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));

						switch_instance.$on("change", function () {
							if (is_function(/*field*/ ctx[1].onChange)) /*field*/ ctx[1].onChange.apply(this, arguments);
						});

						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*getItemId, item, field, helpers*/ 15)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*getItemId, item*/ 5 && {
								id: /*getItemId*/ ctx[0](/*item*/ ctx[2])
							},
							dirty & /*field*/ 2 && { fieldname: /*field*/ ctx[1].path },
							dirty & /*field*/ 2 && { disabled: /*field*/ ctx[1].disabled },
							dirty & /*field*/ 2 && { readonly: /*field*/ ctx[1].readonly },
							dirty & /*field, item, helpers*/ 14 && {
								value: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
							},
							dirty & /*field*/ 2 && get_spread_object(/*field*/ ctx[1].options)
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (51:38) 
	function create_if_block_5$4(ctx) {
		let tableswitch;
		let current;

		tableswitch = new Ui_switch({
				props: {
					id: /*getItemId*/ ctx[0](/*item*/ ctx[2]),
					fieldname: /*field*/ ctx[1].path,
					value: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]),
					disabled: /*field*/ ctx[1].disabled,
					readonly: /*field*/ ctx[1].readonly
				}
			});

		tableswitch.$on("change", function () {
			if (is_function(/*field*/ ctx[1].onChange)) /*field*/ ctx[1].onChange.apply(this, arguments);
		});

		return {
			c() {
				create_component(tableswitch.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tableswitch, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const tableswitch_changes = {};
				if (dirty & /*getItemId, item*/ 5) tableswitch_changes.id = /*getItemId*/ ctx[0](/*item*/ ctx[2]);
				if (dirty & /*field*/ 2) tableswitch_changes.fieldname = /*field*/ ctx[1].path;
				if (dirty & /*field, item, helpers*/ 14) tableswitch_changes.value = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				if (dirty & /*field*/ 2) tableswitch_changes.disabled = /*field*/ ctx[1].disabled;
				if (dirty & /*field*/ 2) tableswitch_changes.readonly = /*field*/ ctx[1].readonly;
				tableswitch.$set(tableswitch_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tableswitch.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tableswitch.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tableswitch, detaching);
			}
		};
	}

	// (49:35) 
	function create_if_block_4$6(ctx) {
		let tabletags;
		let current;

		tabletags = new Ui_tags({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(tabletags.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tabletags, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tabletags_changes = {};
				if (dirty & /*field, item, helpers*/ 14) tabletags_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				tabletags.$set(tabletags_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tabletags.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tabletags.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tabletags, detaching);
			}
		};
	}

	// (47:39) 
	function create_if_block_3$9(ctx) {
		let uibooleans;
		let current;

		uibooleans = new Ui_booleans({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibooleans_changes = {};
				if (dirty & /*field, item, helpers*/ 14) uibooleans_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				uibooleans.$set(uibooleans_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	// (45:37) 
	function create_if_block_2$b(ctx) {
		let uiimages;
		let current;

		uiimages = new Ui_images({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(uiimages.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiimages, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiimages_changes = {};
				if (dirty & /*field, item, helpers*/ 14) uiimages_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				uiimages.$set(uiimages_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiimages.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiimages.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiimages, detaching);
			}
		};
	}

	// (43:38) 
	function create_if_block_1$h(ctx) {
		let uibuttons;
		let current;

		uibuttons = new Ui_buttons({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(uibuttons.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttons, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttons_changes = {};
				if (dirty & /*field, item, helpers*/ 14) uibuttons_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttons, detaching);
			}
		};
	}

	// (41:4) {#if field.type === "link"}
	function create_if_block$k(ctx) {
		let uilinks;
		let current;

		uilinks = new Ui_links({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(uilinks.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uilinks, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uilinks_changes = {};
				if (dirty & /*field, item, helpers*/ 14) uilinks_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				uilinks.$set(uilinks_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilinks.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilinks.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uilinks, detaching);
			}
		};
	}

	function create_fragment$p(ctx) {
		let td;
		let show_if;
		let current_block_type_index;
		let if_block;
		let td_class_value;
		let current;

		const if_block_creators = [
			create_if_block$k,
			create_if_block_1$h,
			create_if_block_2$b,
			create_if_block_3$9,
			create_if_block_4$6,
			create_if_block_5$4,
			create_if_block_6$2,
			create_if_block_7$2,
			create_else_block$e
		];

		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (dirty & /*field*/ 2) show_if = null;
			if (/*field*/ ctx[1].type === "link") return 0;
			if (/*field*/ ctx[1].type === "button") return 1;
			if (/*field*/ ctx[1].type === "image") return 2;
			if (/*field*/ ctx[1].type === "boolean") return 3;
			if (/*field*/ ctx[1].type === "tag") return 4;
			if (/*field*/ ctx[1].type === "switch") return 5;
			if (/*field*/ ctx[1].component) return 6;
			if (show_if == null) show_if = !!(/*field*/ ctx[1] && typeof /*field*/ ctx[1] !== "undefined" && !isNaN(/*field*/ ctx[1].maxLength) && /*field*/ ctx[1].maxLength);
			if (show_if) return 7;
			return 8;
		}

		current_block_type_index = select_block_type(ctx, -1);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				td = element("td");
				if_block.c();
				attr(td, "class", td_class_value = /*field*/ ctx[1].hideOnMobile ? "is-hidden-touch" : "");
				attr(td, "title", /*title*/ ctx[4]);
			},
			m(target, anchor) {
				insert(target, td, anchor);
				if_blocks[current_block_type_index].m(td, null);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(td, null);
				}

				if (!current || dirty & /*field*/ 2 && td_class_value !== (td_class_value = /*field*/ ctx[1].hideOnMobile ? "is-hidden-touch" : "")) {
					attr(td, "class", td_class_value);
				}

				if (!current || dirty & /*title*/ 16) {
					attr(td, "title", /*title*/ ctx[4]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(td);
				}

				if_blocks[current_block_type_index].d();
			}
		};
	}

	function instance$p($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(5, $LOCALE = $$value));
		let title = "";

		onMount(() => {
			if (typeof field.type === "undefined") {
				if (Object.hasOwn(field, "titlePath")) {
					$$invalidate(4, title = notPath$1.get(field.titlePath, item, helpers));
				} else if (Object.hasOwn(field, "titleComposer") && typeof field.titleComposer === "function") {
					$$invalidate(4, title = field.titleComposer(item, helpers));
				} else {
					$$invalidate(4, title = notPath$1.get(field.path, item, helpers));
				}
			}
		});

		let { getItemId = item => item._id } = $$props;
		let { field = {} } = $$props;
		let { item = {} } = $$props;
		let { helpers = {} } = $$props;

		$$self.$$set = $$props => {
			if ('getItemId' in $$props) $$invalidate(0, getItemId = $$props.getItemId);
			if ('field' in $$props) $$invalidate(1, field = $$props.field);
			if ('item' in $$props) $$invalidate(2, item = $$props.item);
			if ('helpers' in $$props) $$invalidate(3, helpers = $$props.helpers);
		};

		return [getItemId, field, item, helpers, title, $LOCALE];
	}

	class NotTableCell extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$p, create_fragment$p, safe_not_equal, {
				getItemId: 0,
				field: 1,
				item: 2,
				helpers: 3
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/table/notTableRow.svelte generated by Svelte v4.2.19 */

	function get_each_context$9(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[12] = list[i];
		return child_ctx;
	}

	// (36:2) {#if showSelect && $selectedList }
	function create_if_block$j(ctx) {
		let td;
		let input;
		let input_id_value;
		let input_data_id_value;
		let input_name_value;
		let mounted;
		let dispose;

		return {
			c() {
				td = element("td");
				input = element("input");
				attr(input, "id", input_id_value = "table-row-select-" + /*getItemId*/ ctx[4](/*item*/ ctx[0]));
				attr(input, "type", "checkbox");
				attr(input, "data-id", input_data_id_value = /*getItemId*/ ctx[4](/*item*/ ctx[0]));
				attr(input, "placeholder", "");
				attr(input, "name", input_name_value = "row_selected_" + /*getItemId*/ ctx[4](/*item*/ ctx[0]));
			},
			m(target, anchor) {
				insert(target, td, anchor);
				append(td, input);
				input.checked = /*$selectedList*/ ctx[7][/*itemId*/ ctx[5]];

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[10]),
						listen(input, "change", /*onRowSelect*/ ctx[8])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*getItemId, item*/ 17 && input_id_value !== (input_id_value = "table-row-select-" + /*getItemId*/ ctx[4](/*item*/ ctx[0]))) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*getItemId, item*/ 17 && input_data_id_value !== (input_data_id_value = /*getItemId*/ ctx[4](/*item*/ ctx[0]))) {
					attr(input, "data-id", input_data_id_value);
				}

				if (dirty & /*getItemId, item*/ 17 && input_name_value !== (input_name_value = "row_selected_" + /*getItemId*/ ctx[4](/*item*/ ctx[0]))) {
					attr(input, "name", input_name_value);
				}

				if (dirty & /*$selectedList, itemId*/ 160) {
					input.checked = /*$selectedList*/ ctx[7][/*itemId*/ ctx[5]];
				}
			},
			d(detaching) {
				if (detaching) {
					detach(td);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (41:2) {#each fields as field }
	function create_each_block$9(ctx) {
		let uitablecell;
		let current;

		uitablecell = new NotTableCell({
				props: {
					field: /*field*/ ctx[12],
					helpers: /*helpers*/ ctx[1],
					item: /*item*/ ctx[0],
					getItemId: /*getItemId*/ ctx[4]
				}
			});

		return {
			c() {
				create_component(uitablecell.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitablecell, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitablecell_changes = {};
				if (dirty & /*fields*/ 4) uitablecell_changes.field = /*field*/ ctx[12];
				if (dirty & /*helpers*/ 2) uitablecell_changes.helpers = /*helpers*/ ctx[1];
				if (dirty & /*item*/ 1) uitablecell_changes.item = /*item*/ ctx[0];
				if (dirty & /*getItemId*/ 16) uitablecell_changes.getItemId = /*getItemId*/ ctx[4];
				uitablecell.$set(uitablecell_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitablecell.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitablecell.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitablecell, detaching);
			}
		};
	}

	function create_fragment$o(ctx) {
		let tr;
		let t;
		let current;
		let if_block = /*showSelect*/ ctx[3] && /*$selectedList*/ ctx[7] && create_if_block$j(ctx);
		let each_value = ensure_array_like(/*fields*/ ctx[2]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				tr = element("tr");
				if (if_block) if_block.c();
				t = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
			},
			m(target, anchor) {
				insert(target, tr, anchor);
				if (if_block) if_block.m(tr, null);
				append(tr, t);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(tr, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (/*showSelect*/ ctx[3] && /*$selectedList*/ ctx[7]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$j(ctx);
						if_block.c();
						if_block.m(tr, t);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty & /*fields, helpers, item, getItemId*/ 23) {
					each_value = ensure_array_like(/*fields*/ ctx[2]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$9(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$9(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(tr, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(tr);
				}

				if (if_block) if_block.d();
				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$o($$self, $$props, $$invalidate) {
		let $selectedList,
			$$unsubscribe_selectedList = noop$1,
			$$subscribe_selectedList = () => ($$unsubscribe_selectedList(), $$unsubscribe_selectedList = subscribe(selectedList, $$value => $$invalidate(7, $selectedList = $$value)), selectedList);

		$$self.$$.on_destroy.push(() => $$unsubscribe_selectedList());
		let dispatch = createEventDispatcher();
		let itemId, selectedList;

		onMount(() => {
			$$invalidate(5, itemId = getItemId(item));
			$$subscribe_selectedList($$invalidate(6, selectedList = get(id).selected));
		});

		let { id } = $$props;
		let { item = {} } = $$props;
		let { helpers = {} } = $$props;
		let { fields = [] } = $$props;
		let { showSelect = false } = $$props;

		let { getItemId = () => {
			
		} } = $$props;

		function onRowSelect(e) {
			e.preventDefault();

			dispatch('rowSelectChange', {
				id: itemId,
				selected: $selectedList[itemId]
			});

			return false;
		}

		function input_change_handler() {
			$selectedList[itemId] = this.checked;
			selectedList.set($selectedList);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(9, id = $$props.id);
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
			if ('helpers' in $$props) $$invalidate(1, helpers = $$props.helpers);
			if ('fields' in $$props) $$invalidate(2, fields = $$props.fields);
			if ('showSelect' in $$props) $$invalidate(3, showSelect = $$props.showSelect);
			if ('getItemId' in $$props) $$invalidate(4, getItemId = $$props.getItemId);
		};

		return [
			item,
			helpers,
			fields,
			showSelect,
			getItemId,
			itemId,
			selectedList,
			$selectedList,
			onRowSelect,
			id,
			input_change_handler
		];
	}

	class NotTableRow extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$o, create_fragment$o, safe_not_equal, {
				id: 9,
				item: 0,
				helpers: 1,
				fields: 2,
				showSelect: 3,
				getItemId: 4
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/table/notTable.svelte generated by Svelte v4.2.19 */

	function get_each_context$8(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		return child_ctx;
	}

	function get_each_context_1$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[33] = list[i];
		return child_ctx;
	}

	function get_each_context_2$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[36] = list[i];
		const constants_0 = /*field*/ child_ctx[36].path.substring(1);
		child_ctx[37] = constants_0;
		return child_ctx;
	}

	// (123:0) {#if links.length}
	function create_if_block_7$1(ctx) {
		let div;
		let uilinks;
		let current;
		uilinks = new Ui_links({ props: { values: /*links*/ ctx[11] } });

		return {
			c() {
				div = element("div");
				create_component(uilinks.$$.fragment);
				attr(div, "class", "field is-grouped");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uilinks, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const uilinks_changes = {};
				if (dirty[0] & /*links*/ 2048) uilinks_changes.values = /*links*/ ctx[11];
				uilinks.$set(uilinks_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilinks.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilinks.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uilinks);
			}
		};
	}

	// (128:0) {#if actions.length}
	function create_if_block_6$1(ctx) {
		let div;
		let uibuttons;
		let current;
		uibuttons = new Ui_buttons({ props: { values: /*actions*/ ctx[10] } });

		return {
			c() {
				div = element("div");
				create_component(uibuttons.$$.fragment);
				attr(div, "class", "field is-grouped");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uibuttons, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttons_changes = {};
				if (dirty[0] & /*actions*/ 1024) uibuttons_changes.values = /*actions*/ ctx[10];
				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uibuttons);
			}
		};
	}

	// (133:0) {#if showSearch}
	function create_if_block_4$5(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_5$3, create_else_block_2$1];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*filterUI*/ ctx[7]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (141:4) {:else}
	function create_else_block_2$1(ctx) {
		let div1;
		let div0;
		let input;
		let mounted;
		let dispose;

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				input = element("input");
				attr(input, "class", "input");
				attr(input, "type", "text");
				attr(input, "placeholder", "Поиск");
				attr(div0, "class", "control");
				attr(div1, "class", "field");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div0, input);
				set_input_value(input, /*search*/ ctx[4]);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[26]),
						listen(input, "input", /*onSearchInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*search*/ 16 && input.value !== /*search*/ ctx[4]) {
					set_input_value(input, /*search*/ ctx[4]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (134:4) {#if filterUI}
	function create_if_block_5$3(ctx) {
		let switch_instance;
		let updating_filter;
		let switch_instance_anchor;
		let current;

		function switch_instance_filter_binding(value) {
			/*switch_instance_filter_binding*/ ctx[25](value);
		}

		var switch_value = /*filterUI*/ ctx[7];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			if (/*filter*/ ctx[1] !== void 0) {
				switch_instance_props.filter = /*filter*/ ctx[1];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'filter', switch_instance_filter_binding));
			switch_instance.$on("change", /*onFilterChange*/ ctx[18]);
			switch_instance.$on("searchChange", /*onSearchChange*/ ctx[17]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*filterUI*/ 128 && switch_value !== (switch_value = /*filterUI*/ ctx[7])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
						binding_callbacks.push(() => bind(switch_instance, 'filter', switch_instance_filter_binding));
						switch_instance.$on("change", /*onFilterChange*/ ctx[18]);
						switch_instance.$on("searchChange", /*onSearchChange*/ ctx[17]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = {};

					if (!updating_filter && dirty[0] & /*filter*/ 2) {
						updating_filter = true;
						switch_instance_changes.filter = /*filter*/ ctx[1];
						add_flush_callback(() => updating_filter = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (157:8) {#if showSelect}
	function create_if_block_3$8(ctx) {
		let th;
		let input;
		let mounted;
		let dispose;

		return {
			c() {
				th = element("th");
				input = element("input");
				attr(input, "type", "checkbox");
				attr(input, "id", "table-row-select-page");
				attr(input, "placeholder", "");
				attr(input, "name", "row_selected_all");
			},
			m(target, anchor) {
				insert(target, th, anchor);
				append(th, input);
				input.checked = /*selectAll*/ ctx[5];

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[27]),
						listen(input, "change", /*onSelectAll*/ ctx[22])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectAll*/ 32) {
					input.checked = /*selectAll*/ ctx[5];
				}
			},
			d(detaching) {
				if (detaching) {
					detach(th);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (182:16) {:else}
	function create_else_block_1$2(ctx) {
		let t_value = /*$LOCALE*/ ctx[15][/*field*/ ctx[36].title] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, fields*/ 33280 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*field*/ ctx[36].title] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (176:16) {#if field.sortable && Object.hasOwn(sorter, propPath)}
	function create_if_block_2$a(ctx) {
		let uiicon;
		let current;

		uiicon = new Ui_icon_font({
				props: {
					font: /*sorter*/ ctx[2][/*propPath*/ ctx[37]] > 0
					? "sort-up"
					: "sort-down",
					title: /*field*/ ctx[36].title,
					pointable: true
				}
			});

		return {
			c() {
				create_component(uiicon.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiicon, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiicon_changes = {};

				if (dirty[0] & /*sorter, fields*/ 516) uiicon_changes.font = /*sorter*/ ctx[2][/*propPath*/ ctx[37]] > 0
				? "sort-up"
				: "sort-down";

				if (dirty[0] & /*fields*/ 512) uiicon_changes.title = /*field*/ ctx[36].title;
				uiicon.$set(uiicon_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiicon.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiicon.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiicon, detaching);
			}
		};
	}

	// (169:8) {#each fields as field}
	function create_each_block_2$3(ctx) {
		let th;
		let show_if;
		let current_block_type_index;
		let if_block;
		let t;
		let th_class_value;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_2$a, create_else_block_1$2];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (dirty[0] & /*fields, sorter*/ 516) show_if = null;
			if (show_if == null) show_if = !!(/*field*/ ctx[36].sortable && Object.hasOwn(/*sorter*/ ctx[2], /*propPath*/ ctx[37]));
			if (show_if) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx, [-1, -1]);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				th = element("th");
				if_block.c();
				t = space();
				attr(th, "class", th_class_value = (/*field*/ ctx[36].hideOnMobile ? " is-hidden-touch" : "") + (/*field*/ ctx[36].sortable ? " is-clickable" : ""));
			},
			m(target, anchor) {
				insert(target, th, anchor);
				if_blocks[current_block_type_index].m(th, null);
				append(th, t);
				current = true;

				if (!mounted) {
					dispose = listen(th, "click", function () {
						if (is_function(/*onFieldHeadClick*/ ctx[23](/*field*/ ctx[36]))) /*onFieldHeadClick*/ ctx[23](/*field*/ ctx[36]).apply(this, arguments);
					});

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(th, t);
				}

				if (!current || dirty[0] & /*fields*/ 512 && th_class_value !== (th_class_value = (/*field*/ ctx[36].hideOnMobile ? " is-hidden-touch" : "") + (/*field*/ ctx[36].sortable ? " is-clickable" : ""))) {
					attr(th, "class", th_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(th);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};
	}

	// (189:8) {#each items as item (item._id)}
	function create_each_block_1$4(key_1, ctx) {
		let first;
		let uitablerow;
		let current;

		uitablerow = new NotTableRow({
				props: {
					id: /*id*/ ctx[6],
					item: /*item*/ ctx[33],
					fields: /*fields*/ ctx[9],
					helpers: /*helpers*/ ctx[8],
					showSelect: /*showSelect*/ ctx[13],
					getItemId: /*getItemId*/ ctx[14]
				}
			});

		uitablerow.$on("rowSelectChange", /*rowSelectChange_handler*/ ctx[28]);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uitablerow.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uitablerow, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const uitablerow_changes = {};
				if (dirty[0] & /*id*/ 64) uitablerow_changes.id = /*id*/ ctx[6];
				if (dirty[0] & /*items*/ 8) uitablerow_changes.item = /*item*/ ctx[33];
				if (dirty[0] & /*fields*/ 512) uitablerow_changes.fields = /*fields*/ ctx[9];
				if (dirty[0] & /*helpers*/ 256) uitablerow_changes.helpers = /*helpers*/ ctx[8];
				if (dirty[0] & /*showSelect*/ 8192) uitablerow_changes.showSelect = /*showSelect*/ ctx[13];
				if (dirty[0] & /*getItemId*/ 16384) uitablerow_changes.getItemId = /*getItemId*/ ctx[14];
				uitablerow.$set(uitablerow_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitablerow.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitablerow.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uitablerow, detaching);
			}
		};
	}

	// (206:8) {#if state.pagination && state.pagination.pages && state.pagination.pages.list}
	function create_if_block$i(ctx) {
		let each_1_anchor;
		let each_value = ensure_array_like(/*state*/ ctx[0].pagination.pages.list);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*state, goTo*/ 2097153) {
					each_value = ensure_array_like(/*state*/ ctx[0].pagination.pages.list);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$8(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$8(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (216:20) {:else}
	function create_else_block$d(ctx) {
		let a;
		let t_value = /*page*/ ctx[30].index + 1 + "";
		let t;
		let a_aria_label_value;
		let a_data_page_value;
		let mounted;
		let dispose;

		return {
			c() {
				a = element("a");
				t = text(t_value);
				attr(a, "href", "");
				attr(a, "class", "pagination-link");
				attr(a, "aria-label", a_aria_label_value = "Страница " + /*page*/ ctx[30].index);
				attr(a, "data-page", a_data_page_value = /*page*/ ctx[30].index);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, t);

				if (!mounted) {
					dispose = listen(a, "click", /*goTo*/ ctx[21]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*state*/ 1 && t_value !== (t_value = /*page*/ ctx[30].index + 1 + "")) set_data(t, t_value);

				if (dirty[0] & /*state*/ 1 && a_aria_label_value !== (a_aria_label_value = "Страница " + /*page*/ ctx[30].index)) {
					attr(a, "aria-label", a_aria_label_value);
				}

				if (dirty[0] & /*state*/ 1 && a_data_page_value !== (a_data_page_value = /*page*/ ctx[30].index)) {
					attr(a, "data-page", a_data_page_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (209:20) {#if page.active}
	function create_if_block_1$g(ctx) {
		let a;
		let t_value = /*page*/ ctx[30].index + 1 + "";
		let t;
		let a_aria_label_value;

		return {
			c() {
				a = element("a");
				t = text(t_value);
				attr(a, "href", "");
				attr(a, "class", "pagination-link is-current");
				attr(a, "aria-label", a_aria_label_value = "Страница " + /*page*/ ctx[30].index);
				attr(a, "aria-current", "page");
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*state*/ 1 && t_value !== (t_value = /*page*/ ctx[30].index + 1 + "")) set_data(t, t_value);

				if (dirty[0] & /*state*/ 1 && a_aria_label_value !== (a_aria_label_value = "Страница " + /*page*/ ctx[30].index)) {
					attr(a, "aria-label", a_aria_label_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}
			}
		};
	}

	// (207:12) {#each state.pagination.pages.list as page}
	function create_each_block$8(ctx) {
		let li;
		let t;

		function select_block_type_2(ctx, dirty) {
			if (/*page*/ ctx[30].active) return create_if_block_1$g;
			return create_else_block$d;
		}

		let current_block_type = select_block_type_2(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				li = element("li");
				if_block.c();
				t = space();
			},
			m(target, anchor) {
				insert(target, li, anchor);
				if_block.m(li, null);
				append(li, t);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(li, t);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				if_block.d();
			}
		};
	}

	function create_fragment$n(ctx) {
		let t0;
		let t1;
		let t2;
		let table;
		let thead;
		let t3;
		let t4;
		let tbody;
		let each_blocks = [];
		let each1_lookup = new Map();
		let t5;
		let nav;
		let a0;
		let t7;
		let a1;
		let t9;
		let ul;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*links*/ ctx[11].length && create_if_block_7$1(ctx);
		let if_block1 = /*actions*/ ctx[10].length && create_if_block_6$1(ctx);
		let if_block2 = /*showSearch*/ ctx[12] && create_if_block_4$5(ctx);
		let if_block3 = /*showSelect*/ ctx[13] && create_if_block_3$8(ctx);
		let each_value_2 = ensure_array_like(/*fields*/ ctx[9]);
		let each_blocks_1 = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks_1[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
		}

		const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
			each_blocks_1[i] = null;
		});

		let each_value_1 = ensure_array_like(/*items*/ ctx[3]);
		const get_key = ctx => /*item*/ ctx[33]._id;

		for (let i = 0; i < each_value_1.length; i += 1) {
			let child_ctx = get_each_context_1$4(ctx, each_value_1, i);
			let key = get_key(child_ctx);
			each1_lookup.set(key, each_blocks[i] = create_each_block_1$4(key, child_ctx));
		}

		let if_block4 = /*state*/ ctx[0].pagination && /*state*/ ctx[0].pagination.pages && /*state*/ ctx[0].pagination.pages.list && create_if_block$i(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				table = element("table");
				thead = element("thead");
				if (if_block3) if_block3.c();
				t3 = space();

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].c();
				}

				t4 = space();
				tbody = element("tbody");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t5 = space();
				nav = element("nav");
				a0 = element("a");
				a0.textContent = "Назад";
				t7 = space();
				a1 = element("a");
				a1.textContent = "Вперед";
				t9 = space();
				ul = element("ul");
				if (if_block4) if_block4.c();
				attr(table, "class", "table");
				attr(a0, "href", "");
				attr(a0, "class", "pagination-previous");
				attr(a1, "href", "");
				attr(a1, "class", "pagination-next");
				attr(ul, "class", "pagination-list");
				attr(nav, "class", "pagination is-centered");
				attr(nav, "aria-label", "pagination");
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t2, anchor);
				insert(target, table, anchor);
				append(table, thead);
				if (if_block3) if_block3.m(thead, null);
				append(thead, t3);

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					if (each_blocks_1[i]) {
						each_blocks_1[i].m(thead, null);
					}
				}

				append(table, t4);
				append(table, tbody);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(tbody, null);
					}
				}

				insert(target, t5, anchor);
				insert(target, nav, anchor);
				append(nav, a0);
				append(nav, t7);
				append(nav, a1);
				append(nav, t9);
				append(nav, ul);
				if (if_block4) if_block4.m(ul, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(a0, "click", /*goPrev*/ ctx[19]),
						listen(a1, "click", /*goNext*/ ctx[20])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (/*links*/ ctx[11].length) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*links*/ 2048) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_7$1(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*actions*/ ctx[10].length) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*actions*/ 1024) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_6$1(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*showSearch*/ ctx[12]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*showSearch*/ 4096) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_4$5(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(t2.parentNode, t2);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*showSelect*/ ctx[13]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block_3$8(ctx);
						if_block3.c();
						if_block3.m(thead, t3);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}

				if (dirty[0] & /*fields, onFieldHeadClick, sorter, $LOCALE*/ 8421892) {
					each_value_2 = ensure_array_like(/*fields*/ ctx[9]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

						if (each_blocks_1[i]) {
							each_blocks_1[i].p(child_ctx, dirty);
							transition_in(each_blocks_1[i], 1);
						} else {
							each_blocks_1[i] = create_each_block_2$3(child_ctx);
							each_blocks_1[i].c();
							transition_in(each_blocks_1[i], 1);
							each_blocks_1[i].m(thead, null);
						}
					}

					group_outros();

					for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (dirty[0] & /*id, items, fields, helpers, showSelect, getItemId*/ 25416) {
					each_value_1 = ensure_array_like(/*items*/ ctx[3]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each1_lookup, tbody, outro_and_destroy_block, create_each_block_1$4, null, get_each_context_1$4);
					check_outros();
				}

				if (/*state*/ ctx[0].pagination && /*state*/ ctx[0].pagination.pages && /*state*/ ctx[0].pagination.pages.list) {
					if (if_block4) {
						if_block4.p(ctx, dirty);
					} else {
						if_block4 = create_if_block$i(ctx);
						if_block4.c();
						if_block4.m(ul, null);
					}
				} else if (if_block4) {
					if_block4.d(1);
					if_block4 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks_1[i]);
				}

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				each_blocks_1 = each_blocks_1.filter(Boolean);

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					transition_out(each_blocks_1[i]);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(table);
					detach(t5);
					detach(nav);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				if (if_block3) if_block3.d();
				destroy_each(each_blocks_1, detaching);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}

				if (if_block4) if_block4.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$n($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(15, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { id } = $$props;
		let { filterUI } = $$props;
		let { helpers = {} } = $$props;
		let { state = {} } = $$props;
		let { filter = {} } = $$props;
		let { sorter = {} } = $$props;
		let { fields = [] } = $$props;
		let { selected = {} } = $$props;
		let { items = [] } = $$props;
		let { actions = [] } = $$props;
		let { links = [] } = $$props;
		let { search = "" } = $$props;
		let { showSearch = true } = $$props;
		let { showSelect = true } = $$props;
		let { selectAll = false } = $$props;
		let { getItemId = item => item._id } = $$props;

		onMount(() => {
			if (showSelect) {
				get(id).selected.subscribe(value => {
					$$invalidate(24, selected = value);
				});
			}

			get(id).refined.subscribe(value => {
				$$invalidate(3, items = value);

				if (showSelect) {
					for (let itemId in selected) {
						if (!items.some(item => getItemId(item) === itemId)) {
							delete selected[itemId];
						} else {
							if (!Object.hasOwn(selected, itemId)) {
								$$invalidate(24, selected[itemId] = false, selected);
							}
						}
					}

					$$invalidate(24, selected);
				}
			});

			get(id).state.subscribe(value => {
				$$invalidate(0, state = value);
			});
		});

		function onSearchInput(ev) {
			try {
				let data = ev.currentTarget.value.trim();
				dispatch("searchChange", data);
			} catch(e) {
				return;
			}
		}

		function onSearchChange({ detail }) {
			try {
				dispatch("searchChange", detail);
			} catch(e) {
				return;
			}
		}

		function onFilterChange({ detail }) {
			try {
				dispatch("filterChange", detail);
			} catch(e) {
				return;
			}
		}

		function goPrev() {
			dispatch("goToPrevPage");
		}

		function goNext() {
			dispatch("goToNextPage");
		}

		function goTo(e) {
			e.preventDefault();
			let el = e.target;
			dispatch("goToPage", parseInt(el.dataset.page));
			return false;
		}

		function onSelectAll() {
			get(id).selected.update(value => {
				items.forEach(item => {
					value[getItemId(item)] = selectAll;
				});

				return value;
			});
		}

		function onFieldHeadClick(field) {
			const propPath = field.path.substring(1);

			if (Object.hasOwn(sorter, propPath)) {
				$$invalidate(2, sorter[propPath] = parseInt(sorter[propPath]) * -1, sorter);
			} else {
				$$invalidate(2, sorter = { [propPath]: 1 });
			}

			dispatch("sorterChange", sorter);
		}

		function switch_instance_filter_binding(value) {
			filter = value;
			$$invalidate(1, filter);
		}

		function input_input_handler() {
			search = this.value;
			$$invalidate(4, search);
		}

		function input_change_handler() {
			selectAll = this.checked;
			$$invalidate(5, selectAll);
		}

		function rowSelectChange_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(6, id = $$props.id);
			if ('filterUI' in $$props) $$invalidate(7, filterUI = $$props.filterUI);
			if ('helpers' in $$props) $$invalidate(8, helpers = $$props.helpers);
			if ('state' in $$props) $$invalidate(0, state = $$props.state);
			if ('filter' in $$props) $$invalidate(1, filter = $$props.filter);
			if ('sorter' in $$props) $$invalidate(2, sorter = $$props.sorter);
			if ('fields' in $$props) $$invalidate(9, fields = $$props.fields);
			if ('selected' in $$props) $$invalidate(24, selected = $$props.selected);
			if ('items' in $$props) $$invalidate(3, items = $$props.items);
			if ('actions' in $$props) $$invalidate(10, actions = $$props.actions);
			if ('links' in $$props) $$invalidate(11, links = $$props.links);
			if ('search' in $$props) $$invalidate(4, search = $$props.search);
			if ('showSearch' in $$props) $$invalidate(12, showSearch = $$props.showSearch);
			if ('showSelect' in $$props) $$invalidate(13, showSelect = $$props.showSelect);
			if ('selectAll' in $$props) $$invalidate(5, selectAll = $$props.selectAll);
			if ('getItemId' in $$props) $$invalidate(14, getItemId = $$props.getItemId);
		};

		return [
			state,
			filter,
			sorter,
			items,
			search,
			selectAll,
			id,
			filterUI,
			helpers,
			fields,
			actions,
			links,
			showSearch,
			showSelect,
			getItemId,
			$LOCALE,
			onSearchInput,
			onSearchChange,
			onFilterChange,
			goPrev,
			goNext,
			goTo,
			onSelectAll,
			onFieldHeadClick,
			selected,
			switch_instance_filter_binding,
			input_input_handler,
			input_change_handler,
			rowSelectChange_handler
		];
	}

	class NotTable extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$n,
				create_fragment$n,
				safe_not_equal,
				{
					id: 6,
					filterUI: 7,
					helpers: 8,
					state: 0,
					filter: 1,
					sorter: 2,
					fields: 9,
					selected: 24,
					items: 3,
					actions: 10,
					links: 11,
					search: 4,
					showSearch: 12,
					showSelect: 13,
					selectAll: 5,
					getItemId: 14
				},
				null,
				[-1, -1]
			);
		}
	}

	const CONST_ID_DUBLICATE_POSTFIX = "__dublicate__";

	const OPT_DEFAULT_PAGE_SIZE$1 = 20,
	    OPT_DEFAULT_PAGE_NUMBER$1 = 0,
	    OPT_DEFAULT_PAGE_RANGE$1 = 6,
	    OPT_DEFAULT_SORT_DIRECTION$1 = 1,
	    OPT_DEFAULT_SEARCH$1 = "",
	    OPT_DEFAULT_RETURN$1 = {},
	    OPT_DEFAULT_COMBINED = false,
	    OPT_DEFAULT_COMBINED_ACTION$1 = "listAndCount",
	    OPT_DEFAULT_COUNT_ACTION = "count",
	    OPT_DEFAULT_LIST_ACTION = "list",
	    OPT_DEFAULT_SORT_FIELD$1 = "_id",
	    OPT_FIELD_NAME_PRE_PROC = "preprocessor";

	const DEFAULT_OPTIONS$3 = {
	    ui: NotTable,
	    links: [],
	    actions: [],
	    endless: false,
	    idField: "_id",
	    getItemId: (item) => {
	        return item._id;
	    },
	};

	class notTable extends EventEmitter {
	    constructor(input = {}) {
	        super();
	        this.id = "table-" + Math.random();
	        this.options = {
	            ...DEFAULT_OPTIONS$3,
	            ...(input.options ? input.options : {}),
	        };
	        this.ui = {};
	        this.data = {
	            raw: [],
	            filtered: [],
	            refined: [],
	            selected: {},
	        };
	        this.state = {
	            pagination: {
	                items: {
	                    count: 0,
	                    from: 0,
	                    to: 0,
	                },
	                pages: {
	                    count: 0,
	                    from: 0,
	                    to: 0,
	                    current: 0,
	                    list: [],
	                },
	            },
	        };
	        this.working = {};

	        this.stores = create(this.id, {
	            raw: [],
	            filtered: [],
	            refined: [],
	            selected: {},
	            state: this.state,
	            working: this.working,
	        });

	        this.stores.working.subscribe(this.onWorkingUpdate.bind(this));
	        //полученные из сети
	        this.stores.raw.subscribe(this.onRawUpdate.bind(this));
	        //применены фильтры, сортировки и т.д.
	        this.stores.filtered.subscribe(this.onFilteredUpdate.bind(this));
	        //урезаны до минимального набора, точно соотвествующего табличному формату
	        this.stores.refined.subscribe(this.onRefinedUpdate.bind(this));
	        //словарь с идентификаторами выбранных строк
	        this.stores.selected.subscribe(this.onSelectedUpdate.bind(this));
	        //pagination, items information
	        this.stores.state.subscribe(this.onStateUpdate.bind(this));

	        if (notCommon$2.objHas(input, "data") && Array.isArray(input.data)) {
	            this.stores.raw.update((val) => {
	                val = input.data;
	                return val;
	            });
	        }
	        if (notCommon$2.objHas(this.options, "filter")) {
	            this.setFilter(this.options.filter, true);
	        } else {
	            this.resetFilter();
	        }
	        if (notCommon$2.objHas(this.options, "pager")) {
	            this.setPager(this.options.pager, true);
	        } else {
	            this.resetPager();
	        }
	        if (notCommon$2.objHas(this.options, "sorter")) {
	            this.setSorter(this.options.sorter, true);
	        } else {
	            this.resetSorter(true);
	        }
	        if (notCommon$2.objHas(this.options, "return")) {
	            this.setReturn(this.options.return);
	        } else {
	            this.setReturn();
	        }
	        if (notCommon$2.objHas(this.options, "search")) {
	            this.setSearch(this.options.search, true);
	        } else {
	            this.setSearch();
	        }
	        this.render();
	        this.updateData();
	        return this;
	    }

	    onWorkingUpdate(val) {
	        this.working = val;
	        return val;
	    }

	    onRawUpdate(val) {
	        this.data.raw = val;
	        return val;
	    }

	    onFilteredUpdate(val) {
	        this.data.filtered = val;
	        this.refineFiltered();
	        return val;
	    }

	    onRefinedUpdate(val) {
	        this.data.refined = val;
	        this.clearSelected();
	        return val;
	    }

	    onStateUpdate(val) {
	        this.state = val;
	        return val;
	    }

	    onSearchChange(line) {
	        if (line.length > 3) {
	            this.setSearch(line);
	        } else {
	            this.setSearch();
	        }
	    }

	    onSorterChange(sorter) {
	        if (sorter) {
	            this.setSorter(sorter);
	        } else {
	            this.resetSorter();
	        }
	    }

	    onFilterChange(filter) {
	        if (filter) {
	            this.setFilter(filter);
	        } else {
	            this.resetFilter();
	        }
	    }

	    onSelectedUpdate(val) {
	        this.data.selected = val;
	    }

	    clearSelected() {
	        this.data.selected = {};
	    }

	    getSelected(object = false, store = "refined") {
	        let res = [];
	        for (let id in this.data.selected) {
	            if (this.data.selected[id]) {
	                if (object) {
	                    let indx = this.data[store].findIndex(
	                        (item) => item._id === id
	                    );
	                    if (indx > -1) {
	                        res.push(this.data[store][indx]);
	                    }
	                } else {
	                    res.push(id);
	                }
	            }
	        }
	        return res;
	    }

	    getItemId(item) {
	        return this.getOptions("getItemId", DEFAULT_OPTIONS$3.getItemId)(item);
	    }

	    selectAll() {
	        this.stores.selected.update(() => {
	            let value = {};
	            this.data.filtered.forEach((item) => {
	                value[this.getItemId(item)] = true;
	            });
	            return value;
	        });
	    }

	    selectNone() {
	        this.stores.selected.update(() => {
	            let value = {};
	            this.data.filtered.forEach((item) => {
	                value[this.getItemId(item)] = false;
	            });
	            return value;
	        });
	    }

	    render() {
	        if (!this.ui.table) {
	            this.ui.table = new this.options.ui({
	                target: this.options.targetEl,
	                props: {
	                    filterUI: this.getOptions("filterUI", undefined),
	                    id: this.id,
	                    helpers: Object.assign({}, this.getHelpers()),
	                    fields: this.getOptions("fields"),
	                    actions: this.getActions(),
	                    links: this.getLinks(),
	                    search: "",
	                    showSelect: this.getOptions("showSelect"),
	                    showSearch: this.getOptions("showSearch"),
	                    showSort: this.getOptions("showSort"),
	                    idField: this.getOptions("idField"),
	                    getItemId: this.getOptions("getItemId"),
	                    filter: this.getFilter(),
	                },
	            });
	        }
	        this.ui.table.$on("searchChange", (e) => this.onSearchChange(e.detail));
	        this.ui.table.$on("sorterChange", (e) => this.onSorterChange(e.detail));
	        this.ui.table.$on("filterChange", (e) => this.onFilterChange(e.detail));
	        this.ui.table.$on("goToPage", (e) => this.goToPage(e.detail));
	        this.ui.table.$on("goToNextPage", () => this.goToNext());
	        this.ui.table.$on("goToPrevPage", () => this.goToPrev());
	    }

	    getActions() {
	        return this.getOptions("actions", []);
	    }

	    getLinks() {
	        return this.getOptions("links", []);
	    }

	    getHelpers() {
	        return this.options.helpers || {};
	    }

	    setWorking(key, value) {
	        this.stores.working.update((val) => {
	            notPath$1.set(key, val, this.getHelpers(), value);
	            return val;
	        });
	        return this;
	    }

	    getWorking(key, def) {
	        let res = notPath$1.get(key, this.working, this.getHelpers());
	        if (res === undefined) {
	            return def;
	        } else {
	            return res;
	        }
	    }

	    setState(key, value) {
	        this.stores.state.update((val) => {
	            notPath$1.set(key, val, this.getHelpers(), value);
	            return val;
	        });
	        return this;
	    }

	    getState(key, def) {
	        let res = notPath$1.get(key, this.state, this.getHelpers());
	        if (res === undefined) {
	            return def;
	        } else {
	            return res;
	        }
	    }

	    setOptions(key, value) {
	        notPath$1.set(key, this.options, this.getHelpers(), value);
	        return this;
	    }

	    getOptions(key, def) {
	        let res = notPath$1.get(key, this.options, this.getHelpers());
	        if (res === undefined) {
	            return def;
	        } else {
	            return res;
	        }
	    }

	    setFilter(hash, withoutInvalidation = false) {
	        this.setState("filter", hash);
	        if (withoutInvalidation) {
	            return this;
	        }
	        this.invalidateData();
	        this.updateData();
	        return this;
	    }

	    resetFilter() {
	        this.setState("filter", {});
	        return this;
	    }

	    getFilter() {
	        return this.getState("filter");
	    }

	    setPager(hash, withoutInvalidation = false) {
	        this.setState("pager", hash);
	        if (withoutInvalidation) {
	            return this;
	        }
	        this.updateData();
	        return this;
	    }

	    getDefaultPageNumber() {
	        return isNaN(this.getOptions("pager.page"))
	            ? OPT_DEFAULT_PAGE_NUMBER$1
	            : this.getOptions("pager.page");
	    }

	    getDefaultPageSize() {
	        return isNaN(this.getOptions("pager.size"))
	            ? OPT_DEFAULT_PAGE_SIZE$1
	            : this.getOptions("pager.size");
	    }

	    resetPager() {
	        this.setState("pager", {
	            size: this.getDefaultPageSize(),
	            page: this.getDefaultPageNumber(),
	        });
	    }

	    getPager() {
	        return this.getState("pager");
	    }

	    setSorter(hash, withoutInvalidation = false) {
	        this.setWorking("sorter", hash);
	        if (withoutInvalidation) {
	            return this;
	        }
	        this.invalidateData();
	        this.updateData();
	        return this;
	    }

	    resetSorter(withoutInvalidation = false) {
	        let t = {};
	        t[OPT_DEFAULT_SORT_FIELD$1] = OPT_DEFAULT_SORT_DIRECTION$1;
	        return this.setSorter(t, withoutInvalidation);
	    }

	    getSorter() {
	        return this.getWorking("sorter");
	    }

	    getSorterDirection() {
	        try {
	            let names = Object.keys(this.getSorter());
	            return this.getSorter()[names[0]];
	        } catch (e) {
	            return OPT_DEFAULT_SORT_DIRECTION$1;
	        }
	    }

	    getSearch() {
	        let search =
	            typeof this.getWorking("search") !== "undefined" &&
	            this.getWorking("search") !== null;
	        return search ? this.getWorking("search") : "";
	    }

	    setSearch(line = OPT_DEFAULT_SEARCH$1, withoutInvalidation = false) {
	        this.setWorking("search", line);
	        if (withoutInvalidation) {
	            return this;
	        }
	        this.invalidateData();
	        this.updateData();
	        return this;
	    }

	    getReturn() {
	        return this.getWorking("return");
	    }

	    setReturn(ret = OPT_DEFAULT_RETURN$1) {
	        this.setWorking("return", ret);
	        return this;
	    }

	    clearFilteredData() {
	        this.stores.filtered.update((val) => {
	            val.splice(0, val.length);
	            return val;
	        });
	    }

	    clearRawData() {
	        this.stores.raw.update((val) => {
	            val.splice(0, val.length);
	            return val;
	        });
	    }

	    clearRefinedData() {
	        this.stores.refined.update((val) => {
	            val.splice(0, val.length);
	            return val;
	        });
	    }

	    invalidateData() {
	        //clearing filtered and sorted
	        this.clearFilteredData();
	        //in case live loading from server
	        if (this.isLive()) {
	            //clearing loaded data
	            this.clearRawData();
	        }
	        //resset pager anyway
	        this.resetPager();
	    }

	    isLive() {
	        return (
	            this.getOptions("interface") && this.getOptions("interface.factory")
	        );
	    }

	    setUpdating() {
	        this.setState("updating", true);
	    }

	    setUpdated() {
	        this.setState("updating", false);
	    }

	    ifUpdating() {
	        return this.getState("updating");
	    }

	    getDataInterface() {
	        let factory = this.getOptions("interface.factory");
	        if (typeof factory === "function") {
	            return factory({});
	        } else {
	            return factory;
	        }
	    }

	    getLoadDataActionName() {
	        return this.getOptions("interface.listAction")
	            ? this.getOptions("interface.listAction")
	            : OPT_DEFAULT_LIST_ACTION;
	    }

	    getCombinedActionName() {
	        return this.getOptions("interface.combinedAction")
	            ? this.getOptions("interface.combinedAction")
	            : OPT_DEFAULT_COMBINED_ACTION$1;
	    }

	    getCountActionName() {
	        return this.getOptions("interface.countAction")
	            ? this.getOptions("interface.countAction")
	            : OPT_DEFAULT_COUNT_ACTION;
	    }

	    loadData() {
	        //load from server
	        let query = this.getDataInterface()
	                .setFilter(this.getFilter())
	                .setSorter(this.getSorter())
	                .setReturn(this.getReturn())
	                .setSearch(this.getSearch())
	                .setPager(this.getPager()),
	            actionName;
	        if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	            actionName = this.getCombinedActionName();
	        } else {
	            actionName = this.getLoadDataActionName();
	        }
	        return query["$" + actionName]();
	    }

	    goToNext() {
	        let next = isNaN(this.getState("pager.page"))
	            ? this.getDefaultPageNumber()
	            : this.getState("pager.page") + 1;
	        this.setState(
	            "pager.page",
	            Math.min(next, this.getState("pagination.pages.to"))
	        );
	        this.updateData();
	    }

	    goToPrev() {
	        let prev = isNaN(this.getState("pager.page"))
	            ? this.getDefaultPageNumber()
	            : this.getState("pager.page") - 1;
	        this.setState(
	            "pager.page",
	            Math.max(prev, this.getState("pagination.pages.from"))
	        );
	        this.updateData();
	    }

	    goToFirst() {
	        this.setState("pager.page", this.getState("pagination.pages.from"));
	        this.updateData();
	    }

	    goToLast() {
	        this.setState("pager.page", this.getState("pagination.pages.to"));
	        this.updateData();
	    }

	    goToPage(pageNumber) {
	        this.setState("pager.page", pageNumber);
	        this.updateData();
	    }

	    testDataItem(item) {
	        var strValue = this.getSearch().toLowerCase();
	        for (var k in item) {
	            var toComp = item[k].toString().toLowerCase();
	            if (toComp.indexOf(strValue) > -1) {
	                return true;
	            }
	        }
	        return false;
	    }

	    getRowsCount() {
	        let query = this.getDataInterface().setFilter(this.getFilter());
	        return query["$" + this.getCountActionName()]()
	            .then((data) => {
	                this.updatePagination(data.count);
	            })
	            .catch((e) => {
	                this.error(e);
	            });
	    }

	    updatePagination(itemsCount) {
	        this.log("update pagination", itemsCount);
	        this.state.pagination.pages.list.splice(
	            0,
	            this.state.pagination.pages.list.length
	        );
	        let itemsFrom =
	                (this.getPager().page - OPT_DEFAULT_PAGE_NUMBER$1) *
	                    this.getPager().size +
	                1,
	            pagesCount =
	                itemsCount % this.getPager().size
	                    ? Math.floor(itemsCount / this.getPager().size) + 1
	                    : Math.round(itemsCount / this.getPager().size),
	            pagesFrom = Math.max(
	                OPT_DEFAULT_PAGE_NUMBER$1,
	                this.getPager().page - OPT_DEFAULT_PAGE_RANGE$1
	            ),
	            pagesTo = Math.min(
	                pagesCount - (1 - OPT_DEFAULT_PAGE_NUMBER$1),
	                this.getPager().page + OPT_DEFAULT_PAGE_RANGE$1
	            ),
	            list = [],
	            itemsTo = Math.min(
	                itemsFrom + this.getPager().size - 1,
	                itemsCount
	            );
	        for (let t = pagesFrom; t <= pagesTo; t++) {
	            list.push({
	                index: t,
	                active: t === this.getPager().page,
	            });
	        }

	        this.stores.state.update((val) => {
	            this.log("update pagination", val);
	            val.pagination.items.count = itemsCount;
	            val.pagination.items.from = itemsFrom;
	            val.pagination.items.to = itemsTo;
	            val.pagination.pages.count = pagesCount;
	            val.pagination.pages.from = pagesFrom;
	            val.pagination.pages.to = pagesTo;
	            val.pagination.pages.current = this.getPager().page;
	            val.pagination.pages.list.splice(
	                0,
	                val.pagination.pages.list.length,
	                ...list
	            );
	            return val;
	        });
	    }

	    updateData() {
	        if (this.isLive()) {
	            if (this.ifUpdating()) {
	                return;
	            }
	            if (!this.getOptions("endless", false)) {
	                this.clearRawData();
	            }
	            this.setUpdating();
	            if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	                this.loadData()
	                    .then((data) => {
	                        let full =
	                            notCommon$2.objHas(data, "status") &&
	                            notCommon$2.objHas(data, "result");
	                        this.stores.filtered.update((val) => {
	                            if (!this.getOptions("endless", false)) {
	                                this.clearFilteredData();
	                            }
	                            if (full) {
	                                val.push(...data.result.list);
	                            } else {
	                                if (
	                                    notCommon$2.objHas(data, "list") &&
	                                    Array.isArray(data.list)
	                                ) {
	                                    val.push(...data.list);
	                                } else if (Array.isArray(data)) {
	                                    val.push(...data);
	                                }
	                            }
	                            return val;
	                        });
	                        this.setWorking(
	                            "lastCount",
	                            full ? data.result.count : data.count
	                        );
	                    })
	                    .then(() => {
	                        this.updatePagination(this.getWorking("lastCount"));
	                    })
	                    .catch(this.error.bind(this))
	                    .then(this.setUpdated.bind(this));
	            } else {
	                this.loadData()
	                    .then((data) => {
	                        this.stores.filtered.update((val) => {
	                            val.push(...data);
	                            return val;
	                        });
	                    })
	                    .then(this.getRowsCount.bind(this))
	                    .catch(this.error.bind(this))
	                    .then(this.setUpdated.bind(this));
	            }
	        } else {
	            //local magic
	            this.setUpdating();
	            this.processData();
	            this.setUpdated();
	        }
	    }

	    getData() {
	        return this.data;
	    }

	    processData() {
	        let thatFilter = this.getFilter();
	        //this.getData('rows').__setPassive;
	        this.log(this.getData());
	        if (
	            typeof thatFilter !== "undefined" &&
	            thatFilter !== null &&
	            typeof thatFilter.filterSearch !== "undefined" &&
	            thatFilter.filterSearch !== null &&
	            thatFilter.filterSearch.length > 0
	        ) {
	            this.stores.filtered.update((val) => {
	                val.splice(
	                    0,
	                    val.length,
	                    ...this.data.raw.filter(this.testDataItem.bind(this))
	                );
	                return val;
	            });
	        } else {
	            this.stores.filtered.update((val) => {
	                val.splice(0, val.length, ...this.data.raw);
	                return val;
	            });
	        }
	        ////sorter
	        let thatSorter = this.getSorter();
	        if (typeof thatSorter !== "undefined" && thatSorter !== null) {
	            this.stores.filtered.update((val) => {
	                val.sort((item1, item2) => {
	                    let t1 = notPath$1.get(thatSorter.sortByField, item1, {}),
	                        t2 = notPath$1.get(thatSorter.sortByField, item2, {});
	                    if (isNaN(t1)) {
	                        if (
	                            typeof t1 !== "undefined" &&
	                            typeof t2 !== "undefined" &&
	                            t1.localeCompare
	                        ) {
	                            return (
	                                t1.localeCompare() * -thatSorter.sortDirection
	                            );
	                        } else {
	                            return 0;
	                        }
	                    } else {
	                        return (t1 < t2 ? 1 : -1) * thatSorter.sortDirection;
	                    }
	                });
	                return val;
	            });
	        }
	    }

	    error() {
	        if (this.options.logger) {
	            this.options.logger.error(...arguments);
	        }
	    }

	    log() {
	        if (this.options.logger) {
	            this.options.logger.log(...arguments);
	        }
	    }

	    checkFieldsNames() {
	        const fieldId = this.getOptions("idField");
	        const pathId = ":" + fieldId;
	        let fields = this.getOptions("fields", []);
	        fields.forEach((field) => {
	            if (pathId === field.path) {
	                field.path = field.path + CONST_ID_DUBLICATE_POSTFIX;
	            }
	        });
	    }

	    readFieldValue(path, item, helpers) {
	        if (path.indexOf(CONST_ID_DUBLICATE_POSTFIX) > -1) {
	            const fieldId = this.getOptions("idField");
	            const pathId = ":" + fieldId;
	            return notPath$1.get(pathId, item, helpers);
	        } else {
	            return notPath$1.get(path, item, helpers);
	        }
	    }

	    refineFiltered() {
	        let result = [];
	        this.checkFieldsNames();
	        this.data.filtered.forEach((item, index) => {
	            let refined = {};
	            if (this.getOptions("idField")) {
	                refined[this.getOptions("idField")] =
	                    item[this.getOptions("idField")];
	            }
	            this.getOptions("fields", []).forEach((field) => {
	                let preprocessed = null,
	                    val = this.readFieldValue(
	                        field.path,
	                        item,
	                        this.getOptions("helpers")
	                    );
	                if (notCommon$2.objHas(field, OPT_FIELD_NAME_PRE_PROC)) {
	                    try {
	                        preprocessed = field[OPT_FIELD_NAME_PRE_PROC](
	                            val,
	                            item,
	                            index
	                        );
	                    } catch (e) {
	                        this.error(
	                            "Error while preprocessing cell value",
	                            val,
	                            item,
	                            index
	                        );
	                        this.error(e);
	                    }
	                    notPath$1.set(field.path, refined, preprocessed);
	                } else {
	                    notPath$1.set(field.path, refined, val);
	                }
	            });
	            result.push(refined);
	        });
	        this.stores.refined.update((val) => {
	            val.splice(0, val.length, ...result);
	            return val;
	        });
	    }

	    $destroy() {
	        for (let name in this.ui) {
	            this.ui[name].$destroy && this.ui[name].$destroy();
	            delete this.ui[name];
	        }
	    }
	}

	/* node_modules/not-bulma/src/frame/components/action/ui.action.container.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$f(ctx) {
		let uinotificationerror;
		let updating_title;
		let updating_message;
		let current;

		function uinotificationerror_title_binding(value) {
			/*uinotificationerror_title_binding*/ ctx[18](value);
		}

		function uinotificationerror_message_binding(value) {
			/*uinotificationerror_message_binding*/ ctx[19](value);
		}

		let uinotificationerror_props = {};

		if (/*errorTitle*/ ctx[5] !== void 0) {
			uinotificationerror_props.title = /*errorTitle*/ ctx[5];
		}

		if (/*errorMessage*/ ctx[6] !== void 0) {
			uinotificationerror_props.message = /*errorMessage*/ ctx[6];
		}

		uinotificationerror = new Ui_error({ props: uinotificationerror_props });
		binding_callbacks.push(() => bind(uinotificationerror, 'title', uinotificationerror_title_binding));
		binding_callbacks.push(() => bind(uinotificationerror, 'message', uinotificationerror_message_binding));

		return {
			c() {
				create_component(uinotificationerror.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinotificationerror, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinotificationerror_changes = {};

				if (!updating_title && dirty & /*errorTitle*/ 32) {
					updating_title = true;
					uinotificationerror_changes.title = /*errorTitle*/ ctx[5];
					add_flush_callback(() => updating_title = false);
				}

				if (!updating_message && dirty & /*errorMessage*/ 64) {
					updating_message = true;
					uinotificationerror_changes.message = /*errorMessage*/ ctx[6];
					add_flush_callback(() => updating_message = false);
				}

				uinotificationerror.$set(uinotificationerror_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinotificationerror.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinotificationerror.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinotificationerror, detaching);
			}
		};
	}

	// (81:2) {#if success}
	function create_if_block$h(ctx) {
		let uinotificationsuccess;
		let updating_title;
		let updating_message;
		let current;

		function uinotificationsuccess_title_binding(value) {
			/*uinotificationsuccess_title_binding*/ ctx[20](value);
		}

		function uinotificationsuccess_message_binding(value) {
			/*uinotificationsuccess_message_binding*/ ctx[21](value);
		}

		let uinotificationsuccess_props = {};

		if (/*successTitle*/ ctx[3] !== void 0) {
			uinotificationsuccess_props.title = /*successTitle*/ ctx[3];
		}

		if (/*successMessage*/ ctx[4] !== void 0) {
			uinotificationsuccess_props.message = /*successMessage*/ ctx[4];
		}

		uinotificationsuccess = new Ui_success({ props: uinotificationsuccess_props });
		binding_callbacks.push(() => bind(uinotificationsuccess, 'title', uinotificationsuccess_title_binding));
		binding_callbacks.push(() => bind(uinotificationsuccess, 'message', uinotificationsuccess_message_binding));

		return {
			c() {
				create_component(uinotificationsuccess.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinotificationsuccess, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinotificationsuccess_changes = {};

				if (!updating_title && dirty & /*successTitle*/ 8) {
					updating_title = true;
					uinotificationsuccess_changes.title = /*successTitle*/ ctx[3];
					add_flush_callback(() => updating_title = false);
				}

				if (!updating_message && dirty & /*successMessage*/ 16) {
					updating_message = true;
					uinotificationsuccess_changes.message = /*successMessage*/ ctx[4];
					add_flush_callback(() => updating_message = false);
				}

				uinotificationsuccess.$set(uinotificationsuccess_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinotificationsuccess.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinotificationsuccess.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinotificationsuccess, detaching);
			}
		};
	}

	// (77:0) <UIContainer {...container} >
	function create_default_slot$2(ctx) {
		let t;
		let if_block1_anchor;
		let current;
		let if_block0 = /*error*/ ctx[9] && create_if_block_1$f(ctx);
		let if_block1 = /*success*/ ctx[8] && create_if_block$h(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*error*/ ctx[9]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*error*/ 512) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$f(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*success*/ ctx[8]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*success*/ 256) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$h(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	function create_fragment$m(ctx) {
		let uiloader;
		let updating_loading;
		let updating_title;
		let updating_size;
		let t;
		let uicontainer;
		let current;

		function uiloader_loading_binding(value) {
			/*uiloader_loading_binding*/ ctx[15](value);
		}

		function uiloader_title_binding(value) {
			/*uiloader_title_binding*/ ctx[16](value);
		}

		function uiloader_size_binding(value) {
			/*uiloader_size_binding*/ ctx[17](value);
		}

		let uiloader_props = {};

		if (/*loaderActive*/ ctx[1] !== void 0) {
			uiloader_props.loading = /*loaderActive*/ ctx[1];
		}

		if (/*loaderTitle*/ ctx[0] !== void 0) {
			uiloader_props.title = /*loaderTitle*/ ctx[0];
		}

		if (/*loaderSize*/ ctx[2] !== void 0) {
			uiloader_props.size = /*loaderSize*/ ctx[2];
		}

		uiloader = new Ui_loader({ props: uiloader_props });
		binding_callbacks.push(() => bind(uiloader, 'loading', uiloader_loading_binding));
		binding_callbacks.push(() => bind(uiloader, 'title', uiloader_title_binding));
		binding_callbacks.push(() => bind(uiloader, 'size', uiloader_size_binding));
		const uicontainer_spread_levels = [/*container*/ ctx[7]];

		let uicontainer_props = {
			$$slots: { default: [create_default_slot$2] },
			$$scope: { ctx }
		};

		for (let i = 0; i < uicontainer_spread_levels.length; i += 1) {
			uicontainer_props = assign(uicontainer_props, uicontainer_spread_levels[i]);
		}

		uicontainer = new Ui_container({ props: uicontainer_props });

		return {
			c() {
				create_component(uiloader.$$.fragment);
				t = space();
				create_component(uicontainer.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiloader, target, anchor);
				insert(target, t, anchor);
				mount_component(uicontainer, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uiloader_changes = {};

				if (!updating_loading && dirty & /*loaderActive*/ 2) {
					updating_loading = true;
					uiloader_changes.loading = /*loaderActive*/ ctx[1];
					add_flush_callback(() => updating_loading = false);
				}

				if (!updating_title && dirty & /*loaderTitle*/ 1) {
					updating_title = true;
					uiloader_changes.title = /*loaderTitle*/ ctx[0];
					add_flush_callback(() => updating_title = false);
				}

				if (!updating_size && dirty & /*loaderSize*/ 4) {
					updating_size = true;
					uiloader_changes.size = /*loaderSize*/ ctx[2];
					add_flush_callback(() => updating_size = false);
				}

				uiloader.$set(uiloader_changes);

				const uicontainer_changes = (dirty & /*container*/ 128)
				? get_spread_update(uicontainer_spread_levels, [get_spread_object(/*container*/ ctx[7])])
				: {};

				if (dirty & /*$$scope, successTitle, successMessage, success, errorTitle, errorMessage, error*/ 4195192) {
					uicontainer_changes.$$scope = { dirty, ctx };
				}

				uicontainer.$set(uicontainer_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiloader.$$.fragment, local);
				transition_in(uicontainer.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiloader.$$.fragment, local);
				transition_out(uicontainer.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}

				destroy_component(uiloader, detaching);
				destroy_component(uicontainer, detaching);
			}
		};
	}

	function instance$m($$self, $$props, $$invalidate) {
		let { container = {} } = $$props;
		let { loaderTitle = 'Отправка данных на сервер' } = $$props;
		let { loaderActive = false } = $$props;
		let { loaderSize = 'container' } = $$props;
		let success = false;
		let { successTitle = 'OK' } = $$props;
		let { successMessage = '' } = $$props;
		let error = false;
		let { errorTitle = 'Error' } = $$props;
		let { errorMessage = '' } = $$props;

		function showSuccess(title, message) {
			$$invalidate(9, error = false);
			$$invalidate(8, success = true);

			if (message != undefined) {
				$$invalidate(4, successMessage = message);
			}

			if (title != undefined) {
				$$invalidate(3, successTitle = title);
			}
		}

		function showError(title, message) {
			$$invalidate(8, success = false);
			$$invalidate(9, error = true);

			if (message != undefined) {
				messageTitle = message;
			}

			if (title != undefined) {
				$$invalidate(3, successTitle = title);
			}
		}

		function setLoading() {
			$$invalidate(1, loaderActive = true);
			$$invalidate(8, success = false);
			$$invalidate(9, error = false);
		}

		function resetLoading() {
			$$invalidate(1, loaderActive = false);
		}

		function hideAll() {
			$$invalidate(1, loaderActive = false);
			$$invalidate(8, success = false);
			$$invalidate(9, error = false);
		}

		function uiloader_loading_binding(value) {
			loaderActive = value;
			$$invalidate(1, loaderActive);
		}

		function uiloader_title_binding(value) {
			loaderTitle = value;
			$$invalidate(0, loaderTitle);
		}

		function uiloader_size_binding(value) {
			loaderSize = value;
			$$invalidate(2, loaderSize);
		}

		function uinotificationerror_title_binding(value) {
			errorTitle = value;
			$$invalidate(5, errorTitle);
		}

		function uinotificationerror_message_binding(value) {
			errorMessage = value;
			$$invalidate(6, errorMessage);
		}

		function uinotificationsuccess_title_binding(value) {
			successTitle = value;
			$$invalidate(3, successTitle);
		}

		function uinotificationsuccess_message_binding(value) {
			successMessage = value;
			$$invalidate(4, successMessage);
		}

		$$self.$$set = $$props => {
			if ('container' in $$props) $$invalidate(7, container = $$props.container);
			if ('loaderTitle' in $$props) $$invalidate(0, loaderTitle = $$props.loaderTitle);
			if ('loaderActive' in $$props) $$invalidate(1, loaderActive = $$props.loaderActive);
			if ('loaderSize' in $$props) $$invalidate(2, loaderSize = $$props.loaderSize);
			if ('successTitle' in $$props) $$invalidate(3, successTitle = $$props.successTitle);
			if ('successMessage' in $$props) $$invalidate(4, successMessage = $$props.successMessage);
			if ('errorTitle' in $$props) $$invalidate(5, errorTitle = $$props.errorTitle);
			if ('errorMessage' in $$props) $$invalidate(6, errorMessage = $$props.errorMessage);
		};

		return [
			loaderTitle,
			loaderActive,
			loaderSize,
			successTitle,
			successMessage,
			errorTitle,
			errorMessage,
			container,
			success,
			error,
			showSuccess,
			showError,
			setLoading,
			resetLoading,
			hideAll,
			uiloader_loading_binding,
			uiloader_title_binding,
			uiloader_size_binding,
			uinotificationerror_title_binding,
			uinotificationerror_message_binding,
			uinotificationsuccess_title_binding,
			uinotificationsuccess_message_binding
		];
	}

	class Ui_action_container extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$m, create_fragment$m, safe_not_equal, {
				container: 7,
				loaderTitle: 0,
				loaderActive: 1,
				loaderSize: 2,
				successTitle: 3,
				successMessage: 4,
				errorTitle: 5,
				errorMessage: 6,
				showSuccess: 10,
				showError: 11,
				setLoading: 12,
				resetLoading: 13,
				hideAll: 14
			});
		}

		get showSuccess() {
			return this.$$.ctx[10];
		}

		get showError() {
			return this.$$.ctx[11];
		}

		get setLoading() {
			return this.$$.ctx[12];
		}

		get resetLoading() {
			return this.$$.ctx[13];
		}

		get hideAll() {
			return this.$$.ctx[14];
		}
	}

	const DEFAULT_CONTAINER_SELECTOR$2 = '.container';

	class notActionUI extends notBase$1 {
	  //UI renderer component class constructor
	  #uiComponent = null;
	  #ui = null;

	  constructor({
	    target = null,
	    name = 'Default',
	    options = {},
	    working = {},
	    data = {},
	    ui = Ui_action_container, //default UI
	  }) {
	    super({
	      working: {
	        name: `${name}ActionUI`,
	        ...working,
	      },
	      options,
	      data
	    });
	    if(target){
	      this.setOptions('target', target);
	    }
	    this.#uiComponent = ui;
	    this.initUI();
	  }

	  initUI() {
	    try {
	      const target = this.getTargetEl();
	      while(target.children.length) target.removeChild(target.firstChild);
	      this.#ui = new this.#uiComponent({
	        target,
	        props: this.getOptions()
	      });
	    } catch (e) {
	      this.error(e);
	    }
	  }

	  setLoading() {
	    this.emit('loading');
	    this.#ui.setLoading();
	  }

	  resetLoading() {
	    this.emit('loaded');
	    this.#ui.resetLoading();
	  }

	  destroy() {
	    this.emit('destroy');
	    if (this.#ui){
	      this.#ui.$destroy && this.#ui.$destroy();
	      this.#ui.destroy && this.#ui.destroy();
	      this.#ui = null;
	    }
	    this.setOptions(null);
	    this.setWorking(null);
	    this.setData(null);
	  }

	  processResult(result) {
	    if (result.status === DEFAULT_STATUS_SUCCESS) {
	      this.setFormSuccess();
	      return true;
	    } else {
	      this.setFormErrors(result);
	      return false;
	    }
	  }

	  /**
	   *   Form validation result
	   **/
	  setFormSuccess() {
	    this.#ui.showSuccess();
	    this.emit('success');
	  }

	  setFormErrors(result) {
	    const status = {
	      form: [],
	      fields: {}
	    };
	    if (result.message) {
	      status.form.push(result.message);
	    }
	    if (result.errors && Object.keys(result.errors).length > 0) {
	      status.fields = { ...result.errors
	      };
	    }
	    this.#ui.showError(status);
	    this.emit('error', status);
	  }

	  /***
	   * Redefinable getters
	   **/
	  getTargetEl() {
	    const targetEl = this.getOptions(
	      'target',
	      DEFAULT_CONTAINER_SELECTOR$2
	    );
	    if (targetEl instanceof HTMLElement) {
	      return targetEl;
	    } else if (typeof targetEl === 'string') {
	      return document.querySelector(targetEl);
	    } else {
	      throw new Error('ActionUI parent element is not defined');
	    }
	  }

	}

	let notFormUtils$1 = class notFormUtils {
	    static validator = null;

	    static addComponent(name, value) {
	        COMPONENTS$2.add(name, value);
	    }

	    static addVariants(name, value) {
	        VARIANTS$1.add(name, value);
	    }

	    static addField(name, field) {
	        FIELDS$2.add(name, field);
	    }

	    static actionFieldsInit(fieldName, options, data) {
	        if (Array.isArray(fieldName)) {
	            fieldName.forEach((subFieldName) => {
	                this.actionFieldsInit(subFieldName, options, data);
	            });
	        } else {
	            if (!notCommon$2.objHas(options, "fields")) {
	                options.fields = {};
	            }
	            if (!notCommon$2.objHas(options.fields, fieldName)) {
	                options.fields[fieldName] = {};
	            }
	            //copying initial data
	            if (
	                typeof data !== "undefined" &&
	                data !== null &&
	                typeof data[fieldName] !== "undefined" &&
	                data[fieldName] !== null
	            ) {
	                options.fields[fieldName].value = data[fieldName];
	            }
	        }
	    }
	};

	const DEFAULT_FIELD = {
	  label: '',
	  placeholder: '',
	  enabled: true,
	  visible: true,
	  required: true,
	  validated: false,
	  valid: false,
	  errors: false
	};

	/**
	* Creates field manifest
	* @param {string} type      name/type of the field
	* @param {Object} mutation  mutation to manifest from library
	* @param {Object} VARIANTS  store which contains named lists of field value variants
	* @param {Object} FIELDS    store which contains named lists of field manifests
	* @return {Object}          field manifest
	**/
	function fieldInit(type, mutation = {}, VARIANTS, FIELDS) {
	  let field = { ...DEFAULT_FIELD };
	  //getting field core manifest
	  if (FIELDS.contains(type)) {
	    field = {
	      ...field,
	      ...FIELDS.get(type)
	    };
	  }
	  //adding mutations
	  if (mutation) {
	    field = {
	      ...field,
	      ...mutation
	    };
	  }
	  //adding variants list to field from VARIANTS store
	  if (
	    notCommon$2.objHas(field, 'variantsSource') &&
	    VARIANTS.contains(field.variantsSource)
	  ) {
	    field.variants = VARIANTS.get(field.variantsSource);
	  }else {
	    if(!field.variants || field.variants.length === 0 ){
	      field.variants = [];
	    }
	  }
	  return field;
	}

	/**
	* Initialization of form structure object
	* @param {object}               form          form structure object
	* @param {string|Array<string>} fieldName     name of the field type if string, array of strings = subform
	* @param {Object}               VARIANTS      store which contains named lists of field value variants
	* @param {Object}               FIELDS        store which contains named lists of field manifests
	* @param {Object}               formFieldsOptions   form wide options
	* @returns {Object}                           form structure object
	**/
	function initFormByField(form = {}, fieldName = [], VARIANTS, FIELDS, formFieldsOptions, data) {
	  if (Array.isArray(fieldName)) {
	    fieldName.forEach(subFormFieldName => initFormByField(form, subFormFieldName, VARIANTS, FIELDS, formFieldsOptions, data));
	  } else {
	    let opts = {};
	    if (formFieldsOptions && notCommon$2.objHas(formFieldsOptions, 'mutations') && notCommon$2.objHas(formFieldsOptions.mutations, fieldName)) {
	      opts = formFieldsOptions.mutations[fieldName]; //option mutation for field
	    }
	    if (data && notCommon$2.objHas(data, fieldName)) {
	      opts.value = data[fieldName];
	    }
	    form[fieldName] = fieldInit(fieldName, opts, VARIANTS, FIELDS);
	    //if form readonly, marking every field as readonly
	    if (formFieldsOptions && formFieldsOptions.readonly) {
	      form[fieldName].readonly = true;
	    }
	  }
	  return form;
	}

	/**
	*  Marking field as invalid by own validator
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @param {any}              value         value of field
	* @param  {Array<string>}   errors        list of errors
	* @return {Object}                        form structure object
	**/
	function setFieldInvalid(form, fieldName, value, errors) {
	  form[fieldName].errors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].valid = false;
	  form[fieldName].value = value;
	  return form;
	}

	/**
	*  Marking field as valid by own validator
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @param {any}              value         value of field
	* @return {Object}                        form structure object
	**/
	function setFieldValid(form, fieldName, value) {
	  form[fieldName].errors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].value = value;
	  for (let fname in form) {
	    if (fname !== fieldName) {
	      if (Array.isArray(form[fname].errors) && form[fname].errors.length === 0) {
	        form[fname].errors = false;
	      }
	      if (form[fname].errors !== false) {
	        break;
	      }
	    }
	  }
	  return form;
	}

	/**
	* Checks if field has errors
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @returns {boolean}                      true - valid, false -invalid
	**/
	function isFieldValid(form, fieldName) {
	  return !Array.isArray(form[fieldName].errors);
	}

	/**
	* Form level validator error in this field
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @param  {Array<string>}   errors        list of errors
	* @return {Object}                        form structure object
	**/
	function setFormFieldInvalid(form, fieldName, errors) {
	  form[fieldName].formErrors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].inputStarted = true;
	  form[fieldName].valid = false;
	  form[fieldName].formLevelError = true;
	  return form;
	}
	/**
	* Form level validator success in this field
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @return {Object}                        form structure object
	**/
	function setFormFieldValid(form, fieldName) {
	  form[fieldName].formErrors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].formLevelError = false;
	  return form;
	}

	/**
	* Updates fields and form error labels
	* @param {Object}           form                  form structure object
	* @param {Object}           validationStatus      results of validation
	**/
	function updateFormValidationStatus(
	  {
	    form,
	    formErrors,
	    formHasErrors,
	    fieldsHasErrors,
	    validationStatus
	  }  /* FormValidationSession.getCompleteResult() */
	) {
	  formHasErrors = false;
	  fieldsHasErrors = false;
	  if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
	    formErrors.splice(0, formErrors.length, ...validationStatus.form);
	    formHasErrors = true;
	  } else {
	    formErrors.splice(0, formErrors.length);
	  }
	  formErrors = formErrors;
	  if (validationStatus.fields) {
	    for (let fieldName in validationStatus.fields) {
	      if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
	        setFormFieldInvalid(form, fieldName, validationStatus.fields[fieldName]);
	        fieldsHasErrors = true;
	      } else {
	        setFormFieldValid(form, fieldName);
	      }
	    }
	  }
	}

	function setFieldsVisibility(form, fieldsList, val) {
	  if (Array.isArray(fieldsList)) {
	    Object.keys(form).forEach(fieldName => {
	      form[fieldName].visible = fieldsList.includes(fieldName) ? val : !val;
	    });
	    return true;
	  }
	  return false;
	}

	function setFieldValue(form, fieldName, value) {
	  if (notCommon$2.objHas(form, fieldName)) {
	    form[fieldName].value = value;
	    return true;
	  }
	  return false;
	}

	function fieldIsVisibleAndFilled(form, fieldName){
	  return notCommon$2.objHas(form, fieldName) &&
	    form[fieldName].enabled &&
	    form[fieldName].visible &&
	    typeof form[fieldName].value !== 'undefined';
	}

	function collectData(fields, form) {
	  let result = {};
	  fields.flat().forEach((fieldName) => {
	    if (fieldIsVisibleAndFilled(form, fieldName)) {
	      result[fieldName] = form[fieldName].value;
	    }
	  });
	  return result;
	}

	var FormHelpers = {
	  fieldInit,
	  initFormByField,
	  setFieldInvalid,
	  setFieldValid,
	  isFieldValid,
	  setFormFieldInvalid,
	  setFormFieldValid,
	  updateFormValidationStatus,
	  fieldIsVisibleAndFilled,
	  setFieldsVisibility,
	  setFieldValue,
	  collectData
	};

	const emptyFieldsResults = (data) => {
	    return Object.keys(data).reduce((acc, curr) => {
	        acc[curr] = [];
	        return acc;
	    }, {});
	};

	const FIELDS$1 = ["fields", "form"];

	var result$1 = class ValidationResult {
	    #clean = true;
	    #result;

	    constructor(result) {
	        this.#result = JSON.parse(JSON.stringify(result));
	        Object.keys(this.#result).forEach((fieldName) => {
	            if (!FIELDS$1.includes(fieldName)) {
	                delete this.#result[fieldName];
	            }
	        });
	        this.#clean = this.#result.form.errors.length === 0;
	        const list = this.#getFieldsList();
	        for (let fieldName of list) {
	            if (this.isFieldDirty(fieldName)) {
	                this.#clean = false;
	            }
	        }
	    }

	    destroy() {
	        this.#result = undefined;
	    }

	    get clean() {
	        return this.#clean;
	    }

	    static getDefaultResult(data) {
	        return {
	            fields: emptyFieldsResults(data),
	            form: {
	                fields: emptyFieldsResults(data),
	                errors: [],
	                exceptions: [],
	            },
	        };
	    }

	    getReport() {
	        return JSON.parse(JSON.stringify(this.#getCompleteResult()));
	    }

	    getDetailedReport() {
	        if (typeof this.#result === "object") {
	            return JSON.parse(JSON.stringify(this.#result));
	        } else {
	            return undefined;
	        }
	    }

	    isFieldDirty(fieldName) {
	        if (
	            Array.isArray(this.#result.fields[fieldName]) &&
	            this.#result.fields[fieldName].length
	        ) {
	            return true;
	        }
	        if (
	            Array.isArray(this.#result.form.fields[fieldName]) &&
	            this.#result.form.fields[fieldName].length
	        ) {
	            return true;
	        }
	        return false;
	    }

	    getCompleteResultForField(fieldName) {
	        const fieldResult = [];
	        if (Array.isArray(this.#result.fields[fieldName])) {
	            fieldResult.push(...this.#result.fields[fieldName]);
	        }
	        if (Array.isArray(this.#result.form.fields[fieldName])) {
	            fieldResult.push(...this.#result.form.fields[fieldName]);
	        }
	        return fieldResult;
	    }

	    #getCompleteResult() {
	        const resultComplete = {
	            clean: this.#clean,
	            fields: {},
	            form: [],
	        };
	        const list = this.#getFieldsList();
	        for (let fieldName of list) {
	            const errors = this.getCompleteResultForField(fieldName);
	            if (errors.length) {
	                resultComplete.fields[fieldName] = errors;
	            }
	        }
	        resultComplete.form = [...this.#result.form.errors];
	        if (resultComplete.form.length === 0) {
	            delete resultComplete.form;
	        }
	        return resultComplete;
	    }

	    #getFieldsList() {
	        const fields = Object.keys(this.#result.fields);
	        const fieldsInForm = Object.keys(this.#result.form.fields);
	        return [...new Set([...fieldsInForm, ...fields])];
	    }
	};

	/**
	 * Test argument type to be 'function'
	 * @param {any}  func    possible function
	 * @return {boolean}     if this is a function
	 **/

	const isFunc$1 = (func) => {
	    return typeof func === "function";
	};

	/**
	 * Returns true if argument is Async function
	 * @param {function} func  to test
	 * @return {boolean}       if this function is constructed as AsyncFunction
	 **/
	const isAsync$1 = (func) => {
	    return func.constructor.name === "AsyncFunction";
	};

	var common = async (proc, params) => {
	    if (isFunc$1(proc)) {
	        if (isAsync$1(proc)) {
	            return await proc(...params);
	        } else {
	            return proc(...params);
	        }
	    }
	};

	const ValidationResult = result$1;

	const executeObjectFunction = common;

	const ValidationSession$1 = async (validators, data) => {
	    const result = ValidationResult.getDefaultResult(data);
	    await validateFields({ validators, data, result });
	    await validateForm({ validators, data, result });
	    return new ValidationResult(result);
	};

	var session = ValidationSession$1;

	const validateFields = async ({ validators, data, result }) => {
	    for (let t in data) {
	        await validateField(t, data[t], validators, result);
	    }
	};

	const validateField = async (fieldName, value, validators, result) => {
	    const fieldValidators = getFieldValidators(fieldName, validators);
	    return await runFieldValidators(fieldName, value, fieldValidators, result);
	};

	const getFieldValidators = (name, validators) => {
	    return validators && validators.fields && validators.fields[name]
	        ? validators.fields[name]
	        : [];
	};

	const runFieldValidators = async (fieldName, value, validators, result) => {
	    for (let validatorRule of validators) {
	        try {
	            const valid = await executeObjectFunction(
	                validatorRule["validator"],
	                [value]
	            );
	            if (!valid) {
	                setFieldError(fieldName, validatorRule.message, result);
	            }
	        } catch (e) {
	            setFieldError(fieldName, validatorRule.message, result);
	        }
	    }
	};

	const setFieldError = (fieldName, errorMessage, result) => {
	    if (!result.fields[fieldName].includes(errorMessage)) {
	        result.fields[fieldName].push(errorMessage);
	    }
	};

	const validateForm = async ({ validators, data, result }) => {
	    const formValidators = getFormValidators(validators);
	    await runFormValidators(data, formValidators, result);
	};

	const getFormValidators = (validators) => {
	    return validators && validators.form ? validators.form : [];
	};

	const runFormValidators = async (data, formValidators, result) => {
	    for (let validator of formValidators) {
	        try {
	            await validator(data);
	        } catch (e) {
	            if (e && typeof e.getFieldsErrors === "function") {
	                const formErrors = e.getFieldsErrors();
	                Array.isArray(formErrors.form) &&
	                    addFormErrors(formErrors.form, result);
	                formErrors.fields &&
	                    addFormFieldsErrors(formErrors.fields, result);
	            } else {
	                throw e;
	            }
	        }
	    }
	};

	const addFormErrors = (errors, result) => {
	    errors.forEach((error) => {
	        addFormError(error, result);
	    });
	};

	const addFormError = (errorMessage, result) => {
	    if (!result.form.errors.includes(errorMessage)) {
	        result.form.errors.push(errorMessage);
	    }
	};

	const addFormFieldsErrors = (fieldsErrors, result) => {
	    for (let fieldName in fieldsErrors) {
	        addFormFieldErrors(fieldName, fieldsErrors[fieldName], result);
	    }
	};

	const addFormFieldErrors = (fieldName, errorMessages, result) => {
	    errorMessages.forEach((error) => {
	        addFormFieldError(fieldName, error, result);
	    });
	};

	const addFormFieldError = (fieldName, errorMessage, result) => {
	    if (!Array.isArray(result.form.fields[fieldName])) {
	        result.form.fields[fieldName] = [];
	    }
	    if (!result.form.fields[fieldName].includes(errorMessage)) {
	        result.form.fields[fieldName].push(errorMessage);
	    }
	};

	const composeFieldsValidators$1 = (data, validatorsLib) => {
	    if (validatorsLib && validatorsLib.fields) {
	        const list = Object.keys(data);
	        const result = {};
	        list.forEach((fieldName) => {
	            if (Array.isArray(validatorsLib.fields[fieldName])) {
	                result[fieldName] = validatorsLib.fields[fieldName];
	            }
	        });
	        return result;
	    } else {
	        return {};
	    }
	};

	const composeFormValidators$1 = (name, validatorsLib) => {
	    if (!validatorsLib) return [];
	    if (validatorsLib.forms && Array.isArray(validatorsLib.forms[name])) {
	        return validatorsLib.forms[name];
	    }
	    if (Array.isArray(validatorsLib.form)) {
	        return validatorsLib.form;
	    }
	    return [];
	};

	var runner_utils = {
	    composeFieldsValidators: composeFieldsValidators$1,
	    composeFormValidators: composeFormValidators$1,
	};

	const {
	    composeFieldsValidators,
	    composeFormValidators,
	} = runner_utils;

	const ValidationSession = session;

	/**
	 * Creates validation runner function from provided validation rules lib
	 * @param {object}     validationLib object containing fields validation rules and form specific rules
	 * @returns {function} (data: object, formName: string)=>Promise<ValidationResult>
	 **/
	const ValidationRunner = (validatorsLib) => {
	    /**
	     * Validation session runner
	     * @param {object} data      object to validate
	     * @param {string} formName
	     * @returns {Promise}
	     **/
	    return (data, formName) => {
	        const validators = {
	            //fields specific validators
	            fields: composeFieldsValidators(data, validatorsLib),
	            //form specific validators
	            form: composeFormValidators(formName, validatorsLib),
	        };
	        return ValidationSession(validators, data);
	    };
	};

	var runner = ValidationRunner;

	const augmentFieldsValidators$1 = (fieldValidators, getValidatorEnv) => {
	    return fieldValidators.map((fieldRule) =>
	        augmentFieldValidator(fieldRule, getValidatorEnv)
	    );
	};

	const augmentFieldValidator = (rule, getValidatorEnv) => {
	    if (rule.validator && typeof rule.validator === "function") {
	        const ruleValidator = rule.validator;
	        const result = {
	            ...rule,
	        };
	        delete result.validator;
	        result.validator = (val) => ruleValidator(val, getValidatorEnv());
	        return result;
	    }
	    return rule;
	};

	const augmentFormValidators$1 = (rules, getValidatorEnv) => {
	    return rules.map((rule) => augmentFormValidator(rule, getValidatorEnv));
	};

	const augmentFormValidator = (rule, getValidatorEnv) => {
	    return (val) => rule(val, getValidatorEnv());
	};

	var builder_utils = {
	    augmentFieldsValidators: augmentFieldsValidators$1,
	    augmentFieldValidator,
	    augmentFormValidators: augmentFormValidators$1,
	    augmentFormValidator,
	};

	const objHas = (obj, name) => {
	    return Object.prototype.hasOwnProperty.call(obj, name);
	};
	const {
	    augmentFieldsValidators,
	    augmentFormValidators,
	} = builder_utils;

	/**
	 * @typedef   {object}    notValidationSchema
	 * @property  {object}    [fields]
	 * @property  {array}     [form]
	 * @property  {object}    [forms]
	 */

	/**
	 * returns valid empty validation scheme
	 *
	 * @return {notValidationSchema}
	 */
	const emptyScheme = () => {
	    return {
	        fields: {},
	        forms: {},
	    };
	};
	/**
	 *
	 *
	 * @param {object} validators
	 * @param {function} getValidatorEnv
	 * @return {notValidationSchema}
	 */
	const validationBuilder = (validators, getValidatorEnv) => {
	    if (typeof validators === "undefined" || validators === null) {
	        return emptyScheme();
	    }
	    const augmented = {};
	    if (objHas(validators, "fields")) {
	        augmented.fields = transformFieldsValidators(
	            validators.fields,
	            getValidatorEnv
	        );
	    }
	    if (objHas(validators, "forms")) {
	        augmented.forms = transformFormsValidators(
	            validators.forms,
	            getValidatorEnv
	        );
	    } else {
	        if (objHas(validators, "form")) {
	            augmented.form = augmentFormValidators(
	                validators.form,
	                getValidatorEnv
	            );
	        }
	    }
	    return augmented;
	};

	var builder = validationBuilder;

	const transformFieldsValidators = (fields, getValidatorEnv) => {
	    const augmented = {};
	    for (let fieldName in fields) {
	        if (Array.isArray(fields[fieldName])) {
	            augmented[fieldName] = augmentFieldsValidators(
	                fields[fieldName],
	                getValidatorEnv
	            );
	        }
	    }
	    return augmented;
	};

	const transformFormsValidators = (formsValidators, getValidatorEnv) => {
	    const augmented = {};
	    for (let formName in formsValidators) {
	        if (Array.isArray(formsValidators[formName])) {
	            augmented[formName] = augmentFormValidators(
	                formsValidators[formName],
	                getValidatorEnv
	            );
	        }
	    }
	    return augmented;
	};

	const Session = session;
	const Runner = runner;
	const Builder = builder;
	const Result = result$1;

	var src = {
	    name: "not-validation",
	    Session,
	    Runner,
	    Builder,
	    Result,
	};

	/* node_modules/not-bulma/src/frame/components/form/field.svelte generated by Svelte v4.2.19 */

	function get_each_context_2$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[18] = list[i];
		return child_ctx;
	}

	function get_each_context_1$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[18] = list[i];
		return child_ctx;
	}

	function get_each_context$7(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[18] = list[i];
		return child_ctx;
	}

	// (84:0) {:else}
	function create_else_block$c(ctx) {
		let div;
		let div_class_value;
		let current;
		let each_value_2 = ensure_array_like(/*controls*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", div_class_value = "field " + /*fieldClasses*/ ctx[4] + " " + /*fieldId*/ ctx[6]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*controls, name, onControlChange*/ 138) {
					each_value_2 = ensure_array_like(/*controls*/ ctx[3]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_2$2(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value_2.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty & /*fieldClasses, fieldId*/ 80 && div_class_value !== (div_class_value = "field " + /*fieldClasses*/ ctx[4] + " " + /*fieldId*/ ctx[6])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (68:21) 
	function create_if_block_1$e(ctx) {
		let div2;
		let div0;
		let uilabel;
		let t;
		let div1;
		let div2_class_value;
		let current;

		uilabel = new Ui_label({
				props: {
					id: /*fieldId*/ ctx[6],
					label: /*label*/ ctx[0] || /*controls*/ ctx[3][0].label
				}
			});

		let each_value_1 = ensure_array_like(/*controls*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				create_component(uilabel.$$.fragment);
				t = space();
				div1 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div0, "class", "field-label is-normal");
				attr(div1, "class", "field-body");
				attr(div1, "id", /*fieldId*/ ctx[6]);
				attr(div2, "class", div2_class_value = "field is-horizontal " + /*fieldClasses*/ ctx[4] + " " + /*fieldId*/ ctx[6]);
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				mount_component(uilabel, div0, null);
				append(div2, t);
				append(div2, div1);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div1, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				const uilabel_changes = {};
				if (dirty & /*fieldId*/ 64) uilabel_changes.id = /*fieldId*/ ctx[6];
				if (dirty & /*label, controls*/ 9) uilabel_changes.label = /*label*/ ctx[0] || /*controls*/ ctx[3][0].label;
				uilabel.$set(uilabel_changes);

				if (dirty & /*controls, name, onControlChange*/ 138) {
					each_value_1 = ensure_array_like(/*controls*/ ctx[3]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$3(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div1, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty & /*fieldId*/ 64) {
					attr(div1, "id", /*fieldId*/ ctx[6]);
				}

				if (!current || dirty & /*fieldClasses, fieldId*/ 80 && div2_class_value !== (div2_class_value = "field is-horizontal " + /*fieldClasses*/ ctx[4] + " " + /*fieldId*/ ctx[6])) {
					attr(div2, "class", div2_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uilabel.$$.fragment, local);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(uilabel.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				destroy_component(uilabel);
				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (59:0) {#if hidden}
	function create_if_block$g(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*controls*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*controls, name, onControlChange*/ 138) {
					each_value = ensure_array_like(/*controls*/ ctx[3]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$7(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$7(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (86:8) {#each controls as control}
	function create_each_block_2$2(ctx) {
		let uilabel;
		let t;
		let switch_instance;
		let switch_instance_anchor;
		let current;

		uilabel = new Ui_label({
				props: {
					id: "form-field-" + /*control*/ ctx[18].component + "-" + /*name*/ ctx[1],
					label: /*control*/ ctx[18].label
				}
			});

		const switch_instance_spread_levels = [/*control*/ ctx[18], { fieldname: /*name*/ ctx[1] }];
		var switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*controls, name*/ 10) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
					dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*onControlChange*/ ctx[7]);
		}

		return {
			c() {
				create_component(uilabel.$$.fragment);
				t = space();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				mount_component(uilabel, target, anchor);
				insert(target, t, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uilabel_changes = {};
				if (dirty & /*controls, name*/ 10) uilabel_changes.id = "form-field-" + /*control*/ ctx[18].component + "-" + /*name*/ ctx[1];
				if (dirty & /*controls*/ 8) uilabel_changes.label = /*control*/ ctx[18].label;
				uilabel.$set(uilabel_changes);

				if (dirty & /*controls*/ 8 && switch_value !== (switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*onControlChange*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*controls, name*/ 10)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
							dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uilabel.$$.fragment, local);
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilabel.$$.fragment, local);
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(switch_instance_anchor);
				}

				destroy_component(uilabel, detaching);
				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (74:12) {#each controls as control}
	function create_each_block_1$3(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*control*/ ctx[18], { fieldname: /*name*/ ctx[1] }];
		var switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*controls, name*/ 10) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
					dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*onControlChange*/ ctx[7]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*controls*/ 8 && switch_value !== (switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*onControlChange*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*controls, name*/ 10)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
							dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (60:4) {#each controls as control}
	function create_each_block$7(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*control*/ ctx[18], { fieldname: /*name*/ ctx[1] }];
		var switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*controls, name*/ 10) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
					dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*onControlChange*/ ctx[7]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*controls*/ 8 && switch_value !== (switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*onControlChange*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*controls, name*/ 10)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
							dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$l(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$g, create_if_block_1$e, create_else_block$c];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*hidden*/ ctx[5]) return 0;
			if (/*horizontal*/ ctx[2]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$l($$self, $$props, $$invalidate) {
		let dispatch = createEventDispatcher();
		let { label = "" } = $$props;
		let { name = "generic field" } = $$props;
		let { readonly = false } = $$props;
		let { horizontal = false } = $$props;
		let { controls = [] } = $$props;
		let { classes = "" } = $$props;
		let { addons = false } = $$props;
		let { addonsCentered = false } = $$props;
		let { addonsRight = false } = $$props;
		let { grouped = false } = $$props;
		let { groupedMultiline = false } = $$props;
		let { groupedRight = false } = $$props;
		let { groupedCentered = false } = $$props;
		let fieldClasses = "";
		let hidden = false;
		let fieldId;

		onMount(() => {
			$$invalidate(4, fieldClasses += " " + classes);
			$$invalidate(4, fieldClasses += addons ? " has-addons " : "");
			$$invalidate(4, fieldClasses += addonsCentered ? " has-addons-centered " : "");
			$$invalidate(4, fieldClasses += addonsRight ? " has-addons-right " : "");
			$$invalidate(4, fieldClasses += grouped ? " is-grouped " : "");
			$$invalidate(4, fieldClasses += groupedMultiline ? " is-grouped-multiline " : "");
			$$invalidate(4, fieldClasses += groupedRight ? " is-grouped-right " : "");
			$$invalidate(4, fieldClasses += groupedCentered ? " is-grouped-centered " : "");

			if (readonly) {
				controls.forEach(control => {
					control.readonly = true;
				});
			}

			let notHidden = controls.filter(control => control.component !== "UIHidden");
			$$invalidate(5, hidden = notHidden.length === 0);
			let tmp = controls.map(itm => itm.component).join("_");
			$$invalidate(6, fieldId = `form-field-${tmp}-${name}`);
		});

		function onControlChange(ev) {
			let data = ev.detail;
			dispatch("change", data);
		}

		$$self.$$set = $$props => {
			if ('label' in $$props) $$invalidate(0, label = $$props.label);
			if ('name' in $$props) $$invalidate(1, name = $$props.name);
			if ('readonly' in $$props) $$invalidate(8, readonly = $$props.readonly);
			if ('horizontal' in $$props) $$invalidate(2, horizontal = $$props.horizontal);
			if ('controls' in $$props) $$invalidate(3, controls = $$props.controls);
			if ('classes' in $$props) $$invalidate(9, classes = $$props.classes);
			if ('addons' in $$props) $$invalidate(10, addons = $$props.addons);
			if ('addonsCentered' in $$props) $$invalidate(11, addonsCentered = $$props.addonsCentered);
			if ('addonsRight' in $$props) $$invalidate(12, addonsRight = $$props.addonsRight);
			if ('grouped' in $$props) $$invalidate(13, grouped = $$props.grouped);
			if ('groupedMultiline' in $$props) $$invalidate(14, groupedMultiline = $$props.groupedMultiline);
			if ('groupedRight' in $$props) $$invalidate(15, groupedRight = $$props.groupedRight);
			if ('groupedCentered' in $$props) $$invalidate(16, groupedCentered = $$props.groupedCentered);
		};

		return [
			label,
			name,
			horizontal,
			controls,
			fieldClasses,
			hidden,
			fieldId,
			onControlChange,
			readonly,
			classes,
			addons,
			addonsCentered,
			addonsRight,
			grouped,
			groupedMultiline,
			groupedRight,
			groupedCentered
		];
	}

	class Field extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$l, create_fragment$l, safe_not_equal, {
				label: 0,
				name: 1,
				readonly: 8,
				horizontal: 2,
				controls: 3,
				classes: 9,
				addons: 10,
				addonsCentered: 11,
				addonsRight: 12,
				grouped: 13,
				groupedMultiline: 14,
				groupedRight: 15,
				groupedCentered: 16
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/form/form.svelte generated by Svelte v4.2.19 */

	function get_each_context$6(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[37] = list[i];
		return child_ctx;
	}

	function get_each_context_1$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[40] = list[i];
		return child_ctx;
	}

	function get_each_context_2$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[43] = list[i];
		return child_ctx;
	}

	// (201:4) {#if loader !== "hidden"}
	function create_if_block_16(ctx) {
		let div;
		let span;
		let t_value = /*$LOCALE*/ ctx[15][/*WAITING_TEXT*/ ctx[5]] + "";
		let t;
		let div_class_value;

		return {
			c() {
				div = element("div");
				span = element("span");
				t = text(t_value);
				attr(span, "class", "title");

				attr(div, "class", div_class_value = "" + ((/*loader*/ ctx[2] === 'page'
				? 'pageloader'
				: 'containerloader') + " " + (/*loading*/ ctx[1] ? 'is-active' : '')));
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, WAITING_TEXT*/ 32800 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*WAITING_TEXT*/ ctx[5]] + "")) set_data(t, t_value);

				if (dirty[0] & /*loader, loading*/ 6 && div_class_value !== (div_class_value = "" + ((/*loader*/ ctx[2] === 'page'
				? 'pageloader'
				: 'containerloader') + " " + (/*loading*/ ctx[1] ? 'is-active' : '')))) {
					attr(div, "class", div_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (215:4) {:else}
	function create_else_block$b(ctx) {
		let t0;
		let t1;
		let t2;
		let t3;
		let if_block3_anchor;
		let current;
		let if_block0 = /*title*/ ctx[6] && create_if_block_15(ctx);
		let if_block1 = /*description*/ ctx[7] && create_if_block_14(ctx);
		let if_block2 = /*buttonsFirst*/ ctx[8] && create_if_block_10(ctx);
		let each_value_1 = ensure_array_like(/*fields*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block3 = !/*buttonsFirst*/ ctx[8] && create_if_block_1$d(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t3 = space();
				if (if_block3) if_block3.c();
				if_block3_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t2, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, t3, anchor);
				if (if_block3) if_block3.m(target, anchor);
				insert(target, if_block3_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*title*/ ctx[6]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_15(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*description*/ ctx[7]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_14(ctx);
						if_block1.c();
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*buttonsFirst*/ ctx[8]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_10(ctx);
						if_block2.c();
						if_block2.m(t2.parentNode, t2);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (dirty[0] & /*fields, form, horizontal, onFieldChange*/ 66057) {
					each_value_1 = ensure_array_like(/*fields*/ ctx[3]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$2(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(t3.parentNode, t3);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!/*buttonsFirst*/ ctx[8]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block_1$d(ctx);
						if_block3.c();
						if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(t3);
					detach(if_block3_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				destroy_each(each_blocks, detaching);
				if (if_block3) if_block3.d(detaching);
			}
		};
	}

	// (211:4) {#if success}
	function create_if_block$f(ctx) {
		let div;
		let h3;
		let t_value = /*$LOCALE*/ ctx[15][/*SUCCESS_TEXT*/ ctx[4]] + "";
		let t;

		return {
			c() {
				div = element("div");
				h3 = element("h3");
				t = text(t_value);
				attr(h3, "class", "form-success-message");
				attr(div, "class", "notification is-success");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, h3);
				append(h3, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, SUCCESS_TEXT*/ 32784 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*SUCCESS_TEXT*/ ctx[4]] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (216:8) {#if title}
	function create_if_block_15(ctx) {
		let h5;
		let t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[6]] + "";
		let t;

		return {
			c() {
				h5 = element("h5");
				t = text(t_value);
				attr(h5, "class", "title is-5");
			},
			m(target, anchor) {
				insert(target, h5, anchor);
				append(h5, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, title*/ 32832 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[6]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(h5);
				}
			}
		};
	}

	// (219:8) {#if description}
	function create_if_block_14(ctx) {
		let h6;
		let t_value = /*$LOCALE*/ ctx[15][/*description*/ ctx[7]] + "";
		let t;

		return {
			c() {
				h6 = element("h6");
				t = text(t_value);
				attr(h6, "class", "subtitle is-6");
			},
			m(target, anchor) {
				insert(target, h6, anchor);
				append(h6, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, description*/ 32896 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*description*/ ctx[7]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(h6);
				}
			}
		};
	}

	// (223:8) {#if buttonsFirst}
	function create_if_block_10(ctx) {
		let div;
		let t0;
		let t1;
		let if_block2_anchor;
		let if_block0 = /*cancel*/ ctx[11].enabled && create_if_block_13(ctx);
		let if_block1 = /*submit*/ ctx[10].enabled && create_if_block_12(ctx);
		let if_block2 = /*formErrors*/ ctx[12].length > 0 && create_if_block_11(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
				attr(div, "class", "buttons is-grouped is-centered");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				if (if_block1) if_block1.m(div, null);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*cancel*/ ctx[11].enabled) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_13(ctx);
						if_block0.c();
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*submit*/ ctx[10].enabled) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_12(ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*formErrors*/ ctx[12].length > 0) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_11(ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t1);
					detach(if_block2_anchor);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d(detaching);
			}
		};
	}

	// (225:16) {#if cancel.enabled}
	function create_if_block_13(ctx) {
		let button;
		let t_value = /*$LOCALE*/ ctx[15][/*cancel*/ ctx[11].caption] + "";
		let t;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(t_value);
				attr(button, "class", button_class_value = "button is-outlined " + /*cancel*/ ctx[11].classes);
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*rejectForm*/ ctx[18]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, cancel*/ 34816 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*cancel*/ ctx[11].caption] + "")) set_data(t, t_value);

				if (dirty[0] & /*cancel*/ 2048 && button_class_value !== (button_class_value = "button is-outlined " + /*cancel*/ ctx[11].classes)) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (231:16) {#if submit.enabled}
	function create_if_block_12(ctx) {
		let button;
		let t_value = /*$LOCALE*/ ctx[15][/*submit*/ ctx[10].caption] + "";
		let t;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(t_value);
				button.disabled = /*formInvalid*/ ctx[14];
				attr(button, "class", button_class_value = "button is-primary is-hovered " + /*submit*/ ctx[10].classes);
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*submitForm*/ ctx[17]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, submit*/ 33792 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*submit*/ ctx[10].caption] + "")) set_data(t, t_value);

				if (dirty[0] & /*formInvalid*/ 16384) {
					button.disabled = /*formInvalid*/ ctx[14];
				}

				if (dirty[0] & /*submit*/ 1024 && button_class_value !== (button_class_value = "button is-primary is-hovered " + /*submit*/ ctx[10].classes)) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (241:12) {#if formErrors.length > 0}
	function create_if_block_11(ctx) {
		let div;
		let t_value = /*formErrors*/ ctx[12].join(", ") + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "edit-form-error notification is-danger");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*formErrors*/ 4096 && t_value !== (t_value = /*formErrors*/ ctx[12].join(", ") + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (285:12) {:else}
	function create_else_block_2(ctx) {
		let div;
		let t0;
		let t1_value = /*field*/ ctx[40] + "";
		let t1;
		let t2;

		return {
			c() {
				div = element("div");
				t0 = text("Field '");
				t1 = text(t1_value);
				t2 = text("' is not registered");
				attr(div, "class", "notification is-danger");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fields*/ 8 && t1_value !== (t1_value = /*field*/ ctx[40] + "")) set_data(t1, t1_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (275:59) 
	function create_if_block_8(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*form*/ ctx[0][/*field*/ ctx[40]].visible && create_if_block_9(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*form*/ ctx[0][/*field*/ ctx[40]].visible) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*form, fields*/ 9) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_9(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (249:12) {#if Array.isArray(field)}
	function create_if_block_5$2(ctx) {
		let div;
		let current;
		let each_value_2 = ensure_array_like(/*field*/ ctx[40]);
		let each_blocks = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", "columns");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*form, fields, horizontal, onFieldChange*/ 66057) {
					each_value_2 = ensure_array_like(/*field*/ ctx[40]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_2$1(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value_2.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (276:16) {#if form[field].visible}
	function create_if_block_9(ctx) {
		let uifield;
		let current;

		uifield = new Field({
				props: {
					controls: [/*form*/ ctx[0][/*field*/ ctx[40]]],
					name: /*field*/ ctx[40],
					horizontal: /*horizontal*/ ctx[9],
					label: /*form*/ ctx[0][/*field*/ ctx[40]].label
				}
			});

		uifield.$on("change", /*onFieldChange*/ ctx[16]);

		return {
			c() {
				create_component(uifield.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uifield, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uifield_changes = {};
				if (dirty[0] & /*form, fields*/ 9) uifield_changes.controls = [/*form*/ ctx[0][/*field*/ ctx[40]]];
				if (dirty[0] & /*fields*/ 8) uifield_changes.name = /*field*/ ctx[40];
				if (dirty[0] & /*horizontal*/ 512) uifield_changes.horizontal = /*horizontal*/ ctx[9];
				if (dirty[0] & /*form, fields*/ 9) uifield_changes.label = /*form*/ ctx[0][/*field*/ ctx[40]].label;
				uifield.$set(uifield_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uifield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uifield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uifield, detaching);
			}
		};
	}

	// (268:24) {:else}
	function create_else_block_1$1(ctx) {
		let div;
		let t0;
		let t1_value = /*subfield*/ ctx[43] + "";
		let t1;
		let t2;

		return {
			c() {
				div = element("div");
				t0 = text("Subfield '");
				t1 = text(t1_value);
				t2 = text("' is not registered");
				attr(div, "class", "column notification is-danger");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fields*/ 8 && t1_value !== (t1_value = /*subfield*/ ctx[43] + "")) set_data(t1, t1_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (252:24) {#if form[subfield] && form[subfield].component}
	function create_if_block_6(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*form*/ ctx[0][/*subfield*/ ctx[43]].visible && create_if_block_7(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*form*/ ctx[0][/*subfield*/ ctx[43]].visible) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*form, fields*/ 9) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_7(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (253:28) {#if form[subfield].visible}
	function create_if_block_7(ctx) {
		let div;
		let uifield;
		let div_class_value;
		let current;

		uifield = new Field({
				props: {
					controls: [/*form*/ ctx[0][/*subfield*/ ctx[43]]],
					name: /*subfield*/ ctx[43],
					horizontal: /*horizontal*/ ctx[9],
					label: /*form*/ ctx[0][/*subfield*/ ctx[43]].label
				}
			});

		uifield.$on("change", /*onFieldChange*/ ctx[16]);

		return {
			c() {
				div = element("div");
				create_component(uifield.$$.fragment);

				attr(div, "class", div_class_value = "column " + (/*form*/ ctx[0][/*subfield*/ ctx[43]].fieldSize
				? 'is-' + /*form*/ ctx[0][/*subfield*/ ctx[43]].fieldSize
				: '') + "");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uifield, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const uifield_changes = {};
				if (dirty[0] & /*form, fields*/ 9) uifield_changes.controls = [/*form*/ ctx[0][/*subfield*/ ctx[43]]];
				if (dirty[0] & /*fields*/ 8) uifield_changes.name = /*subfield*/ ctx[43];
				if (dirty[0] & /*horizontal*/ 512) uifield_changes.horizontal = /*horizontal*/ ctx[9];
				if (dirty[0] & /*form, fields*/ 9) uifield_changes.label = /*form*/ ctx[0][/*subfield*/ ctx[43]].label;
				uifield.$set(uifield_changes);

				if (!current || dirty[0] & /*form, fields*/ 9 && div_class_value !== (div_class_value = "column " + (/*form*/ ctx[0][/*subfield*/ ctx[43]].fieldSize
				? 'is-' + /*form*/ ctx[0][/*subfield*/ ctx[43]].fieldSize
				: '') + "")) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uifield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uifield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uifield);
			}
		};
	}

	// (251:20) {#each field as subfield}
	function create_each_block_2$1(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_6, create_else_block_1$1];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*form*/ ctx[0][/*subfield*/ ctx[43]] && /*form*/ ctx[0][/*subfield*/ ctx[43]].component) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (248:8) {#each fields as field}
	function create_each_block_1$2(ctx) {
		let show_if;
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_5$2, create_if_block_8, create_else_block_2];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (dirty[0] & /*fields*/ 8) show_if = null;
			if (show_if == null) show_if = !!Array.isArray(/*field*/ ctx[40]);
			if (show_if) return 0;
			if (/*form*/ ctx[0][/*field*/ ctx[40]] && /*form*/ ctx[0][/*field*/ ctx[40]].component) return 1;
			return 2;
		}

		current_block_type_index = select_block_type_1(ctx, [-1, -1]);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (292:8) {#if !buttonsFirst}
	function create_if_block_1$d(ctx) {
		let t0;
		let div;
		let t1;
		let if_block0 = /*formErrors*/ ctx[12].length > 0 && create_if_block_4$4(ctx);
		let if_block1 = /*cancel*/ ctx[11].enabled && create_if_block_3$7(ctx);
		let if_block2 = /*submit*/ ctx[10].enabled && create_if_block_2$9(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				div = element("div");
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(div, "class", "buttons is-grouped is-centered");
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				insert(target, div, anchor);
				if (if_block1) if_block1.m(div, null);
				append(div, t1);
				if (if_block2) if_block2.m(div, null);
			},
			p(ctx, dirty) {
				if (/*formErrors*/ ctx[12].length > 0) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$4(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*cancel*/ ctx[11].enabled) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_3$7(ctx);
						if_block1.c();
						if_block1.m(div, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*submit*/ ctx[10].enabled) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_2$9(ctx);
						if_block2.c();
						if_block2.m(div, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(div);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (293:12) {#if formErrors.length > 0}
	function create_if_block_4$4(ctx) {
		let div;
		let each_value = ensure_array_like(/*formErrors*/ ctx[12]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", "edit-form-error notification is-danger");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, formErrors*/ 36864) {
					each_value = ensure_array_like(/*formErrors*/ ctx[12]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$6(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$6(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (295:20) {#each formErrors as formError}
	function create_each_block$6(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[15][/*formError*/ ctx[37]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, formErrors*/ 36864 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*formError*/ ctx[37]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (301:16) {#if cancel.enabled}
	function create_if_block_3$7(ctx) {
		let button;
		let t_value = /*$LOCALE*/ ctx[15][/*cancel*/ ctx[11].caption] + "";
		let t;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(t_value);

				attr(button, "class", button_class_value = "button " + (/*cancel*/ ctx[11].classes
				? /*cancel*/ ctx[11].classes
				: ''));
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*rejectForm*/ ctx[18]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, cancel*/ 34816 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*cancel*/ ctx[11].caption] + "")) set_data(t, t_value);

				if (dirty[0] & /*cancel*/ 2048 && button_class_value !== (button_class_value = "button " + (/*cancel*/ ctx[11].classes
				? /*cancel*/ ctx[11].classes
				: ''))) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (307:16) {#if submit.enabled}
	function create_if_block_2$9(ctx) {
		let button;
		let t_value = /*$LOCALE*/ ctx[15][/*submit*/ ctx[10].caption] + "";
		let t;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(t_value);
				button.disabled = /*formInvalid*/ ctx[14];

				attr(button, "class", button_class_value = "button is-primary is-hovered " + (/*submit*/ ctx[10].classes
				? /*submit*/ ctx[10].classes
				: ''));
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*submitForm*/ ctx[17]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, submit*/ 33792 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*submit*/ ctx[10].caption] + "")) set_data(t, t_value);

				if (dirty[0] & /*formInvalid*/ 16384) {
					button.disabled = /*formInvalid*/ ctx[14];
				}

				if (dirty[0] & /*submit*/ 1024 && button_class_value !== (button_class_value = "button is-primary is-hovered " + (/*submit*/ ctx[10].classes
				? /*submit*/ ctx[10].classes
				: ''))) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$k(ctx) {
		let div;
		let t;
		let current_block_type_index;
		let if_block1;
		let current;
		let if_block0 = /*loader*/ ctx[2] !== "hidden" && create_if_block_16(ctx);
		const if_block_creators = [create_if_block$f, create_else_block$b];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*success*/ ctx[13]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t = space();
				if_block1.c();
				attr(div, "class", "form-container");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t);
				if_blocks[current_block_type_index].m(div, null);
				current = true;
			},
			p(ctx, dirty) {
				if (/*loader*/ ctx[2] !== "hidden") {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_16(ctx);
						if_block0.c();
						if_block0.m(div, t);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if_blocks[current_block_type_index].d();
			}
		};
	}

	function instance$k($$self, $$props, $$invalidate) {
		let formInvalid;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(15, $LOCALE = $$value));
		let dispatch = createEventDispatcher();

		//validation status
		let formErrors = [];

		let formHasErrors = false;
		let fieldsHasErrors = false;
		let success = false;
		let { form = {} } = $$props;
		let { loading = false } = $$props;
		let { loader = "container" } = $$props;
		let { fields = [] } = $$props;
		let { SUCCESS_TEXT = "Операция завершена" } = $$props;
		let { WAITING_TEXT = "Отправка данных на сервер" } = $$props;
		let { title = "Форма" } = $$props;
		let { description = "" } = $$props;
		let { buttonsFirst = false } = $$props;
		let { horizontal = false } = $$props;
		let { submit = { caption: "Отправить", enabled: true } } = $$props;
		let { cancel = { caption: "Назад", enabled: true } } = $$props;

		function collectData() {
			return FormHelpers.collectData(fields, form);
		}

		function setFieldInvalid(fieldName, value, errors) {
			$$invalidate(0, form = FormHelpers.setFieldInvalid(form, fieldName, value, errors));
			$$invalidate(35, fieldsHasErrors = true);
		}

		function setFieldValid(fieldName, value) {
			$$invalidate(0, form = FormHelpers.setFieldValid(form, fieldName, value));

			if (fieldsHasErrors !== some) {
				$$invalidate(35, fieldsHasErrors = some);
			}
		}

		function isFieldValid(fieldName) {
			return FormHelpers.isFieldValid(form, fieldName);
		}

		function setFormFieldInvalid(fieldName, errors) {
			$$invalidate(0, form = FormHelpers.setFormFieldInvalid(form, fieldName, errors));
			dispatch(`field.invalid`, { fieldName });
		}

		function setFormFieldValid(fieldName) {
			$$invalidate(0, form = FormHelpers.setFormFieldValid(form, fieldName));
			dispatch(`field.valid`, { fieldName });
		}

		function updateFormValidationStatus(validationStatus) {
			$$invalidate(/* FormValidationSession.getCompleteResult() */ 34, formHasErrors = false);
			$$invalidate(35, fieldsHasErrors = false);

			if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
				formErrors.splice(0, formErrors.length, ...validationStatus.form);
				$$invalidate(34, formHasErrors = true);
			} else {
				formErrors.splice(0, formErrors.length);
			}

			$$invalidate(12, formErrors);

			if (validationStatus.fields) {
				for (let fieldName of Object.keys(form)) {
					if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
						FormHelpers.setFormFieldInvalid(form, fieldName, validationStatus.fields[fieldName]);
						$$invalidate(35, fieldsHasErrors = true);
					} else {
						FormHelpers.setFormFieldValid(form, fieldName);
					}
				}
			}
		}

		function showSuccess() {
			$$invalidate(13, success = true);
		}

		function setLoading() {
			$$invalidate(1, loading = true);
		}

		function resetLoading() {
			$$invalidate(1, loading = false);
		}

		function setFieldsVisibility(fieldsList, val) {
			if (FormHelpers.setFieldsVisibility(form, fieldsList, val)) {
				$$invalidate(0, form);
			}
		}

		function setVisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, true);
		}

		function setInvisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, false);
		}

		function setFieldValue(fieldName, value) {
			if (FormHelpers.setFieldValue(form, fieldName, value)) {
				onFieldChange({ detail: { field: fieldName, value } });
			}
		}

		function updateField(fieldName, props) {
			$$invalidate(0, form[fieldName] = { ...form[fieldName], ...props }, form);
			$$invalidate(0, form);
		}

		function onFieldChange(ev) {
			let data = ev.detail;
			$$invalidate(0, form[data.field].value = data.value, form);
			$$invalidate(0, form);
			dispatch("change", data);
		}

		function submitForm(e) {
			e && e.preventDefault();
			dispatch("submit", collectData());
			return false;
		}

		function rejectForm() {
			dispatch("reject");
		}

		$$self.$$set = $$props => {
			if ('form' in $$props) $$invalidate(0, form = $$props.form);
			if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
			if ('loader' in $$props) $$invalidate(2, loader = $$props.loader);
			if ('fields' in $$props) $$invalidate(3, fields = $$props.fields);
			if ('SUCCESS_TEXT' in $$props) $$invalidate(4, SUCCESS_TEXT = $$props.SUCCESS_TEXT);
			if ('WAITING_TEXT' in $$props) $$invalidate(5, WAITING_TEXT = $$props.WAITING_TEXT);
			if ('title' in $$props) $$invalidate(6, title = $$props.title);
			if ('description' in $$props) $$invalidate(7, description = $$props.description);
			if ('buttonsFirst' in $$props) $$invalidate(8, buttonsFirst = $$props.buttonsFirst);
			if ('horizontal' in $$props) $$invalidate(9, horizontal = $$props.horizontal);
			if ('submit' in $$props) $$invalidate(10, submit = $$props.submit);
			if ('cancel' in $$props) $$invalidate(11, cancel = $$props.cancel);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[1] & /*formHasErrors, fieldsHasErrors*/ 24) {
				$$invalidate(14, formInvalid = formHasErrors || fieldsHasErrors);
			}
		};

		return [
			form,
			loading,
			loader,
			fields,
			SUCCESS_TEXT,
			WAITING_TEXT,
			title,
			description,
			buttonsFirst,
			horizontal,
			submit,
			cancel,
			formErrors,
			success,
			formInvalid,
			$LOCALE,
			onFieldChange,
			submitForm,
			rejectForm,
			collectData,
			setFieldInvalid,
			setFieldValid,
			isFieldValid,
			setFormFieldInvalid,
			setFormFieldValid,
			updateFormValidationStatus,
			showSuccess,
			setLoading,
			resetLoading,
			setFieldsVisibility,
			setVisibleFields,
			setInvisibleFields,
			setFieldValue,
			updateField,
			formHasErrors,
			fieldsHasErrors
		];
	}

	class Form extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$k,
				create_fragment$k,
				safe_not_equal,
				{
					form: 0,
					loading: 1,
					loader: 2,
					fields: 3,
					SUCCESS_TEXT: 4,
					WAITING_TEXT: 5,
					title: 6,
					description: 7,
					buttonsFirst: 8,
					horizontal: 9,
					submit: 10,
					cancel: 11,
					collectData: 19,
					setFieldInvalid: 20,
					setFieldValid: 21,
					isFieldValid: 22,
					setFormFieldInvalid: 23,
					setFormFieldValid: 24,
					updateFormValidationStatus: 25,
					showSuccess: 26,
					setLoading: 27,
					resetLoading: 28,
					setFieldsVisibility: 29,
					setVisibleFields: 30,
					setInvisibleFields: 31,
					setFieldValue: 32,
					updateField: 33
				},
				null,
				[-1, -1]
			);
		}

		get collectData() {
			return this.$$.ctx[19];
		}

		get setFieldInvalid() {
			return this.$$.ctx[20];
		}

		get setFieldValid() {
			return this.$$.ctx[21];
		}

		get isFieldValid() {
			return this.$$.ctx[22];
		}

		get setFormFieldInvalid() {
			return this.$$.ctx[23];
		}

		get setFormFieldValid() {
			return this.$$.ctx[24];
		}

		get updateFormValidationStatus() {
			return this.$$.ctx[25];
		}

		get showSuccess() {
			return this.$$.ctx[26];
		}

		get setLoading() {
			return this.$$.ctx[27];
		}

		get resetLoading() {
			return this.$$.ctx[28];
		}

		get setFieldsVisibility() {
			return this.$$.ctx[29];
		}

		get setVisibleFields() {
			return this.$$.ctx[30];
		}

		get setInvisibleFields() {
			return this.$$.ctx[31];
		}

		get setFieldValue() {
			return this.$$.ctx[32];
		}

		get updateField() {
			return this.$$.ctx[33];
		}
	}

	const DEFAULT_RULES = {
	    notReadonly(v) {
	        return {
	            readonly: !v,
	        };
	    },
	    readonly(v) {
	        return {
	            readonly: v,
	        };
	    },
	    enable(v) {
	        return {
	            disabled: !v,
	        };
	    },
	    disable(v) {
	        return {
	            disabled: v,
	        };
	    },
	};

	class notFormRules {
	    static #RULES = { ...DEFAULT_RULES };

	    static add(name, func) {
	        if (!notCommon$2.objHas(this.#RULES, name)) {
	            this.#RULES[name] = func;
	        }
	    }

	    static remove(name) {
	        if (
	            notCommon$2.objHas(this.#RULES, name) &&
	            !Object.keys(DEFAULT_RULES).includes(name)
	        ) {
	            delete this.#RULES[name];
	        }
	    }

	    static exec(rule, master, slaves, value, form) {
	        return this.#RULES[rule](value, master, slaves, form);
	    }
	}

	const DEFAULT_CONTAINER_SELECTOR$1 = ".form";
	const DEFAULT_ACTION_NAME = "default";

	let notForm$5 = class notForm extends notBase$1 {
	    //UI renderer component class constructor
	    #uiComponent = null;
	    //form validation
	    #validationRunner = null;
	    //ui component
	    #form = null;
	    //model.action
	    #action = DEFAULT_ACTION_NAME;
	    //fields schemas
	    #fields = new Lib(); //fields of UI
	    //variants sets for select menus and so on
	    #variants = null; //variants for UI

	    constructor({
	        target = null,
	        name = "Default",
	        options = {},
	        working = {},
	        data = {},
	        ui = Form, //default UI
	    }) {
	        super({
	            working: {
	                name: `${name}Form`,
	                ...working,
	            },
	            options,
	            data,
	        });
	        this.#variants = new Lib(VARIANTS$1.getContent());
	        if (target) {
	            this.setOptions("target", target);
	        }
	        this.#uiComponent = ui;
	        if (notCommon$2.objHas(options, "action")) {
	            this.#action = options.action;
	        }
	        this.initForm();
	    }

	    initForm() {
	        if (this.getOptions("autoInit", true)) {
	            this.initLibs();
	        }
	        if (this.getOptions("autoRender", true)) {
	            this.initUI();
	        }
	    }

	    initLibs() {
	        this.initFields();
	        this.initVariants();
	        this.initValidator();
	    }

	    reInit() {
	        this.initLibs();
	        this.updateUI();
	        this.resetLoading();
	    }

	    initFields() {
	        const manifest = this.getFormManifest();
	        if (notCommon$2.objHas(manifest, "fields") && this.#fields.isEmpty()) {
	            this.#fields.import(manifest.fields); //all fields available in model manifest
	        }
	    }

	    initVariants() {
	        if (this.getOptions("variants")) {
	            this.#variants.import(this.getOptions("variants"));
	        }
	    }

	    //creating validators runner for this specific form
	    initValidator() {
	        this.#validationRunner = src.Runner(this.getFormValidators());
	    }

	    initUI() {
	        try {
	            const props = this.#getFormProps({
	                manifest: this.getFormManifest(),
	                formOptions: this.getFormOptions(),
	                data: this.getFormData(),
	                injectedProps: this.getFormInjectedProps(),
	            });
	            const target = this.getFormTargetEl();
	            while (target.children.length)
	                target.removeChild(target.firstChild);
	            this.#form = new this.#uiComponent({
	                target,
	                props,
	            });
	            this.#bindUIEvents();
	            this.validateForm();
	        } catch (e) {
	            this.error(e);
	        }
	    }

	    updateUI() {
	        try {
	            const props = this.#getFormProps({
	                manifest: this.getFormManifest(),
	                formOptions: this.getFormOptions(),
	                data: this.getFormData(),
	                injectedProps: this.getFormInjectedProps(),
	            });
	            this.#form.$set(props);
	            this.validateForm();
	        } catch (e) {
	            this.error(e);
	        }
	    }

	    #bindUIEvents() {
	        this.#form.$on("change", () => this.validateForm());
	        this.#form.$on("change", (ev) => {
	            this.emit("change", ev.detail);
	            this.emit(`change.${ev.detail.field}`, ev.detail.value);
	        });
	        this.#form.$on("submit", (ev) => this.submit(ev.detail));
	        this.#form.$on("reject", () => this.reject());
	        this.#form.$on("error", ({ detail }) => this.emit("error", detail));
	        this.#bindMasterSlaveEvents();
	    }

	    #bindMasterSlaveEvents() {
	        const masters = this.getOptions("masters", false);
	        if (!masters) {
	            return;
	        }
	        for (let master in masters) {
	            const rules = masters[master];
	            for (let ruleName in rules) {
	                const ruleSlaves = rules[ruleName];
	                this.#addMasterSlaveEvents(ruleName, master, ruleSlaves);
	            }
	        }
	    }

	    #addMasterSlaveEvents(rule, master, slaves = []) {
	        this.on(`change.${master}`, (value) => {
	            this.#execSlaveRule(rule, master, slaves, value);
	        });
	        this.emit(`change.${master}`, this.getFormData()[master]);
	    }

	    #execSlaveRule(rule, master, slaves, value) {
	        const cmd = notFormRules.exec(rule, master, slaves, value, this);
	        slaves.forEach((slaveField) => {
	            this.updateField(slaveField, cmd);
	        });
	    }

	    async validateForm() {
	        if (this.getOptions("readonly", false)) {
	            return;
	        }
	        try {
	            const validationResult = await this.#validationRunner(
	                this.#form.collectData(),
	                this.getFormAction()
	            );
	            this.#form.updateFormValidationStatus(validationResult.getReport());
	            if (!validationResult.clean) {
	                this.emit("error", validationResult.getReport());
	            }
	        } catch (e) {
	            const report = {
	                form: [UICommon.ERROR_DEFAULT, e.message],
	            };
	            this.#form && this.#form.updateFormValidationStatus(report);
	            this.emit("error", report);
	            notCommon$2.report(e);
	        }
	    }

	    submit(data) {
	        this.emit("submit", data);
	    }

	    reject() {
	        this.emit("reject");
	    }

	    //binding event to actual UI
	    $on() {
	        if (this.#form) {
	            this.#form.$on(...arguments);
	        }
	    }

	    setLoading() {
	        this.emit("loading");
	        this.#form.setLoading();
	    }

	    resetLoading() {
	        this.emit("loaded");
	        this.#form.resetLoading();
	    }

	    destroy() {
	        this.emit("destroy");
	        if (this.#form) {
	            this.#form.$destroy && this.#form.$destroy();
	            this.#form.destroy && this.#form.destroy();
	            this.#form = null;
	        }
	        this.#validationRunner = null;
	        this.#action = null;
	        this.#fields = null;
	        this.#variants = null;
	        this.setOptions(null);
	        this.setWorking(null);
	        this.setData(null);
	    }

	    #getFormProps({
	        manifest, //model manifest
	        formOptions = {
	            ui: {},
	            fields: {},
	        }, //some options
	        data = null, //initial data for form
	        injectedProps = {},
	    }) {
	        const action = this.#action;
	        if (typeof formOptions === "undefined" || formOptions === null) {
	            formOptions = {
	                ui: {},
	                fields: {},
	            };
	        }

	        const form = FormHelpers.initFormByField(
	            //form seed object
	            {},
	            /*
	      Form structure
	      [
	        //each item is line of form
	        //field - field takes whole line of form
	        //[field1, field2] - few fields in one line
	        nameFirst, nameLast
	        [age, country, language],
	        [email, telephone]
	      ]
	      */
	            manifest.actions[action].fields, //form fields structure
	            this.#variants, //variants library
	            this.#fields, //fields library
	            formOptions.fields, //form wide fields options
	            data
	        );

	        return {
	            //if no auto init of form structure, set to loading state
	            loading: !this.getOptions("autoInit", true),
	            title: manifest.actions[action].title,
	            description: manifest.actions[action].description,
	            fields: manifest.actions[action].fields,
	            form,
	            //injecting options to UI from top level input
	            ...formOptions.ui, //form UI options
	            ...injectedProps,
	        };
	    }

	    getName() {
	        return this.getWorking("name");
	    }

	    getFormAction() {
	        return this.#action;
	    }

	    setFormAction(val) {
	        if (val && val !== this.#action) {
	            this.#action = val;
	            this.#form && this.#form.$destroy();
	            this.initForm();
	        }
	    }

	    processResult(result) {
	        if (result.status === DEFAULT_STATUS_SUCCESS) {
	            this.setFormSuccess();
	            return true;
	        } else {
	            this.setFormErrors(result);
	            return false;
	        }
	    }

	    /**
	     *   Form validation result
	     **/
	    setFormSuccess() {
	        this.#form.showSuccess();
	        this.emit("success");
	    }

	    setFormErrors(result) {
	        if (this.getOptions("readonly", false)) {
	            return;
	        }
	        const status = {
	            form: [],
	            fields: {},
	        };
	        if (result.message) {
	            status.form.push(result.message);
	        }
	        if (result.errors && Object.keys(result.errors).length > 0) {
	            status.fields = { ...result.errors };
	        }
	        this.#form.updateFormValidationStatus(status);
	        this.emit("error", status);
	    }

	    /**
	     * Returns variant by collection name and item id
	     * @param {string}         name  name of the variants collection
	     * @param {string|number}  id    item identificator
	     * @returns {object}             item
	     **/
	    getVariant(name, id) {
	        let lib = this.#variants.get(name);
	        let result = lib.find((item) => item.id === id);
	        if (result) {
	            return result;
	        }
	        return null;
	    }

	    /***
	     * Redefinable getters
	     **/

	    getFormTargetEl() {
	        const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$1);
	        if (targetEl instanceof HTMLElement) {
	            return targetEl;
	        } else if (typeof targetEl === "string") {
	            return document.querySelector(targetEl);
	        } else {
	            throw new Error("Form parent element is not defined");
	        }
	    }

	    getFormValidators() {
	        if (this.getOptions("validators")) {
	            return this.getOptions("validators", {});
	        } else {
	            this.#missingOverrideWarning("validators");
	            return {};
	        }
	    }

	    getFormManifest() {
	        const modelName = this.getModelName();
	        if (modelName && notCommon$2.getApp()) {
	            return notCommon$2.getApp().getInterfaceManifest(modelName);
	        }
	        if (this.getOptions("manifest", undefined)) {
	            return this.getOptions("manifest", {});
	        } else {
	            this.#missingOverrideWarning("manifest");
	            return {};
	        }
	    }

	    getFormData() {
	        if (this.getData()) {
	            return this.getData();
	        } else {
	            this.#missingOverrideWarning("data");
	            return {};
	        }
	    }

	    getFormOptions() {
	        if (
	            this.getOptions("ui", undefined) ||
	            this.getOptions("fields", undefined)
	        ) {
	            return {
	                ui: this.getOptions("ui", {}),
	                fields: this.getOptions("fields", {}),
	            };
	        } else {
	            this.#missingOverrideWarning("options");
	            return {
	                ui: {},
	                fields: {},
	            };
	        }
	    }

	    getFormInjectedProps() {
	        return this.getOptions("injected", {});
	    }

	    /**
	     * Override empty message
	     **/
	    #missingOverrideWarning(missing) {
	        this.error(
	            `${missing} for ${this.getWorking("name")} form is not defined`
	        );
	    }

	    /**
	     * Form operations
	     **/
	    collectData() {
	        if (this.getOptions("readonly", false)) {
	            return this.getData();
	        }
	        const data = this.#form.collectData();
	        this.setData({ ...data }); //update in inner store
	        return data;
	    }

	    updateField(fieldName, props) {
	        this.#form.updateField(fieldName, props);
	    }

	    getModel(name, data) {
	        if (typeof name === "string") {
	            return this.getInterface(name)(data || {});
	        } else {
	            return this.getInterface()(name || {});
	        }
	    }

	    getInterface(name = false) {
	        return notCommon$2.getApp().getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	    getModelName() {
	        return this.getOptions("model");
	    }
	};

	/* node_modules/not-bulma/src/frame/components/form/form.set.svelte generated by Svelte v4.2.19 */

	function create_if_block$e(ctx) {
		let uibuttons;
		let updating_values;
		let current;

		function uibuttons_values_binding(value) {
			/*uibuttons_values_binding*/ ctx[5](value);
		}

		let uibuttons_props = { centered: true, classes: "mt-4" };

		if (/*FORMS_BUTTONS*/ ctx[2] !== void 0) {
			uibuttons_props.values = /*FORMS_BUTTONS*/ ctx[2];
		}

		uibuttons = new Ui_buttons({ props: uibuttons_props });
		binding_callbacks.push(() => bind(uibuttons, 'values', uibuttons_values_binding));

		return {
			c() {
				create_component(uibuttons.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttons, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttons_changes = {};

				if (!updating_values && dirty & /*FORMS_BUTTONS*/ 4) {
					updating_values = true;
					uibuttons_changes.values = /*FORMS_BUTTONS*/ ctx[2];
					add_flush_callback(() => updating_values = false);
				}

				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttons, detaching);
			}
		};
	}

	function create_fragment$j(ctx) {
		let div1;
		let div0;
		let div0_id_value;
		let t;
		let div1_id_value;
		let current;
		let if_block = /*showModes*/ ctx[1] && create_if_block$e(ctx);

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				t = space();
				if (if_block) if_block.c();
				attr(div0, "class", "form-paper");
				attr(div0, "id", div0_id_value = "" + (/*name*/ ctx[0] + "-form-set-container"));
				attr(div1, "class", "block-container");
				attr(div1, "id", div1_id_value = "" + (/*name*/ ctx[0] + "-form-set"));
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div1, t);
				if (if_block) if_block.m(div1, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*name*/ 1 && div0_id_value !== (div0_id_value = "" + (/*name*/ ctx[0] + "-form-set-container"))) {
					attr(div0, "id", div0_id_value);
				}

				if (/*showModes*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*showModes*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$e(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div1, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}

				if (!current || dirty & /*name*/ 1 && div1_id_value !== (div1_id_value = "" + (/*name*/ ctx[0] + "-form-set"))) {
					attr(div1, "id", div1_id_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				if (if_block) if_block.d();
			}
		};
	}

	function instance$j($$self, $$props, $$invalidate) {
		let dispatch = createEventDispatcher();
		let { name = 'default-form' } = $$props;
		let { showModes = false } = $$props;
		let { mode = 'default' } = $$props;
		let { forms = [] } = $$props;

		function setMode(val) {
			$$invalidate(3, mode = val);
			dispatch('mode', val);
			updateModesButtons();
		}

		let FORMS_BUTTONS = [];

		function updateModesButtons() {
			$$invalidate(2, FORMS_BUTTONS = forms.filter(form => {
				return mode !== form.mode;
			}).map(form => {
				return {
					title: form.title,
					outlined: true,
					type: 'link',
					action() {
						setMode(form.mode);
					}
				};
			}));
		}

		onMount(() => {
			updateModesButtons();
		});

		function uibuttons_values_binding(value) {
			FORMS_BUTTONS = value;
			$$invalidate(2, FORMS_BUTTONS);
		}

		$$self.$$set = $$props => {
			if ('name' in $$props) $$invalidate(0, name = $$props.name);
			if ('showModes' in $$props) $$invalidate(1, showModes = $$props.showModes);
			if ('mode' in $$props) $$invalidate(3, mode = $$props.mode);
			if ('forms' in $$props) $$invalidate(4, forms = $$props.forms);
		};

		return [name, showModes, FORMS_BUTTONS, mode, forms, uibuttons_values_binding];
	}

	class Form_set extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$j, create_fragment$j, safe_not_equal, { name: 0, showModes: 1, mode: 3, forms: 4 });
		}
	}

	const DEFAULT_CONTAINER_SELECTOR = ".form-set";
	const DEFAULT_FORM_SET_NAME = "form-set";

	let notFormSet$1 = class notFormSet extends notBase$1 {
	    #formSetComponent = null;
	    #formComponent = null;

	    #form = null;
	    #frame = null;

	    /*
	  new notFormSet({
	    options:{
	      target: el,
	      forms: [{
	        mode: 'form1',
	        title: 'Form 1',
	        form: formConstructor1 //custom constructors
	      },{
	        mode: 'form2',
	        title: 'Form 2',
	        props: {}             //params to create notForm instance
	      },{
	        mode: 'form3',
	        title: 'Form 3',
	        form: formConstructor3 //custom constructors
	      }]
	    }
	  });
	  */

	    constructor({
	        options = {},
	        formComponent = Form,
	        formSetComponent = Form_set,
	    }) {
	        super({
	            options: {
	                name: DEFAULT_FORM_SET_NAME,
	                mode: "default",
	                showModes: true,
	                ...options,
	            },
	        });
	        this.#formComponent = Form;
	        this.#formSetComponent = Form_set;
	        this.setFormMode(this.getOptions("mode"));
	        this.initUI();
	    }

	    /**
	     * Initalizing form frame mode, with switchers between modes
	     **/
	    initUI() {
	        const target = this.getFrameTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        this.#frame = new this.#formSetComponent({
	            target,
	            props: this.#getFrameProps(),
	        });
	        this.#frame.$on("mode", (ev) => {
	            this.setFormMode(ev.detail);
	            this.updateForm();
	        });
	        this.updateForm();
	    }

	    setFormMode(name) {
	        if (this.isModeExists(name)) {
	            this.setWorking("mode", name);
	        } else {
	            this.setWorking("mode", this.getFirstMode());
	            this.updateFormModeInUI();
	        }
	    }

	    updateFormModeInUI() {
	        if (this.#frame && this.getWorking("mode") !== null) {
	            this.#frame.$set({ mode: this.getWorking("mode") });
	        }
	    }

	    getFormMode() {
	        return this.getWorking("mode");
	    }

	    updateForm() {
	        this.destroyForm();
	        if (this.getWorking("mode") !== null) {
	            this.renderForm();
	        }
	    }

	    renderForm() {
	        const targetEl = this.getFormTargetEl();
	        const formConfig = this.getFormConfig();
	        if (!(targetEl instanceof HTMLElement && formConfig)) {
	            throw new Error("error while form rendering");
	        }
	        const changeMode = (mode) => {
	            this.setFormMode(mode);
	            this.updateForm();
	        };
	        if (formConfig.form) {
	            while (targetEl.children.length)
	                targetEl.removeChild(targetEl.firstChild);
	            this.#form = new formConfig.form({
	                options: { target: targetEl, changeMode },
	            });
	        } else if (formConfig.props) {
	            this.#form = new this.#formComponent({
	                target: targetEl,
	                ...formConfig.props,
	                changeMode,
	            });
	        }
	    }

	    getFormConfig() {
	        return this.getOptions("forms").find(
	            (form) => form.mode === this.getFormMode()
	        );
	    }

	    destroyForm() {
	        const containerEl = this.getFormTargetEl();
	        if (containerEl) {
	            while (containerEl.firstChild) {
	                containerEl.removeChild(containerEl.lastChild);
	            }
	        }
	        if (this.#form && this.#form.$destroy) {
	            this.#form.$destroy();
	        }
	        this.#form = null;
	    }

	    destroyFrame() {
	        if (this.#frame && this.#frame.$destroy) {
	            this.#frame.$destroy();
	        }
	        this.#frame = null;
	    }

	    isModeExists(mode) {
	        const forms = this.getOptions("forms", []);
	        return forms.some((item) => item.mode === mode);
	    }

	    getFirstMode() {
	        const forms = this.getOptions("forms", []);
	        if (forms.length > 0) {
	            return forms[0].mode;
	        }
	        return null;
	    }

	    destroy() {
	        this.#formSetComponent = null;
	        this.#formComponent = null;
	        this.destroyForm();
	        this.destroyFrame();
	        thi.setData(null);
	        thi.setOptions(null);
	        thi.setWorking(null);
	    }

	    getFrameTargetEl() {
	        const target = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR);
	        if (target instanceof HTMLElement) {
	            return target;
	        } else if (typeof target === "string") {
	            return document.querySelector(target);
	        } else {
	            throw new Error("form set target is not HTMLElement or string");
	        }
	    }

	    getFormTargetEl() {
	        const name = this.getOptions("name", DEFAULT_FORM_SET_NAME);
	        return document.querySelector(`#${name}-form-set-container`);
	    }

	    #getFrameProps() {
	        return {
	            showModes: this.getOptions("showModes", true),
	            mode: this.getFormMode(),
	            forms: this.getOptions("forms", []),
	            name: this.getOptions("name", DEFAULT_FORM_SET_NAME),
	        };
	    }
	};

	/* node_modules/not-bulma/src/frame/components/breadcrumbs/ui.breadcrumbs.svelte generated by Svelte v4.2.19 */

	function get_each_context$5(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		child_ctx[7] = i;
		return child_ctx;
	}

	// (29:4) {:else}
	function create_else_block$a(ctx) {
		let li;
		let a;
		let t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "";
		let t;
		let a_href_value;
		let a_data_href_value;
		let mounted;
		let dispose;

		return {
			c() {
				li = element("li");
				a = element("a");
				t = text(t_value);
				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*link*/ ctx[5].url));
				attr(a, "data-href", a_data_href_value = /*link*/ ctx[5].url);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, a);
				append(a, t);

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[3]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, items*/ 6 && t_value !== (t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "")) set_data(t, t_value);

				if (dirty & /*root, items*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*link*/ ctx[5].url))) {
					attr(a, "href", a_href_value);
				}

				if (dirty & /*items*/ 2 && a_data_href_value !== (a_data_href_value = /*link*/ ctx[5].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (27:4) {#if link.url === false }
	function create_if_block_1$c(ctx) {
		let li;
		let t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "";
		let t;

		return {
			c() {
				li = element("li");
				t = text(t_value);
				attr(li, "class", "is-plain-crumb");
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, items*/ 6 && t_value !== (t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}
			}
		};
	}

	// (24:4) {#if (items.length === (index + 1)) }
	function create_if_block$d(ctx) {
		let li;
		let a;
		let t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "";
		let t;
		let a_href_value;
		let a_data_href_value;

		return {
			c() {
				li = element("li");
				a = element("a");
				t = text(t_value);
				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*link*/ ctx[5].url));
				attr(a, "data-href", a_data_href_value = /*link*/ ctx[5].url);
				attr(a, "aria-current", "page");
				attr(li, "class", "is-active");
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, a);
				append(a, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, items*/ 6 && t_value !== (t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "")) set_data(t, t_value);

				if (dirty & /*root, items*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*link*/ ctx[5].url))) {
					attr(a, "href", a_href_value);
				}

				if (dirty & /*items*/ 2 && a_data_href_value !== (a_data_href_value = /*link*/ ctx[5].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}
			}
		};
	}

	// (23:4) {#each items as link, index}
	function create_each_block$5(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*items*/ ctx[1].length === /*index*/ ctx[7] + 1) return create_if_block$d;
			if (/*link*/ ctx[5].url === false) return create_if_block_1$c;
			return create_else_block$a;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function create_fragment$i(ctx) {
		let nav;
		let ul;
		let each_value = ensure_array_like(/*items*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
		}

		return {
			c() {
				nav = element("nav");
				ul = element("ul");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(nav, "class", "breadcrumb");
				attr(nav, "aria-label", "breadcrumbs");
			},
			m(target, anchor) {
				insert(target, nav, anchor);
				append(nav, ul);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*root, items, $LOCALE, onClick*/ 15) {
					each_value = ensure_array_like(/*items*/ ctx[1]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$5(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$5(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(nav);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$i($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		let { root = '' } = $$props;
		let { items = [] } = $$props;
		let { go = null } = $$props;

		function onClick(ev) {
			if (typeof go === 'function') {
				ev.preventDefault();
				go(ev.currentTarget.dataset.href);
				return false;
			} else {
				return true;
			}
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('items' in $$props) $$invalidate(1, items = $$props.items);
			if ('go' in $$props) $$invalidate(4, go = $$props.go);
		};

		return [root, items, $LOCALE, onClick, go];
	}

	class Ui_breadcrumbs extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$i, create_fragment$i, safe_not_equal, { root: 0, items: 1, go: 4 });
		}
	}

	class notBreadcrumbs{

	  static UIConstructor = null;
	  static ui = null;
	  static head = [];
	  static tail = [];

	  static render({target, root = '', navigate}){
	    this.remove();
	    if(notBreadcrumbs.UIConstructor){
	      this.ui = new notBreadcrumbs.UIConstructor({
	        target,
	        props:{
	          items:  this.getBreadcrumbs(),
	          root:   root,
	          go:      navigate
	        }
	      });
	    }
	  }

	  static setHead(head){
	    this.head.splice(0,this.head.length,...head);
	    return this;
	  }

	  static setTail(tail){
	    this.tail.splice(0, this.tail.length,...tail);
	    return this;
	  }

	  static getBreadcrumbs(){
	    let crumbs = [];
	    crumbs.push(...this.head);
	    crumbs.push(...this.tail);
	    return crumbs;
	  }

	  static update(){
	    if(this.ui){
	      this.ui.$set({ items: this.getBreadcrumbs() });
	    }
	  }

	  static remove(){
	    if (this.ui) {
	      this.ui.$destroy();
	      this.ui = null;
	    }
	    return this;
	  }

	}

	notBreadcrumbs.UIConstructor = Ui_breadcrumbs;

	class Menu {
	    static MAX_TOUCH_WIDTH = 1023;
	    static DEFAULT = {
	        section: "any",
	        sectionTitle: "Меню",
	        priority: 0,
	        //link, button, dropdown, component
	        type: "link",
	    };
	    static app = false;
	    static directNavigation = false;
	    static menu;
	    static options = {
	        directNavigation: false,
	        navigate: (urls) => {
	            this.hide();
	            if (!this.isDirectNavigation() && this.app) {
	                let func = this.app.getWorking("router");
	                if (func) {
	                    return func.navigate(urls.short);
	                }
	            }
	            document.location.assign(urls.full);
	        },
	    };

	    static items = [];
	    static sections = [];
	    static location;
	    static interval;

	    static setApp(app) {
	        if (!this.app) {
	            this.app = app;
	        }
	        return this;
	    }

	    static setOptions(options) {
	        this.options = { ...this.options, ...options };
	        return this;
	    }

	    static getOptionsPathTo(what) {
	        return `menu.${this.options.type}.${what}`;
	    }

	    static isDirectNavigation() {
	        return this.app
	            ? this.app.getOptions(
	                  this.getOptionsPathTo("directNavigation"),
	                  this.options.directNavigation
	              )
	            : this.options.directNavigation;
	    }

	    static getOptions() {
	        if (this.app) {
	            return {
	                brand: this.app.getOptions("brand", this.options.brand),
	                items: this.app.getOptions(
	                    this.getOptionsPathTo("items"),
	                    this.options.items
	                ),
	                sections: this.app.getOptions(
	                    this.getOptionsPathTo("sections"),
	                    this.options.sections
	                ),
	                targetSelector: this.app.getOptions(
	                    this.getOptionsPathTo("targetSelector"),
	                    this.options.targetSelector
	                ),
	                toggleSelector: this.app.getOptions(
	                    this.getOptionsPathTo("toggleSelector"),
	                    this.options.toggleSelector
	                ),
	                open: this.app.getOptions(
	                    this.getOptionsPathTo("open"),
	                    this.options.open
	                ),
	                directNavigation: this.app.getOptions(
	                    this.getOptionsPathTo("directNavigation"),
	                    this.options.directNavigation
	                ),
	                root: this.app.getOptions("router.root", this.options.root),
	                navigate: this.options.navigate.bind(this),
	                getComponent: this.getComponent.bind(this),
	            };
	        } else {
	            return this.options;
	        }
	    }

	    static getComponent(name) {
	        if (COMPONENTS$2.contains(name)) {
	            return COMPONENTS$2.get(name);
	        } else {
	            return false;
	        }
	    }

	    static initField(list, fields = []) {
	        list.forEach((item) => {
	            fields.forEach((field) => {
	                if (!Object.hasOwn(item, field)) {
	                    item[field] = this.DEFAULT[field];
	                }
	            });
	            if (Object.hasOwn(item, "items")) {
	                this.initField(item.items, fields);
	            }
	        });
	    }

	    static sortList(list) {
	        list.sort((item1, item2) => {
	            if (Object.hasOwn(item1, "items")) {
	                this.sortList(item1.items);
	            }
	            if (Object.hasOwn(item2, "items")) {
	                this.sortList(item2.items);
	            }
	            if (item1.priority === item2.priority) {
	                return item1.title > item2.title ? 1 : -1;
	            } else {
	                return item1.priority < item2.priority ? 1 : -1;
	            }
	        });
	    }

	    static removeDublicates(sections) {
	        for (let i = 0; i < sections.length; i++) {
	            let priority = sections[i].priority;
	            sections
	                .filter((section) => {
	                    return section.id === sections[i].id;
	                })
	                .forEach((item, indx) => {
	                    if (indx === 0) {
	                        return;
	                    }
	                    if (item.priority < priority) {
	                        priority = item.priority;
	                    }
	                    sections.splice(sections.indexOf(item), 1);
	                });
	            sections[i].priority = priority;
	        }
	        return sections;
	    }

	    static prepareData() {
	        let items = [];
	        items.push(...this.getOptions().items);
	        let sections = [];
	        sections.push(...this.getOptions().sections);

	        this.initField(sections, ["priority"]);
	        this.removeDublicates(sections);
	        this.initField(items, ["priority", "section", "type"]);
	        this.sortList(sections);

	        sections.push({
	            id: this.DEFAULT.section,
	            title: this.DEFAULT.sectionTitle,
	        });
	        this.sortList(items);

	        this.sections = sections;
	        this.items = items;
	    }

	    static remove() {
	        if (this.menu) {
	            this.menu.$destroy();
	            this.menu = null;
	            clearInterval(this.interval);
	        }
	    }

	    static updateIndicator(sectionId, itemId, state) {
	        this.updateSection(sectionId, (section) => {
	            section.indicator.state = state;
	        });
	        this.updateItem(itemId, (item) => {
	            item.indicator.state = state;
	        });
	    }

	    static updateTag(sectionId, itemId, tag) {
	        this.updateSection(sectionId, (section) => {
	            section.tag = tag;
	        });
	        this.updateItem(itemId, (item) => {
	            item.tag = tag;
	        });
	    }

	    static updateSectionTag(sectionId, tag) {
	        this.updateSection(sectionId, (section) => {
	            section.tag = { ...section.tag, ...tag };
	        });
	    }

	    static updateItemTag(itemId, tag) {
	        this.updateItem(itemId, (item) => {
	            item.tag = { ...item.tag, ...tag };
	        });
	    }

	    static updateSection(sectionId, proc) {
	        if (this.sections && sectionId) {
	            for (let section in this.sections) {
	                if (this.sections[section].id !== sectionId) continue;
	                proc(this.sections[section]);
	            }
	            if (this.menu) {
	                this.menu.$set({ sections: this.sections });
	            }
	        }
	    }

	    static updateSectionItems(sectionId, proc) {
	        if (this.sections && sectionId) {
	            let oldList = this.items.filter(
	                (item) => item.section === sectionId
	            );
	            for (let i of oldList) {
	                this.items.splice(this.items.indexOf(i), 1);
	            }
	            this.items.push(...proc(oldList));
	            if (this.menu) {
	                this.menu.$set({ items: this.items });
	            }
	        }
	    }

	    static updateItem(itemId, proc) {
	        if (itemId && this.items) {
	            this.items.forEach((item) => {
	                if (item.id !== itemId) return;
	                proc(item);
	            });
	            if (this.menu) {
	                this.menu.$set({ items: this.items });
	            }
	        }
	    }

	    static isTouch() {
	        return window.innerWidth <= this.MAX_TOUCH_WIDTH;
	    }

	    static getSectionComponent() {}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.item.without.children.svelte generated by Svelte v4.2.19 */

	function create_else_block$9(ctx) {
		let li;
		let t0_value = /*$LOCALE*/ ctx[2][/*item*/ ctx[1].title] + "";
		let t0;
		let t1;
		let t2;
		let li_class_value;
		let current;
		let if_block0 = /*item*/ ctx[1].tag && create_if_block_4$3(ctx);
		let if_block1 = /*item*/ ctx[1].indicator && create_if_block_3$6(ctx);

		return {
			c() {
				li = element("li");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				attr(li, "class", li_class_value = "is-no-follow-subtitle " + /*item*/ ctx[1].classes);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, t0);
				append(li, t1);
				if (if_block0) if_block0.m(li, null);
				append(li, t2);
				if (if_block1) if_block1.m(li, null);
				current = true;
			},
			p(ctx, dirty) {
				if ((!current || dirty & /*$LOCALE, item*/ 6) && t0_value !== (t0_value = /*$LOCALE*/ ctx[2][/*item*/ ctx[1].title] + "")) set_data(t0, t0_value);

				if (/*item*/ ctx[1].tag) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*item*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_4$3(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(li, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*item*/ ctx[1].indicator) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*item*/ 2) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_3$6(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(li, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*item*/ 2 && li_class_value !== (li_class_value = "is-no-follow-subtitle " + /*item*/ ctx[1].classes)) {
					attr(li, "class", li_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (22:0) {#if (typeof item.url !== 'undefined' && item.url!==false) }
	function create_if_block$c(ctx) {
		let li;
		let a;
		let t0_value = /*$LOCALE*/ ctx[2][/*item*/ ctx[1].title] + "";
		let t0;
		let t1;
		let t2;
		let a_href_value;
		let a_data_href_value;
		let li_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*item*/ ctx[1].tag && create_if_block_2$8(ctx);
		let if_block1 = /*item*/ ctx[1].indicator && create_if_block_1$b(ctx);

		return {
			c() {
				li = element("li");
				a = element("a");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[1].url));
				attr(a, "data-href", a_data_href_value = /*item*/ ctx[1].url);
				attr(li, "class", li_class_value = /*item*/ ctx[1].classes);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, a);
				append(a, t0);
				append(a, t1);
				if (if_block0) if_block0.m(a, null);
				append(a, t2);
				if (if_block1) if_block1.m(a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[3]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if ((!current || dirty & /*$LOCALE, item*/ 6) && t0_value !== (t0_value = /*$LOCALE*/ ctx[2][/*item*/ ctx[1].title] + "")) set_data(t0, t0_value);

				if (/*item*/ ctx[1].tag) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*item*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$8(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(a, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*item*/ ctx[1].indicator) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*item*/ 2) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$b(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(a, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*root, item*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[1].url))) {
					attr(a, "href", a_href_value);
				}

				if (!current || dirty & /*item*/ 2 && a_data_href_value !== (a_data_href_value = /*item*/ ctx[1].url)) {
					attr(a, "data-href", a_data_href_value);
				}

				if (!current || dirty & /*item*/ 2 && li_class_value !== (li_class_value = /*item*/ ctx[1].classes)) {
					attr(li, "class", li_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				mounted = false;
				dispose();
			}
		};
	}

	// (36:2) {#if item.tag }
	function create_if_block_4$3(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[1].id }, /*item*/ ctx[1].tag];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 2)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[1].id }, get_spread_object(/*item*/ ctx[1].tag)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (39:2) {#if item.indicator }
	function create_if_block_3$6(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[1].id }, /*item*/ ctx[1].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 2)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[1].id }, get_spread_object(/*item*/ ctx[1].indicator)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (26:2) {#if item.tag }
	function create_if_block_2$8(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[1].id }, /*item*/ ctx[1].tag];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 2)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[1].id }, get_spread_object(/*item*/ ctx[1].tag)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (29:2) {#if item.indicator }
	function create_if_block_1$b(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[1].id }, /*item*/ ctx[1].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 2)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[1].id }, get_spread_object(/*item*/ ctx[1].indicator)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	function create_fragment$h(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$c, create_else_block$9];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (typeof /*item*/ ctx[1].url !== 'undefined' && /*item*/ ctx[1].url !== false) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$h($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		const dispatch = createEventDispatcher();
		let { root = '' } = $$props;
		let { item = {} } = $$props;

		function onClick(ev) {
			ev.preventDefault();

			dispatch('navigate', {
				full: ev.target.getAttribute('href'),
				short: ev.target.dataset.href
			});

			return false;
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('item' in $$props) $$invalidate(1, item = $$props.item);
		};

		return [root, item, $LOCALE, onClick];
	}

	class Ui_item_without_children extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$h, create_fragment$h, safe_not_equal, { root: 0, item: 1 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.trigger.svelte generated by Svelte v4.2.19 */

	function create_fragment$g(ctx) {
		let span;
		let i;
		let i_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				i = element("i");

				attr(i, "class", i_class_value = "fas " + (/*closed*/ ctx[0]
				? /*icon_closed*/ ctx[2]
				: /*icon_opened*/ ctx[1]));

				attr(i, "aria-hidden", "true");
				attr(span, "class", "icon is-small is-toggle-submenu is-pulled-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);

				if (!mounted) {
					dispose = [
						listen(span, "click", /*onClick*/ ctx[3]),
						listen(span, "keyup", /*onClick*/ ctx[3])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*closed, icon_closed, icon_opened*/ 7 && i_class_value !== (i_class_value = "fas " + (/*closed*/ ctx[0]
				? /*icon_closed*/ ctx[2]
				: /*icon_opened*/ ctx[1]))) {
					attr(i, "class", i_class_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$g($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();

		const CLASS_ICON = {
			OPENED: "fa-angle-down",
			CLOSED: "fa-angle-up"
		};

		let { icon_opened = CLASS_ICON.OPENED } = $$props;
		let { icon_closed = CLASS_ICON.CLOSED } = $$props;
		let { closed = false } = $$props;

		function onClick(e) {
			e && e.preventDefault() && e.stopPropagation();
			$$invalidate(0, closed = !closed);
			dispatch("toggle", { closed });
			return false;
		}

		$$self.$$set = $$props => {
			if ('icon_opened' in $$props) $$invalidate(1, icon_opened = $$props.icon_opened);
			if ('icon_closed' in $$props) $$invalidate(2, icon_closed = $$props.icon_closed);
			if ('closed' in $$props) $$invalidate(0, closed = $$props.closed);
		};

		return [closed, icon_opened, icon_closed, onClick];
	}

	class Ui_trigger extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$g, create_fragment$g, safe_not_equal, {
				icon_opened: 1,
				icon_closed: 2,
				closed: 0
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.item.label.svelte generated by Svelte v4.2.19 */

	function create_else_block$8(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[1][/*item*/ ctx[0].title] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "class", "is-no-link");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, item*/ 3 && t_value !== (t_value = /*$LOCALE*/ ctx[1][/*item*/ ctx[0].title] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (14:94) 
	function create_if_block_3$5(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].props];
		var switch_value = COMPONENTS$2.get(/*item*/ ctx[0].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*item*/ 1) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].props)]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*item*/ 1 && switch_value !== (switch_value = COMPONENTS$2.get(/*item*/ ctx[0].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*item*/ 1)
					? get_spread_update(switch_instance_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].props)])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (12:0) {#if item.icon }
	function create_if_block_2$7(ctx) {
		let uiicon;
		let current;
		const uiicon_spread_levels = [/*item*/ ctx[0].icon];
		let uiicon_props = {};

		for (let i = 0; i < uiicon_spread_levels.length; i += 1) {
			uiicon_props = assign(uiicon_props, uiicon_spread_levels[i]);
		}

		uiicon = new Ui_icon_font({ props: uiicon_props });

		return {
			c() {
				create_component(uiicon.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiicon, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiicon_changes = (dirty & /*item*/ 1)
				? get_spread_update(uiicon_spread_levels, [get_spread_object(/*item*/ ctx[0].icon)])
				: {};

				uiicon.$set(uiicon_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiicon.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiicon.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiicon, detaching);
			}
		};
	}

	// (23:0) {#if item.tag }
	function create_if_block_1$a(ctx) {
		let uitag;
		let current;
		const uitag_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].tag];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitag_changes = (dirty & /*item*/ 1)
				? get_spread_update(uitag_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].tag)])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	// (26:0) {#if item.indicator }
	function create_if_block$b(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 1)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].indicator)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	function create_fragment$f(ctx) {
		let show_if;
		let current_block_type_index;
		let if_block0;
		let t0;
		let t1;
		let t2;
		let current;
		const if_block_creators = [create_if_block_2$7, create_if_block_3$5, create_else_block$8];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (dirty & /*item*/ 1) show_if = null;
			if (/*item*/ ctx[0].icon) return 0;
			if (show_if == null) show_if = !!(/*item*/ ctx[0].type === 'component' && /*item*/ ctx[0].component && COMPONENTS$2.contains(/*item*/ ctx[0].component));
			if (show_if) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx, -1);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*item*/ ctx[0].tag && create_if_block_1$a(ctx);
		let if_block2 = /*item*/ ctx[0].indicator && create_if_block$b(ctx);
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		return {
			c() {
				if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				if (default_slot) default_slot.c();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t2, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}

				if (/*item*/ ctx[0].tag) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*item*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$a(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*item*/ ctx[0].indicator) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*item*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block$b(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(t2.parentNode, t2);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
				}

				if_blocks[current_block_type_index].d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$f($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(1, $LOCALE = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		let { item = {} } = $$props;

		$$self.$$set = $$props => {
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
			if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
		};

		return [item, $LOCALE, $$scope, slots];
	}

	class Ui_item_label extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$f, create_fragment$f, safe_not_equal, { item: 0 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.items.svelte generated by Svelte v4.2.19 */

	function get_each_context$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[11] = list[i];
		child_ctx[12] = list;
		child_ctx[13] = i;
		return child_ctx;
	}

	// (48:1) {:else}
	function create_else_block_1(ctx) {
		let uisidemenuitemwithoutchildren;
		let current;

		uisidemenuitemwithoutchildren = new Ui_item_without_children({
				props: {
					root: /*root*/ ctx[0],
					item: /*item*/ ctx[11]
				}
			});

		uisidemenuitemwithoutchildren.$on("navigate", /*navigate_handler_1*/ ctx[9]);

		return {
			c() {
				create_component(uisidemenuitemwithoutchildren.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenuitemwithoutchildren, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uisidemenuitemwithoutchildren_changes = {};
				if (dirty & /*root*/ 1) uisidemenuitemwithoutchildren_changes.root = /*root*/ ctx[0];
				if (dirty & /*items*/ 2) uisidemenuitemwithoutchildren_changes.item = /*item*/ ctx[11];
				uisidemenuitemwithoutchildren.$set(uisidemenuitemwithoutchildren_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenuitemwithoutchildren.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenuitemwithoutchildren.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenuitemwithoutchildren, detaching);
			}
		};
	}

	// (33:1) {#if item.items && item.items.length }
	function create_if_block$a(ctx) {
		let li;
		let current_block_type_index;
		let if_block;
		let t0;
		let ui_items;
		let updating_closed;
		let t1;
		let li_class_value;
		let current;
		const if_block_creators = [create_if_block_1$9, create_else_block$7];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (typeof /*item*/ ctx[11].url !== 'undefined' && /*item*/ ctx[11].url !== false) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function ui_items_closed_binding(value) {
			/*ui_items_closed_binding*/ ctx[7](value, /*index*/ ctx[13]);
		}

		let ui_items_props = {
			root: /*root*/ ctx[0],
			items: /*item*/ ctx[11].items
		};

		if (/*closedChildren*/ ctx[3][/*index*/ ctx[13]] !== void 0) {
			ui_items_props.closed = /*closedChildren*/ ctx[3][/*index*/ ctx[13]];
		}

		ui_items = new Ui_items({ props: ui_items_props });
		binding_callbacks.push(() => bind(ui_items, 'closed', ui_items_closed_binding));
		ui_items.$on("navigate", /*navigate_handler*/ ctx[8]);

		return {
			c() {
				li = element("li");
				if_block.c();
				t0 = space();
				create_component(ui_items.$$.fragment);
				t1 = space();
				attr(li, "class", li_class_value = "is-no-follow-subtitle " + /*item*/ ctx[11].classes);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				if_blocks[current_block_type_index].m(li, null);
				append(li, t0);
				mount_component(ui_items, li, null);
				append(li, t1);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(li, t0);
				}

				const ui_items_changes = {};
				if (dirty & /*root*/ 1) ui_items_changes.root = /*root*/ ctx[0];
				if (dirty & /*items*/ 2) ui_items_changes.items = /*item*/ ctx[11].items;

				if (!updating_closed && dirty & /*closedChildren*/ 8) {
					updating_closed = true;
					ui_items_changes.closed = /*closedChildren*/ ctx[3][/*index*/ ctx[13]];
					add_flush_callback(() => updating_closed = false);
				}

				ui_items.$set(ui_items_changes);

				if (!current || dirty & /*items*/ 2 && li_class_value !== (li_class_value = "is-no-follow-subtitle " + /*item*/ ctx[11].classes)) {
					attr(li, "class", li_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(ui_items.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(ui_items.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(ui_items);
			}
		};
	}

	// (41:2) {:else}
	function create_else_block$7(ctx) {
		let uisidemenuitemlabel;
		let current;

		uisidemenuitemlabel = new Ui_item_label({
				props: {
					item: /*item*/ ctx[11],
					$$slots: { default: [create_default_slot_1$1] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uisidemenuitemlabel.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenuitemlabel, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uisidemenuitemlabel_changes = {};
				if (dirty & /*items*/ 2) uisidemenuitemlabel_changes.item = /*item*/ ctx[11];

				if (dirty & /*$$scope, closedChildren*/ 16392) {
					uisidemenuitemlabel_changes.$$scope = { dirty, ctx };
				}

				uisidemenuitemlabel.$set(uisidemenuitemlabel_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenuitemlabel.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenuitemlabel.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenuitemlabel, detaching);
			}
		};
	}

	// (35:2) {#if (typeof item.url !== 'undefined' && item.url!==false) }
	function create_if_block_1$9(ctx) {
		let a;
		let uisidemenuitemlabel;
		let a_href_value;
		let a_data_href_value;
		let current;
		let mounted;
		let dispose;

		uisidemenuitemlabel = new Ui_item_label({
				props: {
					item: /*item*/ ctx[11],
					$$slots: { default: [create_default_slot$1] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				a = element("a");
				create_component(uisidemenuitemlabel.$$.fragment);
				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[11].url));
				attr(a, "data-href", a_data_href_value = /*item*/ ctx[11].url);
				attr(a, "class", "has-subitems");
			},
			m(target, anchor) {
				insert(target, a, anchor);
				mount_component(uisidemenuitemlabel, a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[4]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uisidemenuitemlabel_changes = {};
				if (dirty & /*items*/ 2) uisidemenuitemlabel_changes.item = /*item*/ ctx[11];

				if (dirty & /*$$scope, closedChildren*/ 16392) {
					uisidemenuitemlabel_changes.$$scope = { dirty, ctx };
				}

				uisidemenuitemlabel.$set(uisidemenuitemlabel_changes);

				if (!current || dirty & /*root, items*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[11].url))) {
					attr(a, "href", a_href_value);
				}

				if (!current || dirty & /*items*/ 2 && a_data_href_value !== (a_data_href_value = /*item*/ ctx[11].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenuitemlabel.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenuitemlabel.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				destroy_component(uisidemenuitemlabel);
				mounted = false;
				dispose();
			}
		};
	}

	// (42:3) <UISideMenuItemLabel {item} >
	function create_default_slot_1$1(ctx) {
		let uisidemenutrigger;
		let current;

		function toggle_handler_1(...args) {
			return /*toggle_handler_1*/ ctx[6](/*index*/ ctx[13], ...args);
		}

		uisidemenutrigger = new Ui_trigger({});
		uisidemenutrigger.$on("toggle", toggle_handler_1);

		return {
			c() {
				create_component(uisidemenutrigger.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenutrigger, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenutrigger.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenutrigger.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenutrigger, detaching);
			}
		};
	}

	// (37:3) <UISideMenuItemLabel {item} >
	function create_default_slot$1(ctx) {
		let uisidemenutrigger;
		let current;

		function toggle_handler(...args) {
			return /*toggle_handler*/ ctx[5](/*index*/ ctx[13], ...args);
		}

		uisidemenutrigger = new Ui_trigger({});
		uisidemenutrigger.$on("toggle", toggle_handler);

		return {
			c() {
				create_component(uisidemenutrigger.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenutrigger, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenutrigger.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenutrigger.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenutrigger, detaching);
			}
		};
	}

	// (32:0) {#each items as item, index}
	function create_each_block$4(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$a, create_else_block_1];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*item*/ ctx[11].items && /*item*/ ctx[11].items.length) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function create_fragment$e(ctx) {
		let ul;
		let ul_class_value;
		let current;
		let each_value = ensure_array_like(/*items*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				ul = element("ul");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(ul, "class", ul_class_value = "menu-list " + (/*closed*/ ctx[2] ? 'is-closed' : ''));
			},
			m(target, anchor) {
				insert(target, ul, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*items, root, closedChildren, onClick*/ 27) {
					each_value = ensure_array_like(/*items*/ ctx[1]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$4(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$4(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(ul, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty & /*closed*/ 4 && ul_class_value !== (ul_class_value = "menu-list " + (/*closed*/ ctx[2] ? 'is-closed' : ''))) {
					attr(ul, "class", ul_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(ul);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$e($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let closedChildren = {};
		let { root = '' } = $$props;
		let { items = [] } = $$props;
		let { closed = false } = $$props;

		function onClick(ev) {
			ev.preventDefault();

			dispatch('navigate', {
				full: ev.target.getAttribute('href'),
				short: ev.target.dataset.href
			});

			return false;
		}

		const toggle_handler = (index, { detail }) => {
			$$invalidate(3, closedChildren[index] = detail.closed, closedChildren);
		};

		const toggle_handler_1 = (index, { detail }) => {
			$$invalidate(3, closedChildren[index] = detail.closed, closedChildren);
		};

		function ui_items_closed_binding(value, index) {
			if ($$self.$$.not_equal(closedChildren[index], value)) {
				closedChildren[index] = value;
				$$invalidate(3, closedChildren);
			}
		}

		function navigate_handler(event) {
			bubble.call(this, $$self, event);
		}

		function navigate_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('items' in $$props) $$invalidate(1, items = $$props.items);
			if ('closed' in $$props) $$invalidate(2, closed = $$props.closed);
		};

		return [
			root,
			items,
			closed,
			closedChildren,
			onClick,
			toggle_handler,
			toggle_handler_1,
			ui_items_closed_binding,
			navigate_handler,
			navigate_handler_1
		];
	}

	class Ui_items extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$e, create_fragment$e, safe_not_equal, { root: 0, items: 1, closed: 2 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.section.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$8(ctx) {
		let if_block_anchor;
		let current;
		let if_block = (/*sectionItems*/ ctx[2].length || /*section*/ ctx[0].component || /*section*/ ctx[0].tag || /*section*/ ctx[0].indicator) && create_if_block_2$6(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*sectionItems*/ ctx[2].length || /*section*/ ctx[0].component || /*section*/ ctx[0].tag || /*section*/ ctx[0].indicator) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*sectionItems, section*/ 5) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_2$6(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (15:0) {#if sectionItems.length || section.component || section.tag || section.indicator }
	function create_if_block_2$6(ctx) {
		let p;
		let show_if;
		let current_block_type_index;
		let if_block0;
		let t0;
		let t1;
		let p_class_value;
		let current;
		const if_block_creators = [create_if_block_5$1, create_else_block$6];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (dirty & /*section*/ 1) show_if = null;
			if (show_if == null) show_if = !!(/*section*/ ctx[0].type === 'component' && /*section*/ ctx[0].component && COMPONENTS$2.contains(/*section*/ ctx[0].component));
			if (show_if) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx, -1);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*section*/ ctx[0].tag && create_if_block_4$2(ctx);
		let if_block2 = /*section*/ ctx[0].indicator && create_if_block_3$4(ctx);

		return {
			c() {
				p = element("p");
				if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(p, "class", p_class_value = "menu-label " + /*section*/ ctx[0].classes);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				if_blocks[current_block_type_index].m(p, null);
				append(p, t0);
				if (if_block1) if_block1.m(p, null);
				append(p, t1);
				if (if_block2) if_block2.m(p, null);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(p, t0);
				}

				if (/*section*/ ctx[0].tag) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*section*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_4$2(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(p, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*section*/ ctx[0].indicator) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*section*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_3$4(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(p, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*section*/ 1 && p_class_value !== (p_class_value = "menu-label " + /*section*/ ctx[0].classes)) {
					attr(p, "class", p_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}

				if_blocks[current_block_type_index].d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (23:2) {:else}
	function create_else_block$6(ctx) {
		let t_value = /*$LOCALE*/ ctx[3][/*section*/ ctx[0].title] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, section*/ 9 && t_value !== (t_value = /*$LOCALE*/ ctx[3][/*section*/ ctx[0].title] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (17:2) {#if (section.type==='component' && section.component && COMPONENTS.contains(section.component)) }
	function create_if_block_5$1(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ id: /*section*/ ctx[0].id }, /*section*/ ctx[0].props];
		var switch_value = COMPONENTS$2.get(/*section*/ ctx[0].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*section*/ 1) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [{ id: /*section*/ ctx[0].id }, get_spread_object(/*section*/ ctx[0].props)]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*section*/ 1 && switch_value !== (switch_value = COMPONENTS$2.get(/*section*/ ctx[0].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*section*/ 1)
					? get_spread_update(switch_instance_spread_levels, [
							{ id: /*section*/ ctx[0].id },
							get_spread_object(/*section*/ ctx[0].props)
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (26:2) {#if section.tag }
	function create_if_block_4$2(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*section*/ ctx[0].id }, /*section*/ ctx[0].tag];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*section*/ 1)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*section*/ ctx[0].id }, get_spread_object(/*section*/ ctx[0].tag)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (29:2) {#if section.indicator }
	function create_if_block_3$4(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*section*/ ctx[0].id }, /*section*/ ctx[0].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*section*/ 1)
				? get_spread_update(uiindicator_spread_levels, [
						{ id: /*section*/ ctx[0].id },
						get_spread_object(/*section*/ ctx[0].indicator)
					])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (35:0) {#if sectionItems.length }
	function create_if_block$9(ctx) {
		let uisidemenuitems;
		let current;

		uisidemenuitems = new Ui_items({
				props: {
					root: /*root*/ ctx[1],
					items: /*sectionItems*/ ctx[2]
				}
			});

		uisidemenuitems.$on("navigate", /*navigate_handler*/ ctx[5]);

		return {
			c() {
				create_component(uisidemenuitems.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenuitems, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uisidemenuitems_changes = {};
				if (dirty & /*root*/ 2) uisidemenuitems_changes.root = /*root*/ ctx[1];
				if (dirty & /*sectionItems*/ 4) uisidemenuitems_changes.items = /*sectionItems*/ ctx[2];
				uisidemenuitems.$set(uisidemenuitems_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenuitems.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenuitems.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenuitems, detaching);
			}
		};
	}

	function create_fragment$d(ctx) {
		let t;
		let if_block1_anchor;
		let current;
		let if_block0 = /*section*/ ctx[0] && create_if_block_1$8(ctx);
		let if_block1 = /*sectionItems*/ ctx[2].length && create_if_block$9(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*section*/ ctx[0]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*section*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$8(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*sectionItems*/ ctx[2].length) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*sectionItems*/ 4) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$9(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	function instance$d($$self, $$props, $$invalidate) {
		let sectionItems;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { section } = $$props;
		let { items = [] } = $$props;
		let { root = '' } = $$props;

		function navigate_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('section' in $$props) $$invalidate(0, section = $$props.section);
			if ('items' in $$props) $$invalidate(4, items = $$props.items);
			if ('root' in $$props) $$invalidate(1, root = $$props.root);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*items, section*/ 17) {
				$$invalidate(2, sectionItems = items.filter(item => section.id === item.section));
			}
		};

		return [section, root, sectionItems, $LOCALE, items, navigate_handler];
	}

	let Ui_section$1 = class Ui_section extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$d, create_fragment$d, safe_not_equal, { section: 0, items: 4, root: 1 });
		}
	};

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.side.menu.svelte generated by Svelte v4.2.19 */

	function get_each_context$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	// (16:0) {#each sections as section}
	function create_each_block$3(ctx) {
		let uisidemenusection;
		let current;

		uisidemenusection = new Ui_section$1({
				props: {
					section: /*section*/ ctx[5],
					items: /*items*/ ctx[1],
					root: /*root*/ ctx[0]
				}
			});

		uisidemenusection.$on("navigate", /*onClick*/ ctx[3]);

		return {
			c() {
				create_component(uisidemenusection.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenusection, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uisidemenusection_changes = {};
				if (dirty & /*sections*/ 4) uisidemenusection_changes.section = /*section*/ ctx[5];
				if (dirty & /*items*/ 2) uisidemenusection_changes.items = /*items*/ ctx[1];
				if (dirty & /*root*/ 1) uisidemenusection_changes.root = /*root*/ ctx[0];
				uisidemenusection.$set(uisidemenusection_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenusection.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenusection.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenusection, detaching);
			}
		};
	}

	function create_fragment$c(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*sections*/ ctx[2]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*sections, items, root, onClick*/ 15) {
					each_value = ensure_array_like(/*sections*/ ctx[2]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$3(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$3(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$c($$self, $$props, $$invalidate) {
		let { root = '' } = $$props;
		let { items = [] } = $$props;
		let { sections = [] } = $$props;
		let { navigate = null } = $$props;

		function onClick(ev) {
			if (typeof navigate === 'function') {
				navigate(ev.detail);
			}
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('items' in $$props) $$invalidate(1, items = $$props.items);
			if ('sections' in $$props) $$invalidate(2, sections = $$props.sections);
			if ('navigate' in $$props) $$invalidate(4, navigate = $$props.navigate);
		};

		return [root, items, sections, onClick, navigate];
	}

	class Ui_side_menu extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$c, create_fragment$c, safe_not_equal, {
				root: 0,
				items: 1,
				sections: 2,
				navigate: 4
			});
		}
	}

	const TYPE$1 = "side";

	let notSideMenu$1 = class notSideMenu extends Menu {
	    static nav;
	    static main;
	    static aside;

	    static DEFAULT = {
	        section: "any",
	        sectionTitle: "Меню",
	        priority: 0,
	        open: true,
	    };

	    static options = {
	        type: TYPE$1,
	        items: [],
	        sections: [],
	        targetSelector: `#${TYPE$1}-menu`,
	        toggleSelector: `.${TYPE$1}-menu-toggle`,
	        root: "/",
	        open: true,
	        navigate: (urls) => {
	            if (this.isTouch()) {
	                this.hide();
	                this.app.emit("top-navbar-burger:update", { closed: true });
	            }
	            if (!this.isDirectNavigation() && this.app) {
	                let func = this.app.getWorking("router");
	                if (func) {
	                    return func.navigate(urls.short);
	                }
	            }
	            document.location.assign(urls.full);
	        },
	    };

	    static render(app) {
	        if (app) {
	            this.setApp(app);
	        }
	        this.prepareData();
	        if (!this.menu) {
	            this.createUI();
	        }
	    }

	    static update() {
	        if (this.menu) {
	            this.menu.$destroy();
	            this.createUI();
	        }
	    }

	    static createUI() {
	        let target = document.querySelector(this.getOptions().targetSelector);
	        if (!target) {
	            return;
	        }
	        this.menu = new Ui_side_menu({
	            target,
	            props: {
	                items: this.items,
	                sections: this.sections,
	                root: this.getOptions().root,
	                navigate: this.getOptions().navigate,
	            },
	        });
	        this.initSizeResponse();

	        this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	        this.bindToggle();
	    }

	    static itemIsActive(itemURL) {
	        return (this.location + "/").indexOf(itemURL + "/") > -1;
	    }

	    static updateMenu() {
	        Array.from(
	            document.querySelectorAll(this.getOptions().targetSelector + " a")
	        ).forEach((item) => {
	            if (this.itemIsActive(item.getAttribute("href"))) {
	                item.classList.add("is-active");
	            } else {
	                item.classList.remove("is-active");
	            }
	        });
	    }

	    static updateMenuActiveItem() {
	        let url = window.location.toString(),
	            lastLocation = this.location;
	        if (lastLocation) {
	            if (url !== lastLocation) {
	                this.location = url;
	                this.updateMenu();
	            }
	        } else {
	            this.location = url;
	            this.updateMenu();
	        }
	    }

	    static initSizeResponse() {
	        this.nav = document.querySelector("nav.navbar");
	        this.aside = document.querySelector("aside");
	        this.main = document.querySelector("main");
	        this.resizeAsideAndMain(this.aside, this.main, this.nav);
	        this.resizeMain(this.main, this.aside);
	        window.addEventListener("resize", this.resizeMain.bind(this));
	        if (this.isTouch()) {
	            if (this.getOptions().open) {
	                this.show();
	            } else {
	                this.hide();
	            }
	        }
	    }

	    static resizeMain() {
	        if (this.isTouch()) {
	            if (this.aside.classList.contains("is-active")) {
	                this.main.style.display = "none";
	            } else {
	                this.main.style.display = "block";
	                this.main.style.marginLeft = "0px";
	            }
	        } else {
	            let rect = this.aside.getBoundingClientRect();
	            this.main.style.display = "block";
	            if (this.main.style.height === "0px") {
	                this.main.style.height = "auto";
	            }
	            this.main.style.marginLeft = rect.width + rect.left + "px";
	        }
	    }

	    static resizeAside() {
	        if (this.aside.style.display !== "none") {
	            let rect = this.nav.getBoundingClientRect();
	            this.aside.style.height = window.innerHeight - rect.height + "px";
	            this.aside.style.marginTop = rect.height + "px";
	        }
	    }

	    static resizeAsideAndMain() {
	        let rect = this.nav.getBoundingClientRect();
	        this.aside.style.height = window.innerHeight - rect.height + "px";
	        //this.aside.style.paddingTop = (rect.height) + 'px';
	        //this.main.style.marginTop = (rect.height) + 'px';
	    }

	    static bindToggle() {
	        let els = document.querySelectorAll(this.getOptions().toggleSelector);
	        Array.from(els).forEach((el) => {
	            el.removeEventListener("click", this.toggle.bind(this));
	            el.addEventListener("click", this.toggle.bind(this));
	        });
	    }

	    static toggle(e) {
	        e && e.preventDefault();
	        if (this.aside) {
	            if (this.isTouch()) {
	                this.aside.classList.toggle("is-active");
	            } else {
	                this.aside.classList.toggle("is-closed");
	            }
	            this.resizeMain();
	        }
	        return false;
	    }

	    static hide(e) {
	        e && e.preventDefault();
	        if (this.aside) {
	            if (this.isTouch()) {
	                this.aside.classList.remove("is-active");
	            } else {
	                this.aside.classList.add("is-closed");
	            }
	            this.resizeMain();
	        }
	        return false;
	    }

	    static show(e) {
	        e && e.preventDefault();
	        if (this.aside) {
	            if (this.isTouch()) {
	                this.aside.classList.add("is-active");
	            } else {
	                this.aside.classList.remove("is-closed");
	            }
	            this.resizeMain();
	        }
	        return false;
	    }

	    static isOpen() {
	        if (this.aside) {
	            if (this.isTouch()) {
	                return this.aside.classList.contains("is-active");
	            } else {
	                return !this.aside.classList.contains("is-closed");
	            }
	        } else {
	            return true;
	        }
	    }
	};

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.brand.svelte generated by Svelte v4.2.19 */

	function create_if_block$8(ctx) {
		let html_tag;
		let raw_value = `<span class="navbar-item-brand-title">${/*title*/ ctx[1]}</span>` + "";
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(raw_value, target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*title*/ 2 && raw_value !== (raw_value = `<span class="navbar-item-brand-title">${/*title*/ ctx[1]}</span>` + "")) html_tag.p(raw_value);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	function create_fragment$b(ctx) {
		let a;
		let uiicon;
		let t;
		let current;
		const uiicon_spread_levels = [/*icon*/ ctx[2]];
		let uiicon_props = {};

		for (let i = 0; i < uiicon_spread_levels.length; i += 1) {
			uiicon_props = assign(uiicon_props, uiicon_spread_levels[i]);
		}

		uiicon = new Ui_icon({ props: uiicon_props });
		let if_block = /*title*/ ctx[1] && create_if_block$8(ctx);

		return {
			c() {
				a = element("a");
				create_component(uiicon.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				attr(a, "class", "navbar-item");
				attr(a, "href", /*url*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				mount_component(uiicon, a, null);
				append(a, t);
				if (if_block) if_block.m(a, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uiicon_changes = (dirty & /*icon*/ 4)
				? get_spread_update(uiicon_spread_levels, [get_spread_object(/*icon*/ ctx[2])])
				: {};

				uiicon.$set(uiicon_changes);

				if (/*title*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$8(ctx);
						if_block.c();
						if_block.m(a, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (!current || dirty & /*url*/ 1) {
					attr(a, "href", /*url*/ ctx[0]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiicon.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiicon.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				destroy_component(uiicon);
				if (if_block) if_block.d();
			}
		};
	}

	function instance$b($$self, $$props, $$invalidate) {
		let { url = "/" } = $$props;
		let { title = "" } = $$props;

		let { icon = {
			src: "https://via.placeholder.com/56x28",
			width: 28,
			height: 56
		} } = $$props;

		$$self.$$set = $$props => {
			if ('url' in $$props) $$invalidate(0, url = $$props.url);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		};

		return [url, title, icon];
	}

	class Ui_brand extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$b, create_fragment$b, safe_not_equal, { url: 0, title: 1, icon: 2 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.item.content.svelte generated by Svelte v4.2.19 */

	function create_else_block$5(ctx) {
		let t_value = /*$LOCALE*/ ctx[1][/*item*/ ctx[0].title] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, item*/ 3 && t_value !== (t_value = /*$LOCALE*/ ctx[1][/*item*/ ctx[0].title] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (24:94) 
	function create_if_block_3$3(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].props];
		var switch_value = COMPONENTS$2.get(/*item*/ ctx[0].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*item*/ 1) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].props)]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*item*/ 1 && switch_value !== (switch_value = COMPONENTS$2.get(/*item*/ ctx[0].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*item*/ 1)
					? get_spread_update(switch_instance_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].props)])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (22:0) {#if item.icon}
	function create_if_block_2$5(ctx) {
		let uiicon;
		let current;
		const uiicon_spread_levels = [/*item*/ ctx[0].icon];
		let uiicon_props = {};

		for (let i = 0; i < uiicon_spread_levels.length; i += 1) {
			uiicon_props = assign(uiicon_props, uiicon_spread_levels[i]);
		}

		uiicon = new Ui_icon({ props: uiicon_props });

		return {
			c() {
				create_component(uiicon.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiicon, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiicon_changes = (dirty & /*item*/ 1)
				? get_spread_update(uiicon_spread_levels, [get_spread_object(/*item*/ ctx[0].icon)])
				: {};

				uiicon.$set(uiicon_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiicon.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiicon.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiicon, detaching);
			}
		};
	}

	// (34:0) {#if item.tag }
	function create_if_block_1$7(ctx) {
		let uitag;
		let current;

		const uitag_spread_levels = [
			{ top: true },
			{ right: true },
			{ size: "small" },
			{ id: /*item*/ ctx[0].id },
			/*item*/ ctx[0].tag
		];

		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitag_changes = (dirty & /*item*/ 1)
				? get_spread_update(uitag_spread_levels, [
						uitag_spread_levels[0],
						uitag_spread_levels[1],
						uitag_spread_levels[2],
						{ id: /*item*/ ctx[0].id },
						get_spread_object(/*item*/ ctx[0].tag)
					])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	// (38:0) {#if item.indicator }
	function create_if_block$7(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 1)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].indicator)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	function create_fragment$a(ctx) {
		let show_if;
		let current_block_type_index;
		let if_block0;
		let t0;
		let t1;
		let if_block2_anchor;
		let current;
		const if_block_creators = [create_if_block_2$5, create_if_block_3$3, create_else_block$5];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (dirty & /*item*/ 1) show_if = null;
			if (/*item*/ ctx[0].icon) return 0;
			if (show_if == null) show_if = !!(/*item*/ ctx[0].type === 'component' && /*item*/ ctx[0].component && COMPONENTS$2.contains(/*item*/ ctx[0].component));
			if (show_if) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx, -1);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*item*/ ctx[0].tag && create_if_block_1$7(ctx);
		let if_block2 = /*item*/ ctx[0].indicator && create_if_block$7(ctx);

		return {
			c() {
				if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}

				if (/*item*/ ctx[0].tag) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*item*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$7(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*item*/ ctx[0].indicator) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*item*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block$7(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(if_block2_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
			}
		};
	}

	function instance$a($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(1, $LOCALE = $$value));
		let { item } = $$props;

		$$self.$$set = $$props => {
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
		};

		return [item, $LOCALE];
	}

	class Ui_item_content extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$a, create_fragment$a, safe_not_equal, { item: 0 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.item.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$6(ctx) {
		let hr;
		let hr_class_value;

		return {
			c() {
				hr = element("hr");

				attr(hr, "class", hr_class_value = "navbar-divider " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + "");
			},
			m(target, anchor) {
				insert(target, hr, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*hidden*/ 4 && hr_class_value !== (hr_class_value = "navbar-divider " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + "")) {
					attr(hr, "class", hr_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(hr);
				}
			}
		};
	}

	// (31:0) {:else}
	function create_else_block$4(ctx) {
		let div;
		let uiitemcontent;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*item*/ ctx[1] } });

		return {
			c() {
				div = element("div");
				create_component(uiitemcontent.$$.fragment);

				attr(div, "class", div_class_value = "navbar-item " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + " " + /*item*/ ctx[1].classes + " " + /*classes*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uiitemcontent, div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*onClick*/ ctx[4]),
						listen(div, "keyup", /*onClick*/ ctx[4])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*item*/ 2) uiitemcontent_changes.item = /*item*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*hidden, item, classes*/ 14 && div_class_value !== (div_class_value = "navbar-item " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + " " + /*item*/ ctx[1].classes + " " + /*classes*/ ctx[3])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uiitemcontent);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (20:0) {#if item.url}
	function create_if_block$6(ctx) {
		let a;
		let uiitemcontent;
		let a_class_value;
		let a_href_value;
		let a_data_href_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*item*/ ctx[1] } });

		return {
			c() {
				a = element("a");
				create_component(uiitemcontent.$$.fragment);

				attr(a, "class", a_class_value = "navbar-item " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + " " + /*item*/ ctx[1].classes + " " + /*classes*/ ctx[3] + "");

				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[1].url));
				attr(a, "data-href", a_data_href_value = /*item*/ ctx[1].url);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				mount_component(uiitemcontent, a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[4]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*item*/ 2) uiitemcontent_changes.item = /*item*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*hidden, item, classes*/ 14 && a_class_value !== (a_class_value = "navbar-item " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + " " + /*item*/ ctx[1].classes + " " + /*classes*/ ctx[3] + "")) {
					attr(a, "class", a_class_value);
				}

				if (!current || dirty & /*root, item*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[1].url))) {
					attr(a, "href", a_href_value);
				}

				if (!current || dirty & /*item*/ 2 && a_data_href_value !== (a_data_href_value = /*item*/ ctx[1].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				destroy_component(uiitemcontent);
				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$9(ctx) {
		let t;
		let current_block_type_index;
		let if_block1;
		let if_block1_anchor;
		let current;
		let if_block0 = /*item*/ ctx[1].break && create_if_block_1$6(ctx);
		const if_block_creators = [create_if_block$6, create_else_block$4];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*item*/ ctx[1].url) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*item*/ ctx[1].break) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$6(ctx);
						if_block0.c();
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$9($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { root = "" } = $$props;
		let { item = {} } = $$props;
		let { hidden = "" } = $$props;
		let { classes = "" } = $$props;

		function onClick(event) {
			dispatch("click", { event, element: item });
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('item' in $$props) $$invalidate(1, item = $$props.item);
			if ('hidden' in $$props) $$invalidate(2, hidden = $$props.hidden);
			if ('classes' in $$props) $$invalidate(3, classes = $$props.classes);
		};

		return [root, item, hidden, classes, onClick];
	}

	class Ui_item extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$9, create_fragment$9, safe_not_equal, { root: 0, item: 1, hidden: 2, classes: 3 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.section.svelte generated by Svelte v4.2.19 */

	function get_each_context$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[10] = list[i];
		return child_ctx;
	}

	// (49:0) {:else}
	function create_else_block$3(ctx) {
		let div;
		let uiitemcontent;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*section*/ ctx[1] } });

		return {
			c() {
				div = element("div");
				create_component(uiitemcontent.$$.fragment);

				attr(div, "class", div_class_value = "navbar-item " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uiitemcontent, div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*onClick*/ ctx[7]),
						listen(div, "keyup", /*onClick*/ ctx[7])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*section*/ 2) uiitemcontent_changes.item = /*section*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*hidden*/ 8 && div_class_value !== (div_class_value = "navbar-item " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "")) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uiitemcontent);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (40:22) 
	function create_if_block_1$5(ctx) {
		let a;
		let uiitemcontent;
		let a_class_value;
		let a_href_value;
		let a_data_href_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*section*/ ctx[1] } });

		return {
			c() {
				a = element("a");
				create_component(uiitemcontent.$$.fragment);

				attr(a, "class", a_class_value = "navbar-item " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "");

				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*section*/ ctx[1].url));
				attr(a, "data-href", a_data_href_value = /*section*/ ctx[1].url);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				mount_component(uiitemcontent, a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[7]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*section*/ 2) uiitemcontent_changes.item = /*section*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*hidden*/ 8 && a_class_value !== (a_class_value = "navbar-item " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "")) {
					attr(a, "class", a_class_value);
				}

				if (!current || dirty & /*root, section*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*section*/ ctx[1].url))) {
					attr(a, "href", a_href_value);
				}

				if (!current || dirty & /*section*/ 2 && a_data_href_value !== (a_data_href_value = /*section*/ ctx[1].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				destroy_component(uiitemcontent);
				mounted = false;
				dispose();
			}
		};
	}

	// (21:0) {#if items.length}
	function create_if_block$5(ctx) {
		let div1;
		let a;
		let uiitemcontent;
		let a_class_value;
		let t;
		let div0;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div0_class_value;
		let div1_class_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*section*/ ctx[1] } });
		let each_value = ensure_array_like(/*items*/ ctx[2]);
		const get_key = ctx => /*item*/ ctx[10].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$2(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
		}

		return {
			c() {
				div1 = element("div");
				a = element("a");
				create_component(uiitemcontent.$$.fragment);
				t = space();
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(a, "href", "");
				attr(a, "class", a_class_value = "navbar-link " + (/*arrowless*/ ctx[5] ? 'is-arrowless' : ''));
				attr(div0, "class", div0_class_value = "navbar-dropdown " + (/*right*/ ctx[6] ? 'is-right' : ''));

				attr(div1, "class", div1_class_value = "navbar-item has-dropdown " + (/*hoverable*/ ctx[4] ? 'is-hoverable' : '') + " " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, a);
				mount_component(uiitemcontent, a, null);
				append(div1, t);
				append(div1, div0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[7]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*section*/ 2) uiitemcontent_changes.item = /*section*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*arrowless*/ 32 && a_class_value !== (a_class_value = "navbar-link " + (/*arrowless*/ ctx[5] ? 'is-arrowless' : ''))) {
					attr(a, "class", a_class_value);
				}

				if (dirty & /*root, items*/ 5) {
					each_value = ensure_array_like(/*items*/ ctx[2]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
					check_outros();
				}

				if (!current || dirty & /*right*/ 64 && div0_class_value !== (div0_class_value = "navbar-dropdown " + (/*right*/ ctx[6] ? 'is-right' : ''))) {
					attr(div0, "class", div0_class_value);
				}

				if (!current || dirty & /*hoverable, hidden*/ 24 && div1_class_value !== (div1_class_value = "navbar-item has-dropdown " + (/*hoverable*/ ctx[4] ? 'is-hoverable' : '') + " " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "")) {
					attr(div1, "class", div1_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				destroy_component(uiitemcontent);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (35:12) {#each items as item (item.id)}
	function create_each_block$2(key_1, ctx) {
		let first;
		let uiitem;
		let current;

		uiitem = new Ui_item({
				props: {
					root: /*root*/ ctx[0],
					item: /*item*/ ctx[10]
				}
			});

		uiitem.$on("click", /*click_handler*/ ctx[8]);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uiitem.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uiitem, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const uiitem_changes = {};
				if (dirty & /*root*/ 1) uiitem_changes.root = /*root*/ ctx[0];
				if (dirty & /*items*/ 4) uiitem_changes.item = /*item*/ ctx[10];
				uiitem.$set(uiitem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiitem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uiitem, detaching);
			}
		};
	}

	function create_fragment$8(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$5, create_if_block_1$5, create_else_block$3];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*items*/ ctx[2].length) return 0;
			if (/*section*/ ctx[1].url) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$8($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { root = "" } = $$props;
		let { section = {} } = $$props;
		let { items = [] } = $$props;
		let { hidden = "" } = $$props;
		let { hoverable = true } = $$props;
		let { arrowless = false } = $$props;
		let { right = false } = $$props;

		function onClick(event) {
			dispatch("click", { event, element: section });
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('section' in $$props) $$invalidate(1, section = $$props.section);
			if ('items' in $$props) $$invalidate(2, items = $$props.items);
			if ('hidden' in $$props) $$invalidate(3, hidden = $$props.hidden);
			if ('hoverable' in $$props) $$invalidate(4, hoverable = $$props.hoverable);
			if ('arrowless' in $$props) $$invalidate(5, arrowless = $$props.arrowless);
			if ('right' in $$props) $$invalidate(6, right = $$props.right);
		};

		return [
			root,
			section,
			items,
			hidden,
			hoverable,
			arrowless,
			right,
			onClick,
			click_handler
		];
	}

	class Ui_section extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$8, create_fragment$8, safe_not_equal, {
				root: 0,
				section: 1,
				items: 2,
				hidden: 3,
				hoverable: 4,
				arrowless: 5,
				right: 6
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.burger.svelte generated by Svelte v4.2.19 */

	function create_fragment$7(ctx) {
		let a;
		let span0;
		let t0;
		let span1;
		let t1;
		let span2;
		let a_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				a = element("a");
				span0 = element("span");
				t0 = space();
				span1 = element("span");
				t1 = space();
				span2 = element("span");
				attr(span0, "aria-hidden", "true");
				attr(span1, "aria-hidden", "true");
				attr(span2, "aria-hidden", "true");
				attr(a, "href", "");
				attr(a, "role", "button");
				attr(a, "class", a_class_value = "navbar-burger " + (/*closed*/ ctx[0] ? '' : 'is-active'));
				attr(a, "aria-label", "menu");
				attr(a, "aria-expanded", "false");
				attr(a, "data-target", "navbar");
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, span0);
				append(a, t0);
				append(a, span1);
				append(a, t1);
				append(a, span2);

				if (!mounted) {
					dispose = listen(a, "click", /*toggle*/ ctx[1]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*closed*/ 1 && a_class_value !== (a_class_value = "navbar-burger " + (/*closed*/ ctx[0] ? '' : 'is-active'))) {
					attr(a, "class", a_class_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				mounted = false;
				dispose();
			}
		};
	}

	const COMPONENT_NAME = "top-navbar-burger";

	function getStandartUpdateEventName() {
		return COMPONENT_NAME + ":update";
	}

	function instance$7($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { events = {} } = $$props;
		let { register = notCommon$2.registerWidgetEvents.bind(notCommon$2) } = $$props;
		let { closed = true } = $$props;

		function toggle(e) {
			e.preventDefault();
			$$invalidate(0, closed = !closed);
			dispatch("toggle", { closed });
			return false;
		}

		let { onUpdate = data => {
			$$invalidate(0, closed = data.closed);
		} } = $$props;

		onMount(() => {
			if (!notCommon$2.objHas(events, getStandartUpdateEventName())) {
				$$invalidate(2, events[getStandartUpdateEventName()] = onUpdate, events);
			}

			register(events);
		});

		$$self.$$set = $$props => {
			if ('events' in $$props) $$invalidate(2, events = $$props.events);
			if ('register' in $$props) $$invalidate(3, register = $$props.register);
			if ('closed' in $$props) $$invalidate(0, closed = $$props.closed);
			if ('onUpdate' in $$props) $$invalidate(4, onUpdate = $$props.onUpdate);
		};

		return [closed, toggle, events, register, onUpdate];
	}

	class Ui_burger extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$7, create_fragment$7, safe_not_equal, {
				events: 2,
				register: 3,
				closed: 0,
				onUpdate: 4
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.top.svelte generated by Svelte v4.2.19 */

	function get_each_context$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[13] = list[i];
		return child_ctx;
	}

	function get_each_context_1$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[16] = list[i];
		return child_ctx;
	}

	function get_each_context_2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[16] = list[i];
		return child_ctx;
	}

	function get_each_context_3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[13] = list[i];
		return child_ctx;
	}

	// (63:4) {#if brand}
	function create_if_block_5(ctx) {
		let uibrand;
		let current;
		const uibrand_spread_levels = [/*brand*/ ctx[3]];
		let uibrand_props = {};

		for (let i = 0; i < uibrand_spread_levels.length; i += 1) {
			uibrand_props = assign(uibrand_props, uibrand_spread_levels[i]);
		}

		uibrand = new Ui_brand({ props: uibrand_props });

		return {
			c() {
				create_component(uibrand.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibrand, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibrand_changes = (dirty & /*brand*/ 8)
				? get_spread_update(uibrand_spread_levels, [get_spread_object(/*brand*/ ctx[3])])
				: {};

				uibrand.$set(uibrand_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibrand.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibrand.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibrand, detaching);
			}
		};
	}

	// (67:8) {#if section.showOnTouch}
	function create_if_block_4$1(ctx) {
		let uinavbaritem;
		let current;

		uinavbaritem = new Ui_item({
				props: {
					hidden: "desktop",
					item: /*section*/ ctx[13],
					root: /*root*/ ctx[2]
				}
			});

		uinavbaritem.$on("click", /*onClick*/ ctx[8]);

		return {
			c() {
				create_component(uinavbaritem.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbaritem, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinavbaritem_changes = {};
				if (dirty & /*sections*/ 1) uinavbaritem_changes.item = /*section*/ ctx[13];
				if (dirty & /*root*/ 4) uinavbaritem_changes.root = /*root*/ ctx[2];
				uinavbaritem.$set(uinavbaritem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinavbaritem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbaritem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbaritem, detaching);
			}
		};
	}

	// (66:4) {#each sections as section (section.id)}
	function create_each_block_3(key_1, ctx) {
		let first;
		let if_block_anchor;
		let current;
		let if_block = /*section*/ ctx[13].showOnTouch && create_if_block_4$1(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (/*section*/ ctx[13].showOnTouch) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*sections*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_4$1(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (77:8) {#if item.showOnTouch}
	function create_if_block_3$2(ctx) {
		let uinavbaritem;
		let current;

		uinavbaritem = new Ui_item({
				props: {
					hidden: "desktop",
					item: /*item*/ ctx[16],
					root: /*root*/ ctx[2]
				}
			});

		uinavbaritem.$on("click", /*onClick*/ ctx[8]);

		return {
			c() {
				create_component(uinavbaritem.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbaritem, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinavbaritem_changes = {};
				if (dirty & /*items*/ 2) uinavbaritem_changes.item = /*item*/ ctx[16];
				if (dirty & /*root*/ 4) uinavbaritem_changes.root = /*root*/ ctx[2];
				uinavbaritem.$set(uinavbaritem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinavbaritem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbaritem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbaritem, detaching);
			}
		};
	}

	// (76:4) {#each items as item (item.id)}
	function create_each_block_2(key_1, ctx) {
		let first;
		let if_block_anchor;
		let current;
		let if_block = /*item*/ ctx[16].showOnTouch && create_if_block_3$2(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (/*item*/ ctx[16].showOnTouch) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*items*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$2(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (81:4) {#if showBurger}
	function create_if_block_2$4(ctx) {
		let uinavbarburger;
		let current;
		uinavbarburger = new Ui_burger({});
		uinavbarburger.$on("toggle", /*toggleBurger*/ ctx[9]);

		return {
			c() {
				create_component(uinavbarburger.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbarburger, target, anchor);
				current = true;
			},
			p: noop$1,
			i(local) {
				if (current) return;
				transition_in(uinavbarburger.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbarburger.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbarburger, detaching);
			}
		};
	}

	// (88:12) {#if item.place === "start"}
	function create_if_block_1$4(ctx) {
		let uinavbaritem;
		let current;

		uinavbaritem = new Ui_item({
				props: { hidden: "touch", item: /*item*/ ctx[16] }
			});

		uinavbaritem.$on("click", /*onClick*/ ctx[8]);

		return {
			c() {
				create_component(uinavbaritem.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbaritem, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinavbaritem_changes = {};
				if (dirty & /*items*/ 2) uinavbaritem_changes.item = /*item*/ ctx[16];
				uinavbaritem.$set(uinavbaritem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinavbaritem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbaritem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbaritem, detaching);
			}
		};
	}

	// (87:8) {#each items as item}
	function create_each_block_1$1(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*item*/ ctx[16].place === "start" && create_if_block_1$4(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*item*/ ctx[16].place === "start") {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*items*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_1$4(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (95:12) {#if (sectionsItemsCount[section.id] || section.indicator || section.tag) && section.place == "end"}
	function create_if_block$4(ctx) {
		let uinavbarsection;
		let current;

		uinavbarsection = new Ui_section({
				props: {
					right: true,
					hidden: /*section*/ ctx[13].hidden,
					root: /*root*/ ctx[2],
					section: /*section*/ ctx[13],
					items: /*sectionsItems*/ ctx[7][/*section*/ ctx[13].id]
				}
			});

		uinavbarsection.$on("click", /*onClick*/ ctx[8]);

		return {
			c() {
				create_component(uinavbarsection.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbarsection, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinavbarsection_changes = {};
				if (dirty & /*sections*/ 1) uinavbarsection_changes.hidden = /*section*/ ctx[13].hidden;
				if (dirty & /*root*/ 4) uinavbarsection_changes.root = /*root*/ ctx[2];
				if (dirty & /*sections*/ 1) uinavbarsection_changes.section = /*section*/ ctx[13];
				if (dirty & /*sectionsItems, sections*/ 129) uinavbarsection_changes.items = /*sectionsItems*/ ctx[7][/*section*/ ctx[13].id];
				uinavbarsection.$set(uinavbarsection_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinavbarsection.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbarsection.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbarsection, detaching);
			}
		};
	}

	// (94:8) {#each sections as section (section.id)}
	function create_each_block$1(key_1, ctx) {
		let first;
		let if_block_anchor;
		let current;
		let if_block = (/*sectionsItemsCount*/ ctx[6][/*section*/ ctx[13].id] || /*section*/ ctx[13].indicator || /*section*/ ctx[13].tag) && /*section*/ ctx[13].place == "end" && create_if_block$4(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if ((/*sectionsItemsCount*/ ctx[6][/*section*/ ctx[13].id] || /*section*/ ctx[13].indicator || /*section*/ ctx[13].tag) && /*section*/ ctx[13].place == "end") {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*sectionsItemsCount, sections*/ 65) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$4(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function create_fragment$6(ctx) {
		let div0;
		let t0;
		let each_blocks_3 = [];
		let each0_lookup = new Map();
		let t1;
		let each_blocks_2 = [];
		let each1_lookup = new Map();
		let t2;
		let t3;
		let div3;
		let div1;
		let t4;
		let div2;
		let each_blocks = [];
		let each3_lookup = new Map();
		let div3_class_value;
		let current;
		let if_block0 = /*brand*/ ctx[3] && create_if_block_5(ctx);
		let each_value_3 = ensure_array_like(/*sections*/ ctx[0]);
		const get_key = ctx => /*section*/ ctx[13].id;

		for (let i = 0; i < each_value_3.length; i += 1) {
			let child_ctx = get_each_context_3(ctx, each_value_3, i);
			let key = get_key(child_ctx);
			each0_lookup.set(key, each_blocks_3[i] = create_each_block_3(key, child_ctx));
		}

		let each_value_2 = ensure_array_like(/*items*/ ctx[1]);
		const get_key_1 = ctx => /*item*/ ctx[16].id;

		for (let i = 0; i < each_value_2.length; i += 1) {
			let child_ctx = get_each_context_2(ctx, each_value_2, i);
			let key = get_key_1(child_ctx);
			each1_lookup.set(key, each_blocks_2[i] = create_each_block_2(key, child_ctx));
		}

		let if_block1 = /*showBurger*/ ctx[4] && create_if_block_2$4(ctx);
		let each_value_1 = ensure_array_like(/*items*/ ctx[1]);
		let each_blocks_1 = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
			each_blocks_1[i] = null;
		});

		let each_value = ensure_array_like(/*sections*/ ctx[0]);
		const get_key_2 = ctx => /*section*/ ctx[13].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$1(ctx, each_value, i);
			let key = get_key_2(child_ctx);
			each3_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
		}

		return {
			c() {
				div0 = element("div");
				if (if_block0) if_block0.c();
				t0 = space();

				for (let i = 0; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].c();
				}

				t1 = space();

				for (let i = 0; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].c();
				}

				t2 = space();
				if (if_block1) if_block1.c();
				t3 = space();
				div3 = element("div");
				div1 = element("div");

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].c();
				}

				t4 = space();
				div2 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div0, "class", "navbar-brand");
				attr(div1, "class", "navbar-start");
				attr(div2, "class", "navbar-end");
				attr(div3, "id", "navbar");
				attr(div3, "class", div3_class_value = "navbar-menu " + (/*menuClosed*/ ctx[5] ? '' : 'is-active'));
			},
			m(target, anchor) {
				insert(target, div0, anchor);
				if (if_block0) if_block0.m(div0, null);
				append(div0, t0);

				for (let i = 0; i < each_blocks_3.length; i += 1) {
					if (each_blocks_3[i]) {
						each_blocks_3[i].m(div0, null);
					}
				}

				append(div0, t1);

				for (let i = 0; i < each_blocks_2.length; i += 1) {
					if (each_blocks_2[i]) {
						each_blocks_2[i].m(div0, null);
					}
				}

				append(div0, t2);
				if (if_block1) if_block1.m(div0, null);
				insert(target, t3, anchor);
				insert(target, div3, anchor);
				append(div3, div1);

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					if (each_blocks_1[i]) {
						each_blocks_1[i].m(div1, null);
					}
				}

				append(div3, t4);
				append(div3, div2);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div2, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (/*brand*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*brand*/ 8) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_5(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div0, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (dirty & /*sections, root, onClick*/ 261) {
					each_value_3 = ensure_array_like(/*sections*/ ctx[0]);
					group_outros();
					each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx, each_value_3, each0_lookup, div0, outro_and_destroy_block, create_each_block_3, t1, get_each_context_3);
					check_outros();
				}

				if (dirty & /*items, root, onClick*/ 262) {
					each_value_2 = ensure_array_like(/*items*/ ctx[1]);
					group_outros();
					each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, div0, outro_and_destroy_block, create_each_block_2, t2, get_each_context_2);
					check_outros();
				}

				if (/*showBurger*/ ctx[4]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*showBurger*/ 16) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$4(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div0, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (dirty & /*items, onClick*/ 258) {
					each_value_1 = ensure_array_like(/*items*/ ctx[1]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

						if (each_blocks_1[i]) {
							each_blocks_1[i].p(child_ctx, dirty);
							transition_in(each_blocks_1[i], 1);
						} else {
							each_blocks_1[i] = create_each_block_1$1(child_ctx);
							each_blocks_1[i].c();
							transition_in(each_blocks_1[i], 1);
							each_blocks_1[i].m(div1, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (dirty & /*sections, root, sectionsItems, onClick, sectionsItemsCount*/ 453) {
					each_value = ensure_array_like(/*sections*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key_2, 1, ctx, each_value, each3_lookup, div2, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
					check_outros();
				}

				if (!current || dirty & /*menuClosed*/ 32 && div3_class_value !== (div3_class_value = "navbar-menu " + (/*menuClosed*/ ctx[5] ? '' : 'is-active'))) {
					attr(div3, "class", div3_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);

				for (let i = 0; i < each_value_3.length; i += 1) {
					transition_in(each_blocks_3[i]);
				}

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks_2[i]);
				}

				transition_in(if_block1);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks_1[i]);
				}

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(if_block0);

				for (let i = 0; i < each_blocks_3.length; i += 1) {
					transition_out(each_blocks_3[i]);
				}

				for (let i = 0; i < each_blocks_2.length; i += 1) {
					transition_out(each_blocks_2[i]);
				}

				transition_out(if_block1);
				each_blocks_1 = each_blocks_1.filter(Boolean);

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					transition_out(each_blocks_1[i]);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div0);
					detach(t3);
					detach(div3);
				}

				if (if_block0) if_block0.d();

				for (let i = 0; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].d();
				}

				for (let i = 0; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].d();
				}

				if (if_block1) if_block1.d();
				destroy_each(each_blocks_1, detaching);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	function instance$6($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { sections = [] } = $$props;
		let { items = [] } = $$props;
		let { root = "" } = $$props;
		let { navigate = null } = $$props;
		let { brand = false } = $$props;
		let { showBurger = true } = $$props;
		let { burgerControlsSidemenu = true } = $$props;
		let menuClosed = true;

		function onClick({ detail }) {
			let { event, element } = detail;

			if (Object.hasOwn(element, "action")) {
				return element.action(event, element);
			}

			event.preventDefault();

			if (typeof navigate === "function") {
				navigate({
					full: event.currentTarget.getAttribute("href"),
					short: event.currentTarget.dataset.href
				});
			}

			return false;
		}

		let sectionsItemsCount = {};
		let sectionsItems = {};

		beforeUpdate(() => {
			for (let section of sections) {
				$$invalidate(7, sectionsItems[section.id] = items.filter(t => t.section === section.id), sectionsItems);
				$$invalidate(6, sectionsItemsCount[section.id] = items.filter(t => t.section === section.id).length, sectionsItemsCount);
			}
		});

		function toggleBurger({ detail }) {
			if (burgerControlsSidemenu) {
				notSideMenu$1.toggle();
			} else {
				dispatch("toggleBurger", detail);
				$$invalidate(5, menuClosed = detail.closed);
			}
		}

		$$self.$$set = $$props => {
			if ('sections' in $$props) $$invalidate(0, sections = $$props.sections);
			if ('items' in $$props) $$invalidate(1, items = $$props.items);
			if ('root' in $$props) $$invalidate(2, root = $$props.root);
			if ('navigate' in $$props) $$invalidate(10, navigate = $$props.navigate);
			if ('brand' in $$props) $$invalidate(3, brand = $$props.brand);
			if ('showBurger' in $$props) $$invalidate(4, showBurger = $$props.showBurger);
			if ('burgerControlsSidemenu' in $$props) $$invalidate(11, burgerControlsSidemenu = $$props.burgerControlsSidemenu);
		};

		return [
			sections,
			items,
			root,
			brand,
			showBurger,
			menuClosed,
			sectionsItemsCount,
			sectionsItems,
			onClick,
			toggleBurger,
			navigate,
			burgerControlsSidemenu
		];
	}

	class Ui_top extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$6, create_fragment$6, safe_not_equal, {
				sections: 0,
				items: 1,
				root: 2,
				navigate: 10,
				brand: 3,
				showBurger: 4,
				burgerControlsSidemenu: 11
			});
		}
	}

	const TYPE = 'top';

	let notTopMenu$2 = class notTopMenu extends Menu{
	  static DEFAULT = {
	    section: 'any',
	    sectionTitle: 'Меню',
	    priority: 0,
	    //link, button, dropdown, component
	    type:       'link',
	    place:      'main'
	  };

	  static options = {
	    brand:     false,
	    type:     TYPE,
	    items:     [],
	    sections: [],
	    targetSelector: `#${TYPE}-menu`,
	    root: '/',
	    directNavigation: false,
	    navigate: (urls) => {
	      this.hide();
	      if (!(this.isDirectNavigation()) && this.app) {
	        let func = this.app.getWorking('router');
	        if (func) {
	          return func.navigate(urls.short);
	        }
	      }
	      document.location.assign(urls.full);
	    }
	  };

	  static render(app){
	    if(app){
	      this.setApp(app);
	    }
	    this.prepareData();
	    if (!this.menu) {
	      let target = document.querySelector(this.getOptions().targetSelector);
	      if (!target){return;}
	      this.menu = new Ui_top({
	        target,
	        props:{
	          brand:         this.getOptions().brand,
	          items:        this.items,
	          sections:      this.sections,
	          root:         this.getOptions().root,
	          navigate:      this.getOptions().navigate
	        }
	      });
	      this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	    }
	  }

	  static updateMenu(url){
	    Array.from(document.querySelectorAll(this.getOptions().targetSelector + ' aside.menu a')).forEach((item) => {
	      if( (item.href == url) || (url.href && url.href.indexOf(item.href) == 0)){
	        item.classList.add('is-active');
	      }else {
	        item.classList.remove('is-active');
	      }
	    });
	  }

	  static updateMenuActiveItem(){
	    let url = window.location.toString(),  lastLocation = this.location;
	    if(lastLocation){
	      if ( url !== lastLocation ){
	        this.location = url;
	        this.updateMenu(url);
	      }
	    }else {
	      this.location = url;
	      this.updateMenu(url);
	    }
	  }

	  static toggle(){
	    let el = document.querySelector(this.getOptions().targetSelector);
	    el.classList.toggle('is-active');
	  }

	  static hide(){
	    let el = document.querySelector(this.getOptions().targetSelector);
	    el.classList.remove('is-active');
	  }

	  static setBurgerState(menuClosed){
	    this.menu.$set({
	      menuClosed
	    });
	  }

	};

	const DEFAULT_TRASFORMER = (res) => {
	    return Object.hasOwn(res, "status") && Object.hasOwn(res, "result")
	        ? res.result
	        : res;
	};

	var create_crud_action_ui_view = ({ ACTION, TITLE, UIConstructor, dataProvider, goBack }) => {
	    return class {
	        static async run(controller, params) {
	            try {
	                controller.setBreadcrumbs([
	                    {
	                        title: `Просмотр "${TITLE}"`,
	                    },
	                ]);
	                await controller.preloadVariants(ACTION);
	                if (controller.ui[ACTION]) {
	                    return;
	                } else {
	                    controller.$destroyUI();
	                }
	                let data = {};
	                if (dataProvider) {
	                    if (notCommon$2.isFunc(dataProvider)) {
	                        if (notCommon$2.isAsync(dataProvider)) {
	                            data = await dataProvider(params);
	                        } else {
	                            data = dataProvider(params);
	                        }
	                    } else {
	                        data = { ...dataProvider };
	                    }
	                }
	                const resultTransformer = controller.getOptions(
	                    `${ACTION}.transformer`,
	                    DEFAULT_TRASFORMER
	                );
	                controller.ui[ACTION] = new UIConstructor({
	                    target: controller.getContainerInnerElement(),
	                    props: { params, ...resultTransformer(data) },
	                });
	                controller.emit(`after:render:${ACTION}`);
	                if (goBack && notCommon$2.isFunc(goBack)) {
	                    controller.ui[ACTION].on("reject", () => goBack());
	                }
	            } catch (e) {
	                controller.report(e);
	                controller.showErrorMessage(e);
	            }
	        }
	    };
	};

	const PRELOADABLE = ['create','update','list','delete','details'];

	class CRUDVariantsPreloader{
	  static async preload(controller, type = 'list'){
	    try{
	      if (!PRELOADABLE.includes(type)) { return; }
	      let preload = controller.getOptions(`${type}.preload`, {});
	      if(Object.keys(preload).length == 0){
	        preload = controller.getOptions(`preload`, {});
	      }
	      if(Object.keys(preload).length > 0){
	        let libProps = Object.keys(preload);
	        let proms = [];
	        libProps.forEach((prop)=>{
	          let modelName = notCommon$2.lowerFirstLetter(preload[prop]);
	          let Model = controller.make[modelName]({});
	          proms.push(Model.$listAll());
	        });
	        let results = await Promise.all(proms);
	        for(let i = 0; i < libProps.length; i++){
	          const propName = libProps[i];
	          if(Array.isArray(results[i])){
	            const variants = results[i].map(item => {
	              return {
	                id: item._id,
	                title: item.title
	              };
	            });
	            controller.getOptions(`variants.${type}.${propName}`, variants);
	          }
	        }
	      }
	      controller.log('preload finished');
	    }catch(e){
	      controller.report(e);
	      controller.showErrorMessage(e);
	    }
	  }
	}

	const DEFAULT_ACTION = "list";

	class notCRUDRouter {
	    static extractActionName(controller, params) {
	        let actionName = DEFAULT_ACTION;
	        if (params.length === 1) {
	            if (params[0] === "create") {
	                actionName = "create";
	            } else if (controller.actionHandlerExists(params[0])) {
	                actionName = params[0];
	            } else {
	                actionName = "details";
	            }
	        } else if (params.length > 1) {
	            if (params[1] === "delete") {
	                actionName = "delete";
	            } else if (params[1] === "update") {
	                actionName = "update";
	            } else {
	                actionName = params[1];
	            }
	        }
	        return actionName;
	    }

	    static route(controller, params) {
	        try {
	            const actionName = notCRUDRouter.extractActionName(
	                controller,
	                params
	            );
	            controller.setCurrentAction(actionName);
	            return controller.runAction(actionName, params);
	        } catch (e) {
	            controller.report(e);
	            controller.showErrorMessage(e);
	        }
	    }
	}

	class CRUDMessage {
	    static error(controller, title, message) {
	        controller.setUI(
	            "__message__",
	            new Ui_error({
	                target: controller.getContainerInnerElement(),
	                props: { title, message },
	            })
	        );
	    }

	    static success(controller, title, message) {
	        controller.setUI(
	            "__message__",
	            new Ui_success({
	                target: controller.getContainerInnerElement(),
	                props: { title, message },
	            })
	        );
	    }
	}

	const DEFAULT_BREADCRUMB_TAIL$2 = "Просмотр";

	/**
	 * Generic CRUD action class
	 * @class
	 */
	class CRUDGenericAction {
	    static get NAVIGATION_DELAY() {
	        return NAVIGATION_DELAY_DEFAULT;
	    }
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	    static get deafultBreadcrumbsTail() {
	        return DEFAULT_BREADCRUMB_TAIL$2;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	    static get breadcrumbsTails() {
	        return {
	            preset: DEFAULT_BREADCRUMB_TAIL$2,
	            set: 'Просмотр, "{:title}"',
	        };
	    }

	    /**
	     * Returns template of breadcrumbs tail
	     * @param   {string}    name
	     * @returns {string}    template string
	     */
	    static getBreadcrumbsTail(name) {
	        if (!this.breadcrumbsTails) {
	            return "";
	        }
	        return notCommon$2.select(
	            this.breadcrumbsTails,
	            name,
	            this.deafultBreadcrumbsTail
	        );
	    }
	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	    static get ACTION() {
	        return "details";
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_GET() {
	        return "get";
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_PUT() {
	        return "get";
	    }

	    /**
	     * @static {object} UIConstructor    constructor of UI component
	     */
	    static get UIConstructor() {
	        return notForm$5;
	    }
	    /**
	     * @static {function}   TRANSFORMER     response.result transformation function if want to change it's structure
	     */
	    static get TRANSFORMER() {
	        return DEFAULT_TRASFORMER;
	    }
	    /**
	     * Returns name of model identificaiton field
	     * @param {object} controller instance of controller
	     * @returns {string}    default id field name is '_id'
	     */
	    static getIdField(controller) {
	        return controller.getOptions(`${this.ACTION}.idField`, "_id");
	    }

	    static loadDataQuery(controller, params) {
	        const idField = this.getIdField(controller);
	        return { [idField]: params[0] };
	    }

	    /**
	     * Return Promise of API reponse
	     * @param {object} controller instance of controller
	     * @param {string[]} params     array of strings parsed from URI by router and passed to controller
	     * @returns {Promise}   API response {status:string, result:any, message:string, errors: {[fieldname]:[...errorMessages]}}
	     */
	    static async loadData(controller, params) {
	        const query = this.loadDataQuery(controller, params);
	        const actionName = this.getModelActionName(controller);
	        return await controller.getModel(query)[`$${actionName}`]();
	    }

	    /**
	     * Returns model API action name
	     * @param {object} controller instance of controller
	     * @returns {string}    network interface model action name, for API; default: this.MODEL_ACTION_GET
	     */
	    static getModelActionName(controller) {
	        return controller.getOptions(
	            `${this.ACTION}.actionName`,
	            this.MODEL_ACTION_GET
	        );
	    }

	    /**
	     * Sets breadcrumbs tail, without result details
	     * @param {object} controller instance of controller
	     * @param {string[]} params     list of route params
	     */
	    static presetBreadcrumbs(controller, params) {
	        controller.setBreadcrumbs([
	            {
	                title: this.getBreadcrumbsTail("preset"),
	                url: controller.getModelActionURL(params[0], false),
	            },
	        ]);
	    }

	    static getTitle(contoller, params, response) {
	        return contoller.getItemTitle(response.result);
	    }

	    /**
	     * Sets breadcrumbs tail with response details, aka title of loaded item
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response in wrapper
	     * @param {object} response.result  API response result
	     */
	    static setBreadcrumbs(controller, params, response) {
	        const title = this.getTitle(controller, params, response);
	        const breadcrumbsTailTemplate = this.getBreadcrumbsTail("set");
	        controller.setBreadcrumbs([
	            {
	                title: breadcrumbsTailTemplate
	                    ? notLocale$1.format(breadcrumbsTailTemplate, { title })
	                    : title,
	                url: controller.getModelActionURL(params[0], false),
	            },
	        ]);
	    }

	    /**
	     * Checks response on success
	     * @param {object} response
	     * @param {string} response.status
	     * @returns {boolean}   true if response is bad
	     */
	    static isResponseBad(response) {
	        return !response || response.status !== "ok";
	    }

	    static getValidators(controller) {
	        return (
	            (controller.getValidators && controller.getValidators()) ||
	            controller.getOptions("Validators")
	        );
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	    static prepareUIOptions(controller, response) {
	        const detailsActionName = this.getModelActionName(controller);
	        return {
	            options: {
	                target: controller.getContainerInnerElement(),
	                model: controller.getModelName(),
	                action: detailsActionName,
	                name: `${controller.getName()}.${this.ACTION}Form`,
	                fields: {
	                    readonly: true,
	                },
	                validators: this.getValidators(controller),
	                variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	                masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	                injected: controller.getOptions(`${this.ACTION}.injected`, {}),
	            },
	            data: this.TRANSFORMER(response.result),
	        };
	    }

	    /**
	     * Returns instance of this action UI component from controller
	     * @param {object} controller   instance of controller
	     * @returns {object}    instance of UI component
	     */
	    static getUI(controller) {
	        return controller.ui[this.ACTION];
	    }

	    /**
	     * Sets UI of this action in controller
	     * @param {object} controller   instance of controller
	     * @param {object} ui           instance of UI component
	     */
	    static setUI(controller, ui) {
	        controller.ui[this.ACTION] = ui;
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `true`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	    static setUILoading(controller) {
	        this.getUI(controller).$set({ loading: true });
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `false`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	    static setUILoaded(controller) {
	        this.getUI(controller).$set({ loading: false });
	    }

	    /**
	     *  Sets via `.$set` method `error` to `message`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @param   {Error} message     error message
	     * @memberof CRUDGenericAction
	     */
	    static setUIError(controller, message) {
	        this.getUI(controller).$set({ error: message });
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    static bindUIEvents(controller, params, response) {
	        if (notCommon$2.isFunc(controller.goBack)) {
	            this.bindUIEvent(controller, "reject", () => controller.goBack());
	        }
	    }

	    /**
	     * Bind event handler named event to UI. Checks different binder notation $on/on
	     * @param {object} controller   instance of controller
	     * @param {string} event        event name
	     * @param {function} callback   callback function on event
	     * @returns
	     */
	    static bindUIEvent(controller, event, callback) {
	        const ui = this.getUI(controller);
	        if (ui.$on) {
	            return ui.$on(event, callback);
	        }
	        if (ui.on) {
	            return ui.on(event, callback);
	        }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	    static isUIRendered(controller) {
	        if (this.getUI(controller)) {
	            return true;
	        } else {
	            controller.$destroyUI();
	        }
	        return false;
	    }

	    static tweakUIOptions(options) {
	        return options;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	    static async run(controller, params) {
	        try {
	            //inform that we are starting
	            controller.emit(`before:render:${this.ACTION}`, params);
	            //if UI for this action exists exiting
	            if (this.isUIRendered(controller)) {
	                return;
	            }
	            //indicating that we are working
	            controller.renderLoadingScreen && controller.renderLoadingScreen();
	            //preloading form variants
	            await controller.preloadVariants(this.ACTION);
	            //setting initial state of breadcrumbs tail
	            this.presetBreadcrumbs(controller, params);
	            //loading data
	            const response = await this.loadData(controller, params);
	            //showing error message if response is 'bad'
	            if (this.isResponseBad(response)) {
	                return controller.showErrorMessage(response);
	            }
	            //updating breadcrumbs tail with more details from response
	            this.setBreadcrumbs(controller, params, response);
	            //creating action UI component
	            const uiComponent = this.UIConstructor;
	            this.setUI(
	                controller,
	                new uiComponent(
	                    this.tweakUIOptions(
	                        this.prepareUIOptions(controller, response)
	                    )
	                )
	            );
	            //bind events to UI
	            this.bindUIEvents(controller, params, response);
	            //inform that we are ready
	            controller.emit(`after:render:${this.ACTION}`, params, response);
	        } catch (e) {
	            //informing about exception
	            controller.emit(`exception:render:${this.ACTION}`, params, e);
	            //reporting exception
	            controller.report(e);
	            //showing error message
	            controller.showErrorMessage(e);
	        }
	    }

	    static goBackAfterDelay(controller) {
	        controller.goBack(this.NAVIGATION_DELAY);
	    }

	    static goBack(controller) {
	        controller.goBack(0);
	    }
	}

	const ACTION$2 = "create";
	const DEFAULT_BREADCRUMB_TAIL$1 = "Создание";

	class CRUDGenericActionCreate extends CRUDGenericAction {
	    static get deafultBreadcrumbsTail() {
	        return DEFAULT_BREADCRUMB_TAIL$1;
	    }

	    static get breadcrumbsTails() {
	        return undefined;
	    }

	    static get ACTION() {
	        return ACTION$2;
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_GET() {
	        return ACTION$2;
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_PUT() {
	        return ACTION$2;
	    }

	    /**
	     *
	     * @param {import('../../controller.crud')} controller
	     * @param {any}                         params
	     * @returns {import('not-node/src/types').notAppResponse}
	     */
	    static loadData(controller, params) {
	        let defData = controller.createDefault();
	        if (defData.getData) {
	            defData = defData.getData();
	        }
	        return {
	            status: "ok",
	            result: defData,
	        };
	    }

	    static getTitle(contoller, params, response) {
	        return contoller.getItemTitle(response);
	    }

	    static prepareUIOptions(controller, response) {
	        const actionName = this.getModelActionName(controller);
	        return {
	            options: {
	                target: controller.getContainerInnerElement(),
	                model: controller.getModelName(),
	                action: actionName,
	                name: `${controller.getName()}.${this.ACTION}Form`,
	                validators: this.getValidators(controller),
	                variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	                masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	            },
	            data: this.TRANSFORMER(response),
	        };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    static bindUIEvents(controller, params, response) {
	        if (notCommon$2.isFunc(controller.goBack)) {
	            this.bindUIEvent(controller, "reject", () =>
	                this.goBack(controller)
	            );
	        }
	        if (notCommon$2.isFunc(controller.onActionSubmit)) {
	            this.bindUIEvent(controller, "submit", async (ev) => {
	                const success = await controller.onActionSubmit(this.ACTION, {
	                    ...this.loadDataQuery(controller, params),
	                    ...ev.detail,
	                });
	                if (success) {
	                    this.goBackAfterDelay(controller);
	                }
	            });
	        }
	    }
	}

	class CRUDActionCreate extends CRUDGenericActionCreate{}

	/**
	 * Generic CRUD Details action class
	 * @class
	 */
	class CRUDGenericActionRead extends CRUDGenericAction {
	    static tweakUIOptions(options) {
	        options.options.ui = {
	            submit: {
	                enabled: false,
	            },
	        };
	        return options;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	    static async run(controller, params) {
	        try {
	            //inform that we are starting
	            controller.emit(`before:render:${this.ACTION}`, params);
	            //if UI for this action exists exiting
	            if (this.isUIRendered(controller)) {
	                return;
	            }
	            //indicating that we are working
	            controller.renderLoadingScreen && controller.renderLoadingScreen();
	            //preloading form variants
	            await controller.preloadVariants(this.ACTION);
	            //setting initial state of breadcrumbs tail
	            this.presetBreadcrumbs(controller, params);
	            //loading data
	            const response = await this.loadData(controller, params);
	            //showing error message if response is 'bad'
	            if (this.isResponseBad(response)) {
	                return controller.showErrorMessage(response);
	            }
	            //updating breadcrumbs tail with more details from response
	            this.setBreadcrumbs(controller, params, response);
	            //creating action UI component
	            const uiComponent = this.UIConstructor;
	            this.setUI(
	                controller,
	                new uiComponent(
	                    this.tweakUIOptions(
	                        this.prepareUIOptions(controller, response)
	                    )
	                )
	            );
	            //bind events to UI
	            this.bindUIEvents(controller, params, response);
	            //inform that we are ready
	            controller.emit(`after:render:${this.ACTION}`, params, response);
	        } catch (e) {
	            //informing about exception
	            controller.emit(`exception:render:${this.ACTION}`, params, e);
	            //reporting exception
	            controller.report(e);
	            //showing error message
	            controller.showErrorMessage(e);
	        }
	    }
	}

	/**
	 * CRUD action details
	 */
	class CRUDActionDetails extends CRUDGenericActionRead {}

	const DEFAULT_BREADCRUMB_TAIL = "Редактирование";
	/**
	 * Generic CRUD Update action class
	 * @class
	 */
	class CRUDGenericActionUpdate extends CRUDGenericAction {
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	    static get deafultBreadcrumbsTail() {
	        return DEFAULT_BREADCRUMB_TAIL;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	    static get breadcrumbsTails() {
	        return {
	            preset: DEFAULT_BREADCRUMB_TAIL,
	            set: `${DEFAULT_BREADCRUMB_TAIL}: "{:title}"`,
	        };
	    }

	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	    static get ACTION() {
	        return "update";
	    }

	    /**
	     * @static {string} MODEL_ACTION_GET    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_GET() {
	        return "getRaw";
	    }

	    /**
	     * @static {string} MODEL_ACTION_PUT    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_PUT() {
	        return "update";
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	    static prepareUIOptions(controller, response) {
	        this.getModelActionName(controller);
	        return {
	            options: {
	                target: controller.getContainerInnerElement(),
	                model: controller.getModelName(),
	                action: this.MODEL_ACTION_PUT, //will be used to get form fields information from manifest
	                name: `${controller.getName()}.${this.ACTION}Form`,
	                validators: this.getValidators(controller),
	                variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	                ui: controller.getOptions(`${this.ACTION}.ui`, {}),
	                fields: controller.getOptions(`${this.ACTION}.fields`, {}),
	                masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	            },
	            data: this.TRANSFORMER(notCommon$2.stripProxy(response.result)),
	        };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    static bindUIEvents(controller, params, response) {
	        if (notCommon$2.isFunc(controller.goBack)) {
	            this.bindUIEvent(controller, "reject", () =>
	                this.goBack(controller)
	            );
	        }
	        if (notCommon$2.isFunc(controller.onActionSubmit)) {
	            this.bindUIEvent(controller, "submit", async (ev) => {
	                const success = await controller.onActionSubmit(this.ACTION, {
	                    ...this.loadDataQuery(controller, params),
	                    ...ev.detail,
	                });
	                if (success) {
	                    this.goBackAfterDelay(controller);
	                }
	            });
	        }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	    static isUIRendered(controller) {
	        if (this.getUI(controller)) {
	            return true;
	        } else {
	            controller.$destroyUI();
	        }
	        return false;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	    static async run(controller, params) {
	        try {
	            //inform that we are starting
	            controller.emit(`before:render:${this.ACTION}`, [params]);
	            //if UI for this action exists exiting
	            if (this.isUIRendered(controller)) {
	                return;
	            }
	            //indicating that we are working
	            controller.renderLoadingScreen && controller.renderLoadingScreen();
	            //preloading form variants
	            await controller.preloadVariants(this.ACTION);
	            //setting initial state of breadcrumbs tail
	            this.presetBreadcrumbs(controller, params);
	            //loading data
	            const response = await this.loadData(controller, params);
	            //showing error message if response is 'bad'
	            if (this.isResponseBad(response)) {
	                return controller.showErrorMessage(response);
	            }
	            //updating breadcrumbs tail with more details from response
	            this.setBreadcrumbs(controller, params, response);
	            //creating action UI component
	            const uiComponent = this.UIConstructor;
	            this.setUI(
	                controller,
	                new uiComponent(
	                    this.tweakUIOptions(
	                        this.prepareUIOptions(controller, response)
	                    )
	                )
	            );
	            //bind events to UI
	            this.bindUIEvents(controller, params, response);
	            //inform that we are ready
	            controller.emit(`after:render:${this.ACTION}`, params);
	        } catch (e) {
	            //informing about exception
	            controller.emit(`exception:render:${this.ACTION}`, params, e);
	            //reporting exception
	            controller.report(e);
	            //showing error message
	            controller.showErrorMessage(e);
	        }
	    }
	}

	/**
	 * CRUD action update
	 */
	class CRUDActionUpdate extends CRUDGenericActionUpdate {}

	const ACTION$1 = 'delete';
	const MODEL_ACTION = 'delete';

	class CRUDActionDelete{
	  static async run(controller, params) {
	    try{

	      if (controller.ui[ACTION$1]) {
	        return;
	      } else {
	        controller.$destroyUI();
	      }

	      controller.ui[ACTION$1] = new notActionUI({
	        name: 'CRUDDelete',
	        target: controller.getContainerInnerElement(),
	        options: {
	          loaderActive: true,
	          loaderStyle: 'container',
	          loaderTitle: 'not-node:crud_delete_action_waiting',
	          container: {
	            id: `crud-delete-action-${params[0]}`
	          }
	        }
	      });

	      controller.setBreadcrumbs([{
	        title: 'Удаление',
	        url: controller.getModelActionURL(params[0], ACTION$1)
	      }]);

	      if (confirm('Удалить запись?')) {
	        const deleteActionName = controller.getOptions(`${ACTION$1}.actionName`, MODEL_ACTION);
	        const success = await controller.onActionSubmit(deleteActionName, {
	          _id: params[0]
	        });
	        if(success){
	          controller.goList();
	        }
	        return;
	      }
	      controller.goList();
	    }catch(e){
	      controller.report(e);
	      controller.showErrorMessage(e);
	    }
	  }

	}

	const ACTION = "list";

	class CRUDActionList {
	    static tweakActionsList(controller, ACTIONS_LIST) {
	        if (controller.getOptions(`${ACTION}.createAction`, true)) {
	            ACTIONS_LIST.push({
	                title: "Создать",
	                action: () => controller.goCreate(),
	            });
	        }
	        return ACTIONS_LIST;
	    }

	    static tweakUIOptions(options) {
	        return options;
	    }

	    static createActionsButtons(
	        controller,
	        value,
	        delay = 0,
	        actions = ["details", "update", "delete"],
	        prepend = [],
	        append = []
	    ) {
	        const ACTIONS = {
	            details: {
	                action: () => controller.goDetails(value, delay),
	                title: "Подробнее",
	                size: "small",
	            },
	            update: {
	                action: () => controller.goUpdate(value, delay),
	                title: "Изменить",
	                size: "small",
	            },
	            delete: {
	                action: () => controller.goDelete(value, delay),
	                color: "danger",
	                title: "Удалить",
	                size: "small",
	                style: "outlined",
	            },
	        };
	        const actionsButtons = [...prepend];
	        if (Array.isArray(actions)) {
	            actions.forEach((actionName) =>
	                actionsButtons.push(ACTIONS[actionName])
	            );
	        }
	        actionsButtons.push(...append);
	        return actionsButtons;
	    }

	    static async run(controller, params) {
	        try {
	            //indicating that we are working
	            controller.renderLoadingScreen && controller.renderLoadingScreen();

	            await controller.preloadVariants(ACTION);

	            controller.setBreadcrumbs([
	                {
	                    title: "Список",
	                    url: controller.getModelURL(),
	                },
	            ]);

	            if (controller.ui[ACTION]) {
	                return;
	            } else {
	                controller.$destroyUI();
	            }

	            controller.ui[ACTION] = new notTable(
	                this.tweakUIOptions(CRUDActionList.prepareOptions(controller))
	            );

	            controller.emit(
	                `after:render:${ACTION}`,
	                params,
	                controller.ui[ACTION]
	            );
	        } catch (e) {
	            //informing about exception
	            controller.emit(`exception:render:${ACTION}`, params, e);
	            controller.report(e);
	            controller.showErrorMessage(e);
	        }
	    }

	    static prepareOptions(controller) {
	        const DEFAULT_OPTIONS_TABLE = {
	            interface: controller.getOptions(`${ACTION}.interface`, {
	                combined: true,
	                factory: controller.getInterface(),
	            }),
	            fields: undefined,
	            showSelect: undefined,
	            getItemId: undefined,
	            idField: undefined,
	            preload: {},
	            filterUI: controller.getOptions(`${ACTION}.filterUI`),
	            pager: { size: 50, page: 0 },
	            sorter: {
	                id: -1,
	            },
	            filter: undefined,
	            ui: undefined,
	        };
	        //forming actions buttons list
	        let ACTIONS_LIST = [...controller.getOptions(`${ACTION}.actions`, [])];
	        ACTIONS_LIST = this.tweakActionsList(controller, ACTIONS_LIST);
	        //
	        const TABLE_OPTIONS = {
	            options: {
	                targetEl: controller.getContainerInnerElement(),
	                endless: false,
	                actions: ACTIONS_LIST,
	            },
	        };
	        Object.keys(DEFAULT_OPTIONS_TABLE).forEach((key) => {
	            let optVal = controller.getOptions(
	                `${ACTION}.${key}`,
	                DEFAULT_OPTIONS_TABLE[key]
	            );
	            if (typeof optVal !== "undefined") {
	                TABLE_OPTIONS.options[key] = optVal;
	            }
	        });
	        return TABLE_OPTIONS;
	    }
	}

	var CRUDActions = {
	  create: CRUDActionCreate,
	  details: CRUDActionDetails,
	  update: CRUDActionUpdate,
	  delete: CRUDActionDelete,
	  list: CRUDActionList,
	};

	const BREADCRUMBS = [];
	const TITLE_FIELDS_PRIORITY = ["title", "label", "id", "name"];

	class notCRUD extends notController$2 {
	    #actions = { ...CRUDActions };
	    #router = notCRUDRouter;
	    #preloader = CRUDVariantsPreloader;

	    TITLE_FIELDS_PRIORITY = TITLE_FIELDS_PRIORITY;

	    static ERROR_DEFAULT = UICommon.ERROR_DEFAULT;

	    TOP_CLASS = ["box"];
	    MAIN_CLASS = ["box"];
	    BOTTOM_CLASS = ["box"];

	    WS_CHECK_INTERVAL = 200;

	    constructor(
	        app,
	        name,
	        { actions, router, preloader } = {
	            actions: undefined,
	            router: undefined,
	            preloader: undefined,
	        }
	    ) {
	        super(app, `CRUD.${name}`);
	        if (actions) {
	            // @ts-ignore
	            this.#actions = { ...this.#actions, ...actions };
	        }
	        if (router) {
	            this.#router = router;
	        }
	        if (preloader) {
	            this.#preloader = preloader;
	        }
	        this.ui = {};
	        this.els = {};
	        this.setOptions("names", {
	            module: "",
	            plural: "plural",
	            single: "single",
	        });
	        this.setOptions(
	            "containerSelector",
	            this.app?.getOptions("crud.containerSelector")
	        );
	        this.buildFrame();
	        return this;
	    }

	    setValidators(validators) {
	        //not-module-name -> [not,module,name]
	        const ModuleNameParts = this.getModuleName().split("-");
	        //[not,module,name] -> ModuleName
	        const ModuleName = (
	            ModuleNameParts[0] === "not"
	                ? ModuleNameParts.splice(1)
	                : ModuleNameParts
	        )
	            .map(notCommon$2.capitalizeFirstLetter)
	            .join("");
	        const serviceName = `ns${ModuleName}Common`;
	        const CommonModuleService = this.app?.getService(serviceName);
	        this.setWorking(
	            "validators",
	            CommonModuleService.augmentValidators(validators)
	        );
	    }

	    getValidators() {
	        return this.getWorking("validators");
	    }

	    start() {
	        let newHead = [];
	        if (this.getModuleName() && this.getOptions("names.module")) {
	            newHead.push({
	                title: this.getOptions("names.module"),
	                url: false,
	            });
	        }
	        newHead.push({
	            title: this.getOptions("names.plural"),
	            url: this.getModelURL(),
	        });
	        BREADCRUMBS.splice(0, BREADCRUMBS.length, ...newHead);
	        notBreadcrumbs.setHead(BREADCRUMBS).render({
	            root: "",
	            target: this.els.top,
	            navigate: (url) => this.app?.getWorking("router").navigate(url),
	        });
	        this.route(this.getOptions("params"));
	    }

	    startWhenWSClientReady() {
	        if (this.app?.getWSClient()) {
	            if (this.app?.getWSClient().isConnected()) {
	                this.start();
	            } else {
	                this.app
	                    .getWSClient()
	                    .once("connected", this.startWhenWSClientReady.bind(this));
	            }
	        } else {
	            setTimeout(
	                () => this.startWhenWSClientReady(),
	                this.WS_CHECK_INTERVAL
	            );
	        }
	    }

	    setBreadcrumbs(tail) {
	        notBreadcrumbs.setTail(tail).update();
	    }

	    backToList() {
	        this.navigate(this.linkBackToList());
	    }

	    linkBackToList() {
	        return this.getModelURL();
	    }

	    afterAction(action = "list") {
	        let navBack = this.app?.getOptions("crud.navigateBackAfter", []);
	        if (navBack && Array.isArray(navBack) && navBack.indexOf(action) > -1) {
	            window.history.back();
	        } else {
	            this.backToList();
	        }
	    }

	    buildFrame() {
	        let el = document.querySelector(
	            this.app?.getOptions("crud.containerSelector", "body")
	        );
	        while (el.firstChild) {
	            el.removeChild(el.firstChild);
	        }
	        this.els.top = document.createElement("div");
	        this.els.top.id = "crud-top";
	        this.getFrameClasses().TOP_CLASS.forEach((name) =>
	            this.els.top.classList.add(name)
	        );
	        el.appendChild(this.els.top);
	        this.els.main = document.createElement("div");
	        this.els.main.id = "crud-main";
	        this.getFrameClasses().MAIN_CLASS.forEach((name) =>
	            this.els.main.classList.add(name)
	        );
	        el.appendChild(this.els.main);
	        this.els.bottom = document.createElement("div");
	        this.els.bottom.id = "crud-bottom";
	        this.getFrameClasses().BOTTOM_CLASS.forEach((name) =>
	            this.els.bottom.classList.add(name)
	        );
	        el.appendChild(this.els.bottom);
	    }

	    getFrameClasses() {
	        return {
	            TOP_CLASS: this.TOP_CLASS,
	            MAIN_CLASS: this.MAIN_CLASS,
	            BOTTOM_CLASS: this.BOTTOM_CLASS,
	        };
	    }

	    getContainerTopElement() {
	        return this.els.top;
	    }

	    getContainerInnerElement() {
	        return this.els.main;
	    }

	    getContainerBottomElement() {
	        return this.els.bottom;
	    }

	    async preloadVariants(type = "list") {
	        await this.#preloader.preload(this, type);
	    }

	    getTitleFromLib(propName, id) {
	        throw new Error("not suported anymore");
	        //return Form.getVariant(propName, id).title;
	    }

	    getItemTitle(item) {
	        const fieldName = this.TITLE_FIELDS_PRIORITY.find((key) =>
	            notCommon$2.objHas(item, key)
	        );
	        if (fieldName) {
	            return item[fieldName];
	        } else {
	            return "";
	        }
	    }

	    createDefault() {
	        return this.getModel({}).toDefault();
	    }

	    route(params = []) {
	        try {
	            return this.#router.route(this, params);
	        } catch (e) {
	            this.report(e);
	            this.showErrorMessage(e);
	        }
	    }

	    actionHandlerExists(actionName) {
	        if (Object.keys(this.#actions).includes(actionName)) {
	            return true;
	        }
	        if (
	            typeof this["run" + notCommon$2.capitalizeFirstLetter(actionName)] ===
	            "function"
	        ) {
	            return true;
	        }
	        return false;
	    }

	    runAction(actionName, params) {
	        if (Object.keys(this.#actions).includes(actionName)) {
	            return this.#actions[actionName].run(this, params);
	        } else if (
	            typeof this["run" + notCommon$2.capitalizeFirstLetter(actionName)] ===
	            "function"
	        ) {
	            return this["run" + notCommon$2.capitalizeFirstLetter(actionName)](
	                params
	            );
	        } else {
	            throw new Error(
	                `No such action: ${actionName} in contoller ${this.getWorking(
                    "name"
                )}`
	            );
	        }
	    }

	    /**
	     *  Changes location to create page, after delay
	     *  @param {number|string} [delay=0] number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goCreate(delay = 0) {
	        this.goAfterDelay(this.getModelActionURL("", "create"), delay);
	    }

	    /**
	     *  Changes location to document details page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goDetails(id, delay = 0) {
	        this.goAfterDelay(this.getModelActionURL(id, ""), delay);
	    }

	    /**
	     * Changes location to document update page, after delay
	     * @param {string}          id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goUpdate(id, delay = 0) {
	        this.goAfterDelay(this.getModelActionURL(id, "update"), delay);
	    }

	    /**
	     *  Changes location to document delete page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goDelete(id, delay = 0) {
	        this.goAfterDelay(this.getModelActionURL(id, "delete"), delay);
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goList(delay = 0) {
	        this.goAfterDelay(this.getModelURL(), delay);
	    }

	    /**
	     *
	     * @param {string} url
	     * @param {number|string} delay
	     */
	    goAfterDelay(url, delay = 0) {
	        this.navigateWithDelay(url, delay, () => this.$destroyUI());
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goBack(delay = 0) {
	        this.goList(delay);
	    }

	    async onActionSubmit(action, item) {
	        let state = true;
	        const actionUI = this.ui[action];
	        if (actionUI) {
	            try {
	                actionUI.setLoading();
	                let result = await this.getModel(item)[`$${action}`]();
	                state = actionUI.processResult(result);
	            } catch (e) {
	                state = actionUI.processResult(e);
	            } finally {
	                actionUI.resetLoading();
	                return state;
	            }
	        }
	        throw new Error("Action UI doesnt exist");
	    }

	    $destroyUI() {
	        for (let name in this.ui) {
	            this.ui[name].$destroy && this.ui[name].$destroy();
	            this.ui[name].destroy && this.ui[name].destroy();
	            delete this.ui[name];
	        }
	    }

	    showErrorMessage(res) {
	        this.error && this.error(res);
	        this.app &&
	            this.app.emit("error", {
	                title: "Произошла ошибка",
	                message: res.message ? res.message : UICommon.ERROR_DEFAULT,
	            });
	        CRUDMessage.error(
	            this,
	            "Произошла ошибка",
	            res.message ? res.message : UICommon.ERROR_DEFAULT
	        );
	    }

	    showSuccessMessage(title, message) {
	        this.app && this.app.emit("success", { title, message });
	        CRUDMessage.success(this, title, message);
	    }

	    setUI(name, val) {
	        this.$destroyUI();
	        this.ui[name] = val;
	    }

	    getActionUI() {
	        return this.ui[this.getCurrentAction()];
	    }

	    renderLoadingScreen() {
	        this.setUI("loading_screen", this.createLoaderUI());
	    }

	    createLoaderUI() {
	        return new Ui_loader({
	            target: this.getContainerInnerElement(),
	            props: {
	                loading: true,
	                title: "",
	            },
	        });
	    }
	}

	const ROUTE_LIST = "list";
	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	class notCRUDPlainRouter {
	    static DEFAULT_ROUTE = ROUTE_LIST;
	    /**
	     * Returns first item from params or throws Error
	     * @param {string[]} params array of strings parsed from URI by route rules
	     * @returns {string}
	     */
	    static extractActionName(params) {
	        if (params.length > 0) {
	            return params[0];
	        }
	        return this.DEFAULT_ROUTE;
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	    static route(controller, params) {
	        try {
	            const actionName = this.extractActionName(params);
	            controller.setCurrentAction(actionName);
	            return controller.runAction(actionName, params);
	        } catch (e) {
	            controller.report(e);
	            controller.showErrorMessage(e);
	        }
	    }
	}

	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	class notCRUDRouterSwitch {
	    /**
	     * Variants of this action
	     */
	    static get routesVariants() {
	        return {
	            /**
	            routeName: Action
	             */
	        };
	    }

	    /**
	     * Returns true if variant name is valid
	     * @param {string} name    name of route variant
	     * @returns {boolean}
	     */
	    static isRouteVariantValid(name) {
	        return name !== "" && notCommon$2.objHas(this.routesVariants, name);
	    }

	    /**
	     * This function returns which of routes variant should be executed
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]}    params  params passed to router
	     * @returns {Promise<string>}    name of route variant
	     */
	    static async determineRoute(controller, params = []) {
	        return "";
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	    static async route(controller, params) {
	        try {
	            const actionName = await this.determineRoute(controller, params);
	            if (this.isRouteVariantValid(actionName)) {
	                controller.setCurrentAction(actionName);
	                const routerAction = this.routesVariants[actionName];
	                if (notCommon$2.isAsync(routerAction.run)) {
	                    await routerAction.run(controller, params);
	                } else {
	                    routerAction.run(controller, params);
	                }
	            } else {
	                throw new Error(
	                    `No such action: ${actionName} in contoller ${controller.getWorking(
                        "name"
                    )}`
	                );
	            }
	        } catch (e) {
	            controller.report(e);
	            controller.showErrorMessage(e);
	        }
	    }
	}

	var validator = {exports: {}};

	var toDate = {exports: {}};

	var assertString = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = assertString;
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		function assertString(input) {
		  var isString = typeof input === 'string' || input instanceof String;
		  if (!isString) {
		    var invalidType = _typeof(input);
		    if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;
		    throw new TypeError("Expected a string but received a ".concat(invalidType));
		  }
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (assertString, assertString.exports));

	var assertStringExports = assertString.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toDate;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function toDate(date) {
		  (0, _assertString.default)(date);
		  date = Date.parse(date);
		  return !isNaN(date) ? new Date(date) : null;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toDate, toDate.exports));

	var toDateExports = toDate.exports;

	var toFloat = {exports: {}};

	var isFloat$1 = {};

	var alpha$1 = {};

	Object.defineProperty(alpha$1, "__esModule", {
	  value: true
	});
	alpha$1.farsiLocales = alpha$1.englishLocales = alpha$1.dotDecimal = alpha$1.decimal = alpha$1.commaDecimal = alpha$1.bengaliLocales = alpha$1.arabicLocales = alpha$1.alphanumeric = alpha$1.alpha = void 0;
	var alpha = alpha$1.alpha = {
	  'en-US': /^[A-Z]+$/i,
	  'az-AZ': /^[A-VXYZÇƏĞİıÖŞÜ]+$/i,
	  'bg-BG': /^[А-Я]+$/i,
	  'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
	  'da-DK': /^[A-ZÆØÅ]+$/i,
	  'de-DE': /^[A-ZÄÖÜß]+$/i,
	  'el-GR': /^[Α-ώ]+$/i,
	  'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,
	  'fa-IR': /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i,
	  'fi-FI': /^[A-ZÅÄÖ]+$/i,
	  'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
	  'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
	  'ja-JP': /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
	  'nb-NO': /^[A-ZÆØÅ]+$/i,
	  'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
	  'nn-NO': /^[A-ZÆØÅ]+$/i,
	  'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
	  'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
	  'pt-PT': /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
	  'ru-RU': /^[А-ЯЁ]+$/i,
	  'kk-KZ': /^[А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
	  'sl-SI': /^[A-ZČĆĐŠŽ]+$/i,
	  'sk-SK': /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
	  'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,
	  'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,
	  'sv-SE': /^[A-ZÅÄÖ]+$/i,
	  'th-TH': /^[ก-๐\s]+$/i,
	  'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,
	  'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,
	  'vi-VN': /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
	  'ko-KR': /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
	  'ku-IQ': /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
	  ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
	  he: /^[א-ת]+$/,
	  fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i,
	  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
	  eo: /^[ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
	  'hi-IN': /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
	  'si-LK': /^[\u0D80-\u0DFF]+$/
	};
	var alphanumeric = alpha$1.alphanumeric = {
	  'en-US': /^[0-9A-Z]+$/i,
	  'az-AZ': /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i,
	  'bg-BG': /^[0-9А-Я]+$/i,
	  'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
	  'da-DK': /^[0-9A-ZÆØÅ]+$/i,
	  'de-DE': /^[0-9A-ZÄÖÜß]+$/i,
	  'el-GR': /^[0-9Α-ω]+$/i,
	  'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
	  'fi-FI': /^[0-9A-ZÅÄÖ]+$/i,
	  'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
	  'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
	  'ja-JP': /^[0-9０-９ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
	  'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
	  'nb-NO': /^[0-9A-ZÆØÅ]+$/i,
	  'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
	  'nn-NO': /^[0-9A-ZÆØÅ]+$/i,
	  'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
	  'pt-PT': /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
	  'ru-RU': /^[0-9А-ЯЁ]+$/i,
	  'kk-KZ': /^[0-9А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
	  'sl-SI': /^[0-9A-ZČĆĐŠŽ]+$/i,
	  'sk-SK': /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
	  'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,
	  'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
	  'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,
	  'th-TH': /^[ก-๙\s]+$/i,
	  'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
	  'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
	  'ko-KR': /^[0-9ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
	  'ku-IQ': /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
	  'vi-VN': /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
	  ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
	  he: /^[0-9א-ת]+$/,
	  fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i,
	  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣ০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
	  eo: /^[0-9ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
	  'hi-IN': /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
	  'si-LK': /^[0-9\u0D80-\u0DFF]+$/
	};
	var decimal = alpha$1.decimal = {
	  'en-US': '.',
	  ar: '٫'
	};
	var englishLocales = alpha$1.englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
	for (var locale, i = 0; i < englishLocales.length; i++) {
	  locale = "en-".concat(englishLocales[i]);
	  alpha[locale] = alpha['en-US'];
	  alphanumeric[locale] = alphanumeric['en-US'];
	  decimal[locale] = decimal['en-US'];
	}

	// Source: http://www.localeplanet.com/java/
	var arabicLocales = alpha$1.arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
	for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
	  _locale = "ar-".concat(arabicLocales[_i]);
	  alpha[_locale] = alpha.ar;
	  alphanumeric[_locale] = alphanumeric.ar;
	  decimal[_locale] = decimal.ar;
	}
	var farsiLocales = alpha$1.farsiLocales = ['IR', 'AF'];
	for (var _locale2, _i2 = 0; _i2 < farsiLocales.length; _i2++) {
	  _locale2 = "fa-".concat(farsiLocales[_i2]);
	  alphanumeric[_locale2] = alphanumeric.fa;
	  decimal[_locale2] = decimal.ar;
	}
	var bengaliLocales = alpha$1.bengaliLocales = ['BD', 'IN'];
	for (var _locale3, _i3 = 0; _i3 < bengaliLocales.length; _i3++) {
	  _locale3 = "bn-".concat(bengaliLocales[_i3]);
	  alpha[_locale3] = alpha.bn;
	  alphanumeric[_locale3] = alphanumeric.bn;
	  decimal[_locale3] = decimal['en-US'];
	}

	// Source: https://en.wikipedia.org/wiki/Decimal_mark
	var dotDecimal = alpha$1.dotDecimal = ['ar-EG', 'ar-LB', 'ar-LY'];
	var commaDecimal = alpha$1.commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-ZM', 'eo', 'es-ES', 'fr-CA', 'fr-FR', 'id-ID', 'it-IT', 'ku-IQ', 'hi-IN', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'kk-KZ', 'si-LK', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'vi-VN'];
	for (var _i4 = 0; _i4 < dotDecimal.length; _i4++) {
	  decimal[dotDecimal[_i4]] = decimal['en-US'];
	}
	for (var _i5 = 0; _i5 < commaDecimal.length; _i5++) {
	  decimal[commaDecimal[_i5]] = ',';
	}
	alpha['fr-CA'] = alpha['fr-FR'];
	alphanumeric['fr-CA'] = alphanumeric['fr-FR'];
	alpha['pt-BR'] = alpha['pt-PT'];
	alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
	decimal['pt-BR'] = decimal['pt-PT'];

	// see #862
	alpha['pl-Pl'] = alpha['pl-PL'];
	alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
	decimal['pl-Pl'] = decimal['pl-PL'];

	// see #1455
	alpha['fa-AF'] = alpha.fa;

	Object.defineProperty(isFloat$1, "__esModule", {
	  value: true
	});
	isFloat$1.default = isFloat;
	isFloat$1.locales = void 0;
	var _assertString$b = _interopRequireDefault$b(assertStringExports);
	var _alpha$2 = alpha$1;
	function _interopRequireDefault$b(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function isFloat(str, options) {
	  (0, _assertString$b.default)(str);
	  options = options || {};
	  var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha$2.decimal[options.locale] : '.', "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
	  if (str === '' || str === '.' || str === ',' || str === '-' || str === '+') {
	    return false;
	  }
	  var value = parseFloat(str.replace(',', '.'));
	  return float.test(str) && (!options.hasOwnProperty('min') || value >= options.min) && (!options.hasOwnProperty('max') || value <= options.max) && (!options.hasOwnProperty('lt') || value < options.lt) && (!options.hasOwnProperty('gt') || value > options.gt);
	}
	isFloat$1.locales = Object.keys(_alpha$2.decimal);

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toFloat;
		var _isFloat = _interopRequireDefault(isFloat$1);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function toFloat(str) {
		  if (!(0, _isFloat.default)(str)) return NaN;
		  return parseFloat(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toFloat, toFloat.exports));

	var toFloatExports = toFloat.exports;

	var toInt = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toInt;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function toInt(str, radix) {
		  (0, _assertString.default)(str);
		  return parseInt(str, radix || 10);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toInt, toInt.exports));

	var toIntExports = toInt.exports;

	var toBoolean = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toBoolean;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function toBoolean(str, strict) {
		  (0, _assertString.default)(str);
		  if (strict) {
		    return str === '1' || /^true$/i.test(str);
		  }
		  return str !== '0' && !/^false$/i.test(str) && str !== '';
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toBoolean, toBoolean.exports));

	var toBooleanExports = toBoolean.exports;

	var equals = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = equals;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function equals(str, comparison) {
		  (0, _assertString.default)(str);
		  return str === comparison;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (equals, equals.exports));

	var equalsExports = equals.exports;

	var contains = {exports: {}};

	var toString$1 = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toString;
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		function toString(input) {
		  if (_typeof(input) === 'object' && input !== null) {
		    if (typeof input.toString === 'function') {
		      input = input.toString();
		    } else {
		      input = '[object Object]';
		    }
		  } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {
		    input = '';
		  }
		  return String(input);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toString$1, toString$1.exports));

	var toStringExports = toString$1.exports;

	var merge = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = merge;
		function merge() {
		  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		  var defaults = arguments.length > 1 ? arguments[1] : undefined;
		  for (var key in defaults) {
		    if (typeof obj[key] === 'undefined') {
		      obj[key] = defaults[key];
		    }
		  }
		  return obj;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (merge, merge.exports));

	var mergeExports = merge.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = contains;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _toString = _interopRequireDefault(toStringExports);
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var defaulContainsOptions = {
		  ignoreCase: false,
		  minOccurrences: 1
		};
		function contains(str, elem, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, defaulContainsOptions);
		  if (options.ignoreCase) {
		    return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;
		  }
		  return str.split((0, _toString.default)(elem)).length > options.minOccurrences;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (contains, contains.exports));

	var containsExports = contains.exports;

	var matches = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = matches;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function matches(str, pattern, modifiers) {
		  (0, _assertString.default)(str);
		  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
		    pattern = new RegExp(pattern, modifiers);
		  }
		  return !!str.match(pattern);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (matches, matches.exports));

	var matchesExports = matches.exports;

	var isEmail = {exports: {}};

	var isByteLength = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isByteLength;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		/* eslint-disable prefer-rest-params */
		function isByteLength(str, options) {
		  (0, _assertString.default)(str);
		  var min;
		  var max;
		  if (_typeof(options) === 'object') {
		    min = options.min || 0;
		    max = options.max;
		  } else {
		    // backwards compatibility: isByteLength(str, min [, max])
		    min = arguments[1];
		    max = arguments[2];
		  }
		  var len = encodeURI(str).split(/%..|./).length - 1;
		  return len >= min && (typeof max === 'undefined' || len <= max);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isByteLength, isByteLength.exports));

	var isByteLengthExports = isByteLength.exports;

	var isFQDN = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isFQDN;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var default_fqdn_options = {
		  require_tld: true,
		  allow_underscores: false,
		  allow_trailing_dot: false,
		  allow_numeric_tld: false,
		  allow_wildcard: false,
		  ignore_max_length: false
		};
		function isFQDN(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_fqdn_options);

		  /* Remove the optional trailing dot before checking validity */
		  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
		    str = str.substring(0, str.length - 1);
		  }

		  /* Remove the optional wildcard before checking validity */
		  if (options.allow_wildcard === true && str.indexOf('*.') === 0) {
		    str = str.substring(2);
		  }
		  var parts = str.split('.');
		  var tld = parts[parts.length - 1];
		  if (options.require_tld) {
		    // disallow fqdns without tld
		    if (parts.length < 2) {
		      return false;
		    }
		    if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
		      return false;
		    }

		    // disallow spaces
		    if (/\s/.test(tld)) {
		      return false;
		    }
		  }

		  // reject numeric TLDs
		  if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
		    return false;
		  }
		  return parts.every(function (part) {
		    if (part.length > 63 && !options.ignore_max_length) {
		      return false;
		    }
		    if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
		      return false;
		    }

		    // disallow full-width chars
		    if (/[\uff01-\uff5e]/.test(part)) {
		      return false;
		    }

		    // disallow parts starting or ending with hyphen
		    if (/^-|-$/.test(part)) {
		      return false;
		    }
		    if (!options.allow_underscores && /_/.test(part)) {
		      return false;
		    }
		    return true;
		  });
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isFQDN, isFQDN.exports));

	var isFQDNExports = isFQDN.exports;

	var isIP = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIP;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/**
		11.3.  Examples

		   The following addresses

		             fe80::1234 (on the 1st link of the node)
		             ff02::5678 (on the 5th link of the node)
		             ff08::9abc (on the 10th organization of the node)

		   would be represented as follows:

		             fe80::1234%1
		             ff02::5678%5
		             ff08::9abc%10

		   (Here we assume a natural translation from a zone index to the
		   <zone_id> part, where the Nth zone of any scope is translated into
		   "N".)

		   If we use interface names as <zone_id>, those addresses could also be
		   represented as follows:

		            fe80::1234%ne0
		            ff02::5678%pvc1.3
		            ff08::9abc%interface10

		   where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
		   to the 5th link, and "interface10" belongs to the 10th organization.
		 * * */
		var IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
		var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
		var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
		var IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';
		var IPv6AddressRegExp = new RegExp('^(' + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ')(%[0-9a-zA-Z-.:]{1,})?$');
		function isIP(str) {
		  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
		  (0, _assertString.default)(str);
		  version = String(version);
		  if (!version) {
		    return isIP(str, 4) || isIP(str, 6);
		  }
		  if (version === '4') {
		    return IPv4AddressRegExp.test(str);
		  }
		  if (version === '6') {
		    return IPv6AddressRegExp.test(str);
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIP, isIP.exports));

	var isIPExports = isIP.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isEmail;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _isByteLength = _interopRequireDefault(isByteLengthExports);
		var _isFQDN = _interopRequireDefault(isFQDNExports);
		var _isIP = _interopRequireDefault(isIPExports);
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var default_email_options = {
		  allow_display_name: false,
		  allow_underscores: false,
		  require_display_name: false,
		  allow_utf8_local_part: true,
		  require_tld: true,
		  blacklisted_chars: '',
		  ignore_max_length: false,
		  host_blacklist: [],
		  host_whitelist: []
		};

		/* eslint-disable max-len */
		/* eslint-disable no-control-regex */
		var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
		var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
		var gmailUserPart = /^[a-z\d]+$/;
		var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
		var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
		var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
		var defaultMaxEmailLength = 254;
		/* eslint-enable max-len */
		/* eslint-enable no-control-regex */

		/**
		 * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2
		 * @param {String} display_name
		 */
		function validateDisplayName(display_name) {
		  var display_name_without_quotes = display_name.replace(/^"(.+)"$/, '$1');
		  // display name with only spaces is not valid
		  if (!display_name_without_quotes.trim()) {
		    return false;
		  }

		  // check whether display name contains illegal character
		  var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
		  if (contains_illegal) {
		    // if contains illegal characters,
		    // must to be enclosed in double-quotes, otherwise it's not a valid display name
		    if (display_name_without_quotes === display_name) {
		      return false;
		    }

		    // the quotes in display name must start with character symbol \
		    var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
		    if (!all_start_with_back_slash) {
		      return false;
		    }
		  }
		  return true;
		}
		function isEmail(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_email_options);
		  if (options.require_display_name || options.allow_display_name) {
		    var display_email = str.match(splitNameAddress);
		    if (display_email) {
		      var display_name = display_email[1];

		      // Remove display name and angle brackets to get email address
		      // Can be done in the regex but will introduce a ReDOS (See  #1597 for more info)
		      str = str.replace(display_name, '').replace(/(^<|>$)/g, '');

		      // sometimes need to trim the last space to get the display name
		      // because there may be a space between display name and email address
		      // eg. myname <address@gmail.com>
		      // the display name is `myname` instead of `myname `, so need to trim the last space
		      if (display_name.endsWith(' ')) {
		        display_name = display_name.slice(0, -1);
		      }
		      if (!validateDisplayName(display_name)) {
		        return false;
		      }
		    } else if (options.require_display_name) {
		      return false;
		    }
		  }
		  if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
		    return false;
		  }
		  var parts = str.split('@');
		  var domain = parts.pop();
		  var lower_domain = domain.toLowerCase();
		  if (options.host_blacklist.includes(lower_domain)) {
		    return false;
		  }
		  if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
		    return false;
		  }
		  var user = parts.join('@');
		  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
		    /*
		      Previously we removed dots for gmail addresses before validating.
		      This was removed because it allows `multiple..dots@gmail.com`
		      to be reported as valid, but it is not.
		      Gmail only normalizes single dots, removing them from here is pointless,
		      should be done in normalizeEmail
		    */
		    user = user.toLowerCase();

		    // Removing sub-address from username before gmail validation
		    var username = user.split('+')[0];

		    // Dots are not included in gmail length restriction
		    if (!(0, _isByteLength.default)(username.replace(/\./g, ''), {
		      min: 6,
		      max: 30
		    })) {
		      return false;
		    }
		    var _user_parts = username.split('.');
		    for (var i = 0; i < _user_parts.length; i++) {
		      if (!gmailUserPart.test(_user_parts[i])) {
		        return false;
		      }
		    }
		  }
		  if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
		    max: 64
		  }) || !(0, _isByteLength.default)(domain, {
		    max: 254
		  }))) {
		    return false;
		  }
		  if (!(0, _isFQDN.default)(domain, {
		    require_tld: options.require_tld,
		    ignore_max_length: options.ignore_max_length,
		    allow_underscores: options.allow_underscores
		  })) {
		    if (!options.allow_ip_domain) {
		      return false;
		    }
		    if (!(0, _isIP.default)(domain)) {
		      if (!domain.startsWith('[') || !domain.endsWith(']')) {
		        return false;
		      }
		      var noBracketdomain = domain.slice(1, -1);
		      if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
		        return false;
		      }
		    }
		  }
		  if (user[0] === '"') {
		    user = user.slice(1, user.length - 1);
		    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
		  }
		  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
		  var user_parts = user.split('.');
		  for (var _i = 0; _i < user_parts.length; _i++) {
		    if (!pattern.test(user_parts[_i])) {
		      return false;
		    }
		  }
		  if (options.blacklisted_chars) {
		    if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), 'g')) !== -1) return false;
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isEmail, isEmail.exports));

	var isEmailExports = isEmail.exports;

	var isURL = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isURL;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _isFQDN = _interopRequireDefault(isFQDNExports);
		var _isIP = _interopRequireDefault(isIPExports);
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
		function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
		function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
		function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
		function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
		/*
		options for isURL method

		require_protocol - if set as true isURL will return false if protocol is not present in the URL
		require_valid_protocol - isURL will check if the URL's protocol is present in the protocols option
		protocols - valid protocols can be modified with this option
		require_host - if set as false isURL will not check if host is present in the URL
		require_port - if set as true isURL will check if port is present in the URL
		allow_protocol_relative_urls - if set as true protocol relative URLs will be allowed
		validate_length - if set as false isURL will skip string length validation (IE maximum is 2083)

		*/

		var default_url_options = {
		  protocols: ['http', 'https', 'ftp'],
		  require_tld: true,
		  require_protocol: false,
		  require_host: true,
		  require_port: false,
		  require_valid_protocol: true,
		  allow_underscores: false,
		  allow_trailing_dot: false,
		  allow_protocol_relative_urls: false,
		  allow_fragments: true,
		  allow_query_components: true,
		  validate_length: true
		};
		var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
		function isRegExp(obj) {
		  return Object.prototype.toString.call(obj) === '[object RegExp]';
		}
		function checkHost(host, matches) {
		  for (var i = 0; i < matches.length; i++) {
		    var match = matches[i];
		    if (host === match || isRegExp(match) && match.test(host)) {
		      return true;
		    }
		  }
		  return false;
		}
		function isURL(url, options) {
		  (0, _assertString.default)(url);
		  if (!url || /[\s<>]/.test(url)) {
		    return false;
		  }
		  if (url.indexOf('mailto:') === 0) {
		    return false;
		  }
		  options = (0, _merge.default)(options, default_url_options);
		  if (options.validate_length && url.length >= 2083) {
		    return false;
		  }
		  if (!options.allow_fragments && url.includes('#')) {
		    return false;
		  }
		  if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {
		    return false;
		  }
		  var protocol, auth, host, hostname, port, port_str, split, ipv6;
		  split = url.split('#');
		  url = split.shift();
		  split = url.split('?');
		  url = split.shift();
		  split = url.split('://');
		  if (split.length > 1) {
		    protocol = split.shift().toLowerCase();
		    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
		      return false;
		    }
		  } else if (options.require_protocol) {
		    return false;
		  } else if (url.slice(0, 2) === '//') {
		    if (!options.allow_protocol_relative_urls) {
		      return false;
		    }
		    split[0] = url.slice(2);
		  }
		  url = split.join('://');
		  if (url === '') {
		    return false;
		  }
		  split = url.split('/');
		  url = split.shift();
		  if (url === '' && !options.require_host) {
		    return true;
		  }
		  split = url.split('@');
		  if (split.length > 1) {
		    if (options.disallow_auth) {
		      return false;
		    }
		    if (split[0] === '') {
		      return false;
		    }
		    auth = split.shift();
		    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
		      return false;
		    }
		    var _auth$split = auth.split(':'),
		      _auth$split2 = _slicedToArray(_auth$split, 2),
		      user = _auth$split2[0],
		      password = _auth$split2[1];
		    if (user === '' && password === '') {
		      return false;
		    }
		  }
		  hostname = split.join('@');
		  port_str = null;
		  ipv6 = null;
		  var ipv6_match = hostname.match(wrapped_ipv6);
		  if (ipv6_match) {
		    host = '';
		    ipv6 = ipv6_match[1];
		    port_str = ipv6_match[2] || null;
		  } else {
		    split = hostname.split(':');
		    host = split.shift();
		    if (split.length) {
		      port_str = split.join(':');
		    }
		  }
		  if (port_str !== null && port_str.length > 0) {
		    port = parseInt(port_str, 10);
		    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
		      return false;
		    }
		  } else if (options.require_port) {
		    return false;
		  }
		  if (options.host_whitelist) {
		    return checkHost(host, options.host_whitelist);
		  }
		  if (host === '' && !options.require_host) {
		    return true;
		  }
		  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
		    return false;
		  }
		  host = host || ipv6;
		  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
		    return false;
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isURL, isURL.exports));

	var isURLExports = isURL.exports;

	var isMACAddress = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMACAddress;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
		var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
		var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
		var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
		var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
		var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
		function isMACAddress(str, options) {
		  (0, _assertString.default)(str);
		  if (options !== null && options !== void 0 && options.eui) {
		    options.eui = String(options.eui);
		  }
		  /**
		   * @deprecated `no_colons` TODO: remove it in the next major
		  */
		  if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {
		    if (options.eui === '48') {
		      return macAddress48NoSeparators.test(str);
		    }
		    if (options.eui === '64') {
		      return macAddress64NoSeparators.test(str);
		    }
		    return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);
		  }
		  if ((options === null || options === void 0 ? void 0 : options.eui) === '48') {
		    return macAddress48.test(str) || macAddress48WithDots.test(str);
		  }
		  if ((options === null || options === void 0 ? void 0 : options.eui) === '64') {
		    return macAddress64.test(str) || macAddress64WithDots.test(str);
		  }
		  return isMACAddress(str, {
		    eui: '48'
		  }) || isMACAddress(str, {
		    eui: '64'
		  });
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMACAddress, isMACAddress.exports));

	var isMACAddressExports = isMACAddress.exports;

	var isIPRange = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIPRange;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _isIP = _interopRequireDefault(isIPExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var subnetMaybe = /^\d{1,3}$/;
		var v4Subnet = 32;
		var v6Subnet = 128;
		function isIPRange(str) {
		  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
		  (0, _assertString.default)(str);
		  var parts = str.split('/');

		  // parts[0] -> ip, parts[1] -> subnet
		  if (parts.length !== 2) {
		    return false;
		  }
		  if (!subnetMaybe.test(parts[1])) {
		    return false;
		  }

		  // Disallow preceding 0 i.e. 01, 02, ...
		  if (parts[1].length > 1 && parts[1].startsWith('0')) {
		    return false;
		  }
		  var isValidIP = (0, _isIP.default)(parts[0], version);
		  if (!isValidIP) {
		    return false;
		  }

		  // Define valid subnet according to IP's version
		  var expectedSubnet = null;
		  switch (String(version)) {
		    case '4':
		      expectedSubnet = v4Subnet;
		      break;
		    case '6':
		      expectedSubnet = v6Subnet;
		      break;
		    default:
		      expectedSubnet = (0, _isIP.default)(parts[0], '6') ? v6Subnet : v4Subnet;
		  }
		  return parts[1] <= expectedSubnet && parts[1] >= 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIPRange, isIPRange.exports));

	var isIPRangeExports = isIPRange.exports;

	var isDate = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isDate;
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
		function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
		function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
		function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
		function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
		function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
		var default_date_options = {
		  format: 'YYYY/MM/DD',
		  delimiters: ['/', '-'],
		  strictMode: false
		};
		function isValidFormat(format) {
		  return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format);
		}
		function zip(date, format) {
		  var zippedArr = [],
		    len = Math.min(date.length, format.length);
		  for (var i = 0; i < len; i++) {
		    zippedArr.push([date[i], format[i]]);
		  }
		  return zippedArr;
		}
		function isDate(input, options) {
		  if (typeof options === 'string') {
		    // Allow backward compatibility for old format isDate(input [, format])
		    options = (0, _merge.default)({
		      format: options
		    }, default_date_options);
		  } else {
		    options = (0, _merge.default)(options, default_date_options);
		  }
		  if (typeof input === 'string' && isValidFormat(options.format)) {
		    var formatDelimiter = options.delimiters.find(function (delimiter) {
		      return options.format.indexOf(delimiter) !== -1;
		    });
		    var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function (delimiter) {
		      return input.indexOf(delimiter) !== -1;
		    });
		    var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));
		    var dateObj = {};
		    var _iterator = _createForOfIteratorHelper(dateAndFormat),
		      _step;
		    try {
		      for (_iterator.s(); !(_step = _iterator.n()).done;) {
		        var _step$value = _slicedToArray(_step.value, 2),
		          dateWord = _step$value[0],
		          formatWord = _step$value[1];
		        if (dateWord.length !== formatWord.length) {
		          return false;
		        }
		        dateObj[formatWord.charAt(0)] = dateWord;
		      }
		    } catch (err) {
		      _iterator.e(err);
		    } finally {
		      _iterator.f();
		    }
		    var fullYear = dateObj.y;

		    // Check if the year starts with a hyphen
		    if (fullYear.startsWith('-')) {
		      return false; // Hyphen before year is not allowed
		    }
		    if (dateObj.y.length === 2) {
		      var parsedYear = parseInt(dateObj.y, 10);
		      if (isNaN(parsedYear)) {
		        return false;
		      }
		      var currentYearLastTwoDigits = new Date().getFullYear() % 100;
		      if (parsedYear < currentYearLastTwoDigits) {
		        fullYear = "20".concat(dateObj.y);
		      } else {
		        fullYear = "19".concat(dateObj.y);
		      }
		    }
		    var month = dateObj.m;
		    if (dateObj.m.length === 1) {
		      month = "0".concat(dateObj.m);
		    }
		    var day = dateObj.d;
		    if (dateObj.d.length === 1) {
		      day = "0".concat(dateObj.d);
		    }
		    return new Date("".concat(fullYear, "-").concat(month, "-").concat(day, "T00:00:00.000Z")).getUTCDate() === +dateObj.d;
		  }
		  if (!options.strictMode) {
		    return Object.prototype.toString.call(input) === '[object Date]' && isFinite(input);
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isDate, isDate.exports));

	var isDateExports = isDate.exports;

	var isTime = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isTime;
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var default_time_options = {
		  hourFormat: 'hour24',
		  mode: 'default'
		};
		var formats = {
		  hour24: {
		    default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
		    withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
		  },
		  hour12: {
		    default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
		    withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
		  }
		};
		function isTime(input, options) {
		  options = (0, _merge.default)(options, default_time_options);
		  if (typeof input !== 'string') return false;
		  return formats[options.hourFormat][options.mode].test(input);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isTime, isTime.exports));

	var isTimeExports = isTime.exports;

	var isBoolean = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBoolean;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var defaultOptions = {
		  loose: false
		};
		var strictBooleans = ['true', 'false', '1', '0'];
		var looseBooleans = [].concat(strictBooleans, ['yes', 'no']);
		function isBoolean(str) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
		  (0, _assertString.default)(str);
		  if (options.loose) {
		    return looseBooleans.includes(str.toLowerCase());
		  }
		  return strictBooleans.includes(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBoolean, isBoolean.exports));

	var isBooleanExports = isBoolean.exports;

	var isLocale = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLocale;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/*
		  = 3ALPHA              ; selected ISO 639 codes
		    *2("-" 3ALPHA)      ; permanently reserved
		 */
		var extlang = '([A-Za-z]{3}(-[A-Za-z]{3}){0,2})';

		/*
		  = 2*3ALPHA            ; shortest ISO 639 code
		    ["-" extlang]       ; sometimes followed by
		                        ; extended language subtags
		  / 4ALPHA              ; or reserved for future use
		  / 5*8ALPHA            ; or registered language subtag
		 */
		var language = "(([a-zA-Z]{2,3}(-".concat(extlang, ")?)|([a-zA-Z]{5,8}))");

		/*
		  = 4ALPHA              ; ISO 15924 code
		 */
		var script = '([A-Za-z]{4})';

		/*
		  = 2ALPHA              ; ISO 3166-1 code
		  / 3DIGIT              ; UN M.49 code
		 */
		var region = '([A-Za-z]{2}|\\d{3})';

		/*
		  = 5*8alphanum         ; registered variants
		  / (DIGIT 3alphanum)
		 */
		var variant = '([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))';

		/*
		  = DIGIT               ; 0 - 9
		  / %x41-57             ; A - W
		  / %x59-5A             ; Y - Z
		  / %x61-77             ; a - w
		  / %x79-7A             ; y - z
		 */
		var singleton = '(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])';

		/*
		  = singleton 1*("-" (2*8alphanum))
		                        ; Single alphanumerics
		                        ; "x" reserved for private use
		 */
		var extension = "(".concat(singleton, "(-[A-Za-z0-9]{2,8})+)");

		/*
		  = "x" 1*("-" (1*8alphanum))
		 */
		var privateuse = '(x(-[A-Za-z0-9]{1,8})+)';

		// irregular tags do not match the 'langtag' production and would not
		// otherwise be considered 'well-formed'. These tags are all valid, but
		// most are deprecated in favor of more modern subtags or subtag combination

		var irregular = '((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|' + '(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|' + '(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))';

		// regular tags match the 'langtag' production, but their subtags are not
		// extended language or variant subtags: their meaning is defined by
		// their registration and all of these are deprecated in favor of a more
		// modern subtag or sequence of subtags

		var regular = '((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|' + '(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))';

		/*
		  = irregular           ; non-redundant tags registered
		  / regular             ; during the RFC 3066 era

		 */
		var grandfathered = "(".concat(irregular, "|").concat(regular, ")");

		/*
		  RFC 5646 defines delimitation of subtags via a hyphen:

		      "Subtag" refers to a specific section of a tag, delimited by a
		      hyphen, such as the subtags 'zh', 'Hant', and 'CN' in the tag "zh-
		      Hant-CN".  Examples of subtags in this document are enclosed in
		      single quotes ('Hant')

		  However, we need to add "_" to maintain the existing behaviour.
		 */
		var delimiter = '(-|_)';

		/*
		  = language
		    ["-" script]
		    ["-" region]
		    *("-" variant)
		    *("-" extension)
		    ["-" privateuse]
		 */
		var langtag = "".concat(language, "(").concat(delimiter).concat(script, ")?(").concat(delimiter).concat(region, ")?(").concat(delimiter).concat(variant, ")*(").concat(delimiter).concat(extension, ")*(").concat(delimiter).concat(privateuse, ")?");

		/*
		  Regex implementation based on BCP RFC 5646
		  Tags for Identifying Languages
		  https://www.rfc-editor.org/rfc/rfc5646.html
		 */
		var languageTagRegex = new RegExp("(^".concat(privateuse, "$)|(^").concat(grandfathered, "$)|(^").concat(langtag, "$)"));
		function isLocale(str) {
		  (0, _assertString.default)(str);
		  return languageTagRegex.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLocale, isLocale.exports));

	var isLocaleExports = isLocale.exports;

	var isAbaRouting = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isAbaRouting;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		// http://www.brainjar.com/js/validation/
		// https://www.aba.com/news-research/research-analysis/routing-number-policy-procedures
		// series reserved for future use are excluded
		var isRoutingReg = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;
		function isAbaRouting(str) {
		  (0, _assertString.default)(str);
		  if (!isRoutingReg.test(str)) return false;
		  var checkSumVal = 0;
		  for (var i = 0; i < str.length; i++) {
		    if (i % 3 === 0) checkSumVal += str[i] * 3;else if (i % 3 === 1) checkSumVal += str[i] * 7;else checkSumVal += str[i] * 1;
		  }
		  return checkSumVal % 10 === 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isAbaRouting, isAbaRouting.exports));

	var isAbaRoutingExports = isAbaRouting.exports;

	var isAlpha$1 = {};

	Object.defineProperty(isAlpha$1, "__esModule", {
	  value: true
	});
	isAlpha$1.default = isAlpha;
	isAlpha$1.locales = void 0;
	var _assertString$a = _interopRequireDefault$a(assertStringExports);
	var _alpha$1 = alpha$1;
	function _interopRequireDefault$a(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function isAlpha(_str) {
	  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  (0, _assertString$a.default)(_str);
	  var str = _str;
	  var ignore = options.ignore;
	  if (ignore) {
	    if (ignore instanceof RegExp) {
	      str = str.replace(ignore, '');
	    } else if (typeof ignore === 'string') {
	      str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&'), "]"), 'g'), ''); // escape regex for ignore
	    } else {
	      throw new Error('ignore should be instance of a String or RegExp');
	    }
	  }
	  if (locale in _alpha$1.alpha) {
	    return _alpha$1.alpha[locale].test(str);
	  }
	  throw new Error("Invalid locale '".concat(locale, "'"));
	}
	isAlpha$1.locales = Object.keys(_alpha$1.alpha);

	var isAlphanumeric$1 = {};

	Object.defineProperty(isAlphanumeric$1, "__esModule", {
	  value: true
	});
	isAlphanumeric$1.default = isAlphanumeric;
	isAlphanumeric$1.locales = void 0;
	var _assertString$9 = _interopRequireDefault$9(assertStringExports);
	var _alpha = alpha$1;
	function _interopRequireDefault$9(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function isAlphanumeric(_str) {
	  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  (0, _assertString$9.default)(_str);
	  var str = _str;
	  var ignore = options.ignore;
	  if (ignore) {
	    if (ignore instanceof RegExp) {
	      str = str.replace(ignore, '');
	    } else if (typeof ignore === 'string') {
	      str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&'), "]"), 'g'), ''); // escape regex for ignore
	    } else {
	      throw new Error('ignore should be instance of a String or RegExp');
	    }
	  }
	  if (locale in _alpha.alphanumeric) {
	    return _alpha.alphanumeric[locale].test(str);
	  }
	  throw new Error("Invalid locale '".concat(locale, "'"));
	}
	isAlphanumeric$1.locales = Object.keys(_alpha.alphanumeric);

	var isNumeric = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isNumeric;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _alpha = alpha$1;
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var numericNoSymbols = /^[0-9]+$/;
		function isNumeric(str, options) {
		  (0, _assertString.default)(str);
		  if (options && options.no_symbols) {
		    return numericNoSymbols.test(str);
		  }
		  return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha.decimal[options.locale] : '.', "])?[0-9]+$")).test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isNumeric, isNumeric.exports));

	var isNumericExports = isNumeric.exports;

	var isPassportNumber = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isPassportNumber;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/**
		 * Reference:
		 * https://en.wikipedia.org/ -- Wikipedia
		 * https://docs.microsoft.com/en-us/microsoft-365/compliance/eu-passport-number -- EU Passport Number
		 * https://countrycode.org/ -- Country Codes
		 */
		var passportRegexByCountryCode = {
		  AM: /^[A-Z]{2}\d{7}$/,
		  // ARMENIA
		  AR: /^[A-Z]{3}\d{6}$/,
		  // ARGENTINA
		  AT: /^[A-Z]\d{7}$/,
		  // AUSTRIA
		  AU: /^[A-Z]\d{7}$/,
		  // AUSTRALIA
		  AZ: /^[A-Z]{1}\d{8}$/,
		  // AZERBAIJAN
		  BE: /^[A-Z]{2}\d{6}$/,
		  // BELGIUM
		  BG: /^\d{9}$/,
		  // BULGARIA
		  BR: /^[A-Z]{2}\d{6}$/,
		  // BRAZIL
		  BY: /^[A-Z]{2}\d{7}$/,
		  // BELARUS
		  CA: /^[A-Z]{2}\d{6}$/,
		  // CANADA
		  CH: /^[A-Z]\d{7}$/,
		  // SWITZERLAND
		  CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
		  // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits
		  CY: /^[A-Z](\d{6}|\d{8})$/,
		  // CYPRUS
		  CZ: /^\d{8}$/,
		  // CZECH REPUBLIC
		  DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
		  // GERMANY
		  DK: /^\d{9}$/,
		  // DENMARK
		  DZ: /^\d{9}$/,
		  // ALGERIA
		  EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
		  // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits
		  ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
		  // SPAIN
		  FI: /^[A-Z]{2}\d{7}$/,
		  // FINLAND
		  FR: /^\d{2}[A-Z]{2}\d{5}$/,
		  // FRANCE
		  GB: /^\d{9}$/,
		  // UNITED KINGDOM
		  GR: /^[A-Z]{2}\d{7}$/,
		  // GREECE
		  HR: /^\d{9}$/,
		  // CROATIA
		  HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
		  // HUNGARY
		  IE: /^[A-Z0-9]{2}\d{7}$/,
		  // IRELAND
		  IN: /^[A-Z]{1}-?\d{7}$/,
		  // INDIA
		  ID: /^[A-C]\d{7}$/,
		  // INDONESIA
		  IR: /^[A-Z]\d{8}$/,
		  // IRAN
		  IS: /^(A)\d{7}$/,
		  // ICELAND
		  IT: /^[A-Z0-9]{2}\d{7}$/,
		  // ITALY
		  JM: /^[Aa]\d{7}$/,
		  // JAMAICA
		  JP: /^[A-Z]{2}\d{7}$/,
		  // JAPAN
		  KR: /^[MS]\d{8}$/,
		  // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]
		  KZ: /^[a-zA-Z]\d{7}$/,
		  // KAZAKHSTAN
		  LI: /^[a-zA-Z]\d{5}$/,
		  // LIECHTENSTEIN
		  LT: /^[A-Z0-9]{8}$/,
		  // LITHUANIA
		  LU: /^[A-Z0-9]{8}$/,
		  // LUXEMBURG
		  LV: /^[A-Z0-9]{2}\d{7}$/,
		  // LATVIA
		  LY: /^[A-Z0-9]{8}$/,
		  // LIBYA
		  MT: /^\d{7}$/,
		  // MALTA
		  MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
		  // MOZAMBIQUE
		  MY: /^[AHK]\d{8}$/,
		  // MALAYSIA
		  MX: /^\d{10,11}$/,
		  // MEXICO
		  NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
		  // NETHERLANDS
		  NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
		  // NEW ZEALAND
		  PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
		  // PHILIPPINES
		  PK: /^[A-Z]{2}\d{7}$/,
		  // PAKISTAN
		  PL: /^[A-Z]{2}\d{7}$/,
		  // POLAND
		  PT: /^[A-Z]\d{6}$/,
		  // PORTUGAL
		  RO: /^\d{8,9}$/,
		  // ROMANIA
		  RU: /^\d{9}$/,
		  // RUSSIAN FEDERATION
		  SE: /^\d{8}$/,
		  // SWEDEN
		  SL: /^(P)[A-Z]\d{7}$/,
		  // SLOVENIA
		  SK: /^[0-9A-Z]\d{7}$/,
		  // SLOVAKIA
		  TH: /^[A-Z]{1,2}\d{6,7}$/,
		  // THAILAND
		  TR: /^[A-Z]\d{8}$/,
		  // TURKEY
		  UA: /^[A-Z]{2}\d{6}$/,
		  // UKRAINE
		  US: /^\d{9}$/,
		  // UNITED STATES
		  ZA: /^[TAMD]\d{8}$/ // SOUTH AFRICA
		};

		/**
		 * Check if str is a valid passport number
		 * relative to provided ISO Country Code.
		 *
		 * @param {string} str
		 * @param {string} countryCode
		 * @return {boolean}
		 */
		function isPassportNumber(str, countryCode) {
		  (0, _assertString.default)(str);
		  /** Remove All Whitespaces, Convert to UPPERCASE */
		  var normalizedStr = str.replace(/\s/g, '').toUpperCase();
		  return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isPassportNumber, isPassportNumber.exports));

	var isPassportNumberExports = isPassportNumber.exports;

	var isPort = {exports: {}};

	var isInt = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isInt;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
		var intLeadingZeroes = /^[-+]?[0-9]+$/;
		function isInt(str, options) {
		  (0, _assertString.default)(str);
		  options = options || {};

		  // Get the regex to use for testing, based on whether
		  // leading zeroes are allowed or not.
		  var regex = options.allow_leading_zeroes === false ? int : intLeadingZeroes;

		  // Check min/max/lt/gt
		  var minCheckPassed = !options.hasOwnProperty('min') || str >= options.min;
		  var maxCheckPassed = !options.hasOwnProperty('max') || str <= options.max;
		  var ltCheckPassed = !options.hasOwnProperty('lt') || str < options.lt;
		  var gtCheckPassed = !options.hasOwnProperty('gt') || str > options.gt;
		  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isInt, isInt.exports));

	var isIntExports = isInt.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isPort;
		var _isInt = _interopRequireDefault(isIntExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isPort(str) {
		  return (0, _isInt.default)(str, {
		    allow_leading_zeroes: false,
		    min: 0,
		    max: 65535
		  });
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isPort, isPort.exports));

	var isPortExports = isPort.exports;

	var isLowercase = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLowercase;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isLowercase(str) {
		  (0, _assertString.default)(str);
		  return str === str.toLowerCase();
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLowercase, isLowercase.exports));

	var isLowercaseExports = isLowercase.exports;

	var isUppercase = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isUppercase;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isUppercase(str) {
		  (0, _assertString.default)(str);
		  return str === str.toUpperCase();
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isUppercase, isUppercase.exports));

	var isUppercaseExports = isUppercase.exports;

	var isIMEI = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIMEI;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var imeiRegexWithoutHypens = /^[0-9]{15}$/;
		var imeiRegexWithHypens = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
		function isIMEI(str, options) {
		  (0, _assertString.default)(str);
		  options = options || {};

		  // default regex for checking imei is the one without hyphens

		  var imeiRegex = imeiRegexWithoutHypens;
		  if (options.allow_hyphens) {
		    imeiRegex = imeiRegexWithHypens;
		  }
		  if (!imeiRegex.test(str)) {
		    return false;
		  }
		  str = str.replace(/-/g, '');
		  var sum = 0,
		    mul = 2,
		    l = 14;
		  for (var i = 0; i < l; i++) {
		    var digit = str.substring(l - i - 1, l - i);
		    var tp = parseInt(digit, 10) * mul;
		    if (tp >= 10) {
		      sum += tp % 10 + 1;
		    } else {
		      sum += tp;
		    }
		    if (mul === 1) {
		      mul += 1;
		    } else {
		      mul -= 1;
		    }
		  }
		  var chk = (10 - sum % 10) % 10;
		  if (chk !== parseInt(str.substring(14, 15), 10)) {
		    return false;
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIMEI, isIMEI.exports));

	var isIMEIExports = isIMEI.exports;

	var isAscii = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isAscii;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/* eslint-disable no-control-regex */
		var ascii = /^[\x00-\x7F]+$/;
		/* eslint-enable no-control-regex */

		function isAscii(str) {
		  (0, _assertString.default)(str);
		  return ascii.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isAscii, isAscii.exports));

	var isAsciiExports = isAscii.exports;

	var isFullWidth$1 = {};

	Object.defineProperty(isFullWidth$1, "__esModule", {
	  value: true
	});
	isFullWidth$1.default = isFullWidth;
	isFullWidth$1.fullWidth = void 0;
	var _assertString$8 = _interopRequireDefault$8(assertStringExports);
	function _interopRequireDefault$8(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	var fullWidth = isFullWidth$1.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
	function isFullWidth(str) {
	  (0, _assertString$8.default)(str);
	  return fullWidth.test(str);
	}

	var isHalfWidth$1 = {};

	Object.defineProperty(isHalfWidth$1, "__esModule", {
	  value: true
	});
	isHalfWidth$1.default = isHalfWidth;
	isHalfWidth$1.halfWidth = void 0;
	var _assertString$7 = _interopRequireDefault$7(assertStringExports);
	function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	var halfWidth = isHalfWidth$1.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
	function isHalfWidth(str) {
	  (0, _assertString$7.default)(str);
	  return halfWidth.test(str);
	}

	var isVariableWidth = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isVariableWidth;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _isFullWidth = isFullWidth$1;
		var _isHalfWidth = isHalfWidth$1;
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isVariableWidth(str) {
		  (0, _assertString.default)(str);
		  return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isVariableWidth, isVariableWidth.exports));

	var isVariableWidthExports = isVariableWidth.exports;

	var isMultibyte = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMultibyte;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/* eslint-disable no-control-regex */
		var multibyte = /[^\x00-\x7F]/;
		/* eslint-enable no-control-regex */

		function isMultibyte(str) {
		  (0, _assertString.default)(str);
		  return multibyte.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMultibyte, isMultibyte.exports));

	var isMultibyteExports = isMultibyte.exports;

	var isSemVer = {exports: {}};

	var multilineRegex = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = multilineRegexp;
		/**
		 * Build RegExp object from an array
		 * of multiple/multi-line regexp parts
		 *
		 * @param {string[]} parts
		 * @param {string} flags
		 * @return {object} - RegExp object
		 */
		function multilineRegexp(parts, flags) {
		  var regexpAsStringLiteral = parts.join('');
		  return new RegExp(regexpAsStringLiteral, flags);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (multilineRegex, multilineRegex.exports));

	var multilineRegexExports = multilineRegex.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isSemVer;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _multilineRegex = _interopRequireDefault(multilineRegexExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/**
		 * Regular Expression to match
		 * semantic versioning (SemVer)
		 * built from multi-line, multi-parts regexp
		 * Reference: https://semver.org/
		 */
		var semanticVersioningRegex = (0, _multilineRegex.default)(['^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)', '(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))', '?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$'], 'i');
		function isSemVer(str) {
		  (0, _assertString.default)(str);
		  return semanticVersioningRegex.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isSemVer, isSemVer.exports));

	var isSemVerExports = isSemVer.exports;

	var isSurrogatePair = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isSurrogatePair;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
		function isSurrogatePair(str) {
		  (0, _assertString.default)(str);
		  return surrogatePair.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isSurrogatePair, isSurrogatePair.exports));

	var isSurrogatePairExports = isSurrogatePair.exports;

	var isDecimal = {exports: {}};

	var includes = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;
		var includes = function includes(arr, val) {
		  return arr.some(function (arrVal) {
		    return val === arrVal;
		  });
		};
		exports.default = includes;
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (includes, includes.exports));

	var includesExports = includes.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isDecimal;
		var _merge = _interopRequireDefault(mergeExports);
		var _assertString = _interopRequireDefault(assertStringExports);
		var _includes = _interopRequireDefault(includesExports);
		var _alpha = alpha$1;
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function decimalRegExp(options) {
		  var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? '' : '?', "$"));
		  return regExp;
		}
		var default_decimal_options = {
		  force_decimal: false,
		  decimal_digits: '1,',
		  locale: 'en-US'
		};
		var blacklist = ['', '-', '+'];
		function isDecimal(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_decimal_options);
		  if (options.locale in _alpha.decimal) {
		    return !(0, _includes.default)(blacklist, str.replace(/ /g, '')) && decimalRegExp(options).test(str);
		  }
		  throw new Error("Invalid locale '".concat(options.locale, "'"));
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isDecimal, isDecimal.exports));

	var isDecimalExports = isDecimal.exports;

	var isHexadecimal = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isHexadecimal;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
		function isHexadecimal(str) {
		  (0, _assertString.default)(str);
		  return hexadecimal.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isHexadecimal, isHexadecimal.exports));

	var isHexadecimalExports = isHexadecimal.exports;

	var isOctal = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isOctal;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var octal = /^(0o)?[0-7]+$/i;
		function isOctal(str) {
		  (0, _assertString.default)(str);
		  return octal.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isOctal, isOctal.exports));

	var isOctalExports = isOctal.exports;

	var isDivisibleBy = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isDivisibleBy;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _toFloat = _interopRequireDefault(toFloatExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isDivisibleBy(str, num) {
		  (0, _assertString.default)(str);
		  return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isDivisibleBy, isDivisibleBy.exports));

	var isDivisibleByExports = isDivisibleBy.exports;

	var isHexColor = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isHexColor;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
		function isHexColor(str) {
		  (0, _assertString.default)(str);
		  return hexcolor.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isHexColor, isHexColor.exports));

	var isHexColorExports = isHexColor.exports;

	var isRgbColor = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isRgbColor;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
		var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
		var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
		var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
		function isRgbColor(str) {
		  var includePercentValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
		  (0, _assertString.default)(str);
		  if (!includePercentValues) {
		    return rgbColor.test(str) || rgbaColor.test(str);
		  }
		  return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isRgbColor, isRgbColor.exports));

	var isRgbColorExports = isRgbColor.exports;

	var isHSL = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isHSL;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
		var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
		function isHSL(str) {
		  (0, _assertString.default)(str);

		  // Strip duplicate spaces before calling the validation regex (See  #1598 for more info)
		  var strippedStr = str.replace(/\s+/g, ' ').replace(/\s?(hsla?\(|\)|,)\s?/ig, '$1');
		  if (strippedStr.indexOf(',') !== -1) {
		    return hslComma.test(strippedStr);
		  }
		  return hslSpace.test(strippedStr);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isHSL, isHSL.exports));

	var isHSLExports = isHSL.exports;

	var isISRC = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISRC;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		// see http://isrc.ifpi.org/en/isrc-standard/code-syntax
		var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
		function isISRC(str) {
		  (0, _assertString.default)(str);
		  return isrc.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISRC, isISRC.exports));

	var isISRCExports = isISRC.exports;

	var isIBAN$1 = {};

	Object.defineProperty(isIBAN$1, "__esModule", {
	  value: true
	});
	isIBAN$1.default = isIBAN;
	isIBAN$1.locales = void 0;
	var _assertString$6 = _interopRequireDefault$6(assertStringExports);
	function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	/**
	 * List of country codes with
	 * corresponding IBAN regular expression
	 * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
	 */
	var ibanRegexThroughCountryCode = {
	  AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
	  AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
	  AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
	  AT: /^(AT[0-9]{2})\d{16}$/,
	  AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
	  BA: /^(BA[0-9]{2})\d{16}$/,
	  BE: /^(BE[0-9]{2})\d{12}$/,
	  BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
	  BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
	  BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
	  BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
	  CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
	  CR: /^(CR[0-9]{2})\d{18}$/,
	  CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
	  CZ: /^(CZ[0-9]{2})\d{20}$/,
	  DE: /^(DE[0-9]{2})\d{18}$/,
	  DK: /^(DK[0-9]{2})\d{14}$/,
	  DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
	  DZ: /^(DZ\d{24})$/,
	  EE: /^(EE[0-9]{2})\d{16}$/,
	  EG: /^(EG[0-9]{2})\d{25}$/,
	  ES: /^(ES[0-9]{2})\d{20}$/,
	  FI: /^(FI[0-9]{2})\d{14}$/,
	  FO: /^(FO[0-9]{2})\d{14}$/,
	  FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
	  GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
	  GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
	  GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
	  GL: /^(GL[0-9]{2})\d{14}$/,
	  GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
	  GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
	  HR: /^(HR[0-9]{2})\d{17}$/,
	  HU: /^(HU[0-9]{2})\d{24}$/,
	  IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
	  IL: /^(IL[0-9]{2})\d{19}$/,
	  IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
	  IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
	  IS: /^(IS[0-9]{2})\d{22}$/,
	  IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
	  JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
	  KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
	  KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
	  LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
	  LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
	  LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
	  LT: /^(LT[0-9]{2})\d{16}$/,
	  LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
	  LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
	  MA: /^(MA[0-9]{26})$/,
	  MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
	  MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
	  ME: /^(ME[0-9]{2})\d{18}$/,
	  MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
	  MR: /^(MR[0-9]{2})\d{23}$/,
	  MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
	  MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
	  MZ: /^(MZ[0-9]{2})\d{21}$/,
	  NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
	  NO: /^(NO[0-9]{2})\d{11}$/,
	  PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
	  PL: /^(PL[0-9]{2})\d{24}$/,
	  PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
	  PT: /^(PT[0-9]{2})\d{21}$/,
	  QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
	  RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
	  RS: /^(RS[0-9]{2})\d{18}$/,
	  SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
	  SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
	  SE: /^(SE[0-9]{2})\d{20}$/,
	  SI: /^(SI[0-9]{2})\d{15}$/,
	  SK: /^(SK[0-9]{2})\d{20}$/,
	  SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
	  SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
	  TL: /^(TL[0-9]{2})\d{19}$/,
	  TN: /^(TN[0-9]{2})\d{20}$/,
	  TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
	  UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
	  VA: /^(VA[0-9]{2})\d{18}$/,
	  VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
	  XK: /^(XK[0-9]{2})\d{16}$/
	};

	/**
	 * Check if the country codes passed are valid using the
	 * ibanRegexThroughCountryCode as a reference
	 *
	 * @param {array} countryCodeArray
	 * @return {boolean}
	 */

	function hasOnlyValidCountryCodes(countryCodeArray) {
	  var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function (countryCode) {
	    return !(countryCode in ibanRegexThroughCountryCode);
	  });
	  if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
	    return false;
	  }
	  return true;
	}

	/**
	 * Check whether string has correct universal IBAN format
	 * The IBAN consists of up to 34 alphanumeric characters, as follows:
	 * Country Code using ISO 3166-1 alpha-2, two letters
	 * check digits, two digits and
	 * Basic Bank Account Number (BBAN), up to 30 alphanumeric characters.
	 * NOTE: Permitted IBAN characters are: digits [0-9] and the 26 latin alphabetic [A-Z]
	 *
	 * @param {string} str - string under validation
	 * @param {object} options - object to pass the countries to be either whitelisted or blacklisted
	 * @return {boolean}
	 */
	function hasValidIbanFormat(str, options) {
	  // Strip white spaces and hyphens
	  var strippedStr = str.replace(/[\s\-]+/gi, '').toUpperCase();
	  var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
	  var isoCountryCodeInIbanRegexCodeObject = (isoCountryCode in ibanRegexThroughCountryCode);
	  if (options.whitelist) {
	    if (!hasOnlyValidCountryCodes(options.whitelist)) {
	      return false;
	    }
	    var isoCountryCodeInWhiteList = options.whitelist.includes(isoCountryCode);
	    if (!isoCountryCodeInWhiteList) {
	      return false;
	    }
	  }
	  if (options.blacklist) {
	    var isoCountryCodeInBlackList = options.blacklist.includes(isoCountryCode);
	    if (isoCountryCodeInBlackList) {
	      return false;
	    }
	  }
	  return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
	}

	/**
	   * Check whether string has valid IBAN Checksum
	   * by performing basic mod-97 operation and
	   * the remainder should equal 1
	   * -- Start by rearranging the IBAN by moving the four initial characters to the end of the string
	   * -- Replace each letter in the string with two digits, A -> 10, B = 11, Z = 35
	   * -- Interpret the string as a decimal integer and
	   * -- compute the remainder on division by 97 (mod 97)
	   * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
	   *
	   * @param {string} str
	   * @return {boolean}
	   */
	function hasValidIbanChecksum(str) {
	  var strippedStr = str.replace(/[^A-Z0-9]+/gi, '').toUpperCase(); // Keep only digits and A-Z latin alphabetic
	  var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
	  var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function (char) {
	    return char.charCodeAt(0) - 55;
	  });
	  var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function (acc, value) {
	    return Number(acc + value) % 97;
	  }, '');
	  return remainder === 1;
	}
	function isIBAN(str) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  (0, _assertString$6.default)(str);
	  return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);
	}
	isIBAN$1.locales = Object.keys(ibanRegexThroughCountryCode);

	var isBIC = {exports: {}};

	var isISO31661Alpha2$1 = {};

	Object.defineProperty(isISO31661Alpha2$1, "__esModule", {
	  value: true
	});
	isISO31661Alpha2$1.CountryCodes = void 0;
	isISO31661Alpha2$1.default = isISO31661Alpha2;
	var _assertString$5 = _interopRequireDefault$5(assertStringExports);
	function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	var validISO31661Alpha2CountriesCodes = new Set(['AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ', 'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ', 'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ', 'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ', 'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET', 'FI', 'FJ', 'FK', 'FM', 'FO', 'FR', 'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY', 'HK', 'HM', 'HN', 'HR', 'HT', 'HU', 'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT', 'JE', 'JM', 'JO', 'JP', 'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ', 'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY', 'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ', 'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ', 'OM', 'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY', 'QA', 'RE', 'RO', 'RS', 'RU', 'RW', 'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ', 'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ', 'UA', 'UG', 'UM', 'US', 'UY', 'UZ', 'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU', 'WF', 'WS', 'YE', 'YT', 'ZA', 'ZM', 'ZW']);
	function isISO31661Alpha2(str) {
	  (0, _assertString$5.default)(str);
	  return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());
	}
	isISO31661Alpha2$1.CountryCodes = validISO31661Alpha2CountriesCodes;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBIC;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _isISO31661Alpha = isISO31661Alpha2$1;
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		// https://en.wikipedia.org/wiki/ISO_9362
		var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
		function isBIC(str) {
		  (0, _assertString.default)(str);

		  // toUpperCase() should be removed when a new major version goes out that changes
		  // the regex to [A-Z] (per the spec).
		  var countryCode = str.slice(4, 6).toUpperCase();
		  if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== 'XK') {
		    return false;
		  }
		  return isBICReg.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBIC, isBIC.exports));

	var isBICExports = isBIC.exports;

	var isMD5 = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMD5;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var md5 = /^[a-f0-9]{32}$/;
		function isMD5(str) {
		  (0, _assertString.default)(str);
		  return md5.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMD5, isMD5.exports));

	var isMD5Exports = isMD5.exports;

	var isHash = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isHash;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var lengths = {
		  md5: 32,
		  md4: 32,
		  sha1: 40,
		  sha256: 64,
		  sha384: 96,
		  sha512: 128,
		  ripemd128: 32,
		  ripemd160: 40,
		  tiger128: 32,
		  tiger160: 40,
		  tiger192: 48,
		  crc32: 8,
		  crc32b: 8
		};
		function isHash(str, algorithm) {
		  (0, _assertString.default)(str);
		  var hash = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
		  return hash.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isHash, isHash.exports));

	var isHashExports = isHash.exports;

	var isJWT = {exports: {}};

	var isBase64 = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBase64;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var notBase64 = /[^A-Z0-9+\/=]/i;
		var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
		var defaultBase64Options = {
		  urlSafe: false
		};
		function isBase64(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, defaultBase64Options);
		  var len = str.length;
		  if (options.urlSafe) {
		    return urlSafeBase64.test(str);
		  }
		  if (len % 4 !== 0 || notBase64.test(str)) {
		    return false;
		  }
		  var firstPaddingChar = str.indexOf('=');
		  return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBase64, isBase64.exports));

	var isBase64Exports = isBase64.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isJWT;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _isBase = _interopRequireDefault(isBase64Exports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isJWT(str) {
		  (0, _assertString.default)(str);
		  var dotSplit = str.split('.');
		  var len = dotSplit.length;
		  if (len !== 3) {
		    return false;
		  }
		  return dotSplit.reduce(function (acc, currElem) {
		    return acc && (0, _isBase.default)(currElem, {
		      urlSafe: true
		    });
		  }, true);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isJWT, isJWT.exports));

	var isJWTExports = isJWT.exports;

	var isJSON = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isJSON;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		var default_json_options = {
		  allow_primitives: false
		};
		function isJSON(str, options) {
		  (0, _assertString.default)(str);
		  try {
		    options = (0, _merge.default)(options, default_json_options);
		    var primitives = [];
		    if (options.allow_primitives) {
		      primitives = [null, false, true];
		    }
		    var obj = JSON.parse(str);
		    return primitives.includes(obj) || !!obj && _typeof(obj) === 'object';
		  } catch (e) {/* ignore */}
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isJSON, isJSON.exports));

	var isJSONExports = isJSON.exports;

	var isEmpty = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isEmpty;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var default_is_empty_options = {
		  ignore_whitespace: false
		};
		function isEmpty(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_is_empty_options);
		  return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isEmpty, isEmpty.exports));

	var isEmptyExports = isEmpty.exports;

	var isLength = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLength;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		/* eslint-disable prefer-rest-params */
		function isLength(str, options) {
		  (0, _assertString.default)(str);
		  var min;
		  var max;
		  if (_typeof(options) === 'object') {
		    min = options.min || 0;
		    max = options.max;
		  } else {
		    // backwards compatibility: isLength(str, min [, max])
		    min = arguments[1] || 0;
		    max = arguments[2];
		  }
		  var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
		  var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
		  var len = str.length - presentationSequences.length - surrogatePairs.length;
		  return len >= min && (typeof max === 'undefined' || len <= max);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLength, isLength.exports));

	var isLengthExports = isLength.exports;

	var isUUID = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isUUID;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var uuid = {
		  1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
		  2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
		  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
		  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
		};
		function isUUID(str, version) {
		  (0, _assertString.default)(str);
		  var pattern = uuid[![undefined, null].includes(version) ? version : 'all'];
		  return !!pattern && pattern.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isUUID, isUUID.exports));

	var isUUIDExports = isUUID.exports;

	var isMongoId = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMongoId;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _isHexadecimal = _interopRequireDefault(isHexadecimalExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isMongoId(str) {
		  (0, _assertString.default)(str);
		  return (0, _isHexadecimal.default)(str) && str.length === 24;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMongoId, isMongoId.exports));

	var isMongoIdExports = isMongoId.exports;

	var isAfter = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isAfter;
		var _toDate = _interopRequireDefault(toDateExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isAfter(date, options) {
		  // For backwards compatibility:
		  // isAfter(str [, date]), i.e. `options` could be used as argument for the legacy `date`
		  var comparisonDate = (options === null || options === void 0 ? void 0 : options.comparisonDate) || options || Date().toString();
		  var comparison = (0, _toDate.default)(comparisonDate);
		  var original = (0, _toDate.default)(date);
		  return !!(original && comparison && original > comparison);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isAfter, isAfter.exports));

	var isAfterExports = isAfter.exports;

	var isBefore = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBefore;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _toDate = _interopRequireDefault(toDateExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isBefore(str) {
		  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
		  (0, _assertString.default)(str);
		  var comparison = (0, _toDate.default)(date);
		  var original = (0, _toDate.default)(str);
		  return !!(original && comparison && original < comparison);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBefore, isBefore.exports));

	var isBeforeExports = isBefore.exports;

	var isIn = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIn;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _toString = _interopRequireDefault(toStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		function isIn(str, options) {
		  (0, _assertString.default)(str);
		  var i;
		  if (Object.prototype.toString.call(options) === '[object Array]') {
		    var array = [];
		    for (i in options) {
		      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
		      // istanbul ignore else
		      if ({}.hasOwnProperty.call(options, i)) {
		        array[i] = (0, _toString.default)(options[i]);
		      }
		    }
		    return array.indexOf(str) >= 0;
		  } else if (_typeof(options) === 'object') {
		    return options.hasOwnProperty(str);
		  } else if (options && typeof options.indexOf === 'function') {
		    return options.indexOf(str) >= 0;
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIn, isIn.exports));

	var isInExports = isIn.exports;

	var isLuhnNumber = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLuhnNumber;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isLuhnNumber(str) {
		  (0, _assertString.default)(str);
		  var sanitized = str.replace(/[- ]+/g, '');
		  var sum = 0;
		  var digit;
		  var tmpNum;
		  var shouldDouble;
		  for (var i = sanitized.length - 1; i >= 0; i--) {
		    digit = sanitized.substring(i, i + 1);
		    tmpNum = parseInt(digit, 10);
		    if (shouldDouble) {
		      tmpNum *= 2;
		      if (tmpNum >= 10) {
		        sum += tmpNum % 10 + 1;
		      } else {
		        sum += tmpNum;
		      }
		    } else {
		      sum += tmpNum;
		    }
		    shouldDouble = !shouldDouble;
		  }
		  return !!(sum % 10 === 0 ? sanitized : false);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLuhnNumber, isLuhnNumber.exports));

	var isLuhnNumberExports = isLuhnNumber.exports;

	var isCreditCard = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isCreditCard;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _isLuhnNumber = _interopRequireDefault(isLuhnNumberExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var cards = {
		  amex: /^3[47][0-9]{13}$/,
		  dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
		  discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
		  jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
		  mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
		  // /^[25][1-7][0-9]{14}$/;
		  unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
		  visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
		};
		var allCards = function () {
		  var tmpCardsArray = [];
		  for (var cardProvider in cards) {
		    // istanbul ignore else
		    if (cards.hasOwnProperty(cardProvider)) {
		      tmpCardsArray.push(cards[cardProvider]);
		    }
		  }
		  return tmpCardsArray;
		}();
		function isCreditCard(card) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		  (0, _assertString.default)(card);
		  var provider = options.provider;
		  var sanitized = card.replace(/[- ]+/g, '');
		  if (provider && provider.toLowerCase() in cards) {
		    // specific provider in the list
		    if (!cards[provider.toLowerCase()].test(sanitized)) {
		      return false;
		    }
		  } else if (provider && !(provider.toLowerCase() in cards)) {
		    /* specific provider not in the list */
		    throw new Error("".concat(provider, " is not a valid credit card provider."));
		  } else if (!allCards.some(function (cardProvider) {
		    return cardProvider.test(sanitized);
		  })) {
		    // no specific provider
		    return false;
		  }
		  return (0, _isLuhnNumber.default)(card);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isCreditCard, isCreditCard.exports));

	var isCreditCardExports = isCreditCard.exports;

	var isIdentityCard = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIdentityCard;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _isInt = _interopRequireDefault(isIntExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var validators = {
		  PL: function PL(str) {
		    (0, _assertString.default)(str);
		    var weightOfDigits = {
		      1: 1,
		      2: 3,
		      3: 7,
		      4: 9,
		      5: 1,
		      6: 3,
		      7: 7,
		      8: 9,
		      9: 1,
		      10: 3,
		      11: 0
		    };
		    if (str != null && str.length === 11 && (0, _isInt.default)(str, {
		      allow_leading_zeroes: true
		    })) {
		      var digits = str.split('').slice(0, -1);
		      var sum = digits.reduce(function (acc, digit, index) {
		        return acc + Number(digit) * weightOfDigits[index + 1];
		      }, 0);
		      var modulo = sum % 10;
		      var lastDigit = Number(str.charAt(str.length - 1));
		      if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
		        return true;
		      }
		    }
		    return false;
		  },
		  ES: function ES(str) {
		    (0, _assertString.default)(str);
		    var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
		    var charsValue = {
		      X: 0,
		      Y: 1,
		      Z: 2
		    };
		    var controlDigits = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E'];

		    // sanitize user input
		    var sanitized = str.trim().toUpperCase();

		    // validate the data structure
		    if (!DNI.test(sanitized)) {
		      return false;
		    }

		    // validate the control digit
		    var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function (char) {
		      return charsValue[char];
		    });
		    return sanitized.endsWith(controlDigits[number % 23]);
		  },
		  FI: function FI(str) {
		    // https://dvv.fi/en/personal-identity-code#:~:text=control%20character%20for%20a-,personal,-identity%20code%20calculated
		    (0, _assertString.default)(str);
		    if (str.length !== 11) {
		      return false;
		    }
		    if (!str.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
		      return false;
		    }
		    var checkDigits = '0123456789ABCDEFHJKLMNPRSTUVWXY';
		    var idAsNumber = parseInt(str.slice(0, 6), 10) * 1000 + parseInt(str.slice(7, 10), 10);
		    var remainder = idAsNumber % 31;
		    var checkDigit = checkDigits[remainder];
		    return checkDigit === str.slice(10, 11);
		  },
		  IN: function IN(str) {
		    var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;

		    // multiplication table
		    var d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];

		    // permutation table
		    var p = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];

		    // sanitize user input
		    var sanitized = str.trim();

		    // validate the data structure
		    if (!DNI.test(sanitized)) {
		      return false;
		    }
		    var c = 0;
		    var invertedArray = sanitized.replace(/\s/g, '').split('').map(Number).reverse();
		    invertedArray.forEach(function (val, i) {
		      c = d[c][p[i % 8][val]];
		    });
		    return c === 0;
		  },
		  IR: function IR(str) {
		    if (!str.match(/^\d{10}$/)) return false;
		    str = "0000".concat(str).slice(str.length - 6);
		    if (parseInt(str.slice(3, 9), 10) === 0) return false;
		    var lastNumber = parseInt(str.slice(9, 10), 10);
		    var sum = 0;
		    for (var i = 0; i < 9; i++) {
		      sum += parseInt(str.slice(i, i + 1), 10) * (10 - i);
		    }
		    sum %= 11;
		    return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;
		  },
		  IT: function IT(str) {
		    if (str.length !== 9) return false;
		    if (str === 'CA00000AA') return false; // https://it.wikipedia.org/wiki/Carta_d%27identit%C3%A0_elettronica_italiana
		    return str.search(/C[A-Z]\d{5}[A-Z]{2}/i) > -1;
		  },
		  NO: function NO(str) {
		    var sanitized = str.trim();
		    if (isNaN(Number(sanitized))) return false;
		    if (sanitized.length !== 11) return false;
		    if (sanitized === '00000000000') return false;

		    // https://no.wikipedia.org/wiki/F%C3%B8dselsnummer
		    var f = sanitized.split('').map(Number);
		    var k1 = (11 - (3 * f[0] + 7 * f[1] + 6 * f[2] + 1 * f[3] + 8 * f[4] + 9 * f[5] + 4 * f[6] + 5 * f[7] + 2 * f[8]) % 11) % 11;
		    var k2 = (11 - (5 * f[0] + 4 * f[1] + 3 * f[2] + 2 * f[3] + 7 * f[4] + 6 * f[5] + 5 * f[6] + 4 * f[7] + 3 * f[8] + 2 * k1) % 11) % 11;
		    if (k1 !== f[9] || k2 !== f[10]) return false;
		    return true;
		  },
		  TH: function TH(str) {
		    if (!str.match(/^[1-8]\d{12}$/)) return false;

		    // validate check digit
		    var sum = 0;
		    for (var i = 0; i < 12; i++) {
		      sum += parseInt(str[i], 10) * (13 - i);
		    }
		    return str[12] === ((11 - sum % 11) % 10).toString();
		  },
		  LK: function LK(str) {
		    var old_nic = /^[1-9]\d{8}[vx]$/i;
		    var new_nic = /^[1-9]\d{11}$/i;
		    if (str.length === 10 && old_nic.test(str)) return true;else if (str.length === 12 && new_nic.test(str)) return true;
		    return false;
		  },
		  'he-IL': function heIL(str) {
		    var DNI = /^\d{9}$/;

		    // sanitize user input
		    var sanitized = str.trim();

		    // validate the data structure
		    if (!DNI.test(sanitized)) {
		      return false;
		    }
		    var id = sanitized;
		    var sum = 0,
		      incNum;
		    for (var i = 0; i < id.length; i++) {
		      incNum = Number(id[i]) * (i % 2 + 1); // Multiply number by 1 or 2
		      sum += incNum > 9 ? incNum - 9 : incNum; // Sum the digits up and add to total
		    }
		    return sum % 10 === 0;
		  },
		  'ar-LY': function arLY(str) {
		    // Libya National Identity Number NIN is 12 digits, the first digit is either 1 or 2
		    var NIN = /^(1|2)\d{11}$/;

		    // sanitize user input
		    var sanitized = str.trim();

		    // validate the data structure
		    if (!NIN.test(sanitized)) {
		      return false;
		    }
		    return true;
		  },
		  'ar-TN': function arTN(str) {
		    var DNI = /^\d{8}$/;

		    // sanitize user input
		    var sanitized = str.trim();

		    // validate the data structure
		    if (!DNI.test(sanitized)) {
		      return false;
		    }
		    return true;
		  },
		  'zh-CN': function zhCN(str) {
		    var provincesAndCities = ['11',
		    // 北京
		    '12',
		    // 天津
		    '13',
		    // 河北
		    '14',
		    // 山西
		    '15',
		    // 内蒙古
		    '21',
		    // 辽宁
		    '22',
		    // 吉林
		    '23',
		    // 黑龙江
		    '31',
		    // 上海
		    '32',
		    // 江苏
		    '33',
		    // 浙江
		    '34',
		    // 安徽
		    '35',
		    // 福建
		    '36',
		    // 江西
		    '37',
		    // 山东
		    '41',
		    // 河南
		    '42',
		    // 湖北
		    '43',
		    // 湖南
		    '44',
		    // 广东
		    '45',
		    // 广西
		    '46',
		    // 海南
		    '50',
		    // 重庆
		    '51',
		    // 四川
		    '52',
		    // 贵州
		    '53',
		    // 云南
		    '54',
		    // 西藏
		    '61',
		    // 陕西
		    '62',
		    // 甘肃
		    '63',
		    // 青海
		    '64',
		    // 宁夏
		    '65',
		    // 新疆
		    '71',
		    // 台湾
		    '81',
		    // 香港
		    '82',
		    // 澳门
		    '91' // 国外
		    ];
		    var powers = ['7', '9', '10', '5', '8', '4', '2', '1', '6', '3', '7', '9', '10', '5', '8', '4', '2'];
		    var parityBit = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];
		    var checkAddressCode = function checkAddressCode(addressCode) {
		      return provincesAndCities.includes(addressCode);
		    };
		    var checkBirthDayCode = function checkBirthDayCode(birDayCode) {
		      var yyyy = parseInt(birDayCode.substring(0, 4), 10);
		      var mm = parseInt(birDayCode.substring(4, 6), 10);
		      var dd = parseInt(birDayCode.substring(6), 10);
		      var xdata = new Date(yyyy, mm - 1, dd);
		      if (xdata > new Date()) {
		        return false;
		        // eslint-disable-next-line max-len
		      } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd) {
		        return true;
		      }
		      return false;
		    };
		    var getParityBit = function getParityBit(idCardNo) {
		      var id17 = idCardNo.substring(0, 17);
		      var power = 0;
		      for (var i = 0; i < 17; i++) {
		        power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);
		      }
		      var mod = power % 11;
		      return parityBit[mod];
		    };
		    var checkParityBit = function checkParityBit(idCardNo) {
		      return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
		    };
		    var check15IdCardNo = function check15IdCardNo(idCardNo) {
		      var check = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
		      if (!check) return false;
		      var addressCode = idCardNo.substring(0, 2);
		      check = checkAddressCode(addressCode);
		      if (!check) return false;
		      var birDayCode = "19".concat(idCardNo.substring(6, 12));
		      check = checkBirthDayCode(birDayCode);
		      if (!check) return false;
		      return true;
		    };
		    var check18IdCardNo = function check18IdCardNo(idCardNo) {
		      var check = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
		      if (!check) return false;
		      var addressCode = idCardNo.substring(0, 2);
		      check = checkAddressCode(addressCode);
		      if (!check) return false;
		      var birDayCode = idCardNo.substring(6, 14);
		      check = checkBirthDayCode(birDayCode);
		      if (!check) return false;
		      return checkParityBit(idCardNo);
		    };
		    var checkIdCardNo = function checkIdCardNo(idCardNo) {
		      var check = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
		      if (!check) return false;
		      if (idCardNo.length === 15) {
		        return check15IdCardNo(idCardNo);
		      }
		      return check18IdCardNo(idCardNo);
		    };
		    return checkIdCardNo(str);
		  },
		  'zh-HK': function zhHK(str) {
		    // sanitize user input
		    str = str.trim();

		    // HKID number starts with 1 or 2 letters, followed by 6 digits,
		    // then a checksum contained in square / round brackets or nothing
		    var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
		    var regexIsDigit = /^[0-9]$/;

		    // convert the user input to all uppercase and apply regex
		    str = str.toUpperCase();
		    if (!regexHKID.test(str)) return false;
		    str = str.replace(/\[|\]|\(|\)/g, '');
		    if (str.length === 8) str = "3".concat(str);
		    var checkSumVal = 0;
		    for (var i = 0; i <= 7; i++) {
		      var convertedChar = void 0;
		      if (!regexIsDigit.test(str[i])) convertedChar = (str[i].charCodeAt(0) - 55) % 11;else convertedChar = str[i];
		      checkSumVal += convertedChar * (9 - i);
		    }
		    checkSumVal %= 11;
		    var checkSumConverted;
		    if (checkSumVal === 0) checkSumConverted = '0';else if (checkSumVal === 1) checkSumConverted = 'A';else checkSumConverted = String(11 - checkSumVal);
		    if (checkSumConverted === str[str.length - 1]) return true;
		    return false;
		  },
		  'zh-TW': function zhTW(str) {
		    var ALPHABET_CODES = {
		      A: 10,
		      B: 11,
		      C: 12,
		      D: 13,
		      E: 14,
		      F: 15,
		      G: 16,
		      H: 17,
		      I: 34,
		      J: 18,
		      K: 19,
		      L: 20,
		      M: 21,
		      N: 22,
		      O: 35,
		      P: 23,
		      Q: 24,
		      R: 25,
		      S: 26,
		      T: 27,
		      U: 28,
		      V: 29,
		      W: 32,
		      X: 30,
		      Y: 31,
		      Z: 33
		    };
		    var sanitized = str.trim().toUpperCase();
		    if (!/^[A-Z][0-9]{9}$/.test(sanitized)) return false;
		    return Array.from(sanitized).reduce(function (sum, number, index) {
		      if (index === 0) {
		        var code = ALPHABET_CODES[number];
		        return code % 10 * 9 + Math.floor(code / 10);
		      }
		      if (index === 9) {
		        return (10 - sum % 10 - Number(number)) % 10 === 0;
		      }
		      return sum + Number(number) * (9 - index);
		    }, 0);
		  }
		};
		function isIdentityCard(str, locale) {
		  (0, _assertString.default)(str);
		  if (locale in validators) {
		    return validators[locale](str);
		  } else if (locale === 'any') {
		    for (var key in validators) {
		      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
		      // istanbul ignore else
		      if (validators.hasOwnProperty(key)) {
		        var validator = validators[key];
		        if (validator(str)) {
		          return true;
		        }
		      }
		    }
		    return false;
		  }
		  throw new Error("Invalid locale '".concat(locale, "'"));
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIdentityCard, isIdentityCard.exports));

	var isIdentityCardExports = isIdentityCard.exports;

	var isEAN = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isEAN;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/**
		 * The most commonly used EAN standard is
		 * the thirteen-digit EAN-13, while the
		 * less commonly used 8-digit EAN-8 barcode was
		 * introduced for use on small packages.
		 * Also EAN/UCC-14 is used for Grouping of individual
		 * trade items above unit level(Intermediate, Carton or Pallet).
		 * For more info about EAN-14 checkout: https://www.gtin.info/itf-14-barcodes/
		 * EAN consists of:
		 * GS1 prefix, manufacturer code, product code and check digit
		 * Reference: https://en.wikipedia.org/wiki/International_Article_Number
		 * Reference: https://www.gtin.info/
		 */

		/**
		 * Define EAN Lenghts; 8 for EAN-8; 13 for EAN-13; 14 for EAN-14
		 * and Regular Expression for valid EANs (EAN-8, EAN-13, EAN-14),
		 * with exact numberic matching of 8 or 13 or 14 digits [0-9]
		 */
		var LENGTH_EAN_8 = 8;
		var LENGTH_EAN_14 = 14;
		var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;

		/**
		 * Get position weight given:
		 * EAN length and digit index/position
		 *
		 * @param {number} length
		 * @param {number} index
		 * @return {number}
		 */
		function getPositionWeightThroughLengthAndIndex(length, index) {
		  if (length === LENGTH_EAN_8 || length === LENGTH_EAN_14) {
		    return index % 2 === 0 ? 3 : 1;
		  }
		  return index % 2 === 0 ? 1 : 3;
		}

		/**
		 * Calculate EAN Check Digit
		 * Reference: https://en.wikipedia.org/wiki/International_Article_Number#Calculation_of_checksum_digit
		 *
		 * @param {string} ean
		 * @return {number}
		 */
		function calculateCheckDigit(ean) {
		  var checksum = ean.slice(0, -1).split('').map(function (char, index) {
		    return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index);
		  }).reduce(function (acc, partialSum) {
		    return acc + partialSum;
		  }, 0);
		  var remainder = 10 - checksum % 10;
		  return remainder < 10 ? remainder : 0;
		}

		/**
		 * Check if string is valid EAN:
		 * Matches EAN-8/EAN-13/EAN-14 regex
		 * Has valid check digit.
		 *
		 * @param {string} str
		 * @return {boolean}
		 */
		function isEAN(str) {
		  (0, _assertString.default)(str);
		  var actualCheckDigit = Number(str.slice(-1));
		  return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isEAN, isEAN.exports));

	var isEANExports = isEAN.exports;

	var isISIN = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISIN;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

		// this link details how the check digit is calculated:
		// https://www.isin.org/isin-format/. it is a little bit
		// odd in that it works with digits, not numbers. in order
		// to make only one pass through the ISIN characters, the
		// each alpha character is handled as 2 characters within
		// the loop.

		function isISIN(str) {
		  (0, _assertString.default)(str);
		  if (!isin.test(str)) {
		    return false;
		  }
		  var double = true;
		  var sum = 0;
		  // convert values
		  for (var i = str.length - 2; i >= 0; i--) {
		    if (str[i] >= 'A' && str[i] <= 'Z') {
		      var value = str[i].charCodeAt(0) - 55;
		      var lo = value % 10;
		      var hi = Math.trunc(value / 10);
		      // letters have two digits, so handle the low order
		      // and high order digits separately.
		      for (var _i = 0, _arr = [lo, hi]; _i < _arr.length; _i++) {
		        var digit = _arr[_i];
		        if (double) {
		          if (digit >= 5) {
		            sum += 1 + (digit - 5) * 2;
		          } else {
		            sum += digit * 2;
		          }
		        } else {
		          sum += digit;
		        }
		        double = !double;
		      }
		    } else {
		      var _digit = str[i].charCodeAt(0) - '0'.charCodeAt(0);
		      if (double) {
		        if (_digit >= 5) {
		          sum += 1 + (_digit - 5) * 2;
		        } else {
		          sum += _digit * 2;
		        }
		      } else {
		        sum += _digit;
		      }
		      double = !double;
		    }
		  }
		  var check = Math.trunc((sum + 9) / 10) * 10 - sum;
		  return +str[str.length - 1] === check;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISIN, isISIN.exports));

	var isISINExports = isISIN.exports;

	var isISBN = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISBN;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
		var possibleIsbn13 = /^(?:[0-9]{13})$/;
		var factor = [1, 3];
		function isISBN(isbn, options) {
		  (0, _assertString.default)(isbn);

		  // For backwards compatibility:
		  // isISBN(str [, version]), i.e. `options` could be used as argument for the legacy `version`
		  var version = String((options === null || options === void 0 ? void 0 : options.version) || options);
		  if (!(options !== null && options !== void 0 && options.version || options)) {
		    return isISBN(isbn, {
		      version: 10
		    }) || isISBN(isbn, {
		      version: 13
		    });
		  }
		  var sanitizedIsbn = isbn.replace(/[\s-]+/g, '');
		  var checksum = 0;
		  if (version === '10') {
		    if (!possibleIsbn10.test(sanitizedIsbn)) {
		      return false;
		    }
		    for (var i = 0; i < version - 1; i++) {
		      checksum += (i + 1) * sanitizedIsbn.charAt(i);
		    }
		    if (sanitizedIsbn.charAt(9) === 'X') {
		      checksum += 10 * 10;
		    } else {
		      checksum += 10 * sanitizedIsbn.charAt(9);
		    }
		    if (checksum % 11 === 0) {
		      return true;
		    }
		  } else if (version === '13') {
		    if (!possibleIsbn13.test(sanitizedIsbn)) {
		      return false;
		    }
		    for (var _i = 0; _i < 12; _i++) {
		      checksum += factor[_i % 2] * sanitizedIsbn.charAt(_i);
		    }
		    if (sanitizedIsbn.charAt(12) - (10 - checksum % 10) % 10 === 0) {
		      return true;
		    }
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISBN, isISBN.exports));

	var isISBNExports = isISBN.exports;

	var isISSN = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISSN;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var issn = '^\\d{4}-?\\d{3}[\\dX]$';
		function isISSN(str) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		  (0, _assertString.default)(str);
		  var testIssn = issn;
		  testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;
		  testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');
		  if (!testIssn.test(str)) {
		    return false;
		  }
		  var digits = str.replace('-', '').toUpperCase();
		  var checksum = 0;
		  for (var i = 0; i < digits.length; i++) {
		    var digit = digits[i];
		    checksum += (digit === 'X' ? 10 : +digit) * (8 - i);
		  }
		  return checksum % 11 === 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISSN, isISSN.exports));

	var isISSNExports = isISSN.exports;

	var isTaxID = {exports: {}};

	var algorithms$1 = {};

	Object.defineProperty(algorithms$1, "__esModule", {
	  value: true
	});
	algorithms$1.iso7064Check = iso7064Check;
	algorithms$1.luhnCheck = luhnCheck;
	algorithms$1.reverseMultiplyAndSum = reverseMultiplyAndSum;
	algorithms$1.verhoeffCheck = verhoeffCheck;
	/**
	 * Algorithmic validation functions
	 * May be used as is or implemented in the workflow of other validators.
	 */

	/*
	 * ISO 7064 validation function
	 * Called with a string of numbers (incl. check digit)
	 * to validate according to ISO 7064 (MOD 11, 10).
	 */
	function iso7064Check(str) {
	  var checkvalue = 10;
	  for (var i = 0; i < str.length - 1; i++) {
	    checkvalue = (parseInt(str[i], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str[i], 10) + checkvalue) % 10 * 2 % 11;
	  }
	  checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
	  return checkvalue === parseInt(str[10], 10);
	}

	/*
	 * Luhn (mod 10) validation function
	 * Called with a string of numbers (incl. check digit)
	 * to validate according to the Luhn algorithm.
	 */
	function luhnCheck(str) {
	  var checksum = 0;
	  var second = false;
	  for (var i = str.length - 1; i >= 0; i--) {
	    if (second) {
	      var product = parseInt(str[i], 10) * 2;
	      if (product > 9) {
	        // sum digits of product and add to checksum
	        checksum += product.toString().split('').map(function (a) {
	          return parseInt(a, 10);
	        }).reduce(function (a, b) {
	          return a + b;
	        }, 0);
	      } else {
	        checksum += product;
	      }
	    } else {
	      checksum += parseInt(str[i], 10);
	    }
	    second = !second;
	  }
	  return checksum % 10 === 0;
	}

	/*
	 * Reverse TIN multiplication and summation helper function
	 * Called with an array of single-digit integers and a base multiplier
	 * to calculate the sum of the digits multiplied in reverse.
	 * Normally used in variations of MOD 11 algorithmic checks.
	 */
	function reverseMultiplyAndSum(digits, base) {
	  var total = 0;
	  for (var i = 0; i < digits.length; i++) {
	    total += digits[i] * (base - i);
	  }
	  return total;
	}

	/*
	 * Verhoeff validation helper function
	 * Called with a string of numbers
	 * to validate according to the Verhoeff algorithm.
	 */
	function verhoeffCheck(str) {
	  var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
	  var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];

	  // Copy (to prevent replacement) and reverse
	  var str_copy = str.split('').reverse().join('');
	  var checksum = 0;
	  for (var i = 0; i < str_copy.length; i++) {
	    checksum = d_table[checksum][p_table[i % 8][parseInt(str_copy[i], 10)]];
	  }
	  return checksum === 0;
	}

	(function (module, exports) {

		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isTaxID;
		var _assertString = _interopRequireDefault(assertStringExports);
		var algorithms = _interopRequireWildcard(algorithms$1);
		var _isDate = _interopRequireDefault(isDateExports);
		function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
		function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
		function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
		function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
		function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
		function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
		/**
		 * TIN Validation
		 * Validates Tax Identification Numbers (TINs) from the US, EU member states and the United Kingdom.
		 *
		 * EU-UK:
		 * National TIN validity is calculated using public algorithms as made available by DG TAXUD.
		 *
		 * See `https://ec.europa.eu/taxation_customs/tin/specs/FS-TIN%20Algorithms-Public.docx` for more information.
		 *
		 * US:
		 * An Employer Identification Number (EIN), also known as a Federal Tax Identification Number,
		 *  is used to identify a business entity.
		 *
		 * NOTES:
		 *  - Prefix 47 is being reserved for future use
		 *  - Prefixes 26, 27, 45, 46 and 47 were previously assigned by the Philadelphia campus.
		 *
		 * See `http://www.irs.gov/Businesses/Small-Businesses-&-Self-Employed/How-EINs-are-Assigned-and-Valid-EIN-Prefixes`
		 * for more information.
		 */

		// Locale functions

		/*
		 * bg-BG validation function
		 * (Edinen graždanski nomer (EGN/ЕГН), persons only)
		 * Checks if birth date (first six digits) is valid and calculates check (last) digit
		 */
		function bgBgCheck(tin) {
		  // Extract full year, normalize month and check birth date validity
		  var century_year = tin.slice(0, 2);
		  var month = parseInt(tin.slice(2, 4), 10);
		  if (month > 40) {
		    month -= 40;
		    century_year = "20".concat(century_year);
		  } else if (month > 20) {
		    month -= 20;
		    century_year = "18".concat(century_year);
		  } else {
		    century_year = "19".concat(century_year);
		  }
		  if (month < 10) {
		    month = "0".concat(month);
		  }
		  var date = "".concat(century_year, "/").concat(month, "/").concat(tin.slice(4, 6));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });

		  // Calculate checksum by multiplying digits with fixed values
		  var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
		  var checksum = 0;
		  for (var i = 0; i < multip_lookup.length; i++) {
		    checksum += digits[i] * multip_lookup[i];
		  }
		  checksum = checksum % 11 === 10 ? 0 : checksum % 11;
		  return checksum === digits[9];
		}

		/**
		 * Check if an input is a valid Canadian SIN (Social Insurance Number)
		 *
		 * The Social Insurance Number (SIN) is a 9 digit number that
		 * you need to work in Canada or to have access to government programs and benefits.
		 *
		 * https://en.wikipedia.org/wiki/Social_Insurance_Number
		 * https://www.canada.ca/en/employment-social-development/services/sin.html
		 * https://www.codercrunch.com/challenge/819302488/sin-validator
		 *
		 * @param {string} input
		 * @return {boolean}
		 */
		function isCanadianSIN(input) {
		  var digitsArray = input.split('');
		  var even = digitsArray.filter(function (_, idx) {
		    return idx % 2;
		  }).map(function (i) {
		    return Number(i) * 2;
		  }).join('').split('');
		  var total = digitsArray.filter(function (_, idx) {
		    return !(idx % 2);
		  }).concat(even).map(function (i) {
		    return Number(i);
		  }).reduce(function (acc, cur) {
		    return acc + cur;
		  });
		  return total % 10 === 0;
		}

		/*
		 * cs-CZ validation function
		 * (Rodné číslo (RČ), persons only)
		 * Checks if birth date (first six digits) is valid and divisibility by 11
		 * Material not in DG TAXUD document sourced from:
		 * -`https://lorenc.info/3MA381/overeni-spravnosti-rodneho-cisla.htm`
		 * -`https://www.mvcr.cz/clanek/rady-a-sluzby-dokumenty-rodne-cislo.aspx`
		 */
		function csCzCheck(tin) {
		  tin = tin.replace(/\W/, '');

		  // Extract full year from TIN length
		  var full_year = parseInt(tin.slice(0, 2), 10);
		  if (tin.length === 10) {
		    if (full_year < 54) {
		      full_year = "20".concat(full_year);
		    } else {
		      full_year = "19".concat(full_year);
		    }
		  } else {
		    if (tin.slice(6) === '000') {
		      return false;
		    } // Three-zero serial not assigned before 1954
		    if (full_year < 54) {
		      full_year = "19".concat(full_year);
		    } else {
		      return false; // No 18XX years seen in any of the resources
		    }
		  }
		  // Add missing zero if needed
		  if (full_year.length === 3) {
		    full_year = [full_year.slice(0, 2), '0', full_year.slice(2)].join('');
		  }

		  // Extract month from TIN and normalize
		  var month = parseInt(tin.slice(2, 4), 10);
		  if (month > 50) {
		    month -= 50;
		  }
		  if (month > 20) {
		    // Month-plus-twenty was only introduced in 2004
		    if (parseInt(full_year, 10) < 2004) {
		      return false;
		    }
		    month -= 20;
		  }
		  if (month < 10) {
		    month = "0".concat(month);
		  }

		  // Check date validity
		  var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Verify divisibility by 11
		  if (tin.length === 10) {
		    if (parseInt(tin, 10) % 11 !== 0) {
		      // Some numbers up to and including 1985 are still valid if
		      // check (last) digit equals 0 and modulo of first 9 digits equals 10
		      var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
		      if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {
		        if (parseInt(tin.slice(9), 10) !== 0) {
		          return false;
		        }
		      } else {
		        return false;
		      }
		    }
		  }
		  return true;
		}

		/*
		 * de-AT validation function
		 * (Abgabenkontonummer, persons/entities)
		 * Verify TIN validity by calling luhnCheck()
		 */
		function deAtCheck(tin) {
		  return algorithms.luhnCheck(tin);
		}

		/*
		 * de-DE validation function
		 * (Steueridentifikationsnummer (Steuer-IdNr.), persons only)
		 * Tests for single duplicate/triplicate value, then calculates ISO 7064 check (last) digit
		 * Partial implementation of spec (same result with both algorithms always)
		 */
		function deDeCheck(tin) {
		  // Split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });

		  // Fill array with strings of number positions
		  var occurences = [];
		  for (var i = 0; i < digits.length - 1; i++) {
		    occurences.push('');
		    for (var j = 0; j < digits.length - 1; j++) {
		      if (digits[i] === digits[j]) {
		        occurences[i] += j;
		      }
		    }
		  }

		  // Remove digits with one occurence and test for only one duplicate/triplicate
		  occurences = occurences.filter(function (a) {
		    return a.length > 1;
		  });
		  if (occurences.length !== 2 && occurences.length !== 3) {
		    return false;
		  }

		  // In case of triplicate value only two digits are allowed next to each other
		  if (occurences[0].length === 3) {
		    var trip_locations = occurences[0].split('').map(function (a) {
		      return parseInt(a, 10);
		    });
		    var recurrent = 0; // Amount of neighbour occurences
		    for (var _i = 0; _i < trip_locations.length - 1; _i++) {
		      if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {
		        recurrent += 1;
		      }
		    }
		    if (recurrent === 2) {
		      return false;
		    }
		  }
		  return algorithms.iso7064Check(tin);
		}

		/*
		 * dk-DK validation function
		 * (CPR-nummer (personnummer), persons only)
		 * Checks if birth date (first six digits) is valid and assigned to century (seventh) digit,
		 * and calculates check (last) digit
		 */
		function dkDkCheck(tin) {
		  tin = tin.replace(/\W/, '');

		  // Extract year, check if valid for given century digit and add century
		  var year = parseInt(tin.slice(4, 6), 10);
		  var century_digit = tin.slice(6, 7);
		  switch (century_digit) {
		    case '0':
		    case '1':
		    case '2':
		    case '3':
		      year = "19".concat(year);
		      break;
		    case '4':
		    case '9':
		      if (year < 37) {
		        year = "20".concat(year);
		      } else {
		        year = "19".concat(year);
		      }
		      break;
		    default:
		      if (year < 37) {
		        year = "20".concat(year);
		      } else if (year > 58) {
		        year = "18".concat(year);
		      } else {
		        return false;
		      }
		      break;
		  }
		  // Add missing zero if needed
		  if (year.length === 3) {
		    year = [year.slice(0, 2), '0', year.slice(2)].join('');
		  }
		  // Check date validity
		  var date = "".concat(year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 0;
		  var weight = 4;
		  // Multiply by weight and add to checksum
		  for (var i = 0; i < 9; i++) {
		    checksum += digits[i] * weight;
		    weight -= 1;
		    if (weight === 1) {
		      weight = 7;
		    }
		  }
		  checksum %= 11;
		  if (checksum === 1) {
		    return false;
		  }
		  return checksum === 0 ? digits[9] === 0 : digits[9] === 11 - checksum;
		}

		/*
		 * el-CY validation function
		 * (Arithmos Forologikou Mitroou (AFM/ΑΦΜ), persons only)
		 * Verify TIN validity by calculating ASCII value of check (last) character
		 */
		function elCyCheck(tin) {
		  // split digits into an array for further processing
		  var digits = tin.slice(0, 8).split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 0;
		  // add digits in even places
		  for (var i = 1; i < digits.length; i += 2) {
		    checksum += digits[i];
		  }

		  // add digits in odd places
		  for (var _i2 = 0; _i2 < digits.length; _i2 += 2) {
		    if (digits[_i2] < 2) {
		      checksum += 1 - digits[_i2];
		    } else {
		      checksum += 2 * (digits[_i2] - 2) + 5;
		      if (digits[_i2] > 4) {
		        checksum += 2;
		      }
		    }
		  }
		  return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);
		}

		/*
		 * el-GR validation function
		 * (Arithmos Forologikou Mitroou (AFM/ΑΦΜ), persons/entities)
		 * Verify TIN validity by calculating check (last) digit
		 * Algorithm not in DG TAXUD document- sourced from:
		 * - `http://epixeirisi.gr/%CE%9A%CE%A1%CE%99%CE%A3%CE%99%CE%9C%CE%91-%CE%98%CE%95%CE%9C%CE%91%CE%A4%CE%91-%CE%A6%CE%9F%CE%A1%CE%9F%CE%9B%CE%9F%CE%93%CE%99%CE%91%CE%A3-%CE%9A%CE%91%CE%99-%CE%9B%CE%9F%CE%93%CE%99%CE%A3%CE%A4%CE%99%CE%9A%CE%97%CE%A3/23791/%CE%91%CF%81%CE%B9%CE%B8%CE%BC%CF%8C%CF%82-%CE%A6%CE%BF%CF%81%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CE%BA%CE%BF%CF%8D-%CE%9C%CE%B7%CF%84%CF%81%CF%8E%CE%BF%CF%85`
		 */
		function elGrCheck(tin) {
		  // split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 0;
		  for (var i = 0; i < 8; i++) {
		    checksum += digits[i] * Math.pow(2, 8 - i);
		  }
		  return checksum % 11 % 10 === digits[8];
		}

		/*
		 * en-GB validation function (should go here if needed)
		 * (National Insurance Number (NINO) or Unique Taxpayer Reference (UTR),
		 * persons/entities respectively)
		 */

		/*
		 * en-IE validation function
		 * (Personal Public Service Number (PPS No), persons only)
		 * Verify TIN validity by calculating check (second to last) character
		 */
		function enIeCheck(tin) {
		  var checksum = algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {
		    return parseInt(a, 10);
		  }), 8);
		  if (tin.length === 9 && tin[8] !== 'W') {
		    checksum += (tin[8].charCodeAt(0) - 64) * 9;
		  }
		  checksum %= 23;
		  if (checksum === 0) {
		    return tin[7].toUpperCase() === 'W';
		  }
		  return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);
		}

		// Valid US IRS campus prefixes
		var enUsCampusPrefix = {
		  andover: ['10', '12'],
		  atlanta: ['60', '67'],
		  austin: ['50', '53'],
		  brookhaven: ['01', '02', '03', '04', '05', '06', '11', '13', '14', '16', '21', '22', '23', '25', '34', '51', '52', '54', '55', '56', '57', '58', '59', '65'],
		  cincinnati: ['30', '32', '35', '36', '37', '38', '61'],
		  fresno: ['15', '24'],
		  internet: ['20', '26', '27', '45', '46', '47'],
		  kansas: ['40', '44'],
		  memphis: ['94', '95'],
		  ogden: ['80', '90'],
		  philadelphia: ['33', '39', '41', '42', '43', '46', '48', '62', '63', '64', '66', '68', '71', '72', '73', '74', '75', '76', '77', '81', '82', '83', '84', '85', '86', '87', '88', '91', '92', '93', '98', '99'],
		  sba: ['31']
		};

		// Return an array of all US IRS campus prefixes
		function enUsGetPrefixes() {
		  var prefixes = [];
		  for (var location in enUsCampusPrefix) {
		    // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
		    // istanbul ignore else
		    if (enUsCampusPrefix.hasOwnProperty(location)) {
		      prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));
		    }
		  }
		  return prefixes;
		}

		/*
		 * en-US validation function
		 * Verify that the TIN starts with a valid IRS campus prefix
		 */
		function enUsCheck(tin) {
		  return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
		}

		/*
		 * es-AR validation function
		 * Clave Única de Identificación Tributaria (CUIT/CUIL)
		 * Sourced from:
		 * - https://servicioscf.afip.gob.ar/publico/abc/ABCpaso2.aspx?id_nivel1=3036&id_nivel2=3040&p=Conceptos%20b%C3%A1sicos
		 * - https://es.wikipedia.org/wiki/Clave_%C3%9Anica_de_Identificaci%C3%B3n_Tributaria
		 */

		function esArCheck(tin) {
		  var accum = 0;
		  var digits = tin.split('');
		  var digit = parseInt(digits.pop(), 10);
		  for (var i = 0; i < digits.length; i++) {
		    accum += digits[9 - i] * (2 + i % 6);
		  }
		  var verif = 11 - accum % 11;
		  if (verif === 11) {
		    verif = 0;
		  } else if (verif === 10) {
		    verif = 9;
		  }
		  return digit === verif;
		}

		/*
		 * es-ES validation function
		 * (Documento Nacional de Identidad (DNI)
		 * or Número de Identificación de Extranjero (NIE), persons only)
		 * Verify TIN validity by calculating check (last) character
		 */
		function esEsCheck(tin) {
		  // Split characters into an array for further processing
		  var chars = tin.toUpperCase().split('');

		  // Replace initial letter if needed
		  if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {
		    var lead_replace = 0;
		    switch (chars[0]) {
		      case 'Y':
		        lead_replace = 1;
		        break;
		      case 'Z':
		        lead_replace = 2;
		        break;
		    }
		    chars.splice(0, 1, lead_replace);
		    // Fill with zeros if smaller than proper
		  } else {
		    while (chars.length < 9) {
		      chars.unshift(0);
		    }
		  }

		  // Calculate checksum and check according to lookup
		  var lookup = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E'];
		  chars = chars.join('');
		  var checksum = parseInt(chars.slice(0, 8), 10) % 23;
		  return chars[8] === lookup[checksum];
		}

		/*
		 * et-EE validation function
		 * (Isikukood (IK), persons only)
		 * Checks if birth date (century digit and six following) is valid and calculates check (last) digit
		 * Material not in DG TAXUD document sourced from:
		 * - `https://www.oecd.org/tax/automatic-exchange/crs-implementation-and-assistance/tax-identification-numbers/Estonia-TIN.pdf`
		 */
		function etEeCheck(tin) {
		  // Extract year and add century
		  var full_year = tin.slice(1, 3);
		  var century_digit = tin.slice(0, 1);
		  switch (century_digit) {
		    case '1':
		    case '2':
		      full_year = "18".concat(full_year);
		      break;
		    case '3':
		    case '4':
		      full_year = "19".concat(full_year);
		      break;
		    default:
		      full_year = "20".concat(full_year);
		      break;
		  }
		  // Check date validity
		  var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 0;
		  var weight = 1;
		  // Multiply by weight and add to checksum
		  for (var i = 0; i < 10; i++) {
		    checksum += digits[i] * weight;
		    weight += 1;
		    if (weight === 10) {
		      weight = 1;
		    }
		  }
		  // Do again if modulo 11 of checksum is 10
		  if (checksum % 11 === 10) {
		    checksum = 0;
		    weight = 3;
		    for (var _i3 = 0; _i3 < 10; _i3++) {
		      checksum += digits[_i3] * weight;
		      weight += 1;
		      if (weight === 10) {
		        weight = 1;
		      }
		    }
		    if (checksum % 11 === 10) {
		      return digits[10] === 0;
		    }
		  }
		  return checksum % 11 === digits[10];
		}

		/*
		 * fi-FI validation function
		 * (Henkilötunnus (HETU), persons only)
		 * Checks if birth date (first six digits plus century symbol) is valid
		 * and calculates check (last) digit
		 */
		function fiFiCheck(tin) {
		  // Extract year and add century
		  var full_year = tin.slice(4, 6);
		  var century_symbol = tin.slice(6, 7);
		  switch (century_symbol) {
		    case '+':
		      full_year = "18".concat(full_year);
		      break;
		    case '-':
		      full_year = "19".concat(full_year);
		      break;
		    default:
		      full_year = "20".concat(full_year);
		      break;
		  }
		  // Check date validity
		  var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Calculate check character
		  var checksum = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
		  if (checksum < 10) {
		    return checksum === parseInt(tin.slice(10), 10);
		  }
		  checksum -= 10;
		  var letters_lookup = ['A', 'B', 'C', 'D', 'E', 'F', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'];
		  return letters_lookup[checksum] === tin.slice(10);
		}

		/*
		 * fr/nl-BE validation function
		 * (Numéro national (N.N.), persons only)
		 * Checks if birth date (first six digits) is valid and calculates check (last two) digits
		 */
		function frBeCheck(tin) {
		  // Zero month/day value is acceptable
		  if (tin.slice(2, 4) !== '00' || tin.slice(4, 6) !== '00') {
		    // Extract date from first six digits of TIN
		    var date = "".concat(tin.slice(0, 2), "/").concat(tin.slice(2, 4), "/").concat(tin.slice(4, 6));
		    if (!(0, _isDate.default)(date, 'YY/MM/DD')) {
		      return false;
		    }
		  }
		  var checksum = 97 - parseInt(tin.slice(0, 9), 10) % 97;
		  var checkdigits = parseInt(tin.slice(9, 11), 10);
		  if (checksum !== checkdigits) {
		    checksum = 97 - parseInt("2".concat(tin.slice(0, 9)), 10) % 97;
		    if (checksum !== checkdigits) {
		      return false;
		    }
		  }
		  return true;
		}

		/*
		 * fr-FR validation function
		 * (Numéro fiscal de référence (numéro SPI), persons only)
		 * Verify TIN validity by calculating check (last three) digits
		 */
		function frFrCheck(tin) {
		  tin = tin.replace(/\s/g, '');
		  var checksum = parseInt(tin.slice(0, 10), 10) % 511;
		  var checkdigits = parseInt(tin.slice(10, 13), 10);
		  return checksum === checkdigits;
		}

		/*
		 * fr/lb-LU validation function
		 * (numéro d’identification personnelle, persons only)
		 * Verify birth date validity and run Luhn and Verhoeff checks
		 */
		function frLuCheck(tin) {
		  // Extract date and check validity
		  var date = "".concat(tin.slice(0, 4), "/").concat(tin.slice(4, 6), "/").concat(tin.slice(6, 8));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Run Luhn check
		  if (!algorithms.luhnCheck(tin.slice(0, 12))) {
		    return false;
		  }
		  // Remove Luhn check digit and run Verhoeff check
		  return algorithms.verhoeffCheck("".concat(tin.slice(0, 11)).concat(tin[12]));
		}

		/*
		 * hr-HR validation function
		 * (Osobni identifikacijski broj (OIB), persons/entities)
		 * Verify TIN validity by calling iso7064Check(digits)
		 */
		function hrHrCheck(tin) {
		  return algorithms.iso7064Check(tin);
		}

		/*
		 * hu-HU validation function
		 * (Adóazonosító jel, persons only)
		 * Verify TIN validity by calculating check (last) digit
		 */
		function huHuCheck(tin) {
		  // split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 8;
		  for (var i = 1; i < 9; i++) {
		    checksum += digits[i] * (i + 1);
		  }
		  return checksum % 11 === digits[9];
		}

		/*
		 * lt-LT validation function (should go here if needed)
		 * (Asmens kodas, persons/entities respectively)
		 * Current validation check is alias of etEeCheck- same format applies
		 */

		/*
		 * it-IT first/last name validity check
		 * Accepts it-IT TIN-encoded names as a three-element character array and checks their validity
		 * Due to lack of clarity between resources ("Are only Italian consonants used?
		 * What happens if a person has X in their name?" etc.) only two test conditions
		 * have been implemented:
		 * Vowels may only be followed by other vowels or an X character
		 * and X characters after vowels may only be followed by other X characters.
		 */
		function itItNameCheck(name) {
		  // true at the first occurence of a vowel
		  var vowelflag = false;

		  // true at the first occurence of an X AFTER vowel
		  // (to properly handle last names with X as consonant)
		  var xflag = false;
		  for (var i = 0; i < 3; i++) {
		    if (!vowelflag && /[AEIOU]/.test(name[i])) {
		      vowelflag = true;
		    } else if (!xflag && vowelflag && name[i] === 'X') {
		      xflag = true;
		    } else if (i > 0) {
		      if (vowelflag && !xflag) {
		        if (!/[AEIOU]/.test(name[i])) {
		          return false;
		        }
		      }
		      if (xflag) {
		        if (!/X/.test(name[i])) {
		          return false;
		        }
		      }
		    }
		  }
		  return true;
		}

		/*
		 * it-IT validation function
		 * (Codice fiscale (TIN-IT), persons only)
		 * Verify name, birth date and codice catastale validity
		 * and calculate check character.
		 * Material not in DG-TAXUD document sourced from:
		 * `https://en.wikipedia.org/wiki/Italian_fiscal_code`
		 */
		function itItCheck(tin) {
		  // Capitalize and split characters into an array for further processing
		  var chars = tin.toUpperCase().split('');

		  // Check first and last name validity calling itItNameCheck()
		  if (!itItNameCheck(chars.slice(0, 3))) {
		    return false;
		  }
		  if (!itItNameCheck(chars.slice(3, 6))) {
		    return false;
		  }

		  // Convert letters in number spaces back to numbers if any
		  var number_locations = [6, 7, 9, 10, 12, 13, 14];
		  var number_replace = {
		    L: '0',
		    M: '1',
		    N: '2',
		    P: '3',
		    Q: '4',
		    R: '5',
		    S: '6',
		    T: '7',
		    U: '8',
		    V: '9'
		  };
		  for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {
		    var i = _number_locations[_i4];
		    if (chars[i] in number_replace) {
		      chars.splice(i, 1, number_replace[chars[i]]);
		    }
		  }

		  // Extract month and day, and check date validity
		  var month_replace = {
		    A: '01',
		    B: '02',
		    C: '03',
		    D: '04',
		    E: '05',
		    H: '06',
		    L: '07',
		    M: '08',
		    P: '09',
		    R: '10',
		    S: '11',
		    T: '12'
		  };
		  var month = month_replace[chars[8]];
		  var day = parseInt(chars[9] + chars[10], 10);
		  if (day > 40) {
		    day -= 40;
		  }
		  if (day < 10) {
		    day = "0".concat(day);
		  }
		  var date = "".concat(chars[6]).concat(chars[7], "/").concat(month, "/").concat(day);
		  if (!(0, _isDate.default)(date, 'YY/MM/DD')) {
		    return false;
		  }

		  // Calculate check character by adding up even and odd characters as numbers
		  var checksum = 0;
		  for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {
		    var char_to_int = parseInt(chars[_i5], 10);
		    if (isNaN(char_to_int)) {
		      char_to_int = chars[_i5].charCodeAt(0) - 65;
		    }
		    checksum += char_to_int;
		  }
		  var odd_convert = {
		    // Maps of characters at odd places
		    A: 1,
		    B: 0,
		    C: 5,
		    D: 7,
		    E: 9,
		    F: 13,
		    G: 15,
		    H: 17,
		    I: 19,
		    J: 21,
		    K: 2,
		    L: 4,
		    M: 18,
		    N: 20,
		    O: 11,
		    P: 3,
		    Q: 6,
		    R: 8,
		    S: 12,
		    T: 14,
		    U: 16,
		    V: 10,
		    W: 22,
		    X: 25,
		    Y: 24,
		    Z: 23,
		    0: 1,
		    1: 0
		  };
		  for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {
		    var _char_to_int = 0;
		    if (chars[_i6] in odd_convert) {
		      _char_to_int = odd_convert[chars[_i6]];
		    } else {
		      var multiplier = parseInt(chars[_i6], 10);
		      _char_to_int = 2 * multiplier + 1;
		      if (multiplier > 4) {
		        _char_to_int += 2;
		      }
		    }
		    checksum += _char_to_int;
		  }
		  if (String.fromCharCode(65 + checksum % 26) !== chars[15]) {
		    return false;
		  }
		  return true;
		}

		/*
		 * lv-LV validation function
		 * (Personas kods (PK), persons only)
		 * Check validity of birth date and calculate check (last) digit
		 * Support only for old format numbers (not starting with '32', issued before 2017/07/01)
		 * Material not in DG TAXUD document sourced from:
		 * `https://boot.ritakafija.lv/forums/index.php?/topic/88314-personas-koda-algoritms-%C4%8Deksumma/`
		 */
		function lvLvCheck(tin) {
		  tin = tin.replace(/\W/, '');
		  // Extract date from TIN
		  var day = tin.slice(0, 2);
		  if (day !== '32') {
		    // No date/checksum check if new format
		    var month = tin.slice(2, 4);
		    if (month !== '00') {
		      // No date check if unknown month
		      var full_year = tin.slice(4, 6);
		      switch (tin[6]) {
		        case '0':
		          full_year = "18".concat(full_year);
		          break;
		        case '1':
		          full_year = "19".concat(full_year);
		          break;
		        default:
		          full_year = "20".concat(full_year);
		          break;
		      }
		      // Check date validity
		      var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(day);
		      if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		        return false;
		      }
		    }

		    // Calculate check digit
		    var checksum = 1101;
		    var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
		    for (var i = 0; i < tin.length - 1; i++) {
		      checksum -= parseInt(tin[i], 10) * multip_lookup[i];
		    }
		    return parseInt(tin[10], 10) === checksum % 11;
		  }
		  return true;
		}

		/*
		 * mt-MT validation function
		 * (Identity Card Number or Unique Taxpayer Reference, persons/entities)
		 * Verify Identity Card Number structure (no other tests found)
		 */
		function mtMtCheck(tin) {
		  if (tin.length !== 9) {
		    // No tests for UTR
		    var chars = tin.toUpperCase().split('');
		    // Fill with zeros if smaller than proper
		    while (chars.length < 8) {
		      chars.unshift(0);
		    }
		    // Validate format according to last character
		    switch (tin[7]) {
		      case 'A':
		      case 'P':
		        if (parseInt(chars[6], 10) === 0) {
		          return false;
		        }
		        break;
		      default:
		        {
		          var first_part = parseInt(chars.join('').slice(0, 5), 10);
		          if (first_part > 32000) {
		            return false;
		          }
		          var second_part = parseInt(chars.join('').slice(5, 7), 10);
		          if (first_part === second_part) {
		            return false;
		          }
		        }
		    }
		  }
		  return true;
		}

		/*
		 * nl-NL validation function
		 * (Burgerservicenummer (BSN) or Rechtspersonen Samenwerkingsverbanden Informatie Nummer (RSIN),
		 * persons/entities respectively)
		 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
		 */
		function nlNlCheck(tin) {
		  return algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {
		    return parseInt(a, 10);
		  }), 9) % 11 === parseInt(tin[8], 10);
		}

		/*
		 * pl-PL validation function
		 * (Powszechny Elektroniczny System Ewidencji Ludności (PESEL)
		 * or Numer identyfikacji podatkowej (NIP), persons/entities)
		 * Verify TIN validity by validating birth date (PESEL) and calculating check (last) digit
		 */
		function plPlCheck(tin) {
		  // NIP
		  if (tin.length === 10) {
		    // Calculate last digit by multiplying with lookup
		    var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];
		    var _checksum = 0;
		    for (var i = 0; i < lookup.length; i++) {
		      _checksum += parseInt(tin[i], 10) * lookup[i];
		    }
		    _checksum %= 11;
		    if (_checksum === 10) {
		      return false;
		    }
		    return _checksum === parseInt(tin[9], 10);
		  }

		  // PESEL
		  // Extract full year using month
		  var full_year = tin.slice(0, 2);
		  var month = parseInt(tin.slice(2, 4), 10);
		  if (month > 80) {
		    full_year = "18".concat(full_year);
		    month -= 80;
		  } else if (month > 60) {
		    full_year = "22".concat(full_year);
		    month -= 60;
		  } else if (month > 40) {
		    full_year = "21".concat(full_year);
		    month -= 40;
		  } else if (month > 20) {
		    full_year = "20".concat(full_year);
		    month -= 20;
		  } else {
		    full_year = "19".concat(full_year);
		  }
		  // Add leading zero to month if needed
		  if (month < 10) {
		    month = "0".concat(month);
		  }
		  // Check date validity
		  var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Calculate last digit by mulitplying with odd one-digit numbers except 5
		  var checksum = 0;
		  var multiplier = 1;
		  for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {
		    checksum += parseInt(tin[_i7], 10) * multiplier % 10;
		    multiplier += 2;
		    if (multiplier > 10) {
		      multiplier = 1;
		    } else if (multiplier === 5) {
		      multiplier += 2;
		    }
		  }
		  checksum = 10 - checksum % 10;
		  return checksum === parseInt(tin[10], 10);
		}

		/*
		* pt-BR validation function
		* (Cadastro de Pessoas Físicas (CPF, persons)
		* Cadastro Nacional de Pessoas Jurídicas (CNPJ, entities)
		* Both inputs will be validated
		*/

		function ptBrCheck(tin) {
		  if (tin.length === 11) {
		    var _sum;
		    var remainder;
		    _sum = 0;
		    if (
		    // Reject known invalid CPFs
		    tin === '11111111111' || tin === '22222222222' || tin === '33333333333' || tin === '44444444444' || tin === '55555555555' || tin === '66666666666' || tin === '77777777777' || tin === '88888888888' || tin === '99999999999' || tin === '00000000000') return false;
		    for (var i = 1; i <= 9; i++) _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);
		    remainder = _sum * 10 % 11;
		    if (remainder === 10) remainder = 0;
		    if (remainder !== parseInt(tin.substring(9, 10), 10)) return false;
		    _sum = 0;
		    for (var _i8 = 1; _i8 <= 10; _i8++) _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
		    remainder = _sum * 10 % 11;
		    if (remainder === 10) remainder = 0;
		    if (remainder !== parseInt(tin.substring(10, 11), 10)) return false;
		    return true;
		  }
		  if (
		  // Reject know invalid CNPJs
		  tin === '00000000000000' || tin === '11111111111111' || tin === '22222222222222' || tin === '33333333333333' || tin === '44444444444444' || tin === '55555555555555' || tin === '66666666666666' || tin === '77777777777777' || tin === '88888888888888' || tin === '99999999999999') {
		    return false;
		  }
		  var length = tin.length - 2;
		  var identifiers = tin.substring(0, length);
		  var verificators = tin.substring(length);
		  var sum = 0;
		  var pos = length - 7;
		  for (var _i9 = length; _i9 >= 1; _i9--) {
		    sum += identifiers.charAt(length - _i9) * pos;
		    pos -= 1;
		    if (pos < 2) {
		      pos = 9;
		    }
		  }
		  var result = sum % 11 < 2 ? 0 : 11 - sum % 11;
		  if (result !== parseInt(verificators.charAt(0), 10)) {
		    return false;
		  }
		  length += 1;
		  identifiers = tin.substring(0, length);
		  sum = 0;
		  pos = length - 7;
		  for (var _i10 = length; _i10 >= 1; _i10--) {
		    sum += identifiers.charAt(length - _i10) * pos;
		    pos -= 1;
		    if (pos < 2) {
		      pos = 9;
		    }
		  }
		  result = sum % 11 < 2 ? 0 : 11 - sum % 11;
		  if (result !== parseInt(verificators.charAt(1), 10)) {
		    return false;
		  }
		  return true;
		}

		/*
		 * pt-PT validation function
		 * (Número de identificação fiscal (NIF), persons/entities)
		 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
		 */
		function ptPtCheck(tin) {
		  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {
		    return parseInt(a, 10);
		  }), 9) % 11;
		  if (checksum > 9) {
		    return parseInt(tin[8], 10) === 0;
		  }
		  return checksum === parseInt(tin[8], 10);
		}

		/*
		 * ro-RO validation function
		 * (Cod Numeric Personal (CNP) or Cod de înregistrare fiscală (CIF),
		 * persons only)
		 * Verify CNP validity by calculating check (last) digit (test not found for CIF)
		 * Material not in DG TAXUD document sourced from:
		 * `https://en.wikipedia.org/wiki/National_identification_number#Romania`
		 */
		function roRoCheck(tin) {
		  if (tin.slice(0, 4) !== '9000') {
		    // No test found for this format
		    // Extract full year using century digit if possible
		    var full_year = tin.slice(1, 3);
		    switch (tin[0]) {
		      case '1':
		      case '2':
		        full_year = "19".concat(full_year);
		        break;
		      case '3':
		      case '4':
		        full_year = "18".concat(full_year);
		        break;
		      case '5':
		      case '6':
		        full_year = "20".concat(full_year);
		        break;
		    }

		    // Check date validity
		    var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
		    if (date.length === 8) {
		      if (!(0, _isDate.default)(date, 'YY/MM/DD')) {
		        return false;
		      }
		    } else if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		      return false;
		    }

		    // Calculate check digit
		    var digits = tin.split('').map(function (a) {
		      return parseInt(a, 10);
		    });
		    var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
		    var checksum = 0;
		    for (var i = 0; i < multipliers.length; i++) {
		      checksum += digits[i] * multipliers[i];
		    }
		    if (checksum % 11 === 10) {
		      return digits[12] === 1;
		    }
		    return digits[12] === checksum % 11;
		  }
		  return true;
		}

		/*
		 * sk-SK validation function
		 * (Rodné číslo (RČ) or bezvýznamové identifikačné číslo (BIČ), persons only)
		 * Checks validity of pre-1954 birth numbers (rodné číslo) only
		 * Due to the introduction of the pseudo-random BIČ it is not possible to test
		 * post-1954 birth numbers without knowing whether they are BIČ or RČ beforehand
		 */
		function skSkCheck(tin) {
		  if (tin.length === 9) {
		    tin = tin.replace(/\W/, '');
		    if (tin.slice(6) === '000') {
		      return false;
		    } // Three-zero serial not assigned before 1954

		    // Extract full year from TIN length
		    var full_year = parseInt(tin.slice(0, 2), 10);
		    if (full_year > 53) {
		      return false;
		    }
		    if (full_year < 10) {
		      full_year = "190".concat(full_year);
		    } else {
		      full_year = "19".concat(full_year);
		    }

		    // Extract month from TIN and normalize
		    var month = parseInt(tin.slice(2, 4), 10);
		    if (month > 50) {
		      month -= 50;
		    }
		    if (month < 10) {
		      month = "0".concat(month);
		    }

		    // Check date validity
		    var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
		    if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		      return false;
		    }
		  }
		  return true;
		}

		/*
		 * sl-SI validation function
		 * (Davčna številka, persons/entities)
		 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
		 */
		function slSiCheck(tin) {
		  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {
		    return parseInt(a, 10);
		  }), 8) % 11;
		  if (checksum === 10) {
		    return parseInt(tin[7], 10) === 0;
		  }
		  return checksum === parseInt(tin[7], 10);
		}

		/*
		 * sv-SE validation function
		 * (Personnummer or samordningsnummer, persons only)
		 * Checks validity of birth date and calls luhnCheck() to validate check (last) digit
		 */
		function svSeCheck(tin) {
		  // Make copy of TIN and normalize to two-digit year form
		  var tin_copy = tin.slice(0);
		  if (tin.length > 11) {
		    tin_copy = tin_copy.slice(2);
		  }

		  // Extract date of birth
		  var full_year = '';
		  var month = tin_copy.slice(2, 4);
		  var day = parseInt(tin_copy.slice(4, 6), 10);
		  if (tin.length > 11) {
		    full_year = tin.slice(0, 4);
		  } else {
		    full_year = tin.slice(0, 2);
		    if (tin.length === 11 && day < 60) {
		      // Extract full year from centenarian symbol
		      // Should work just fine until year 10000 or so
		      var current_year = new Date().getFullYear().toString();
		      var current_century = parseInt(current_year.slice(0, 2), 10);
		      current_year = parseInt(current_year, 10);
		      if (tin[6] === '-') {
		        if (parseInt("".concat(current_century).concat(full_year), 10) > current_year) {
		          full_year = "".concat(current_century - 1).concat(full_year);
		        } else {
		          full_year = "".concat(current_century).concat(full_year);
		        }
		      } else {
		        full_year = "".concat(current_century - 1).concat(full_year);
		        if (current_year - parseInt(full_year, 10) < 100) {
		          return false;
		        }
		      }
		    }
		  }

		  // Normalize day and check date validity
		  if (day > 60) {
		    day -= 60;
		  }
		  if (day < 10) {
		    day = "0".concat(day);
		  }
		  var date = "".concat(full_year, "/").concat(month, "/").concat(day);
		  if (date.length === 8) {
		    if (!(0, _isDate.default)(date, 'YY/MM/DD')) {
		      return false;
		    }
		  } else if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }
		  return algorithms.luhnCheck(tin.replace(/\W/, ''));
		}

		/**
		 * uk-UA validation function
		 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
		 */
		function ukUaCheck(tin) {
		  // Calculate check digit
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];
		  var checksum = 0;
		  for (var i = 0; i < multipliers.length; i++) {
		    checksum += digits[i] * multipliers[i];
		  }
		  return checksum % 11 === 10 ? digits[9] === 0 : digits[9] === checksum % 11;
		}

		// Locale lookup objects

		/*
		 * Tax id regex formats for various locales
		 *
		 * Where not explicitly specified in DG-TAXUD document both
		 * uppercase and lowercase letters are acceptable.
		 */
		var taxIdFormat = {
		  'bg-BG': /^\d{10}$/,
		  'cs-CZ': /^\d{6}\/{0,1}\d{3,4}$/,
		  'de-AT': /^\d{9}$/,
		  'de-DE': /^[1-9]\d{10}$/,
		  'dk-DK': /^\d{6}-{0,1}\d{4}$/,
		  'el-CY': /^[09]\d{7}[A-Z]$/,
		  'el-GR': /^([0-4]|[7-9])\d{8}$/,
		  'en-CA': /^\d{9}$/,
		  'en-GB': /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
		  'en-IE': /^\d{7}[A-W][A-IW]{0,1}$/i,
		  'en-US': /^\d{2}[- ]{0,1}\d{7}$/,
		  'es-AR': /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,
		  'es-ES': /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
		  'et-EE': /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
		  'fi-FI': /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
		  'fr-BE': /^\d{11}$/,
		  'fr-FR': /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
		  // Conforms both to official spec and provided example
		  'fr-LU': /^\d{13}$/,
		  'hr-HR': /^\d{11}$/,
		  'hu-HU': /^8\d{9}$/,
		  'it-IT': /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
		  'lv-LV': /^\d{6}-{0,1}\d{5}$/,
		  // Conforms both to DG TAXUD spec and original research
		  'mt-MT': /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
		  'nl-NL': /^\d{9}$/,
		  'pl-PL': /^\d{10,11}$/,
		  'pt-BR': /(?:^\d{11}$)|(?:^\d{14}$)/,
		  'pt-PT': /^\d{9}$/,
		  'ro-RO': /^\d{13}$/,
		  'sk-SK': /^\d{6}\/{0,1}\d{3,4}$/,
		  'sl-SI': /^[1-9]\d{7}$/,
		  'sv-SE': /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/,
		  'uk-UA': /^\d{10}$/
		};
		// taxIdFormat locale aliases
		taxIdFormat['lb-LU'] = taxIdFormat['fr-LU'];
		taxIdFormat['lt-LT'] = taxIdFormat['et-EE'];
		taxIdFormat['nl-BE'] = taxIdFormat['fr-BE'];
		taxIdFormat['fr-CA'] = taxIdFormat['en-CA'];

		// Algorithmic tax id check functions for various locales
		var taxIdCheck = {
		  'bg-BG': bgBgCheck,
		  'cs-CZ': csCzCheck,
		  'de-AT': deAtCheck,
		  'de-DE': deDeCheck,
		  'dk-DK': dkDkCheck,
		  'el-CY': elCyCheck,
		  'el-GR': elGrCheck,
		  'en-CA': isCanadianSIN,
		  'en-IE': enIeCheck,
		  'en-US': enUsCheck,
		  'es-AR': esArCheck,
		  'es-ES': esEsCheck,
		  'et-EE': etEeCheck,
		  'fi-FI': fiFiCheck,
		  'fr-BE': frBeCheck,
		  'fr-FR': frFrCheck,
		  'fr-LU': frLuCheck,
		  'hr-HR': hrHrCheck,
		  'hu-HU': huHuCheck,
		  'it-IT': itItCheck,
		  'lv-LV': lvLvCheck,
		  'mt-MT': mtMtCheck,
		  'nl-NL': nlNlCheck,
		  'pl-PL': plPlCheck,
		  'pt-BR': ptBrCheck,
		  'pt-PT': ptPtCheck,
		  'ro-RO': roRoCheck,
		  'sk-SK': skSkCheck,
		  'sl-SI': slSiCheck,
		  'sv-SE': svSeCheck,
		  'uk-UA': ukUaCheck
		};
		// taxIdCheck locale aliases
		taxIdCheck['lb-LU'] = taxIdCheck['fr-LU'];
		taxIdCheck['lt-LT'] = taxIdCheck['et-EE'];
		taxIdCheck['nl-BE'] = taxIdCheck['fr-BE'];
		taxIdCheck['fr-CA'] = taxIdCheck['en-CA'];

		// Regexes for locales where characters should be omitted before checking format
		var allsymbols = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g;
		var sanitizeRegexes = {
		  'de-AT': allsymbols,
		  'de-DE': /[\/\\]/g,
		  'fr-BE': allsymbols
		};
		// sanitizeRegexes locale aliases
		sanitizeRegexes['nl-BE'] = sanitizeRegexes['fr-BE'];

		/*
		 * Validator function
		 * Return true if the passed string is a valid tax identification number
		 * for the specified locale.
		 * Throw an error exception if the locale is not supported.
		 */
		function isTaxID(str) {
		  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
		  (0, _assertString.default)(str);
		  // Copy TIN to avoid replacement if sanitized
		  var strcopy = str.slice(0);
		  if (locale in taxIdFormat) {
		    if (locale in sanitizeRegexes) {
		      strcopy = strcopy.replace(sanitizeRegexes[locale], '');
		    }
		    if (!taxIdFormat[locale].test(strcopy)) {
		      return false;
		    }
		    if (locale in taxIdCheck) {
		      return taxIdCheck[locale](strcopy);
		    }
		    // Fallthrough; not all locales have algorithmic checks
		    return true;
		  }
		  throw new Error("Invalid locale '".concat(locale, "'"));
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isTaxID, isTaxID.exports));

	var isTaxIDExports = isTaxID.exports;

	var isMobilePhone$1 = {};

	Object.defineProperty(isMobilePhone$1, "__esModule", {
	  value: true
	});
	isMobilePhone$1.default = isMobilePhone;
	isMobilePhone$1.locales = void 0;
	var _assertString$4 = _interopRequireDefault$4(assertStringExports);
	function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	/* eslint-disable max-len */
	var phones = {
	  'am-AM': /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
	  'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
	  'ar-BH': /^(\+?973)?(3|6)\d{7}$/,
	  'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
	  'ar-LB': /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
	  'ar-EG': /^((\+?20)|0)?1[0125]\d{8}$/,
	  'ar-IQ': /^(\+?964|0)?7[0-9]\d{8}$/,
	  'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
	  'ar-KW': /^(\+?965)([569]\d{7}|41\d{6})$/,
	  'ar-LY': /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
	  'ar-MA': /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
	  'ar-OM': /^((\+|00)968)?(9[1-9])\d{6}$/,
	  'ar-PS': /^(\+?970|0)5[6|9](\d{7})$/,
	  'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
	  'ar-SD': /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
	  'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
	  'ar-TN': /^(\+?216)?[2459]\d{7}$/,
	  'az-AZ': /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
	  'bs-BA': /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
	  'be-BY': /^(\+?375)?(24|25|29|33|44)\d{7}$/,
	  'bg-BG': /^(\+?359|0)?8[789]\d{7}$/,
	  'bn-BD': /^(\+?880|0)1[13456789][0-9]{8}$/,
	  'ca-AD': /^(\+376)?[346]\d{5}$/,
	  'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
	  'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
	  'de-DE': /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
	  'de-AT': /^(\+43|0)\d{1,4}\d{3,12}$/,
	  'de-CH': /^(\+41|0)([1-9])\d{1,9}$/,
	  'de-LU': /^(\+352)?((6\d1)\d{6})$/,
	  'dv-MV': /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
	  'el-GR': /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
	  'el-CY': /^(\+?357?)?(9(9|6)\d{6})$/,
	  'en-AI': /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
	  'en-AU': /^(\+?61|0)4\d{8}$/,
	  'en-AG': /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
	  'en-BM': /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
	  'en-BS': /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
	  'en-GB': /^(\+?44|0)7\d{9}$/,
	  'en-GG': /^(\+?44|0)1481\d{6}$/,
	  'en-GH': /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
	  'en-GY': /^(\+592|0)6\d{6}$/,
	  'en-HK': /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
	  'en-MO': /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
	  'en-IE': /^(\+?353|0)8[356789]\d{7}$/,
	  'en-IN': /^(\+?91|0)?[6789]\d{9}$/,
	  'en-JM': /^(\+?876)?\d{7}$/,
	  'en-KE': /^(\+?254|0)(7|1)\d{8}$/,
	  'fr-CF': /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
	  'en-SS': /^(\+?211|0)(9[1257])\d{7}$/,
	  'en-KI': /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
	  'en-KN': /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
	  'en-LS': /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
	  'en-MT': /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
	  'en-MU': /^(\+?230|0)?\d{8}$/,
	  'en-MW': /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
	  'en-NA': /^(\+?264|0)(6|8)\d{7}$/,
	  'en-NG': /^(\+?234|0)?[789]\d{9}$/,
	  'en-NZ': /^(\+?64|0)[28]\d{7,9}$/,
	  'en-PG': /^(\+?675|0)?(7\d|8[18])\d{6}$/,
	  'en-PK': /^((00|\+)?92|0)3[0-6]\d{8}$/,
	  'en-PH': /^(09|\+639)\d{9}$/,
	  'en-RW': /^(\+?250|0)?[7]\d{8}$/,
	  'en-SG': /^(\+65)?[3689]\d{7}$/,
	  'en-SL': /^(\+?232|0)\d{8}$/,
	  'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
	  'en-UG': /^(\+?256|0)?[7]\d{8}$/,
	  'en-US': /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
	  'en-ZA': /^(\+?27|0)\d{9}$/,
	  'en-ZM': /^(\+?26)?09[567]\d{7}$/,
	  'en-ZW': /^(\+263)[0-9]{9}$/,
	  'en-BW': /^(\+?267)?(7[1-8]{1})\d{6}$/,
	  'es-AR': /^\+?549(11|[2368]\d)\d{8}$/,
	  'es-BO': /^(\+?591)?(6|7)\d{7}$/,
	  'es-CO': /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
	  'es-CL': /^(\+?56|0)[2-9]\d{1}\d{7}$/,
	  'es-CR': /^(\+506)?[2-8]\d{7}$/,
	  'es-CU': /^(\+53|0053)?5\d{7}$/,
	  'es-DO': /^(\+?1)?8[024]9\d{7}$/,
	  'es-HN': /^(\+?504)?[9|8|3|2]\d{7}$/,
	  'es-EC': /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
	  'es-ES': /^(\+?34)?[6|7]\d{8}$/,
	  'es-PE': /^(\+?51)?9\d{8}$/,
	  'es-MX': /^(\+?52)?(1|01)?\d{10,11}$/,
	  'es-NI': /^(\+?505)\d{7,8}$/,
	  'es-PA': /^(\+?507)\d{7,8}$/,
	  'es-PY': /^(\+?595|0)9[9876]\d{7}$/,
	  'es-SV': /^(\+?503)?[67]\d{7}$/,
	  'es-UY': /^(\+598|0)9[1-9][\d]{6}$/,
	  'es-VE': /^(\+?58)?(2|4)\d{9}$/,
	  'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
	  'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
	  'fi-FI': /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
	  'fj-FJ': /^(\+?679)?\s?\d{3}\s?\d{4}$/,
	  'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
	  'fr-BF': /^(\+226|0)[67]\d{7}$/,
	  'fr-BJ': /^(\+229)\d{8}$/,
	  'fr-CD': /^(\+?243|0)?(8|9)\d{8}$/,
	  'fr-CM': /^(\+?237)6[0-9]{8}$/,
	  'fr-FR': /^(\+?33|0)[67]\d{8}$/,
	  'fr-GF': /^(\+?594|0|00594)[67]\d{8}$/,
	  'fr-GP': /^(\+?590|0|00590)[67]\d{8}$/,
	  'fr-MQ': /^(\+?596|0|00596)[67]\d{8}$/,
	  'fr-PF': /^(\+?689)?8[789]\d{6}$/,
	  'fr-RE': /^(\+?262|0|00262)[67]\d{8}$/,
	  'fr-WF': /^(\+681)?\d{6}$/,
	  'he-IL': /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
	  'hu-HU': /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
	  'id-ID': /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
	  'ir-IR': /^(\+98|0)?9\d{9}$/,
	  'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
	  'it-SM': /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
	  'ja-JP': /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
	  'ka-GE': /^(\+?995)?(79\d{7}|5\d{8})$/,
	  'kk-KZ': /^(\+?7|8)?7\d{9}$/,
	  'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
	  'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
	  'ky-KG': /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
	  'lt-LT': /^(\+370|8)\d{8}$/,
	  'lv-LV': /^(\+?371)2\d{7}$/,
	  'mg-MG': /^((\+?261|0)(2|3)\d)?\d{7}$/,
	  'mn-MN': /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
	  'my-MM': /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
	  'ms-MY': /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
	  'mz-MZ': /^(\+?258)?8[234567]\d{7}$/,
	  'nb-NO': /^(\+?47)?[49]\d{7}$/,
	  'ne-NP': /^(\+?977)?9[78]\d{8}$/,
	  'nl-BE': /^(\+?32|0)4\d{8}$/,
	  'nl-NL': /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
	  'nl-AW': /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
	  'nn-NO': /^(\+?47)?[49]\d{7}$/,
	  'pl-PL': /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
	  'pt-BR': /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
	  'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
	  'pt-AO': /^(\+244)\d{9}$/,
	  'ro-MD': /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
	  'ro-RO': /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
	  'ru-RU': /^(\+?7|8)?9\d{9}$/,
	  'si-LK': /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
	  'sl-SI': /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
	  'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
	  'so-SO': /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
	  'sq-AL': /^(\+355|0)6[789]\d{6}$/,
	  'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
	  'sv-SE': /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
	  'tg-TJ': /^(\+?992)?[5][5]\d{7}$/,
	  'th-TH': /^(\+66|66|0)\d{9}$/,
	  'tr-TR': /^(\+?90|0)?5\d{9}$/,
	  'tk-TM': /^(\+993|993|8)\d{8}$/,
	  'uk-UA': /^(\+?38|8)?0\d{9}$/,
	  'uz-UZ': /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
	  'vi-VN': /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
	  'zh-CN': /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
	  'zh-TW': /^(\+?886\-?|0)?9\d{8}$/,
	  'dz-BT': /^(\+?975|0)?(17|16|77|02)\d{6}$/,
	  'ar-YE': /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
	  'ar-EH': /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
	  'fa-AF': /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
	};
	/* eslint-enable max-len */

	// aliases
	phones['en-CA'] = phones['en-US'];
	phones['fr-CA'] = phones['en-CA'];
	phones['fr-BE'] = phones['nl-BE'];
	phones['zh-HK'] = phones['en-HK'];
	phones['zh-MO'] = phones['en-MO'];
	phones['ga-IE'] = phones['en-IE'];
	phones['fr-CH'] = phones['de-CH'];
	phones['it-CH'] = phones['fr-CH'];
	function isMobilePhone(str, locale, options) {
	  (0, _assertString$4.default)(str);
	  if (options && options.strictMode && !str.startsWith('+')) {
	    return false;
	  }
	  if (Array.isArray(locale)) {
	    return locale.some(function (key) {
	      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
	      // istanbul ignore else
	      if (phones.hasOwnProperty(key)) {
	        var phone = phones[key];
	        if (phone.test(str)) {
	          return true;
	        }
	      }
	      return false;
	    });
	  } else if (locale in phones) {
	    return phones[locale].test(str);
	    // alias falsey locale as 'any'
	  } else if (!locale || locale === 'any') {
	    for (var key in phones) {
	      // istanbul ignore else
	      if (phones.hasOwnProperty(key)) {
	        var phone = phones[key];
	        if (phone.test(str)) {
	          return true;
	        }
	      }
	    }
	    return false;
	  }
	  throw new Error("Invalid locale '".concat(locale, "'"));
	}
	isMobilePhone$1.locales = Object.keys(phones);

	var isEthereumAddress = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isEthereumAddress;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var eth = /^(0x)[0-9a-f]{40}$/i;
		function isEthereumAddress(str) {
		  (0, _assertString.default)(str);
		  return eth.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isEthereumAddress, isEthereumAddress.exports));

	var isEthereumAddressExports = isEthereumAddress.exports;

	var isCurrency = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isCurrency;
		var _merge = _interopRequireDefault(mergeExports);
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function currencyRegex(options) {
		  var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
		  options.digits_after_decimal.forEach(function (digit, index) {
		    if (index !== 0) decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
		  });
		  var symbol = "(".concat(options.symbol.replace(/\W/, function (m) {
		      return "\\".concat(m);
		    }), ")").concat(options.require_symbol ? '' : '?'),
		    negative = '-?',
		    whole_dollar_amount_without_sep = '[1-9]\\d*',
		    whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"),
		    valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],
		    whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join('|'), ")?"),
		    decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? '' : '?');
		  var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : '');

		  // default is negative sign before symbol, but there are two other options (besides parens)
		  if (options.allow_negatives && !options.parens_for_negatives) {
		    if (options.negative_sign_after_digits) {
		      pattern += negative;
		    } else if (options.negative_sign_before_digits) {
		      pattern = negative + pattern;
		    }
		  }

		  // South African Rand, for example, uses R 123 (space) and R-123 (no space)
		  if (options.allow_negative_sign_placeholder) {
		    pattern = "( (?!\\-))?".concat(pattern);
		  } else if (options.allow_space_after_symbol) {
		    pattern = " ?".concat(pattern);
		  } else if (options.allow_space_after_digits) {
		    pattern += '( (?!$))?';
		  }
		  if (options.symbol_after_digits) {
		    pattern += symbol;
		  } else {
		    pattern = symbol + pattern;
		  }
		  if (options.allow_negatives) {
		    if (options.parens_for_negatives) {
		      pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
		    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
		      pattern = negative + pattern;
		    }
		  }

		  // ensure there's a dollar and/or decimal amount, and that
		  // it doesn't start with a space or a negative sign followed by a space
		  return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
		}
		var default_currency_options = {
		  symbol: '$',
		  require_symbol: false,
		  allow_space_after_symbol: false,
		  symbol_after_digits: false,
		  allow_negatives: true,
		  parens_for_negatives: false,
		  negative_sign_before_digits: false,
		  negative_sign_after_digits: false,
		  allow_negative_sign_placeholder: false,
		  thousands_separator: ',',
		  decimal_separator: '.',
		  allow_decimal: true,
		  require_decimal: false,
		  digits_after_decimal: [2],
		  allow_space_after_digits: false
		};
		function isCurrency(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_currency_options);
		  return currencyRegex(options).test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isCurrency, isCurrency.exports));

	var isCurrencyExports = isCurrency.exports;

	var isBtcAddress = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBtcAddress;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var bech32 = /^(bc1)[a-z0-9]{25,39}$/;
		var base58 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
		function isBtcAddress(str) {
		  (0, _assertString.default)(str);
		  return bech32.test(str) || base58.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBtcAddress, isBtcAddress.exports));

	var isBtcAddressExports = isBtcAddress.exports;

	var isISO6346$1 = {};

	Object.defineProperty(isISO6346$1, "__esModule", {
	  value: true
	});
	isISO6346$1.isFreightContainerID = void 0;
	isISO6346$1.isISO6346 = isISO6346;
	var _assertString$3 = _interopRequireDefault$3(assertStringExports);
	function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	// https://en.wikipedia.org/wiki/ISO_6346
	// according to ISO6346 standard, checksum digit is mandatory for freight container but recommended
	// for other container types (J and Z)
	var isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;
	var isDigit = /^[0-9]$/;
	function isISO6346(str) {
	  (0, _assertString$3.default)(str);
	  str = str.toUpperCase();
	  if (!isISO6346Str.test(str)) return false;
	  if (str.length === 11) {
	    var sum = 0;
	    for (var i = 0; i < str.length - 1; i++) {
	      if (!isDigit.test(str[i])) {
	        var convertedCode = void 0;
	        var letterCode = str.charCodeAt(i) - 55;
	        if (letterCode < 11) convertedCode = letterCode;else if (letterCode >= 11 && letterCode <= 20) convertedCode = 12 + letterCode % 11;else if (letterCode >= 21 && letterCode <= 30) convertedCode = 23 + letterCode % 21;else convertedCode = 34 + letterCode % 31;
	        sum += convertedCode * Math.pow(2, i);
	      } else sum += str[i] * Math.pow(2, i);
	    }
	    var checkSumDigit = sum % 11;
	    return Number(str[str.length - 1]) === checkSumDigit;
	  }
	  return true;
	}
	isISO6346$1.isFreightContainerID = isISO6346;

	var isISO6391 = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISO6391;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var isISO6391Set = new Set(['aa', 'ab', 'ae', 'af', 'ak', 'am', 'an', 'ar', 'as', 'av', 'ay', 'az', 'az', 'ba', 'be', 'bg', 'bh', 'bi', 'bm', 'bn', 'bo', 'br', 'bs', 'ca', 'ce', 'ch', 'co', 'cr', 'cs', 'cu', 'cv', 'cy', 'da', 'de', 'dv', 'dz', 'ee', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'ff', 'fi', 'fj', 'fo', 'fr', 'fy', 'ga', 'gd', 'gl', 'gn', 'gu', 'gv', 'ha', 'he', 'hi', 'ho', 'hr', 'ht', 'hu', 'hy', 'hz', 'ia', 'id', 'ie', 'ig', 'ii', 'ik', 'io', 'is', 'it', 'iu', 'ja', 'jv', 'ka', 'kg', 'ki', 'kj', 'kk', 'kl', 'km', 'kn', 'ko', 'kr', 'ks', 'ku', 'kv', 'kw', 'ky', 'la', 'lb', 'lg', 'li', 'ln', 'lo', 'lt', 'lu', 'lv', 'mg', 'mh', 'mi', 'mk', 'ml', 'mn', 'mr', 'ms', 'mt', 'my', 'na', 'nb', 'nd', 'ne', 'ng', 'nl', 'nn', 'no', 'nr', 'nv', 'ny', 'oc', 'oj', 'om', 'or', 'os', 'pa', 'pi', 'pl', 'ps', 'pt', 'qu', 'rm', 'rn', 'ro', 'ru', 'rw', 'sa', 'sc', 'sd', 'se', 'sg', 'si', 'sk', 'sl', 'sm', 'sn', 'so', 'sq', 'sr', 'ss', 'st', 'su', 'sv', 'sw', 'ta', 'te', 'tg', 'th', 'ti', 'tk', 'tl', 'tn', 'to', 'tr', 'ts', 'tt', 'tw', 'ty', 'ug', 'uk', 'ur', 'uz', 've', 'vi', 'vo', 'wa', 'wo', 'xh', 'yi', 'yo', 'za', 'zh', 'zu']);
		function isISO6391(str) {
		  (0, _assertString.default)(str);
		  return isISO6391Set.has(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISO6391, isISO6391.exports));

	var isISO6391Exports = isISO6391.exports;

	var isISO8601 = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISO8601;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/* eslint-disable max-len */
		// from http://goo.gl/0ejHHW
		var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
		// same as above, except with a strict 'T' separator between date and time
		var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
		/* eslint-enable max-len */
		var isValidDate = function isValidDate(str) {
		  // str must have passed the ISO8601 check
		  // this check is meant to catch invalid dates
		  // like 2009-02-31
		  // first check for ordinal dates
		  var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
		  if (ordinalMatch) {
		    var oYear = Number(ordinalMatch[1]);
		    var oDay = Number(ordinalMatch[2]);
		    // if is leap year
		    if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0) return oDay <= 366;
		    return oDay <= 365;
		  }
		  var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
		  var year = match[1];
		  var month = match[2];
		  var day = match[3];
		  var monthString = month ? "0".concat(month).slice(-2) : month;
		  var dayString = day ? "0".concat(day).slice(-2) : day;

		  // create a date object and compare
		  var d = new Date("".concat(year, "-").concat(monthString || '01', "-").concat(dayString || '01'));
		  if (month && day) {
		    return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
		  }
		  return true;
		};
		function isISO8601(str) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		  (0, _assertString.default)(str);
		  var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
		  if (check && options.strict) return isValidDate(str);
		  return check;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISO8601, isISO8601.exports));

	var isISO8601Exports = isISO8601.exports;

	var isRFC3339 = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isRFC3339;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */

		var dateFullYear = /[0-9]{4}/;
		var dateMonth = /(0[1-9]|1[0-2])/;
		var dateMDay = /([12]\d|0[1-9]|3[01])/;
		var timeHour = /([01][0-9]|2[0-3])/;
		var timeMinute = /[0-5][0-9]/;
		var timeSecond = /([0-5][0-9]|60)/;
		var timeSecFrac = /(\.[0-9]+)?/;
		var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
		var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
		var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
		var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
		var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
		var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
		function isRFC3339(str) {
		  (0, _assertString.default)(str);
		  return rfc3339.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isRFC3339, isRFC3339.exports));

	var isRFC3339Exports = isRFC3339.exports;

	var isISO31661Alpha3 = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISO31661Alpha3;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
		var validISO31661Alpha3CountriesCodes = new Set(['AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE', 'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA', 'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK', 'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM', 'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB', 'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI', 'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN', 'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE', 'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX', 'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC', 'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN', 'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM', 'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD', 'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL', 'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT', 'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE']);
		function isISO31661Alpha3(str) {
		  (0, _assertString.default)(str);
		  return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISO31661Alpha3, isISO31661Alpha3.exports));

	var isISO31661Alpha3Exports = isISO31661Alpha3.exports;

	var isISO4217$1 = {};

	Object.defineProperty(isISO4217$1, "__esModule", {
	  value: true
	});
	isISO4217$1.CurrencyCodes = void 0;
	isISO4217$1.default = isISO4217;
	var _assertString$2 = _interopRequireDefault$2(assertStringExports);
	function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	// from https://en.wikipedia.org/wiki/ISO_4217
	var validISO4217CurrencyCodes = new Set(['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYN', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLE', 'SLL', 'SOS', 'SRD', 'SSP', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'UYI', 'UYU', 'UYW', 'UZS', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XAG', 'XAU', 'XBA', 'XBB', 'XBC', 'XBD', 'XCD', 'XDR', 'XOF', 'XPD', 'XPF', 'XPT', 'XSU', 'XTS', 'XUA', 'XXX', 'YER', 'ZAR', 'ZMW', 'ZWL']);
	function isISO4217(str) {
	  (0, _assertString$2.default)(str);
	  return validISO4217CurrencyCodes.has(str.toUpperCase());
	}
	isISO4217$1.CurrencyCodes = validISO4217CurrencyCodes;

	var isBase32 = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBase32;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var base32 = /^[A-Z2-7]+=*$/;
		var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
		var defaultBase32Options = {
		  crockford: false
		};
		function isBase32(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, defaultBase32Options);
		  if (options.crockford) {
		    return crockfordBase32.test(str);
		  }
		  var len = str.length;
		  if (len % 8 === 0 && base32.test(str)) {
		    return true;
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBase32, isBase32.exports));

	var isBase32Exports = isBase32.exports;

	var isBase58 = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBase58;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		// Accepted chars - 123456789ABCDEFGH JKLMN PQRSTUVWXYZabcdefghijk mnopqrstuvwxyz
		var base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;
		function isBase58(str) {
		  (0, _assertString.default)(str);
		  if (base58Reg.test(str)) {
		    return true;
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBase58, isBase58.exports));

	var isBase58Exports = isBase58.exports;

	var isDataURI = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isDataURI;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
		var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
		var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
		function isDataURI(str) {
		  (0, _assertString.default)(str);
		  var data = str.split(',');
		  if (data.length < 2) {
		    return false;
		  }
		  var attributes = data.shift().trim().split(';');
		  var schemeAndMediaType = attributes.shift();
		  if (schemeAndMediaType.slice(0, 5) !== 'data:') {
		    return false;
		  }
		  var mediaType = schemeAndMediaType.slice(5);
		  if (mediaType !== '' && !validMediaType.test(mediaType)) {
		    return false;
		  }
		  for (var i = 0; i < attributes.length; i++) {
		    if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') && !validAttribute.test(attributes[i])) {
		      return false;
		    }
		  }
		  for (var _i = 0; _i < data.length; _i++) {
		    if (!validData.test(data[_i])) {
		      return false;
		    }
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isDataURI, isDataURI.exports));

	var isDataURIExports = isDataURI.exports;

	var isMagnetURI = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMagnetURI;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
		function isMagnetURI(url) {
		  (0, _assertString.default)(url);
		  if (url.indexOf('magnet:?') !== 0) {
		    return false;
		  }
		  return magnetURIComponent.test(url);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMagnetURI, isMagnetURI.exports));

	var isMagnetURIExports = isMagnetURI.exports;

	var isMailtoURI = {exports: {}};

	var trim = {exports: {}};

	var rtrim = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = rtrim;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function rtrim(str, chars) {
		  (0, _assertString.default)(str);
		  if (chars) {
		    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
		    var pattern = new RegExp("[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "]+$"), 'g');
		    return str.replace(pattern, '');
		  }
		  // Use a faster and more safe than regex trim method https://blog.stevenlevithan.com/archives/faster-trim-javascript
		  var strIndex = str.length - 1;
		  while (/\s/.test(str.charAt(strIndex))) {
		    strIndex -= 1;
		  }
		  return str.slice(0, strIndex + 1);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (rtrim, rtrim.exports));

	var rtrimExports = rtrim.exports;

	var ltrim = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = ltrim;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function ltrim(str, chars) {
		  (0, _assertString.default)(str);
		  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
		  var pattern = chars ? new RegExp("^[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "]+"), 'g') : /^\s+/g;
		  return str.replace(pattern, '');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (ltrim, ltrim.exports));

	var ltrimExports = ltrim.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = trim;
		var _rtrim = _interopRequireDefault(rtrimExports);
		var _ltrim = _interopRequireDefault(ltrimExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function trim(str, chars) {
		  return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (trim, trim.exports));

	var trimExports = trim.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMailtoURI;
		var _trim = _interopRequireDefault(trimExports);
		var _isEmail = _interopRequireDefault(isEmailExports);
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
		function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
		function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
		function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
		function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
		function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
		function parseMailtoQueryString(queryString) {
		  var allowedParams = new Set(['subject', 'body', 'cc', 'bcc']),
		    query = {
		      cc: '',
		      bcc: ''
		    };
		  var isParseFailed = false;
		  var queryParams = queryString.split('&');
		  if (queryParams.length > 4) {
		    return false;
		  }
		  var _iterator = _createForOfIteratorHelper(queryParams),
		    _step;
		  try {
		    for (_iterator.s(); !(_step = _iterator.n()).done;) {
		      var q = _step.value;
		      var _q$split = q.split('='),
		        _q$split2 = _slicedToArray(_q$split, 2),
		        key = _q$split2[0],
		        value = _q$split2[1];

		      // checked for invalid and duplicated query params
		      if (key && !allowedParams.has(key)) {
		        isParseFailed = true;
		        break;
		      }
		      if (value && (key === 'cc' || key === 'bcc')) {
		        query[key] = value;
		      }
		      if (key) {
		        allowedParams.delete(key);
		      }
		    }
		  } catch (err) {
		    _iterator.e(err);
		  } finally {
		    _iterator.f();
		  }
		  return isParseFailed ? false : query;
		}
		function isMailtoURI(url, options) {
		  (0, _assertString.default)(url);
		  if (url.indexOf('mailto:') !== 0) {
		    return false;
		  }
		  var _url$replace$split = url.replace('mailto:', '').split('?'),
		    _url$replace$split2 = _slicedToArray(_url$replace$split, 2),
		    to = _url$replace$split2[0],
		    _url$replace$split2$ = _url$replace$split2[1],
		    queryString = _url$replace$split2$ === void 0 ? '' : _url$replace$split2$;
		  if (!to && !queryString) {
		    return true;
		  }
		  var query = parseMailtoQueryString(queryString);
		  if (!query) {
		    return false;
		  }
		  return "".concat(to, ",").concat(query.cc, ",").concat(query.bcc).split(',').every(function (email) {
		    email = (0, _trim.default)(email, ' ');
		    if (email) {
		      return (0, _isEmail.default)(email, options);
		    }
		    return true;
		  });
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMailtoURI, isMailtoURI.exports));

	var isMailtoURIExports = isMailtoURI.exports;

	var isMimeType = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMimeType;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/*
		  Checks if the provided string matches to a correct Media type format (MIME type)

		  This function only checks is the string format follows the
		  etablished rules by the according RFC specifications.
		  This function supports 'charset' in textual media types
		  (https://tools.ietf.org/html/rfc6657).

		  This function does not check against all the media types listed
		  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)
		  because of lightness purposes : it would require to include
		  all these MIME types in this librairy, which would weigh it
		  significantly. This kind of effort maybe is not worth for the use that
		  this function has in this entire librairy.

		  More informations in the RFC specifications :
		  - https://tools.ietf.org/html/rfc2045
		  - https://tools.ietf.org/html/rfc2046
		  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1
		  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5
		*/

		// Match simple MIME types
		// NB :
		//   Subtype length must not exceed 100 characters.
		//   This rule does not comply to the RFC specs (what is the max length ?).
		var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i; // eslint-disable-line max-len

		// Handle "charset" in "text/*"
		var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i; // eslint-disable-line max-len

		// Handle "boundary" in "multipart/*"
		var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i; // eslint-disable-line max-len

		function isMimeType(str) {
		  (0, _assertString.default)(str);
		  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMimeType, isMimeType.exports));

	var isMimeTypeExports = isMimeType.exports;

	var isLatLong = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLatLong;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
		var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
		var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
		var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
		var defaultLatLongOptions = {
		  checkDMS: false
		};
		function isLatLong(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, defaultLatLongOptions);
		  if (!str.includes(',')) return false;
		  var pair = str.split(',');
		  if (pair[0].startsWith('(') && !pair[1].endsWith(')') || pair[1].endsWith(')') && !pair[0].startsWith('(')) return false;
		  if (options.checkDMS) {
		    return latDMS.test(pair[0]) && longDMS.test(pair[1]);
		  }
		  return lat.test(pair[0]) && long.test(pair[1]);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLatLong, isLatLong.exports));

	var isLatLongExports = isLatLong.exports;

	var isPostalCode$1 = {};

	Object.defineProperty(isPostalCode$1, "__esModule", {
	  value: true
	});
	isPostalCode$1.default = isPostalCode;
	isPostalCode$1.locales = void 0;
	var _assertString$1 = _interopRequireDefault$1(assertStringExports);
	function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	// common patterns
	var threeDigit = /^\d{3}$/;
	var fourDigit = /^\d{4}$/;
	var fiveDigit = /^\d{5}$/;
	var sixDigit = /^\d{6}$/;
	var patterns = {
	  AD: /^AD\d{3}$/,
	  AT: fourDigit,
	  AU: fourDigit,
	  AZ: /^AZ\d{4}$/,
	  BA: /^([7-8]\d{4}$)/,
	  BE: fourDigit,
	  BG: fourDigit,
	  BR: /^\d{5}-\d{3}$/,
	  BY: /^2[1-4]\d{4}$/,
	  CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
	  CH: fourDigit,
	  CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
	  CZ: /^\d{3}\s?\d{2}$/,
	  DE: fiveDigit,
	  DK: fourDigit,
	  DO: fiveDigit,
	  DZ: fiveDigit,
	  EE: fiveDigit,
	  ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
	  FI: fiveDigit,
	  FR: /^\d{2}\s?\d{3}$/,
	  GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
	  GR: /^\d{3}\s?\d{2}$/,
	  HR: /^([1-5]\d{4}$)/,
	  HT: /^HT\d{4}$/,
	  HU: fourDigit,
	  ID: fiveDigit,
	  IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
	  IL: /^(\d{5}|\d{7})$/,
	  IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
	  IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
	  IS: threeDigit,
	  IT: fiveDigit,
	  JP: /^\d{3}\-\d{4}$/,
	  KE: fiveDigit,
	  KR: /^(\d{5}|\d{6})$/,
	  LI: /^(948[5-9]|949[0-7])$/,
	  LT: /^LT\-\d{5}$/,
	  LU: fourDigit,
	  LV: /^LV\-\d{4}$/,
	  LK: fiveDigit,
	  MG: threeDigit,
	  MX: fiveDigit,
	  MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
	  MY: fiveDigit,
	  NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
	  NO: fourDigit,
	  NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
	  NZ: fourDigit,
	  PL: /^\d{2}\-\d{3}$/,
	  PR: /^00[679]\d{2}([ -]\d{4})?$/,
	  PT: /^\d{4}\-\d{3}?$/,
	  RO: sixDigit,
	  RU: sixDigit,
	  SA: fiveDigit,
	  SE: /^[1-9]\d{2}\s?\d{2}$/,
	  SG: sixDigit,
	  SI: fourDigit,
	  SK: /^\d{3}\s?\d{2}$/,
	  TH: fiveDigit,
	  TN: fourDigit,
	  TW: /^\d{3}(\d{2})?$/,
	  UA: fiveDigit,
	  US: /^\d{5}(-\d{4})?$/,
	  ZA: fourDigit,
	  ZM: fiveDigit
	};
	isPostalCode$1.locales = Object.keys(patterns);
	function isPostalCode(str, locale) {
	  (0, _assertString$1.default)(str);
	  if (locale in patterns) {
	    return patterns[locale].test(str);
	  } else if (locale === 'any') {
	    for (var key in patterns) {
	      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
	      // istanbul ignore else
	      if (patterns.hasOwnProperty(key)) {
	        var pattern = patterns[key];
	        if (pattern.test(str)) {
	          return true;
	        }
	      }
	    }
	    return false;
	  }
	  throw new Error("Invalid locale '".concat(locale, "'"));
	}

	var _escape = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = escape;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function escape(str) {
		  (0, _assertString.default)(str);
		  return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '&#x2F;').replace(/\\/g, '&#x5C;').replace(/`/g, '&#96;');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (_escape, _escape.exports));

	var _escapeExports = _escape.exports;

	var _unescape = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = unescape;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function unescape(str) {
		  (0, _assertString.default)(str);
		  return str.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '/').replace(/&#x5C;/g, '\\').replace(/&#96;/g, '`').replace(/&amp;/g, '&');
		  // &amp; replacement has to be the last one to prevent
		  // bugs with intermediate strings containing escape sequences
		  // See: https://github.com/validatorjs/validator.js/issues/1827
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (_unescape, _unescape.exports));

	var _unescapeExports = _unescape.exports;

	var stripLow = {exports: {}};

	var blacklist = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = blacklist;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function blacklist(str, chars) {
		  (0, _assertString.default)(str);
		  return str.replace(new RegExp("[".concat(chars, "]+"), 'g'), '');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (blacklist, blacklist.exports));

	var blacklistExports = blacklist.exports;

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = stripLow;
		var _assertString = _interopRequireDefault(assertStringExports);
		var _blacklist = _interopRequireDefault(blacklistExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function stripLow(str, keep_new_lines) {
		  (0, _assertString.default)(str);
		  var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
		  return (0, _blacklist.default)(str, chars);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (stripLow, stripLow.exports));

	var stripLowExports = stripLow.exports;

	var whitelist = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = whitelist;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function whitelist(str, chars) {
		  (0, _assertString.default)(str);
		  return str.replace(new RegExp("[^".concat(chars, "]+"), 'g'), '');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (whitelist, whitelist.exports));

	var whitelistExports = whitelist.exports;

	var isWhitelisted = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isWhitelisted;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		function isWhitelisted(str, chars) {
		  (0, _assertString.default)(str);
		  for (var i = str.length - 1; i >= 0; i--) {
		    if (chars.indexOf(str[i]) === -1) {
		      return false;
		    }
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isWhitelisted, isWhitelisted.exports));

	var isWhitelistedExports = isWhitelisted.exports;

	var normalizeEmail = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = normalizeEmail;
		var _merge = _interopRequireDefault(mergeExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var default_normalize_email_options = {
		  // The following options apply to all email addresses
		  // Lowercases the local part of the email address.
		  // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
		  // The domain is always lowercased, as per RFC 1035
		  all_lowercase: true,
		  // The following conversions are specific to GMail
		  // Lowercases the local part of the GMail address (known to be case-insensitive)
		  gmail_lowercase: true,
		  // Removes dots from the local part of the email address, as that's ignored by GMail
		  gmail_remove_dots: true,
		  // Removes the subaddress (e.g. "+foo") from the email address
		  gmail_remove_subaddress: true,
		  // Conversts the googlemail.com domain to gmail.com
		  gmail_convert_googlemaildotcom: true,
		  // The following conversions are specific to Outlook.com / Windows Live / Hotmail
		  // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
		  outlookdotcom_lowercase: true,
		  // Removes the subaddress (e.g. "+foo") from the email address
		  outlookdotcom_remove_subaddress: true,
		  // The following conversions are specific to Yahoo
		  // Lowercases the local part of the Yahoo address (known to be case-insensitive)
		  yahoo_lowercase: true,
		  // Removes the subaddress (e.g. "-foo") from the email address
		  yahoo_remove_subaddress: true,
		  // The following conversions are specific to Yandex
		  // Lowercases the local part of the Yandex address (known to be case-insensitive)
		  yandex_lowercase: true,
		  // The following conversions are specific to iCloud
		  // Lowercases the local part of the iCloud address (known to be case-insensitive)
		  icloud_lowercase: true,
		  // Removes the subaddress (e.g. "+foo") from the email address
		  icloud_remove_subaddress: true
		};

		// List of domains used by iCloud
		var icloud_domains = ['icloud.com', 'me.com'];

		// List of domains used by Outlook.com and its predecessors
		// This list is likely incomplete.
		// Partial reference:
		// https://blogs.office.com/2013/04/17/outlook-com-gets-two-step-verification-sign-in-by-alias-and-new-international-domains/
		var outlookdotcom_domains = ['hotmail.at', 'hotmail.be', 'hotmail.ca', 'hotmail.cl', 'hotmail.co.il', 'hotmail.co.nz', 'hotmail.co.th', 'hotmail.co.uk', 'hotmail.com', 'hotmail.com.ar', 'hotmail.com.au', 'hotmail.com.br', 'hotmail.com.gr', 'hotmail.com.mx', 'hotmail.com.pe', 'hotmail.com.tr', 'hotmail.com.vn', 'hotmail.cz', 'hotmail.de', 'hotmail.dk', 'hotmail.es', 'hotmail.fr', 'hotmail.hu', 'hotmail.id', 'hotmail.ie', 'hotmail.in', 'hotmail.it', 'hotmail.jp', 'hotmail.kr', 'hotmail.lv', 'hotmail.my', 'hotmail.ph', 'hotmail.pt', 'hotmail.sa', 'hotmail.sg', 'hotmail.sk', 'live.be', 'live.co.uk', 'live.com', 'live.com.ar', 'live.com.mx', 'live.de', 'live.es', 'live.eu', 'live.fr', 'live.it', 'live.nl', 'msn.com', 'outlook.at', 'outlook.be', 'outlook.cl', 'outlook.co.il', 'outlook.co.nz', 'outlook.co.th', 'outlook.com', 'outlook.com.ar', 'outlook.com.au', 'outlook.com.br', 'outlook.com.gr', 'outlook.com.pe', 'outlook.com.tr', 'outlook.com.vn', 'outlook.cz', 'outlook.de', 'outlook.dk', 'outlook.es', 'outlook.fr', 'outlook.hu', 'outlook.id', 'outlook.ie', 'outlook.in', 'outlook.it', 'outlook.jp', 'outlook.kr', 'outlook.lv', 'outlook.my', 'outlook.ph', 'outlook.pt', 'outlook.sa', 'outlook.sg', 'outlook.sk', 'passport.com'];

		// List of domains used by Yahoo Mail
		// This list is likely incomplete
		var yahoo_domains = ['rocketmail.com', 'yahoo.ca', 'yahoo.co.uk', 'yahoo.com', 'yahoo.de', 'yahoo.fr', 'yahoo.in', 'yahoo.it', 'ymail.com'];

		// List of domains used by yandex.ru
		var yandex_domains = ['yandex.ru', 'yandex.ua', 'yandex.kz', 'yandex.com', 'yandex.by', 'ya.ru'];

		// replace single dots, but not multiple consecutive dots
		function dotsReplacer(match) {
		  if (match.length > 1) {
		    return match;
		  }
		  return '';
		}
		function normalizeEmail(email, options) {
		  options = (0, _merge.default)(options, default_normalize_email_options);
		  var raw_parts = email.split('@');
		  var domain = raw_parts.pop();
		  var user = raw_parts.join('@');
		  var parts = [user, domain];

		  // The domain is always lowercased, as it's case-insensitive per RFC 1035
		  parts[1] = parts[1].toLowerCase();
		  if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
		    // Address is GMail
		    if (options.gmail_remove_subaddress) {
		      parts[0] = parts[0].split('+')[0];
		    }
		    if (options.gmail_remove_dots) {
		      // this does not replace consecutive dots like example..email@gmail.com
		      parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
		    }
		    if (!parts[0].length) {
		      return false;
		    }
		    if (options.all_lowercase || options.gmail_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		    parts[1] = options.gmail_convert_googlemaildotcom ? 'gmail.com' : parts[1];
		  } else if (icloud_domains.indexOf(parts[1]) >= 0) {
		    // Address is iCloud
		    if (options.icloud_remove_subaddress) {
		      parts[0] = parts[0].split('+')[0];
		    }
		    if (!parts[0].length) {
		      return false;
		    }
		    if (options.all_lowercase || options.icloud_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		  } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
		    // Address is Outlook.com
		    if (options.outlookdotcom_remove_subaddress) {
		      parts[0] = parts[0].split('+')[0];
		    }
		    if (!parts[0].length) {
		      return false;
		    }
		    if (options.all_lowercase || options.outlookdotcom_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		  } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
		    // Address is Yahoo
		    if (options.yahoo_remove_subaddress) {
		      var components = parts[0].split('-');
		      parts[0] = components.length > 1 ? components.slice(0, -1).join('-') : components[0];
		    }
		    if (!parts[0].length) {
		      return false;
		    }
		    if (options.all_lowercase || options.yahoo_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		  } else if (yandex_domains.indexOf(parts[1]) >= 0) {
		    if (options.all_lowercase || options.yandex_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		    parts[1] = 'yandex.ru'; // all yandex domains are equal, 1st preferred
		  } else if (options.all_lowercase) {
		    // Any other address
		    parts[0] = parts[0].toLowerCase();
		  }
		  return parts.join('@');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (normalizeEmail, normalizeEmail.exports));

	var normalizeEmailExports = normalizeEmail.exports;

	var isSlug = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isSlug;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
		function isSlug(str) {
		  (0, _assertString.default)(str);
		  return charsetRegex.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isSlug, isSlug.exports));

	var isSlugExports = isSlug.exports;

	var isLicensePlate = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLicensePlate;
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var validators = {
		  'cs-CZ': function csCZ(str) {
		    return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str);
		  },
		  'de-DE': function deDE(str) {
		    return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|AÖ|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|BÖ|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|FÜ|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|GÖ|GP|GR|GS|GT|GÜ|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|LÖ|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|MÜ|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|NÖ|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|TÜ|ÜB|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|WÜ|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BÜD|BUL|BÜR|BÜS|BÜZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DÜW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FLÖ|FOR|FRG|FRI|FRW|FTL|FÜS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HMÜ|HOG|HOH|HOL|HOM|HOR|HÖS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JÜL|KEH|KEL|KEM|KIB|KLE|KLZ|KÖN|KÖT|KÖZ|KRU|KÜN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LÖB|LOS|LRO|LSZ|LÜN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MÜB|MÜR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|ÖHR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PLÖ|PRÜ|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RÜD|RÜG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SLÜ|SLZ|SMÜ|SOB|SOG|SOK|SÖM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SÜW|SWA|SZB|TBB|TDO|TET|TIR|TÖL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WÜM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(str);
		  },
		  'de-LI': function deLI(str) {
		    return /^FL[- ]?\d{1,5}[UZ]?$/.test(str);
		  },
		  'en-IN': function enIN(str) {
		    return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str);
		  },
		  'es-AR': function esAR(str) {
		    return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str);
		  },
		  'fi-FI': function fiFI(str) {
		    return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str);
		  },
		  'hu-HU': function huHU(str) {
		    return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(str);
		  },
		  'pt-BR': function ptBR(str) {
		    return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str);
		  },
		  'pt-PT': function ptPT(str) {
		    return /^([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})$/.test(str);
		  },
		  'sq-AL': function sqAL(str) {
		    return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(str);
		  },
		  'sv-SE': function svSE(str) {
		    return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-ZÅÄÖ ]{2,7}$)/.test(str.trim());
		  },
		  'en-PK': function enPK(str) {
		    return /(^[A-Z]{2}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{3}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{4}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]((\s|-){0,1})[0-9]{4}((\s|-)[0-9]{2}){0,1}$)/.test(str.trim());
		  }
		};
		function isLicensePlate(str, locale) {
		  (0, _assertString.default)(str);
		  if (locale in validators) {
		    return validators[locale](str);
		  } else if (locale === 'any') {
		    for (var key in validators) {
		      /* eslint guard-for-in: 0 */
		      var validator = validators[key];
		      if (validator(str)) {
		        return true;
		      }
		    }
		    return false;
		  }
		  throw new Error("Invalid locale '".concat(locale, "'"));
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLicensePlate, isLicensePlate.exports));

	var isLicensePlateExports = isLicensePlate.exports;

	var isStrongPassword = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isStrongPassword;
		var _merge = _interopRequireDefault(mergeExports);
		var _assertString = _interopRequireDefault(assertStringExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var upperCaseRegex = /^[A-Z]$/;
		var lowerCaseRegex = /^[a-z]$/;
		var numberRegex = /^[0-9]$/;
		var symbolRegex = /^[-#!$@£%^&*()_+|~=`{}\[\]:";'<>?,.\/\\ ]$/;
		var defaultOptions = {
		  minLength: 8,
		  minLowercase: 1,
		  minUppercase: 1,
		  minNumbers: 1,
		  minSymbols: 1,
		  returnScore: false,
		  pointsPerUnique: 1,
		  pointsPerRepeat: 0.5,
		  pointsForContainingLower: 10,
		  pointsForContainingUpper: 10,
		  pointsForContainingNumber: 10,
		  pointsForContainingSymbol: 10
		};

		/* Counts number of occurrences of each char in a string
		 * could be moved to util/ ?
		*/
		function countChars(str) {
		  var result = {};
		  Array.from(str).forEach(function (char) {
		    var curVal = result[char];
		    if (curVal) {
		      result[char] += 1;
		    } else {
		      result[char] = 1;
		    }
		  });
		  return result;
		}

		/* Return information about a password */
		function analyzePassword(password) {
		  var charMap = countChars(password);
		  var analysis = {
		    length: password.length,
		    uniqueChars: Object.keys(charMap).length,
		    uppercaseCount: 0,
		    lowercaseCount: 0,
		    numberCount: 0,
		    symbolCount: 0
		  };
		  Object.keys(charMap).forEach(function (char) {
		    /* istanbul ignore else */
		    if (upperCaseRegex.test(char)) {
		      analysis.uppercaseCount += charMap[char];
		    } else if (lowerCaseRegex.test(char)) {
		      analysis.lowercaseCount += charMap[char];
		    } else if (numberRegex.test(char)) {
		      analysis.numberCount += charMap[char];
		    } else if (symbolRegex.test(char)) {
		      analysis.symbolCount += charMap[char];
		    }
		  });
		  return analysis;
		}
		function scorePassword(analysis, scoringOptions) {
		  var points = 0;
		  points += analysis.uniqueChars * scoringOptions.pointsPerUnique;
		  points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;
		  if (analysis.lowercaseCount > 0) {
		    points += scoringOptions.pointsForContainingLower;
		  }
		  if (analysis.uppercaseCount > 0) {
		    points += scoringOptions.pointsForContainingUpper;
		  }
		  if (analysis.numberCount > 0) {
		    points += scoringOptions.pointsForContainingNumber;
		  }
		  if (analysis.symbolCount > 0) {
		    points += scoringOptions.pointsForContainingSymbol;
		  }
		  return points;
		}
		function isStrongPassword(str) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
		  (0, _assertString.default)(str);
		  var analysis = analyzePassword(str);
		  options = (0, _merge.default)(options || {}, defaultOptions);
		  if (options.returnScore) {
		    return scorePassword(analysis, options);
		  }
		  return analysis.length >= options.minLength && analysis.lowercaseCount >= options.minLowercase && analysis.uppercaseCount >= options.minUppercase && analysis.numberCount >= options.minNumbers && analysis.symbolCount >= options.minSymbols;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isStrongPassword, isStrongPassword.exports));

	var isStrongPasswordExports = isStrongPassword.exports;

	var isVAT$1 = {};

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	Object.defineProperty(isVAT$1, "__esModule", {
	  value: true
	});
	isVAT$1.default = isVAT;
	isVAT$1.vatMatchers = void 0;
	var _assertString = _interopRequireDefault(assertStringExports);
	var algorithms = _interopRequireWildcard(algorithms$1);
	function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
	function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	var AU = function AU(str) {
	  var match = str.match(/^(AU)?(\d{11})$/);
	  if (!match) {
	    return false;
	  }
	  // @see {@link https://abr.business.gov.au/Help/AbnFormat}
	  var weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
	  str = str.replace(/^AU/, '');
	  var ABN = (parseInt(str.slice(0, 1), 10) - 1).toString() + str.slice(1);
	  var total = 0;
	  for (var i = 0; i < 11; i++) {
	    total += weights[i] * ABN.charAt(i);
	  }
	  return total !== 0 && total % 89 === 0;
	};
	var CH = function CH(str) {
	  // @see {@link https://www.ech.ch/de/ech/ech-0097/5.2.0}
	  var hasValidCheckNumber = function hasValidCheckNumber(digits) {
	    var lastDigit = digits.pop(); // used as check number
	    var weights = [5, 4, 3, 2, 7, 6, 5, 4];
	    var calculatedCheckNumber = (11 - digits.reduce(function (acc, el, idx) {
	      return acc + el * weights[idx];
	    }, 0) % 11) % 11;
	    return lastDigit === calculatedCheckNumber;
	  };

	  // @see {@link https://www.estv.admin.ch/estv/de/home/mehrwertsteuer/uid/mwst-uid-nummer.html}
	  return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(str) && hasValidCheckNumber(str.match(/\d/g).map(function (el) {
	    return +el;
	  }));
	};
	var PT = function PT(str) {
	  var match = str.match(/^(PT)?(\d{9})$/);
	  if (!match) {
	    return false;
	  }
	  var tin = match[2];
	  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {
	    return parseInt(a, 10);
	  }), 9) % 11;
	  if (checksum > 9) {
	    return parseInt(tin[8], 10) === 0;
	  }
	  return checksum === parseInt(tin[8], 10);
	};
	var vatMatchers = isVAT$1.vatMatchers = {
	  /**
	   * European Union VAT identification numbers
	   */
	  AT: function AT(str) {
	    return /^(AT)?U\d{8}$/.test(str);
	  },
	  BE: function BE(str) {
	    return /^(BE)?\d{10}$/.test(str);
	  },
	  BG: function BG(str) {
	    return /^(BG)?\d{9,10}$/.test(str);
	  },
	  HR: function HR(str) {
	    return /^(HR)?\d{11}$/.test(str);
	  },
	  CY: function CY(str) {
	    return /^(CY)?\w{9}$/.test(str);
	  },
	  CZ: function CZ(str) {
	    return /^(CZ)?\d{8,10}$/.test(str);
	  },
	  DK: function DK(str) {
	    return /^(DK)?\d{8}$/.test(str);
	  },
	  EE: function EE(str) {
	    return /^(EE)?\d{9}$/.test(str);
	  },
	  FI: function FI(str) {
	    return /^(FI)?\d{8}$/.test(str);
	  },
	  FR: function FR(str) {
	    return /^(FR)?\w{2}\d{9}$/.test(str);
	  },
	  DE: function DE(str) {
	    return /^(DE)?\d{9}$/.test(str);
	  },
	  EL: function EL(str) {
	    return /^(EL)?\d{9}$/.test(str);
	  },
	  HU: function HU(str) {
	    return /^(HU)?\d{8}$/.test(str);
	  },
	  IE: function IE(str) {
	    return /^(IE)?\d{7}\w{1}(W)?$/.test(str);
	  },
	  IT: function IT(str) {
	    return /^(IT)?\d{11}$/.test(str);
	  },
	  LV: function LV(str) {
	    return /^(LV)?\d{11}$/.test(str);
	  },
	  LT: function LT(str) {
	    return /^(LT)?\d{9,12}$/.test(str);
	  },
	  LU: function LU(str) {
	    return /^(LU)?\d{8}$/.test(str);
	  },
	  MT: function MT(str) {
	    return /^(MT)?\d{8}$/.test(str);
	  },
	  NL: function NL(str) {
	    return /^(NL)?\d{9}B\d{2}$/.test(str);
	  },
	  PL: function PL(str) {
	    return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(str);
	  },
	  PT: PT,
	  RO: function RO(str) {
	    return /^(RO)?\d{2,10}$/.test(str);
	  },
	  SK: function SK(str) {
	    return /^(SK)?\d{10}$/.test(str);
	  },
	  SI: function SI(str) {
	    return /^(SI)?\d{8}$/.test(str);
	  },
	  ES: function ES(str) {
	    return /^(ES)?\w\d{7}[A-Z]$/.test(str);
	  },
	  SE: function SE(str) {
	    return /^(SE)?\d{12}$/.test(str);
	  },
	  /**
	   * VAT numbers of non-EU countries
	   */
	  AL: function AL(str) {
	    return /^(AL)?\w{9}[A-Z]$/.test(str);
	  },
	  MK: function MK(str) {
	    return /^(MK)?\d{13}$/.test(str);
	  },
	  AU: AU,
	  BY: function BY(str) {
	    return /^(УНП )?\d{9}$/.test(str);
	  },
	  CA: function CA(str) {
	    return /^(CA)?\d{9}$/.test(str);
	  },
	  IS: function IS(str) {
	    return /^(IS)?\d{5,6}$/.test(str);
	  },
	  IN: function IN(str) {
	    return /^(IN)?\d{15}$/.test(str);
	  },
	  ID: function ID(str) {
	    return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(str);
	  },
	  IL: function IL(str) {
	    return /^(IL)?\d{9}$/.test(str);
	  },
	  KZ: function KZ(str) {
	    return /^(KZ)?\d{12}$/.test(str);
	  },
	  NZ: function NZ(str) {
	    return /^(NZ)?\d{9}$/.test(str);
	  },
	  NG: function NG(str) {
	    return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(str);
	  },
	  NO: function NO(str) {
	    return /^(NO)?\d{9}MVA$/.test(str);
	  },
	  PH: function PH(str) {
	    return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(str);
	  },
	  RU: function RU(str) {
	    return /^(RU)?(\d{10}|\d{12})$/.test(str);
	  },
	  SM: function SM(str) {
	    return /^(SM)?\d{5}$/.test(str);
	  },
	  SA: function SA(str) {
	    return /^(SA)?\d{15}$/.test(str);
	  },
	  RS: function RS(str) {
	    return /^(RS)?\d{9}$/.test(str);
	  },
	  CH: CH,
	  TR: function TR(str) {
	    return /^(TR)?\d{10}$/.test(str);
	  },
	  UA: function UA(str) {
	    return /^(UA)?\d{12}$/.test(str);
	  },
	  GB: function GB(str) {
	    return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str);
	  },
	  UZ: function UZ(str) {
	    return /^(UZ)?\d{9}$/.test(str);
	  },
	  /**
	   * VAT numbers of Latin American countries
	   */
	  AR: function AR(str) {
	    return /^(AR)?\d{11}$/.test(str);
	  },
	  BO: function BO(str) {
	    return /^(BO)?\d{7}$/.test(str);
	  },
	  BR: function BR(str) {
	    return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(str);
	  },
	  CL: function CL(str) {
	    return /^(CL)?\d{8}-\d{1}$/.test(str);
	  },
	  CO: function CO(str) {
	    return /^(CO)?\d{10}$/.test(str);
	  },
	  CR: function CR(str) {
	    return /^(CR)?\d{9,12}$/.test(str);
	  },
	  EC: function EC(str) {
	    return /^(EC)?\d{13}$/.test(str);
	  },
	  SV: function SV(str) {
	    return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(str);
	  },
	  GT: function GT(str) {
	    return /^(GT)?\d{7}-\d{1}$/.test(str);
	  },
	  HN: function HN(str) {
	    return /^(HN)?$/.test(str);
	  },
	  MX: function MX(str) {
	    return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(str);
	  },
	  NI: function NI(str) {
	    return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(str);
	  },
	  PA: function PA(str) {
	    return /^(PA)?$/.test(str);
	  },
	  PY: function PY(str) {
	    return /^(PY)?\d{6,8}-\d{1}$/.test(str);
	  },
	  PE: function PE(str) {
	    return /^(PE)?\d{11}$/.test(str);
	  },
	  DO: function DO(str) {
	    return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(str);
	  },
	  UY: function UY(str) {
	    return /^(UY)?\d{12}$/.test(str);
	  },
	  VE: function VE(str) {
	    return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(str);
	  }
	};
	function isVAT(str, countryCode) {
	  (0, _assertString.default)(str);
	  (0, _assertString.default)(countryCode);
	  if (countryCode in vatMatchers) {
	    return vatMatchers[countryCode](str);
	  }
	  throw new Error("Invalid country code: '".concat(countryCode, "'"));
	}

	(function (module, exports) {

		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;
		var _toDate = _interopRequireDefault(toDateExports);
		var _toFloat = _interopRequireDefault(toFloatExports);
		var _toInt = _interopRequireDefault(toIntExports);
		var _toBoolean = _interopRequireDefault(toBooleanExports);
		var _equals = _interopRequireDefault(equalsExports);
		var _contains = _interopRequireDefault(containsExports);
		var _matches = _interopRequireDefault(matchesExports);
		var _isEmail = _interopRequireDefault(isEmailExports);
		var _isURL = _interopRequireDefault(isURLExports);
		var _isMACAddress = _interopRequireDefault(isMACAddressExports);
		var _isIP = _interopRequireDefault(isIPExports);
		var _isIPRange = _interopRequireDefault(isIPRangeExports);
		var _isFQDN = _interopRequireDefault(isFQDNExports);
		var _isDate = _interopRequireDefault(isDateExports);
		var _isTime = _interopRequireDefault(isTimeExports);
		var _isBoolean = _interopRequireDefault(isBooleanExports);
		var _isLocale = _interopRequireDefault(isLocaleExports);
		var _isAbaRouting = _interopRequireDefault(isAbaRoutingExports);
		var _isAlpha = _interopRequireWildcard(isAlpha$1);
		var _isAlphanumeric = _interopRequireWildcard(isAlphanumeric$1);
		var _isNumeric = _interopRequireDefault(isNumericExports);
		var _isPassportNumber = _interopRequireDefault(isPassportNumberExports);
		var _isPort = _interopRequireDefault(isPortExports);
		var _isLowercase = _interopRequireDefault(isLowercaseExports);
		var _isUppercase = _interopRequireDefault(isUppercaseExports);
		var _isIMEI = _interopRequireDefault(isIMEIExports);
		var _isAscii = _interopRequireDefault(isAsciiExports);
		var _isFullWidth = _interopRequireDefault(isFullWidth$1);
		var _isHalfWidth = _interopRequireDefault(isHalfWidth$1);
		var _isVariableWidth = _interopRequireDefault(isVariableWidthExports);
		var _isMultibyte = _interopRequireDefault(isMultibyteExports);
		var _isSemVer = _interopRequireDefault(isSemVerExports);
		var _isSurrogatePair = _interopRequireDefault(isSurrogatePairExports);
		var _isInt = _interopRequireDefault(isIntExports);
		var _isFloat = _interopRequireWildcard(isFloat$1);
		var _isDecimal = _interopRequireDefault(isDecimalExports);
		var _isHexadecimal = _interopRequireDefault(isHexadecimalExports);
		var _isOctal = _interopRequireDefault(isOctalExports);
		var _isDivisibleBy = _interopRequireDefault(isDivisibleByExports);
		var _isHexColor = _interopRequireDefault(isHexColorExports);
		var _isRgbColor = _interopRequireDefault(isRgbColorExports);
		var _isHSL = _interopRequireDefault(isHSLExports);
		var _isISRC = _interopRequireDefault(isISRCExports);
		var _isIBAN = _interopRequireWildcard(isIBAN$1);
		var _isBIC = _interopRequireDefault(isBICExports);
		var _isMD = _interopRequireDefault(isMD5Exports);
		var _isHash = _interopRequireDefault(isHashExports);
		var _isJWT = _interopRequireDefault(isJWTExports);
		var _isJSON = _interopRequireDefault(isJSONExports);
		var _isEmpty = _interopRequireDefault(isEmptyExports);
		var _isLength = _interopRequireDefault(isLengthExports);
		var _isByteLength = _interopRequireDefault(isByteLengthExports);
		var _isUUID = _interopRequireDefault(isUUIDExports);
		var _isMongoId = _interopRequireDefault(isMongoIdExports);
		var _isAfter = _interopRequireDefault(isAfterExports);
		var _isBefore = _interopRequireDefault(isBeforeExports);
		var _isIn = _interopRequireDefault(isInExports);
		var _isLuhnNumber = _interopRequireDefault(isLuhnNumberExports);
		var _isCreditCard = _interopRequireDefault(isCreditCardExports);
		var _isIdentityCard = _interopRequireDefault(isIdentityCardExports);
		var _isEAN = _interopRequireDefault(isEANExports);
		var _isISIN = _interopRequireDefault(isISINExports);
		var _isISBN = _interopRequireDefault(isISBNExports);
		var _isISSN = _interopRequireDefault(isISSNExports);
		var _isTaxID = _interopRequireDefault(isTaxIDExports);
		var _isMobilePhone = _interopRequireWildcard(isMobilePhone$1);
		var _isEthereumAddress = _interopRequireDefault(isEthereumAddressExports);
		var _isCurrency = _interopRequireDefault(isCurrencyExports);
		var _isBtcAddress = _interopRequireDefault(isBtcAddressExports);
		var _isISO = isISO6346$1;
		var _isISO2 = _interopRequireDefault(isISO6391Exports);
		var _isISO3 = _interopRequireDefault(isISO8601Exports);
		var _isRFC = _interopRequireDefault(isRFC3339Exports);
		var _isISO31661Alpha = _interopRequireDefault(isISO31661Alpha2$1);
		var _isISO31661Alpha2 = _interopRequireDefault(isISO31661Alpha3Exports);
		var _isISO4 = _interopRequireDefault(isISO4217$1);
		var _isBase = _interopRequireDefault(isBase32Exports);
		var _isBase2 = _interopRequireDefault(isBase58Exports);
		var _isBase3 = _interopRequireDefault(isBase64Exports);
		var _isDataURI = _interopRequireDefault(isDataURIExports);
		var _isMagnetURI = _interopRequireDefault(isMagnetURIExports);
		var _isMailtoURI = _interopRequireDefault(isMailtoURIExports);
		var _isMimeType = _interopRequireDefault(isMimeTypeExports);
		var _isLatLong = _interopRequireDefault(isLatLongExports);
		var _isPostalCode = _interopRequireWildcard(isPostalCode$1);
		var _ltrim = _interopRequireDefault(ltrimExports);
		var _rtrim = _interopRequireDefault(rtrimExports);
		var _trim = _interopRequireDefault(trimExports);
		var _escape = _interopRequireDefault(_escapeExports);
		var _unescape = _interopRequireDefault(_unescapeExports);
		var _stripLow = _interopRequireDefault(stripLowExports);
		var _whitelist = _interopRequireDefault(whitelistExports);
		var _blacklist = _interopRequireDefault(blacklistExports);
		var _isWhitelisted = _interopRequireDefault(isWhitelistedExports);
		var _normalizeEmail = _interopRequireDefault(normalizeEmailExports);
		var _isSlug = _interopRequireDefault(isSlugExports);
		var _isLicensePlate = _interopRequireDefault(isLicensePlateExports);
		var _isStrongPassword = _interopRequireDefault(isStrongPasswordExports);
		var _isVAT = _interopRequireDefault(isVAT$1);
		function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
		function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		var version = '13.12.0';
		var validator = {
		  version: version,
		  toDate: _toDate.default,
		  toFloat: _toFloat.default,
		  toInt: _toInt.default,
		  toBoolean: _toBoolean.default,
		  equals: _equals.default,
		  contains: _contains.default,
		  matches: _matches.default,
		  isEmail: _isEmail.default,
		  isURL: _isURL.default,
		  isMACAddress: _isMACAddress.default,
		  isIP: _isIP.default,
		  isIPRange: _isIPRange.default,
		  isFQDN: _isFQDN.default,
		  isBoolean: _isBoolean.default,
		  isIBAN: _isIBAN.default,
		  isBIC: _isBIC.default,
		  isAbaRouting: _isAbaRouting.default,
		  isAlpha: _isAlpha.default,
		  isAlphaLocales: _isAlpha.locales,
		  isAlphanumeric: _isAlphanumeric.default,
		  isAlphanumericLocales: _isAlphanumeric.locales,
		  isNumeric: _isNumeric.default,
		  isPassportNumber: _isPassportNumber.default,
		  isPort: _isPort.default,
		  isLowercase: _isLowercase.default,
		  isUppercase: _isUppercase.default,
		  isAscii: _isAscii.default,
		  isFullWidth: _isFullWidth.default,
		  isHalfWidth: _isHalfWidth.default,
		  isVariableWidth: _isVariableWidth.default,
		  isMultibyte: _isMultibyte.default,
		  isSemVer: _isSemVer.default,
		  isSurrogatePair: _isSurrogatePair.default,
		  isInt: _isInt.default,
		  isIMEI: _isIMEI.default,
		  isFloat: _isFloat.default,
		  isFloatLocales: _isFloat.locales,
		  isDecimal: _isDecimal.default,
		  isHexadecimal: _isHexadecimal.default,
		  isOctal: _isOctal.default,
		  isDivisibleBy: _isDivisibleBy.default,
		  isHexColor: _isHexColor.default,
		  isRgbColor: _isRgbColor.default,
		  isHSL: _isHSL.default,
		  isISRC: _isISRC.default,
		  isMD5: _isMD.default,
		  isHash: _isHash.default,
		  isJWT: _isJWT.default,
		  isJSON: _isJSON.default,
		  isEmpty: _isEmpty.default,
		  isLength: _isLength.default,
		  isLocale: _isLocale.default,
		  isByteLength: _isByteLength.default,
		  isUUID: _isUUID.default,
		  isMongoId: _isMongoId.default,
		  isAfter: _isAfter.default,
		  isBefore: _isBefore.default,
		  isIn: _isIn.default,
		  isLuhnNumber: _isLuhnNumber.default,
		  isCreditCard: _isCreditCard.default,
		  isIdentityCard: _isIdentityCard.default,
		  isEAN: _isEAN.default,
		  isISIN: _isISIN.default,
		  isISBN: _isISBN.default,
		  isISSN: _isISSN.default,
		  isMobilePhone: _isMobilePhone.default,
		  isMobilePhoneLocales: _isMobilePhone.locales,
		  isPostalCode: _isPostalCode.default,
		  isPostalCodeLocales: _isPostalCode.locales,
		  isEthereumAddress: _isEthereumAddress.default,
		  isCurrency: _isCurrency.default,
		  isBtcAddress: _isBtcAddress.default,
		  isISO6346: _isISO.isISO6346,
		  isFreightContainerID: _isISO.isFreightContainerID,
		  isISO6391: _isISO2.default,
		  isISO8601: _isISO3.default,
		  isRFC3339: _isRFC.default,
		  isISO31661Alpha2: _isISO31661Alpha.default,
		  isISO31661Alpha3: _isISO31661Alpha2.default,
		  isISO4217: _isISO4.default,
		  isBase32: _isBase.default,
		  isBase58: _isBase2.default,
		  isBase64: _isBase3.default,
		  isDataURI: _isDataURI.default,
		  isMagnetURI: _isMagnetURI.default,
		  isMailtoURI: _isMailtoURI.default,
		  isMimeType: _isMimeType.default,
		  isLatLong: _isLatLong.default,
		  ltrim: _ltrim.default,
		  rtrim: _rtrim.default,
		  trim: _trim.default,
		  escape: _escape.default,
		  unescape: _unescape.default,
		  stripLow: _stripLow.default,
		  whitelist: _whitelist.default,
		  blacklist: _blacklist.default,
		  isWhitelisted: _isWhitelisted.default,
		  normalizeEmail: _normalizeEmail.default,
		  toString: toString,
		  isSlug: _isSlug.default,
		  isStrongPassword: _isStrongPassword.default,
		  isTaxID: _isTaxID.default,
		  isDate: _isDate.default,
		  isTime: _isTime.default,
		  isLicensePlate: _isLicensePlate.default,
		  isVAT: _isVAT.default,
		  ibanLocales: _isIBAN.locales
		};
		exports.default = validator;
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (validator, validator.exports));

	var validatorExports = validator.exports;
	var Validator = /*@__PURE__*/getDefaultExportFromCjs(validatorExports);

	const emptyResult$1 = () => {
	    return {
	        list: [],
	        count: 0,
	        page: 0,
	        pages: 0,
	        skip: 0,
	    };
	};

	class notServiceModelSearch {
	    constructor(app, modelName) {
	        this.modelName = modelName;
	        this.app = app;
	    }

	    destroy() {
	        delete this.app;
	    }

	    getSearchRouteName() {
	        return "listAndCount";
	    }

	    getDataLoadRouteName() {
	        return "get";
	    }

	    transformSearchResult(result) {
	        result.list = result.list.map((item) => {
	            return {
	                _id: item._id,
	                id: item[`${this.modelName}ID`],
	                title: item.name || item.title || item.label || item.username,
	            };
	        });
	        return result;
	    }

	    transformSelectedResult(result) {
	        return {
	            _id: result._id,
	            [`${this.modelName}ID`]: result.id,
	            title: result.title,
	        };
	    }

	    async searchByTerm(term) {
	        try {
	            if (term.value.length > 2) {
	                const model = this.app.getModel(this.modelName);
	                model.setSearch(term.value);
	                const response = await model[`$${this.getSearchRouteName()}`]();
	                if (response.status === "ok") {
	                    return this.transformSearchResult(response.result);
	                } else {
	                    return emptyResult$1();
	                }
	            } else {
	                return emptyResult$1();
	            }
	        } catch (e) {
	            return emptyResult$1();
	        }
	    }

	    openSelector() {
	        return new Promise((resolve, reject) => {
	            try {
	                const el = new Ui_generic_selector({
	                    target: document.body,
	                    props: {},
	                });
	                el.$on("termChange", async ({ detail }) => {
	                    const results = await this.searchByTerm(detail);
	                    el.$set({ results });
	                });

	                el.$on("next", () => {
	                    console.log("next selector results");
	                });

	                el.$on("prev", () => {
	                    console.log("prev selector results");
	                });

	                el.$on("reject", () => {
	                    el.$destroy();
	                    reject();
	                });
	                el.$on("resolve", ({ detail }) => {
	                    el.$destroy();
	                    resolve(this.transformSelectedResult(detail));
	                });
	            } catch (e) {
	                this.app.error(e);
	                reject(e);
	            }
	        });
	    }

	    async loadData(_id) {
	        try {
	            if (_id && _id.length > 10) {
	                const model = this.app.getModel(this.modelName, { _id });
	                const response = await model[
	                    `$${this.getDataLoadRouteName()}`
	                ]();
	                if (response.status === "ok") {
	                    return response.result;
	                } else {
	                    return null;
	                }
	            } else {
	                return null;
	            }
	        } catch (e) {
	            this.app.error(e);
	            return null;
	        }
	    }
	}

	//import 'babel-polyfill/dist/polyfill';


	const ncCRUD = notCRUD; //legacy alias

	var Frame = /*#__PURE__*/Object.freeze({
		__proto__: null,
		COMPONENTS: COMPONENTS$2,
		FIELDS: FIELDS$2,
		UIForm: Form,
		VARIANTS: VARIANTS$1,
		createCRUDActionUIView: create_crud_action_ui_view,
		ncCRUD: ncCRUD,
		notAPI: index,
		notApp: notApp$1,
		notBase: notBase$1,
		notBreadcrumbs: notBreadcrumbs,
		notCRUD: notCRUD,
		notCRUDRouter: notCRUDRouter,
		notCRUDRouterPlain: notCRUDPlainRouter,
		notCRUDRouterSwitch: notCRUDRouterSwitch,
		notCommon: notCommon$2,
		notController: notController$2,
		notForm: notForm$5,
		notFormHelpers: FormHelpers,
		notFormRules: notFormRules,
		notFormSet: notFormSet$1,
		notFormUtils: notFormUtils$1,
		notInterface: notInterface,
		notPath: notPath$1,
		notRecord: notRecord,
		notRouter: notRouter$1,
		notServiceModelSearch: notServiceModelSearch,
		notSideMenu: notSideMenu$1,
		notStores: stores,
		notTable: notTable,
		notTopMenu: notTopMenu$2
	});

	const { notCommon: notCommon$1, COMPONENTS: COMPONENTS$1, FIELDS, VARIANTS, notFormUtils } = Frame;

	Object.keys(Elements).forEach((componentsSetName) => {
	    Object.keys(Elements[componentsSetName]).forEach((componentName) => {
	        notFormUtils$1.addComponent(
	            componentName,
	            Elements[componentsSetName][componentName]
	        );
	    });
	});

	/**
	*	Template of error.js
	*	For building for specific environment.
	*	Node.js or Browser
	*	@param {string}	env	node|browser in wich env it will be running
	*	@param {string}	url	URL of report collector
	*	@param {string}	key	key to indetificate reporter
	*/
	/**
	* Error reporting with features, saving browser info, uri and so on.
	* @module not-error/error
	*/
	class notError extends Error {
		constructor(message, options = {}, error = null){
			super(message);
			this.options = options;
			this.adopt(error);
			this.fill();
			this.getTime();
			return this;
		}

		/**
		*	Adopting native error object
		*	@param {Error}	error 	Error object
		*	@return {notError}		chainable
		*/
		adopt(error){
			if(error instanceof Error){
				this.parent = error;
			}
			return this;
		}

		getStack(){
			if(this.parent){
				return this.parent.stack;
			}else {
				return this.stack;
			}
		}

		getDetails(){
			let src = this;
			if(this.parent){
				src = this.parent;
			}
			return {
				columnNumber:    	src.columnNumber,
				fileName:        	src.fileName,
				lineNumber:      	src.lineNumber,
				name:            	src.name,
				message:        	src.message,
				stack:          	src.stack
			};
		}

		/**
		*	Updating this.env.date property
		*	@return  {object}	{timestamp, offset}
		*/
		getTime(){
			let date = new Date();
			this.env.date = {
				timestamp : date.getTime(),
				offset: date.getTimezoneOffset()
			};
			return this.env.date;
		}


		/**
		******************************************************************************************************
		******************************************************************************************************
		***	Browser Section
		******************************************************************************************************
		******************************************************************************************************
		**/

		/**
		*	Collecting information specific for browsers
		*	@return {notError}		chainable
		*/
		fill(){
			this.env = {
				browser: true,
				node: false,
				document: {
					title: document.title
				},
				location: {
					hash: 			window.location.hash,
					port:				window.location.port,
					protocol:		window.location.protocol,
					search:			window.location.search,
					host:				window.location.host,
					url:				window.location.url,
					href:				window.location.href,
					hostname: 	window.location.hostname,
					pathname: 	window.location.pathname,
				},
				navigator:{
					appName: 				navigator.appName,
					appCodeName: 		navigator.appCodeName,
					appVersion: 		navigator.appVersion,
					userAgent: 			navigator.userAgent,
					platform: 			navigator.platform,
					language: 			navigator.language,
					product: 				navigator.product,
					onLine: 				navigator.onLine,
					cookieEnabled:	navigator.cookieEnabled,
				},
				window:{
					height: 				window.innerHeight,
					width: 					window.innerWidth,
				}
			};
			return this;
		}


	}

	//reportable
	class notValidationError extends notError{
		constructor(message, fields = {}, err = null, params = {}){
			super(message, {fields, params}, err);
			return this;
		}

		/**
	  * Sets hash of fields errors messages for usage in forms
	  *	@return {Object}	hash of field->errors [key:string]: Array<string>
	  **/
		setFieldsErrors(messages){
			this.options.fields = messages;
		}

		/**
	  * Returns hash of errors
	  *	@return {Object}	hash of field->errors [key:string]: Array<string>
	  **/
		getFieldsErrors(){
			return this.options.fields;
		}

	}

	//reportable
	class notRequestError extends notError{
		constructor(
			message,
			{code, errors, redirect, params} = {code:500, errors:{}, redirect: false, params:{}},
			error = null
		){
			super(
				message,
				{
					code,
					errors,
					redirect,
					params
				},
				error
			);
			return this;
		}

		setRedirect(url){
			this.options.redirect = url;
		}

		getRedirect(){
			return this.options.redirect;
		}

		setCode(code){
			this.options.code = code;
		}

		getCode(){
			return this.options.code;
		}

		setErrors(list){
			this.options.errors = list;
		}

		getErrors(){
			return this.options.errors;
		}

		getResult(){
			return {
				message:  this.message,
				code:     this.getCode(),
				errors:   this.getErrors(),
				redirect: this.getRedirect(),
			};
		}

	}

	/**
	*  Template of reporter.js
	*  For building for specific environment.
	*  Node.js or Browser
	*  @param {string}  env  node|browser in wich env it will be running
	*  @param {string}  url  URL of report collector
	*  @param {string}  key  key to indetificate reporter
	*/

	const PARASITES = ['report@', 'notError@'];
	const LINES_TO_CAPTURE = 6;
	const STACK_PROPS = [
		'file',
		'path',
		'type',
		'line',
		'column',
		'function',
	];

	const FILE_LINE_PARSERS = [
		{
			test: (line)=>{
				const tester = /(.*)@(.+):(\d+):(\d+)/gi;
				let matches = [...line.matchAll(tester)];
				if(matches.length){
					let res = matches[0];
					if(res && res.length > 2 ){
						return res;
					}
				}
				return false;
			},
			parse: (res)=>{
				if(res){
					//separation of different types of data
					let functionFullPath = res[1].split('.');
					let file = res[2];
					//extraction of exact values
					let pathParts = file.split('/');
					let fileName = pathParts[pathParts.length - 1];
					pathParts.pop();
					let filePath = pathParts.join('/');
					let lineNumber = parseInt(res[3]);
					let columnNumber = parseInt(res[4]);
					let functionName = functionFullPath[functionFullPath.length - 1];
					if (functionName.replaceAll){
						functionName = functionName.replaceAll('/' , '').replaceAll('\\' , '').replaceAll('>', '').replaceAll('<', '');
					}
					let fileDir;
					if(pathParts && pathParts.length){
						fileDir = pathParts.pop();
					}
					return {
						file: fileName,
						path: filePath,
						line: lineNumber,
						column: columnNumber,
						function: functionName,
						type: fileDir,
					};
				}else {
					return false;
				}
			}
		},
		{
			test: (line)=>{
				const tester = /\sat\s(.+)\s\((.+)\)/gi;
				let matches = [...line.matchAll(tester)];
				if(matches.length){
					let res = matches[0];
					if(res && res.length > 2 ){
						return res;
					}
				}
				return false;
			},
			parse: (res)=>{
				if(res){
					//separation of different types of data
					let functionFullPath = res[1].split('.');
					let file = res[2].split(':');
					//extraction of exact values
					let pathParts = file[0].split('/');
					let fileName = pathParts[pathParts.length - 1];
					pathParts.pop();
					let filePath = pathParts.join('/');
					let lineNumber = parseInt(file[1]);
					let columnNumber = parseInt(file[2]);
					let functionName = functionFullPath[functionFullPath.length - 1];
					if (functionName.replaceAll){
						functionName = functionName.replaceAll('/' , '').replaceAll('\\' , '').replaceAll('>', '').replaceAll('<', '');
					}
					let fileDir;
					if(pathParts && pathParts.length){
						fileDir = pathParts.pop();
					}
					return {
						file: fileName,
						path: filePath,
						line: lineNumber,
						column: columnNumber,
						function: functionName,
						type: fileDir,
					};
				}else {
					return false;
				}
			}
		},
	];


	const LOG = window.console;
	const NOT_NODE_ERROR_URL_BROWSER = 'https://appmon.ru/api/key/collect';


	const DEFAULT_OPTIONS$2 = {
			envFirst: false,
			origin: {},
			url:undefined,
			key:undefined,
			registerAll: true
		};

	/**
	* Error reporting with features, saving browser info, uri and so on.
	* @module not-error/error
	*/
	class notErrorReporter{
		static notError = notError;
		static notValidationError = notValidationError;
		static notRequestError = notRequestError;

		constructor(opts = DEFAULT_OPTIONS$2){
			let {envFirst, origin,	url, key,registerAll } = opts;
			this.envFirst = envFirst;
			this.processWatching = false;
			this.setOrigin(origin);
			this.setKey(key);
			this.setURL(url);
			this.setRegisterAll(registerAll);
			
			window.addEventListener('error', this.registerError.bind(this));
			
			return this;
		}

		setOrigin(origin){
			this.origin = origin;
			return this;
		}

		setKey(key){
			this.key = key;
			return this;
		}

		setURL(url){
			this.url = url;
			return this;
		}

		setRegisterAll(registerAll = true){
			this.registerAll = registerAll;
			return this;
		}

		errorIsReportable(error){
			return error instanceof notError;
		}

		async report(error, notSecure){
			let local = false;
			if(!this.errorIsReportable(error)){
				error = new notError(error.message, {}, error);
				local = true;
			}
			let data = await this.packError(error, local);
			return await this._report(data, this.getReportURL(), notSecure, 'error');
		}

		reportError(name, opts = {}, parent = null, notSecure){
			return this.report(new notError(name, opts, parent), notSecure);
		}

		isLineParasite(line){
			return PARASITES.some((str) => line.includes(str));
		}

		trunkStack(stack){
			let lines = stack.split("\n");
			while(lines.length && this.isLineParasite(lines[0])){
				lines.shift();
			}
			return lines;
		}

		__stackFirstLineParser(line){
			let result;
			let parser = FILE_LINE_PARSERS.find((itm) =>{ return result = itm.test(line);});
			if(parser){
				return parser.parse(result);
			}
			return false;
		}

		__stackFirstLineSearcher(stack){
			for(let i = 0; stack.length > i; i++){
				let	line = stack[i];
				if(!line){continue;}
				let res = this.__stackFirstLineParser(line);
				if(res){
					return res;
				}else {
					continue;
				}
			}
			return false;
		}

		parseStack(rawStack){
			try{
				let stack = this.trunkStack(rawStack);
				let res = this.__stackFirstLineSearcher(stack);
				if(!res){
					return {stack};
				}
				let fileinfo = this.__stackFirstLineSearcher(stack);
				if(!fileinfo){
					return {stack};
				}
				return {
					stack,
					...fileinfo
				};
			}catch(e){
				LOG.error(e);
				return false;
			}
		}

		extractDataFromError(err, local){
			let res = err.getDetails();
			if(res.stack){
				let stackInfo = this.parseStack(res.stack);
				if(stackInfo && stackInfo.stack){
					if(local){
						res.stack = stackInfo.stack.join("\n");
						STACK_PROPS.forEach((j) => {
							if(stackInfo[j]){ res[j] = stackInfo[j];}
						});
					}else {
						STACK_PROPS.forEach((j) => {
							if(!res[j]){res[j] = stackInfo[j];}
						});
					}
				}
			}
			return res;
		}

		async packError(error, local = false){
			let result = {};
			result.details   = this.extractDataFromError(error, local);
			await this.tryToGetSourceBlock(result);
			result.options   = error.options;
			result.env       = error.env;
			result.origin   = this.origin?this.origin:{};
			return result;
		}

		async tryToGetSourceBlock(result){
			if(result.details.fileName && !isNaN(result.details.lineNumber)){
				try{
					let text = await this.loadSources(result.details.fileName);
					if(text){
						let lines = this.extractLinesFromFile(text, parseInt(result.details.lineNumber));
						result.lines = lines;
					}
				}catch(e){
					return false;
				}
			}
		}

		extractLinesFromFile(text, targetLine){
			let lines = text.split("\n");
			targetLine = parseInt(targetLine) - 1;
			let fromLine = (targetLine - LINES_TO_CAPTURE);
			let toLine = (targetLine + LINES_TO_CAPTURE);
			if(fromLine < 0){
				fromLine = 0;
			}
			if(toLine > lines.length - 1){
				toLine = lines.length - 1;
			}
			let result = [];
			for(let t = fromLine; t < toLine; t++){
				result.push({l: t + 1, txt: lines[t], color: { danger: targetLine === t} });
			}
			return result;
		}


		/**
		******************************************************************************************************
		******************************************************************************************************
		***	Browser Section
		******************************************************************************************************
		******************************************************************************************************
		**/
		getReportURL(){
			if(typeof this.url !== 'undefined'){
				return this.url;
			}else	if(window.NOT_NODE_ERROR_URL_BROWSER && window.NOT_NODE_ERROR_URL_BROWSER.length>0){
				return window.NOT_NODE_ERROR_URL_BROWSER;
			}if(window.APPMON_URL && typeof window.APPMON_URL === 'string' && window.APPMON_URL.length>0){
				return window.APPMON_URL;
			}else if(NOT_NODE_ERROR_URL_BROWSER.length>0){
				return NOT_NODE_ERROR_URL_BROWSER;
			}else {
				return '/api/error';
			}
		}

		getReportKey(){
			if(typeof this.key !== 'undefined'){
				return this.key;
			}else	if(window.NOT_NODE_ERROR_KEY && window.NOT_NODE_ERROR_KEY.length > 0){
				return window.NOT_NODE_ERROR_KEY;
			}else	if(window.APPMON_KEY && typeof window.APPMON_KEY === 'string' && window.APPMON_KEY.length > 0){
				return window.APPMON_KEY;
			}else {
				return '';
			}
		}

		_report(data, url){
			let report = {
				report: data,
				type: 'error',
				key: this.getReportKey(),
			};
			return fetch(url, {
				method: 			'PUT',
				cache: 				'no-cache',
				headers: 			{
					'Content-Type': 'application/json; charset=utf-8'
				},
				redirect: 		'follow',
				referrer: 		'no-referrer',
				body: 				JSON.stringify(report),
			});
		}

		async loadSources(filePath){
			let res = await fetch(filePath);
			if(parseInt(res.status) === 200){
				return await res.text();
			}else {
				return false;
			}
		}

		registerError(ev){
			if(this.registerAll){
				this.report(ev.error);
			}
		}


	}

	class Common{
		static DEFAULT_REDIRECT_TIMEOUT = 5000;
		static CLASS_OK = 'is-success';
		static CLASS_ERR = 'is-danger';
	  static isError(e){
	    return e instanceof Error;
	  }
	}

	var mod_0 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: Common
	});

	const { notBase } = Frame;

	const OPT_DEFAULT_PAGE_SIZE = 20,
		OPT_DEFAULT_PAGE_NUMBER = 0,
		OPT_DEFAULT_PAGE_RANGE = 6,
		OPT_DEFAULT_SORT_DIRECTION = 1,
		OPT_DEFAULT_SEARCH = "",
		OPT_DEFAULT_RETURN = {},
		OPT_DEFAULT_COMBINED_ACTION = "listAndCount",
		OPT_DEFAULT_SORT_FIELD = "_id";

	/**
		Few concepts
			*	two modes 1 - live requesting from server, 2 - static data

			*	in live mode: changing of filters or sorters leads to another request
				to server, in endless mode after scroll down to the bottom of
				table next page will be requested and glued to the bottom of the
				table, in pagination mode after change of sorter or filter
				pagination will be reset

			*	in static mode: change in filters or sorters will lead to pagination
				reset

		let input = {
			data:	//array of items to be presented in table
					//in case of static - unfiltered
					//in case of live - will be mirrored to table without any changes
			options: {
				pager:{
					size: 50,		//how many rows per "page"
					number: 0,		//default page number aka first
				},
				interface:{			//for online requested list
					factory: 		//target notRecord factory with notRecordInterface, source of online data
					listAction:		//which action will be called to retrieve data from server, default 'list'
					countAction:	//which action will be called to retrieve raws count from server, default 'count'
					combined: 		//cobined request list and count
					combinedAction:	//name of combined action
					onSuccess:		//will be called after successfull request
					onError:		//will be called after failed request
				}
			}
		}
	*/

	class notFilter extends notBase {
		constructor(input) {
			super(input);
			this.data = {
				pagination: {
					items: {
						count: 0,
						from: 0,
						to: 0,
					},
					pages: {
						count: 0,
						from: 0,
						to: 0,
						current: 0,
						list: [],
					},
				},
			};
			if (Object.prototype.hasOwnProperty.call(input.options, "filter")) {
				this.setFilter(input.options.filter, true);
			} else {
				this.resetFilter();
			}
			if (Object.prototype.hasOwnProperty.call(input.options, "pager")) {
				this.setPager(input.options.pager, true);
			} else {
				this.resetPager();
			}
			if (Object.prototype.hasOwnProperty.call(input.options, "sorter")) {
				this.setSorter(input.options.sorter, true);
			} else {
				this.resetSorter(true);
			}
			if (Object.prototype.hasOwnProperty.call(input.options, "return")) {
				this.setReturn(input.options.return);
			} else {
				this.setReturn();
			}
			if (Object.prototype.hasOwnProperty.call(input.options, "search")) {
				this.setSearch(input.options.search, true);
			} else {
				this.setSearch();
			}
		}

		////////////////////////////////////////////////////////////////////////////
		////navigation
		////////////////////////////////////////////////////////////////////////////
		getNext() {
			let next = isNaN(this.getWorking("pager").page)
				? this.getDefaultPageNumber()
				: this.getWorking("pager").page + 1;
			this.getWorking("pager").page = Math.min(
				next,
				this.data.pagination.pages.to
			);
			return this.loadData();
		}

		getPrev() {
			let prev = isNaN(this.getWorking("pager").page)
				? this.getDefaultPageNumber()
				: this.getWorking("pager").page - 1;
			this.getWorking("pager").page = Math.max(
				prev,
				this.data.pagination.pages.from
			);
			return this.loadData();
		}

		getFirst() {
			this.getWorking("pager").page = this.data.pagination.pages.from;
			return this.loadData();
		}

		getLast() {
			this.getWorking("pager").page = this.data.pagination.pages.to;
			return this.loadData();
		}

		getPage(pageNumber = 0) {
			this.getWorking("pager").page = pageNumber;
			return this.loadData();
		}

		///////////////////////////////////////////////////////////////////////////
		////networking
		///////////////////////////////////////////////////////////////////////////
		getDataInterface() {
			return this.getOptions("interface.factory")({});
		}

		getCombinedActionName() {
			return this.getOptions("interface.combinedAction")
				? this.getOptions("interface.combinedAction")
				: OPT_DEFAULT_COMBINED_ACTION;
		}

		loadData() {
			//load from server
			let query = this.getDataInterface()
					.setFilter(this.getFilter())
					.setSorter(this.getSorter())
					.setReturn(this.getReturn())
					.setSearch(this.getSearch())
					.setPager(this.getPager().size, this.getPager().page),
				actionName = this.getCombinedActionName();
			return query["$" + actionName]()
				.then(this.extractResult.bind(this))
				.then(this.updatePagination.bind(this));
		}

		extractResult(response) {
			const resultPath = this.getOptions("resultPath", ":");
			if (resultPath) {
				return notPath$1.get(resultPath, response);
			} else {
				return response;
			}
		}

		updatePagination(result) {
			return new Promise((resolve, reject) => {
				try {
					this.data.pagination.pages.list.splice(
						0,
						this.data.pagination.pages.list.length
					);
					let itemsCount = result.count,
						itemsFrom =
	                        (this.getPager().page - OPT_DEFAULT_PAGE_NUMBER) *
	                            this.getPager().size +
	                        1,
						pagesCount =
	                        itemsCount % this.getPager().size
	                        	? Math.floor(itemsCount / this.getPager().size) + 1
	                        	: Math.round(itemsCount / this.getPager().size),
						pagesFrom = Math.max(
							OPT_DEFAULT_PAGE_NUMBER,
							this.getPager().page - OPT_DEFAULT_PAGE_RANGE
						),
						pagesTo = Math.min(
							pagesCount - (1 - OPT_DEFAULT_PAGE_NUMBER),
							this.getPager().page + OPT_DEFAULT_PAGE_RANGE
						),
						list = [],
						itemsTo = Math.min(
							itemsFrom + this.getPager().size - 1,
							itemsCount
						);
					for (let t = pagesFrom; t <= pagesTo; t++) {
						list.push({
							index: t,
							active: t === this.getPager().page,
						});
					}
					this.data.pagination.items.count = itemsCount;
					this.data.pagination.items.from = itemsFrom;
					this.data.pagination.items.to = itemsTo;
					this.data.pagination.pages.count = pagesCount;
					this.data.pagination.pages.from = pagesFrom;
					this.data.pagination.pages.to = pagesTo;
					this.data.pagination.pages.current = this.getPager().page;
					this.data.pagination.pages.list.splice(
						0,
						this.data.pagination.pages.list.length,
						...list
					);
					result.pagination = this.data.pagination;
					resolve(result);
				} catch (e) {
					e.response = result;
					reject(e);
				}
			});
		}

		///////////////////////////////////////////////////////////////////////////
		////sorter
		///////////////////////////////////////////////////////////////////////////
		setSorter(hash) {
			this.setWorking("sorter", hash);
			return this;
		}

		resetSorter() {
			let t = {};
			t[OPT_DEFAULT_SORT_FIELD] = OPT_DEFAULT_SORT_DIRECTION;
			return this.setSorter(t);
		}

		getSorter() {
			return this.getWorking("sorter");
		}

		getSorterDirection() {
			try {
				let names = Object.keys(this.getSorter());
				return this.getSorter()[names[0]];
			} catch (_) {
				return OPT_DEFAULT_SORT_DIRECTION;
			}
		}

		///////////////////////////////////////////////////////////////////////////
		////search
		///////////////////////////////////////////////////////////////////////////
		getSearch() {
			let search =
	            typeof this.getWorking("search") !== "undefined" &&
	            this.getWorking("search") !== null;
			return search ? this.getWorking("search") : "";
		}

		setSearch(line = OPT_DEFAULT_SEARCH) {
			this.setWorking("search", line);
			return this;
		}

		///////////////////////////////////////////////////////////////////////////
		////return
		///////////////////////////////////////////////////////////////////////////
		getReturn() {
			return this.getWorking("return");
		}

		setReturn(ret = OPT_DEFAULT_RETURN) {
			this.setWorking("return", ret);
			return this;
		}

		///////////////////////////////////////////////////////////////////////////
		////filter
		///////////////////////////////////////////////////////////////////////////
		setFilter(hash) {
			this.setWorking("filter", hash);
			return this;
		}

		resetFilter() {
			return this.setFilter({});
		}

		getFilter() {
			return this.getWorking("filter");
		}

		///////////////////////////////////////////////////////////////////////////
		////pager
		///////////////////////////////////////////////////////////////////////////
		setPager(hash) {
			this.setWorking("pager", hash);
			return this;
		}

		getDefaultPageNumber() {
			return isNaN(this.getOptions("pager.page"))
				? OPT_DEFAULT_PAGE_NUMBER
				: this.getOptions("pager.page");
		}

		getDefaultPageSize() {
			return isNaN(this.getOptions("pager.size"))
				? OPT_DEFAULT_PAGE_SIZE
				: this.getOptions("pager.size");
		}

		resetPager() {
			this.setWorking("pager", {
				size: this.getDefaultPageSize(),
				page: this.getDefaultPageNumber(),
			});
			return this;
		}

		getPager() {
			return this.getWorking("pager");
		}
	}

	const manifest$8 = {};

	const services$7 = {};

	var mod_1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$8,
		notFilter: notFilter,
		services: services$7
	});

	const services$6 = { };
	const wsc$3 = {};
	const manifest$7 = {};

	var mod_2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$7,
		services: services$6,
		wsc: wsc$3
	});

	/**
	 * detects current locale, loads dictionary from server
	 *
	 **/

	const SECTION_ID = "locale";

	const { notTopMenu: notTopMenu$1 } = Frame;

	class nsLocale {
	    constructor(app) {
	        this.app = app;
	        this.locales = [];
	        this.failures = 0;
	        this.app.on("wsClient:main:connected", this.update.bind(this));
	        notLocale$1.on("change", () => {
	            this.app.emit("locale");
	        });
	    }

	    /**
	     * Creates network interface for this service
	     */
	    interface(data) {
	        return this.app.getInterface("locale")(data);
	    }

	    /**
	     * Retrieves dictionary for current locale
	     * sets dictionary in notLocale object
	     */
	    async update() {
	        try {
	            await this.updateAvailable();
	            let res = await this.interface({
	                locale: this.getCurrentLocale(),
	            }).$get({});
	            if (res.status === "ok" && res.result) {
	                notLocale$1.set(res.result);
	            } else {
	                this.scheduleUpdate();
	            }
	        } catch (e) {
	            notCommon$1.error(e);
	            this.scheduleUpdate();
	        }
	    }

	    scheduleUpdate() {
	        this.failures++;
	        if (this.failures < 100) {
	            setTimeout(this.update.bind(this), 1000 * this.failures);
	        } else {
	            notCommon$1.error("Too many failures of locale loading");
	        }
	    }

	    async updateAvailable() {
	        try {
	            let res = await this.interface({}).$available({});
	            if (res.status === "ok" && res.result) {
	                this.setAvailable(res.result);
	            }
	        } catch (e) {
	            notCommon$1.error(e);
	        }
	    }

	    updateUI(list) {
	        let menuItems = this.createMenuItems(list);
	        notTopMenu$1.updateSectionItems(SECTION_ID, () => {
	            return menuItems;
	        });
	        setTimeout(() => {
	            this.app.emit(`tag-${SECTION_ID}:update`, {
	                title: this.getCurrentLocale(),
	            });
	        }, 1000);
	    }

	    createMenuItems(list) {
	        let items = list.map(this.createMenuItem.bind(this));
	        return items;
	    }

	    createMenuItem(item) {
	        return {
	            id: `${SECTION_ID}.${item}`,
	            section: SECTION_ID,
	            title: item,
	            classes: " is-clickable ",
	            action: this.changeLocale.bind(this, item),
	        };
	    }

	    changeLocale(locale) {
	        this.saveLocaleToStore(locale);
	        this.update();
	    }

	    /**
	     * @returns {string}   code of current locale
	     **/
	    getCurrentLocale() {
	        let stored = this.restoreLocaleFromStore();
	        if (stored) {
	            if (this.locales.includes(stored)) {
	                return stored;
	            }
	        }
	        return this.selectBest();
	    }

	    /**
	     * @returns {Promise<Array>}   of locales objects {code, title}
	     **/
	    getAvailable() {
	        return this.interface().$available({});
	    }

	    setAvailable(list) {
	        this.locales = list;
	        this.updateUI(list);
	    }

	    restoreLocaleFromStore() {
	        if (window.localStorage) {
	            try {
	                return window.localStorage.getItem("locale");
	            } catch (e) {
	                this.app.error(e);
	                return false;
	            }
	        }
	        return false;
	    }

	    saveLocaleToStore(locale) {
	        if (window.localStorage) {
	            try {
	                return window.localStorage.setItem("locale", locale);
	            } catch (e) {
	                this.app.error(e);
	                return false;
	            }
	        }
	        return false;
	    }

	    selectBest() {
	        if (navigator.languages) {
	            let locale = navigator.languages.find((itm) => {
	                return this.locales.includes(itm);
	            });
	            if (locale) {
	                return locale;
	            }
	        }
	        return this.app.getWorking(
	            "locale",
	            this.app.getOptions("modules.locale.default", "ru")
	        );
	    }
	}

	const services$5 = { nsLocale };
	const manifest$6 = {
	  modules:{
	    locale:{
	      default: 'ru'
	    }
	  },
	  menu:{
	    top:{
	      sections:[
					{
						id: 'locale',
	          title: '',
						icon: {
							font: 'language',
							size: 'medium',
							svg: '',
							src: '',
						},
						tag: {
							padding: 	'small',
							bold: 		true,
							color: 		'success',
							title: 		''
						},
						showOnTouch: true,
						place: 'end'
					}
				]
	    }
	  }
	};

	var mod_3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$6,
		services: services$5
	});

	/* node_modules/not-key/src/controllers/common/UIListOfURLs.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$3(ctx) {
		let span;

		function select_block_type(ctx, dirty) {
			if (/*valid*/ ctx[6] === true) return create_if_block_2$3;
			if (/*valid*/ ctx[6] === false) return create_if_block_3$1;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (76:35) 
	function create_if_block_3$1(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (74:6) {#if valid === true }
	function create_if_block_2$3(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (85:2) {:else}
	function create_else_block$2(ctx) {
		let t;

		return {
			c() {
				t = text(" ");
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (83:2) {#if !(validated && valid) && (inputStarted) }
	function create_if_block$3(ctx) {
		let t;

		return {
			c() {
				t = text(/*helper*/ ctx[11]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*helper*/ 2048) set_data(t, /*helper*/ ctx[11]);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	function create_fragment$5(ctx) {
		let div;
		let textarea;
		let textarea_id_value;
		let textarea_class_value;
		let textarea_aria_controls_value;
		let textarea_aria_describedby_value;
		let t0;
		let t1;
		let p;
		let p_class_value;
		let p_id_value;
		let mounted;
		let dispose;
		let if_block0 = /*validated*/ ctx[7] === true && create_if_block_1$3(ctx);

		function select_block_type_1(ctx, dirty) {
			if (!(/*validated*/ ctx[7] && /*valid*/ ctx[6]) && /*inputStarted*/ ctx[0]) return create_if_block$3;
			return create_else_block$2;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block1 = current_block_type(ctx);

		return {
			c() {
				div = element("div");
				textarea = element("textarea");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				p = element("p");
				if_block1.c();
				attr(textarea, "id", textarea_id_value = "form-field-listOfUrls-" + /*fieldname*/ ctx[2]);
				attr(textarea, "name", /*fieldname*/ ctx[2]);
				attr(textarea, "class", textarea_class_value = "textarea " + /*validationClasses*/ ctx[9]);
				textarea.readOnly = /*readonly*/ ctx[5];
				textarea.disabled = /*readonly*/ ctx[5];
				attr(textarea, "invalid", /*invalid*/ ctx[10]);
				textarea.required = /*required*/ ctx[4];
				attr(textarea, "rows", /*rows*/ ctx[3]);
				attr(textarea, "placeholder", /*placeholder*/ ctx[1]);
				attr(textarea, "aria-controls", textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(textarea, "aria-describedby", textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(div, "class", "control");
				attr(p, "class", p_class_value = "help " + /*validationClasses*/ ctx[9]);
				attr(p, "id", p_id_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, textarea);
				set_input_value(textarea, /*listText*/ ctx[8]);
				append(div, t0);
				if (if_block0) if_block0.m(div, null);
				insert(target, t1, anchor);
				insert(target, p, anchor);
				if_block1.m(p, null);

				if (!mounted) {
					dispose = [
						listen(textarea, "input", /*textarea_input_handler*/ ctx[19]),
						listen(textarea, "change", /*onBlur*/ ctx[12]),
						listen(textarea, "input", /*onInput*/ ctx[13])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*fieldname*/ 4 && textarea_id_value !== (textarea_id_value = "form-field-listOfUrls-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "id", textarea_id_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(textarea, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*validationClasses*/ 512 && textarea_class_value !== (textarea_class_value = "textarea " + /*validationClasses*/ ctx[9])) {
					attr(textarea, "class", textarea_class_value);
				}

				if (dirty & /*readonly*/ 32) {
					textarea.readOnly = /*readonly*/ ctx[5];
				}

				if (dirty & /*readonly*/ 32) {
					textarea.disabled = /*readonly*/ ctx[5];
				}

				if (dirty & /*invalid*/ 1024) {
					attr(textarea, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty & /*required*/ 16) {
					textarea.required = /*required*/ ctx[4];
				}

				if (dirty & /*rows*/ 8) {
					attr(textarea, "rows", /*rows*/ ctx[3]);
				}

				if (dirty & /*placeholder*/ 2) {
					attr(textarea, "placeholder", /*placeholder*/ ctx[1]);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_controls_value !== (textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-controls", textarea_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_describedby_value !== (textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-describedby", textarea_aria_describedby_value);
				}

				if (dirty & /*listText*/ 256) {
					set_input_value(textarea, /*listText*/ ctx[8]);
				}

				if (/*validated*/ ctx[7] === true) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$3(ctx);
						if_block0.c();
						if_block0.m(div, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1.d(1);
					if_block1 = current_block_type(ctx);

					if (if_block1) {
						if_block1.c();
						if_block1.m(p, null);
					}
				}

				if (dirty & /*validationClasses*/ 512 && p_class_value !== (p_class_value = "help " + /*validationClasses*/ ctx[9])) {
					attr(p, "class", p_class_value);
				}

				if (dirty & /*fieldname*/ 4 && p_id_value !== (p_id_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(p, "id", p_id_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t1);
					detach(p);
				}

				if (if_block0) if_block0.d();
				if_block1.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$5($$self, $$props, $$invalidate) {
		let allErrors;
		let helper;
		let invalid;
		let validationClasses;
		const UICommon = { Elements };
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = [] } = $$props;
		let { placeholder = 'List of urls' } = $$props;
		let { fieldname = 'list-of-urls' } = $$props;
		let { rows = 10 } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let listText = '';

		onMount(() => {
			$$invalidate(8, listText = value.join("\n"));
		});

		function onBlur(ev) {
			$$invalidate(14, value = listText.split("\n"));
			let data = { field: fieldname, value };
			$$invalidate(0, inputStarted = true);
			dispatch('change', data);
			return true;
		}

		function onInput(ev) {
			$$invalidate(14, value = listText.split("\n"));
			let data = { field: fieldname, value };
			$$invalidate(0, inputStarted = true);
			dispatch('change', data);
			return true;
		}

		function textarea_input_handler() {
			listText = this.value;
			$$invalidate(8, listText);
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(0, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(14, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('rows' in $$props) $$invalidate(3, rows = $$props.rows);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(7, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(15, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(16, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(17, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*errors, formErrors*/ 98304) {
				$$invalidate(18, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*allErrors, placeholder*/ 262146) {
				$$invalidate(11, helper = allErrors ? allErrors.join(', ') : placeholder);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 131136) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 65) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			inputStarted,
			placeholder,
			fieldname,
			rows,
			required,
			readonly,
			valid,
			validated,
			listText,
			validationClasses,
			invalid,
			helper,
			onBlur,
			onInput,
			value,
			errors,
			formErrors,
			formLevelError,
			allErrors,
			textarea_input_handler
		];
	}

	class UIListOfURLs extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$5, create_fragment$5, safe_not_equal, {
				inputStarted: 0,
				value: 14,
				placeholder: 1,
				fieldname: 2,
				rows: 3,
				required: 4,
				readonly: 5,
				valid: 6,
				validated: 7,
				errors: 15,
				formErrors: 16,
				formLevelError: 17
			});
		}
	}

	/* node_modules/not-key/src/controllers/common/UIJSON.svelte generated by Svelte v4.2.19 */

	function create_else_block$1(ctx) {
		let textarea;
		let textarea_id_value;
		let textarea_class_value;
		let textarea_aria_controls_value;
		let textarea_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4(ctx);
		let if_block1 = /*validated*/ ctx[8] === true && create_if_block_1$2(ctx);

		return {
			c() {
				textarea = element("textarea");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(textarea, "id", textarea_id_value = "form-field-textarea-" + /*fieldname*/ ctx[2]);
				attr(textarea, "invalid", /*invalid*/ ctx[12]);
				textarea.disabled = /*disabled*/ ctx[7];
				textarea.required = /*required*/ ctx[5];
				textarea.readOnly = /*readonly*/ ctx[6];
				attr(textarea, "class", textarea_class_value = "textarea " + /*validationClasses*/ ctx[11]);
				attr(textarea, "name", /*fieldname*/ ctx[2]);
				attr(textarea, "placeholder", /*placeholder*/ ctx[1]);
				attr(textarea, "rows", /*rows*/ ctx[4]);
				attr(textarea, "aria-controls", textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(textarea, "aria-describedby", textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, textarea, anchor);
				set_input_value(textarea, /*editingValue*/ ctx[9]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(textarea, "blur", /*onBlur*/ ctx[16]),
						listen(textarea, "input", /*textarea_input_handler*/ ctx[22])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 4 && textarea_id_value !== (textarea_id_value = "form-field-textarea-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "id", textarea_id_value);
				}

				if (dirty & /*invalid*/ 4096) {
					attr(textarea, "invalid", /*invalid*/ ctx[12]);
				}

				if (dirty & /*disabled*/ 128) {
					textarea.disabled = /*disabled*/ ctx[7];
				}

				if (dirty & /*required*/ 32) {
					textarea.required = /*required*/ ctx[5];
				}

				if (dirty & /*readonly*/ 64) {
					textarea.readOnly = /*readonly*/ ctx[6];
				}

				if (dirty & /*validationClasses*/ 2048 && textarea_class_value !== (textarea_class_value = "textarea " + /*validationClasses*/ ctx[11])) {
					attr(textarea, "class", textarea_class_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(textarea, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*placeholder*/ 2) {
					attr(textarea, "placeholder", /*placeholder*/ ctx[1]);
				}

				if (dirty & /*rows*/ 16) {
					attr(textarea, "rows", /*rows*/ ctx[4]);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_controls_value !== (textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-controls", textarea_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_describedby_value !== (textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-describedby", textarea_aria_describedby_value);
				}

				if (dirty & /*editingValue*/ 512) {
					set_input_value(textarea, /*editingValue*/ ctx[9]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[8] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$2(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(textarea);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (58:6) {#if readonly }
	function create_if_block$2(ctx) {
		let pre;
		let t;

		return {
			c() {
				pre = element("pre");
				t = text(/*readonlyValueStringified*/ ctx[10]);
			},
			m(target, anchor) {
				insert(target, pre, anchor);
				append(pre, t);
			},
			p(ctx, dirty) {
				if (dirty & /*readonlyValueStringified*/ 1024) set_data(t, /*readonlyValueStringified*/ ctx[10]);
			},
			d(detaching) {
				if (detaching) {
					detach(pre);
				}
			}
		};
	}

	// (73:6) {#if icon }
	function create_if_block_4(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (76:6) {#if validated === true }
	function create_if_block_1$2(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[0] === true) return create_if_block_2$2;
			if (/*valid*/ ctx[0] === false) return create_if_block_3;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (80:37) 
	function create_if_block_3(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (78:8) {#if valid === true }
	function create_if_block_2$2(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$4(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return create_if_block$2;
			return create_else_block$1;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[23](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[24](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[25](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[14] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[14];
		}

		if (/*showErrors*/ ctx[13] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[13];
		}

		if (/*validationClasses*/ ctx[11] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[11];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[15]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 32768 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[15])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 16384) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[14];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 8192) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[13];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 2048) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[11];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$4($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let readonlyValueStringified;
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = {} } = $$props;
		let { placeholder = 'input some text here, please' } = $$props;
		let { fieldname = 'textarea' } = $$props;
		let { icon = false } = $$props;
		let { rows = 10 } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			try {
				$$invalidate(18, value = JSON.parse(editingValue));
				$$invalidate(0, valid = true);
				$$invalidate(19, errors = false);
				let data = { field: fieldname, value };
				$$invalidate(17, inputStarted = true);
				dispatch('change', data);
				return true;
			} catch(e) {
				$$invalidate(0, valid = false);
				$$invalidate(19, errors = ["JSON parsing error"]);
			}
		}

		let editingValue = '';

		onMount(() => {
			$$invalidate(9, editingValue = JSON.stringify(value, null, 4));
		});

		function textarea_input_handler() {
			editingValue = this.value;
			$$invalidate(9, editingValue);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(14, allErrors), $$invalidate(19, errors)), $$invalidate(20, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(13, showErrors), $$invalidate(8, validated)), $$invalidate(0, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(11, validationClasses), $$invalidate(0, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(18, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('rows' in $$props) $$invalidate(4, rows = $$props.rows);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(0, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(8, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(19, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(20, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(21, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(15, iconClasses = (icon ? ' has-icons-left ' : '') + ' has-icons-right ');
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 1572864) {
				$$invalidate(14, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131329) {
				$$invalidate(13, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 2097153) {
				$$invalidate(12, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131073) {
				$$invalidate(11, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}

			if ($$self.$$.dirty & /*value*/ 262144) {
				$$invalidate(10, readonlyValueStringified = JSON.stringify(value, null, 4));
			}
		};

		return [
			valid,
			placeholder,
			fieldname,
			icon,
			rows,
			required,
			readonly,
			disabled,
			validated,
			editingValue,
			readonlyValueStringified,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			onBlur,
			inputStarted,
			value,
			errors,
			formErrors,
			formLevelError,
			textarea_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class UIJSON extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$4, create_fragment$4, safe_not_equal, {
				inputStarted: 17,
				value: 18,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				rows: 4,
				required: 5,
				readonly: 6,
				disabled: 7,
				valid: 0,
				validated: 8,
				errors: 19,
				formErrors: 20,
				formLevelError: 21
			});
		}
	}

	const uis$3 = { UIListOfUrls: UIListOfURLs, UIJSON };

	const manifest$5 = {};

	var mod_4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$5,
		uis: uis$3
	});

	class nsErrorReporter {
	    constructor(app) {
	        this.app = app;
	        this.reporter = new notErrorReporter();
	        this.reporter.setOrigin({ server: window.location.host });
	        this.reporter.setRegisterAll(
	            this.app.getOptions("module.error.registerAll", true)
	        );
	    }

	    report(e) {
	        return this.reporter.report(e);
	    }
	}

	const manifest$4 = {};
	const services$4 = { nsErrorReporter };

	var mod_5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$4,
		notError: notError,
		notErrorReporter: notErrorReporter,
		notRequestError: notRequestError,
		notValidationError: notValidationError,
		services: services$4
	});

	const STATE = {
	//нет подключения
		NOT_CONNECTED: 0,
		//есть подключение
		CONNECTED: 1,
		//есть авторизация
		AUTHORIZED: 2,
		//нет отклика
		NO_PING: 3,
		//ошибка соединения
		ERRORED: 4
	};

	const STATE_NAME = {
		0: 'Не подключен',
		1: 'Подключен',
		2: 'Авторизован',
		3: 'Нет отклика',
		4: 'Ошибка связи',
	};

	//деятельность объекта, не завершенное дествие
	const ACTIVITY = {
		IDLE: 0,
		//идёт подключение
		CONNECTING: 1,
		//закрытие соединения
		CLOSING: 2,
		//разрыв соединения
		TERMINATING: 3,
		//авторизация по токену
		AUTHORIZING: 4
	};

	const ACTIVITY_NAME = {
		0: 'Простаивает',
		1: 'Открытие связи',
		2: 'Закрытие связи',
		3: 'Обрыв связи',
		4: 'Авторизация',
	};


	//Список кодов закрытия взят с https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
	let WS_CLOSURE_REASONS = {
		1000 : 'Normal Closure',
		1001 : 'Going Away',
		1002 : 'Protocol Error',
		1003 : 'Unsupported Data',
		1005 : 'No Status Recvd',
		1006 : 'Abnormal Closure',
		1007 : 'Invalid frame payload data',
		1008 : 'Policy Violation',
		1009 : 'Message too big',
		1010 : 'Missing Extension',
		1011 : 'Internal Error',
		1012 : 'Service Restart',
		1013 : 'Try Again Later',
		1014 : 'Bad Gateway',
		1015 : 'TLS Handshake'
	};

	//Возвращает описание причины возникновения ивента закрытия WS-подключения
	function mapWsCloseCodes(event){
		if(!event) return 'unknown reason'; //Если event не задан, то причина неизвестна.
		if(event.reason) return event.reason; //Если reason уже задан, возвращаем его.
		//Определяем reason-код и ищем его в WS_CLOSURE_REASONS
		let code = (typeof event.code !== 'undefined'? event.code.toString(): 'undefined');
		if (!isNaN(parseInt(event))){
			code = event;
		}
		return Object.hasOwn(WS_CLOSURE_REASONS, code) ? WS_CLOSURE_REASONS[code] : `Unknown reason: ${code}`;
	}

	const SYMBOL_ACTIVITY$1 = Symbol('activity');
	const SYMBOL_STATE$1 = Symbol('state');
	const DEFAULT_CLIENT_NAME = 'not-ws link';
	const DEFAULT_SERVER_NAME = 'not-ws server';

	const ERR_MSG = {
		REQUEST_TIMEOUT: 'Request timeout',
		MSG_ID_IS_NOT_VALID: 'Message ID is not valid uuidv4',
		MSG_CREDENTIALS_IS_NOT_VALID: 'Message Credentials is not valid!',
		MSG_TYPE_IS_NOT_VALID: 'Message Type is not valid!',
		MSG_NAME_IS_NOT_VALID: 'Message Name is not valid!',
	};

	const PING_TIMEOUT = 5000;
	const HEARTBEAT_INTERVAL = 5000;
	const CLIENT_RECONNECT_TIMEOUT = 5000;
	const CLIENT_RECONNECT_TIMEOUT_LONG = 30000;
	const TIME_OFFSET_REQUEST_INTERVAL = 5 * 60 * 1000;
	const CLIENT_AUTO_RECONNECT = true;

	const TOKEN_TTL$1 = 1800;
	const TOKEN_RENEW_TTL = 300;

	const MSG_TYPE = {
		REQUEST: 'request',
		RESPONSE: 'response',
		EVENT: 'event',
		COMMAND: 'command',
	};

	const DEV_ENV = 'development';

	class notWSException extends Error{
		constructor(){
			super(...arguments);
		}
	}



	let [, hash] = location.hash.split('#');
	const ENV_TYPE = hash;

	var CONST = {
		ENV_TYPE,
		DEV_ENV,
		STATE,
		STATE_NAME,
		ACTIVITY,
		ACTIVITY_NAME,
		WS_CLOSURE_REASONS,
		mapWsCloseCodes,
		HEARTBEAT_INTERVAL,
		SYMBOL_ACTIVITY: SYMBOL_ACTIVITY$1,
		SYMBOL_STATE: SYMBOL_STATE$1,
		DEFAULT_SERVER_NAME,
		DEFAULT_CLIENT_NAME,
		ERR_MSG,
		PING_TIMEOUT,
		CLIENT_RECONNECT_TIMEOUT,
		CLIENT_RECONNECT_TIMEOUT_LONG,
		CLIENT_AUTO_RECONNECT,
		TIME_OFFSET_REQUEST_INTERVAL,
		MSG_TYPE,
		TOKEN_TTL: TOKEN_TTL$1,
		TOKEN_RENEW_TTL,
		notWSException
	};

	//Проверка является ли переменная функцией.
	function isFunc(func){
		return typeof(func) === 'function';
	}

	/**
	* Returns true if argument is Async function
	* @param {function} func to test
	* @return {boolean} if this function is constructed as AsyncFunction
	**/
	function isAsync(func){
		return func.constructor.name === "AsyncFunction";
	}

	/**
	* Executes method in appropriate way inside Promise
	* @param {function} proc function to execute
	* @param {Array} params array of params
	* @return {Promise} results of method execution
	**/
	async function executeFunctionAsAsync (proc, params){
		if (isFunc(proc)) {
			if (isAsync(proc)) {
				return await proc(...params);
			} else {
				return proc(...params);
			}
		}
	//throw new Error("Could not execute `proc` is not a function");
	}

	function noop() {}
	function heartbeat() { this._alive = true;}

	function ObjHas(obj, prop){
		return Object.hasOwn(obj, prop);
	}

	//Проверка строки на JSON(со stackoverflow).
	//http://stackoverflow.com/questions/3710204/how-to-check-if-a-string-is-a-valid-json-string-in-javascript-without-using-try
	let tryParseJSON = function (jsonString){
		try {
			let o = JSON.parse(jsonString);
			// Handle non-exception-throwing cases:
			// Neither JSON.parse(false) or JSON.parse(1234) throw errors, hence the type-checking,
			// but... JSON.parse(null) returns null, and typeof null === "object",
			// so we must check for that, too. Thankfully, null is falsey, so this suffices:
			if (o && typeof o === "object") {
				return o;
			}
		}catch (e) {
			// eslint-disable-next-line no-console
			console.error(e);
		}
		return false;
	};

	function isArray(val){
		return Array.isArray(val);
	}

	let capitalizeFirstLetter = function(name){
		return name.charAt(0).toUpperCase() + name.slice(1);
	};


	var Func = {
		isFunc,
		isAsync,
		executeFunctionAsAsync,
		isArray,
		noop,
		heartbeat,
		ObjHas,
		tryParseJSON,
		capitalizeFirstLetter
	};

	/**
	      * Routing for messages
	      *
	      */

	class notWSRouter extends EventEmitter{
		constructor({name, routes = {}, logger}){
			super();
			this.__name = name || 'notWSRouter';
			this.logMsg = logger?logger.log:()=>{};
			this.logDebug = logger?logger.debug:()=>{};
			this.logError = logger?logger.error:()=>{};
			this.routes = {
				__service: {
					updateToken:()=>{
						this.emit('updateToken');
						return Promise.resolve();
					}
				},
				test: {
					sayHello:()=>{
						this.logMsg('Say hello for test route!');
						return Promise.resolve(true);
					}
				},
				request:{
					auth:()=>{
						this.logMsg('request.auth');
					}
				}
			};
			if(routes && Object.keys(routes).length > 0 ){
				this.initRoutes(routes);
			}
			return this;
		}

		initRoutes(routes){
			for(let type in routes){
				this.setRoutesForType(type, routes[type]);
			}
		}

		/**
	      * Routing action
	      * @parms {object} messageServiceData object with fields:
	      type - msg type, routes set
	      name - action name
	      cred - some credentials info
	      @params {object} data payload information from message
	      @params {object} client WS Connection
	      @returns {Promise} from targeted action or throwing Error if route doesn't exist
	      */
		async route({type, name, cred}, data, client){
	      
			const identity = client.identity;
	          
			if(
				Func.ObjHas(this.routes, type) &&
	            Func.ObjHas(this.routes[type], name)
			){
				this.logMsg('ip:', client.getIP(), type, name);
				if(Array.isArray(this.routes[type][name]) && this.routes[type][name].length > 1){
					const len = this.routes[type][name].length;
					const guards = this.routes[type][name].slice(0, len - 1);
					const actualRoute = this.routes[type][name][len - 1];
					await Promise.all(
						guards.map((guard) => Func.executeFunctionAsAsync(guard, [{data, cred, client, identity}]))
					);
					return Func.executeFunctionAsAsync(actualRoute,[{data, cred, client, identity}]);

				}else if(Func.isFunc(this.routes[type][name])){
					return await Func.executeFunctionAsAsync(this.routes[type][name], [{data, cred, client, identity}]);
				}
			}
			throw (new CONST.notWSException(`Route not found ${type}/${name}`));
		}

		/**
	            * Adding routes, chainable
	            * @params {string} type name of type
	            * @params {object} routes hash with name => () => {return new Promise} alike workers
	            * @returns {object} self
	            */
		setRoutesForType(type, routes){
			this.validateType(type);
			this.validateRoutes(routes);
			if (Func.ObjHas(this.routes, type)){
				this.routes[type] = Object.assign(this.routes[type], routes);
			}else {
				this.routes[type] = routes;
			}
			return this;
		}

		unsetRoutesForType(type, list = []){
			this.validateType(type);
			this.validateRoutesList(list);
			if (Func.ObjHas(this.routes, type)){
				for(let name of list){
					if(Func.ObjHas(this.routes[type], name)){
						delete this.routes[type][name];
					}
				}
				if(Object.keys(this.routes[type]).length === 0){
					delete this.routes[type];
				}
			}
			return this;
		}

		validateType(type){
			if((typeof type !== 'string') || (type === '')){
				throw new CONST.notWSException('Route\'s type name should be a String!');
			}
			return true;
		}

		validateRoutes(routes){
			if((typeof routes !== 'object') || (routes === null) || (routes === undefined)){
				throw new CONST.notWSException('Route\'s type\'s routes set should be an Object!');
			}
			return true;
		}

		validateRoutesList(list){
			if(!Array.isArray(list) || (typeof list === 'undefined')){
				throw new CONST.notWSException('List of routes names should be an Array!');
			}
			return true;
		}

		getRoutes(){
			return this.routes;
		}

	}

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	let getRandomValues;
	const rnds8 = new Uint8Array(16);
	function rng() {
	  // lazy load so that environments that need to polyfill have a chance to do so
	  if (!getRandomValues) {
	    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
	    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

	    if (!getRandomValues) {
	      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	    }
	  }

	  return getRandomValues(rnds8);
	}

	var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

	function validate(uuid) {
	  return typeof uuid === 'string' && REGEX.test(uuid);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	const byteToHex = [];

	for (let i = 0; i < 256; ++i) {
	  byteToHex.push((i + 0x100).toString(16).slice(1));
	}

	function unsafeStringify(arr, offset = 0) {
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
	}

	const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
	var native = {
	  randomUUID
	};

	function v4(options, buf, offset) {
	  if (native.randomUUID && !buf && !options) {
	    return native.randomUUID();
	  }

	  options = options || {};
	  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  return unsafeStringify(rnds);
	}

	/**
	 * set of default options
	 */
	const DEFAULT_OPTIONS$1 = {
		validateType:         true, //validation of message type
		validateTypeAndName:  true, //validation of message type and name
		secure: false, // if true - all not validated credentials are wrong
		securityException: ['request.auth'], //пример того как указывать пути без аутентификации, даже при secure=true
		validators: { //additional validators for validate method
			/**
	    credentials(credentials){
	      return (credentials.password === 'password') && (credentials.login === 'login');
	    }
	    */
		},
		types:      {
			'typeOfMessage':  ['list', 'of', 'name\'s', 'of', 'actions'],
			'test': ['sayHello'],
			'__service': ['updateToken'],
		},
		wrap:{
			ok: undefined,
			error: undefined
		},
		isErrored: undefined,             //override rule of defining unpacked message as failed (msg):void
		markMessageAsErrored: undefined   //override rule of marking message as errored (msg, serviceData, error):void
	};

	/***
	message format for this default adaptor
	{
	  id:uuidv4
	  type:string
	  name:string
	  payload:{} <- payload
	  cred:any
	  time:int
	  error:{} <- if errored on communitaction level, errors from other levels could be transported in payload

	}
	*/

	/**
	 * Message pre/post transmittion adapter
	 * Creates standart interface, mostly freeing other parts from
	 * understanding message inner structure
	 */
	class notWSMessenger extends EventEmitter {
		constructor(options = {}) {
			super();
			this.options = {...DEFAULT_OPTIONS$1, ...options};
			if(Func.ObjHas(this.options.types, CONST.MSG_TYPE.REQUEST) && !Func.ObjHas(this.options.types, CONST.MSG_TYPE.RESPONSE)){
				this.options.types[CONST.MSG_TYPE.RESPONSE] = this.options.types[CONST.MSG_TYPE.REQUEST];
			}
			return this;
		}

		setCredentials(credentials) {
			this.options.credentials = credentials;
			return this;
		}

		getServiceData(msg) {
			if(Func.ObjHas(msg, 'service')){
				return msg.service;
			}else {
				return {
					id: msg.id,
					time: msg.time,
					type: msg.type,
					name: msg.name,
				};
			}
		}

		getType(msg) {
			return msg.type;
		}

		getName(msg) {
			return msg.name;
		}

		getCredentials(msg) {
			return msg.cred;
		}

		getPayload(msg) {
			return msg.payload;
		}

		isErrored(msg) {
			if(Func.isFunc(this.options.isErrored)){
				return this.options.isErrored(msg);
			}else {
				return (typeof msg.error !== 'undefined') && (msg.error !== null);
			}
		}

		markMessageAsErrored(msg, serviceData, error ){
			if(Func.isFunc(this.options.markMessageAsErrored)){
				this.options.markMessageAsErrored(msg, serviceData, error);
			}else {
				if (error instanceof CONST.notWSException) {
					msg.error = error;
				}
			}
		}

		getErrorMessage(msg) {
			if (typeof msg.error === 'string') {
				return msg.error;
			} else if (typeof msg.error === 'object') {
				return `${msg.error.code}: ${msg.error.message}`;
			} else {
				throw new CONST.notWSException('No error data in message');
			}
		}

		getErrorReport(msg) {
			return msg.error;
		}

		/**
	   *
	   *
	   */
		pack(payload, serviceData, error) {
			if (!error && (typeof serviceData === 'undefined') || (serviceData === null)) {
				throw new CONST.notWSException('No Service Data or Error for packing notWSMsg');
			}
			const payloadWrapped = this.wrapPayload(payload, serviceData, error);
			let msg = {
				id: v4(),
				time: (new Date()).getTime(),
				payload: payloadWrapped,
			};    
			if (this.options.credentials) {
				msg.cred = this.options.credentials;
			}
			this.markMessageAsErrored(msg, serviceData, error);
			return Object.assign(msg, serviceData);
		}

		wrapPayload(payload, serviceData, error){
			if((error && error instanceof Error)){
				return this.wrapPayloadAs('error', payload, serviceData, error);
			}else {
				return this.wrapPayloadAs('ok', payload, serviceData, error);
			}
		}

		wrapPayloadAs(status, payload, serviceData, error){
			if(typeof this.options.wrap === 'object' && Func.isFunc(this.options.wrap[status])){
				return this.options.wrap[status](payload, serviceData, error);
			}else {
				return payload;
			}
		}

		unpack(msg) {
			if (this.isErrored(msg)) {
				let err = new CONST.notWSException(this.getErrorMessage(msg));
				err.report = this.getErrorReport(msg);
				throw err;
			}
			return {
				cred: this.getCredentials(msg),
				service: this.getServiceData(msg),
				payload: this.getPayload(msg)
			};
		}

		validateCredentials(credentials = {}, serviceData) {
			if (this.options.validators && this.options.validators.credentials) {
				return this.options.validators.credentials(credentials, serviceData);
			}
			return !this.options.secure;
		}

		validateType(type) {
			if (this.options.types) {
				return Object.keys(this.options.types).indexOf(type) > -1;
			}
			return false;
		}

		validateTypeAndName(type, name) {
			if (this.options.types && Func.ObjHas(this.options.types, type)) {
				return this.options.types[type].indexOf(name) > -1;
			}
			return false;
		}

		routeIsSecurityException(type, name) {
			let route = `${type}.${name}`;
			if (this.options.securityException && Array.isArray(this.options.securityException)) {
				return (this.options.securityException.indexOf(route) > -1);
			}
			return false;
		}

		validate(msg) {
			let serviceData = this.getServiceData(msg);
			if (!validate(serviceData.id)) {
				throw new CONST.notWSException(CONST.ERR_MSG.MSG_ID_IS_NOT_VALID);
			}
			if (
			//если не в списке исключений
				!this.routeIsSecurityException(serviceData.type, serviceData.name) &&
	      //проверяем права доступа
	      !this.validateCredentials(this.getCredentials(msg), serviceData)
			) {
				throw new CONST.notWSException(CONST.ERR_MSG.MSG_CREDENTIALS_IS_NOT_VALID);
			}
			//not neccessary, but
			this.validateRouteTypeAndName(msg);
			return msg;
		}

		validateRouteTypeAndName(msg){
			//default: false
			if(this.options.validateTypeAndName){
				this.validateRouteType(msg);
				let type = this.getType(msg),
					name = this.getName(msg);
				if (!this.validateTypeAndName(type, name)) {
					let err = new CONST.notWSException(CONST.ERR_MSG.MSG_NAME_IS_NOT_VALID);
					err.details = {type,name};
					throw err;
				}
			}else {
				this.validateRouteType(msg);
			}
		}

		validateRouteType(msg){
			let type = this.getType(msg);
			//default: true
			if(this.options.validateType){
				if (!this.validateType(type)) {
					let err = new CONST.notWSException(CONST.ERR_MSG.MSG_TYPE_IS_NOT_VALID);
					err.details = {type};
					throw err;
				}
			}
		}

		enableRoute(route, name){
			if(!Func.ObjHas(this.options, 'types')){
				this.options.types = {};
			}
			if(!Func.ObjHas(this.options.types, route)){
				this.options.types[route] = [];
			}
			if(this.options.types[route].indexOf(name) === -1){
				this.options.types[route].push(name);
			}
			return this;
		}

		disableRoute(route, name){
			if(!Func.ObjHas(this.options, 'types')){
				return this;
			}
			if(!Func.ObjHas(this.options.types, route)){
				return this;
			}
			if(this.options.types[route].indexOf(name) > -1){
				this.options.types[route].splice(this.options.types[route].indexOf(name), 1);
			}
			return this;
		}
	}

	//imports




	const SYMBOL_ACTIVITY = Symbol('activity');
	const SYMBOL_STATE = Symbol('state');

	const MAX_HISTORY_DEPTH = 40;

	const DEFAULT_OPTIONS = {
		secure:     true,
		reconnect:  true,
		ping:       true,
		count:      true,
	};

	class notWSConnection extends EventEmitter{
		constructor(options, slave = false){
			super();
			this.options = Object.assign({}, DEFAULT_OPTIONS, options);
			if(this.options.ws){
				this.ws = options.ws;
				delete options.ws;
				if(this.ws.readyState === 1){
					this.setAlive(); //результат пинг запросов
					this[SYMBOL_STATE] = CONST.STATE.CONNECTED;
					if(this.options.secure){
						this[SYMBOL_STATE] = CONST.STATE.AUTHORIZED;
					}
				}else {
					this[SYMBOL_STATE] = CONST.STATE.NOT_CONNECTED;
					this.setDead(); //результат пинг запросов
				}
			}else {
				this[SYMBOL_STATE] = CONST.STATE.NOT_CONNECTED;
				this.setDead(); //результат пинг запросов
				this.ws = null; //Подключение к websocket серверу.
			}
			this[SYMBOL_ACTIVITY] = CONST.ACTIVITY.IDLE;
			//if was terminated
			this.isTerminated = false;
			this.isReconnecting = false;
			this.closing = false;
			this.slave = slave;
			this.heartbeatTimeout = null;
			this.connectInterval = null;
			this.connCount = 0; //Количество неудачных попыток подключения к websocket серверу.
			this.connCountMax = 10; //Количество попыток по превышении которого считаем что соединение с серверов разорвано.
			this.errConnMsg = null; //Идентификатор сообщения об ошибке подключения к вебсокет серверу.
			this.firstConn = true;
			this.bindEnvEvents();
			this.bindSocketEvents();
			//message history
			this.history = [];
			this.passed = {
				in:  0,
				out: 0,
			};
			return this;
		}

		getStatus(){
			return {
				state:          CONST.STATE_NAME[this[SYMBOL_STATE]],
				activity:       CONST.ACTIVITY_NAME[this[SYMBOL_ACTIVITY]],
				isAlive:        this.isAlive(),
				isTerminated:   this.isTerminated,
				isReconnecting: this.isReconnecting,
				in:             this.passed.in,
				out:            this.passed.out,
			};
		}

		getSocket(){
			return this.ws;
		}

		getIP(){
			if(this.isOpen() && this.ws._socket && this.ws._socket.remoteAddress){
				return this.ws._socket.remoteAddress;
			}else {
				return false;
			}
		}

		bindSocketEvents(){
			if(this.ws){
				this.listeners = {
					open: this.onOpen.bind(this),
					message: this.onMessage.bind(this),
					close: this.onClose.bind(this),
					error: this.onError.bind(this)
				};
	    
				this.ws.onopen = this.listeners.open;
				this.ws.onmessage = this.listeners.message;
				this.ws.onclose = this.listeners.close;
				this.ws.onerror = this.listeners.error;
	    
			}
		}



		bindEnvEvents(){
	    
			window.onunload = this.disconnect.bind(this);
			window.onbeforeunload = this.disconnect.bind(this);
	    
		}

		//Отключение от ws сервиса.
		disconnect(){
			this.emit('diconnecting');
			if(this.ws){
				//заменяем метод для onclose на пустую функцию.
	      
				this.ws.onclose = Func.noop;
				this.ws.onerror = Func.noop;
				this.ws.onmessage = Func.noop;
				this.ws.onopen = Func.noop;
	      
				//закрываем подключение.
				this.ws.close && this.ws.close();
				this.terminate();
			}
		}

		terminate() {
			if(this.connectInterval){
				clearInterval(this.connectInterval);
			}
			if (this.ws) {
				this.activity = CONST.ACTIVITY.TERMINATING;
	      
				this.ws.terminate && this.ws.terminate();
			}
			this.isTerminated = true;
			this.ws = null;
			if(this.state !== CONST.STATE.NOT_CONNECTED){
				this.state = CONST.STATE.NOT_CONNECTED;
			}
			this.setDead();
		}

		//Подключение к websocket сервису.
		async connect(){
			try{
				if(!this.jwtToken){        
					this.scheduleReconnect();
					return;
				}
				if(this.ws && (this.ws.readyState !== WebSocket.CLOSED)){
					this.disconnect();
				}
				this.setAlive();
				this.isTerminated = false;
				//Счётчик колиества попыток подключения:
				this.connCount++;
				//пытаемся подключиться к вебсокет сервису.
				let connURI = this.getConnectURI();
				this.emit('connectURI', connURI);
				this.activity = CONST.ACTIVITY.CONNECTING;
				this.ws = new WebSocket(connURI);
				this.bindSocketEvents();
			}catch(e){
				this.emit('error',e);
				this.scheduleReconnect();
			}
		}

		setHalfDead(){
			if(this._alive){
				this._alive = false;
			}else {
				this.setDead();
			}
		}

		setAlive(){
			this._alive = true;
			this.alive = true;
		}

		setDead(){
			this.alive = false;
		}

		isAlive(){
			return this.alive;
		}

		isDead(){
			return !this.alive;
		}

		getConnectURI(){
			let protocol = 'ws';
			if(this.options.protocol){
				protocol = this.options.protocol;
			}else {
				if(this.options.ssl){
					protocol = 'wss';
				}
			}
			let base = `${protocol}://${this.options.host}`;
			if(this.options.port && parseInt(this.options.port) !== 80){
				base = `${base}:${this.options.port}/${this.options.path}`;
			}else {
				base = `${base}/${this.options.path}`;
			}    
			if(this.isSecure()){
				return `${base}?token=${this.jwtToken}`;
			}else {
				return base;
			}
		}

		setToken(token){
			this.jwtToken = token;
		}

		onOpen(){
			//Сбрасываем счётчик количества попыток подключения и данные об ошибках.
			this.connCount = 0;
			this.setAlive();
			clearInterval(this.connectInterval);
			this.connectInterval = false;
			this.errConnMsg = null;
			this.state = CONST.STATE.CONNECTED;
			if(this.isSecure()){
				this.state = CONST.STATE.AUTHORIZED;
			}
			this.initPing();
			this.emit('ready');
			this.sendAllFromHistory();
		}

		//Обработчик сообщений пришедших от сервера.
		//msg - это messageEvent пришедший по WS, соответственно данные лежат в msg.data.
		onMessage(input){
			try{
				this.countPassed(input, 'in');
				//проверяем не "понг" ли это, если так - выходим
	      
				let rawMsg = input.data;
	      
				if(this.checkPingMsg(rawMsg)){
					return;
				}
				let data = Func.tryParseJSON(rawMsg);
				//Не удалось распарсить ответ от сервера как JSON
				if(!data){
					this.emit('messageInWrongFormat', rawMsg);
					return;
				}
				this.emit('message', data);
			}catch(e){
				this.emit('error', e);
			}
		}

		onError(err){
			if(this.connectInterval){
				clearInterval(this.connectInterval);
				this.connectInterval = false;
			}
			if (this.activity === CONST.ACTIVITY.TERMINATING) {
				this.state = CONST.STATE.NOT_CONNECTED;
			} else {
				this.state = CONST.STATE.ERRORED;
			}
			this.emit('error', err);
		}

		//Обработчик закрытия подключения.
		onClose(event){
			if (typeof event.code !== 'undefined') {
				let reason = `${event.code}::` + CONST.mapWsCloseCodes(event);
				this.emit('close', reason);
			}else {
				if (isNaN(event)) {
					this.emit('close', event);
				} else {
					this.emit('terminated', CONST.mapWsCloseCodes(event));
				}
			}

			if (this.activity === CONST.ACTIVITY.CLOSING) {
				this.state = CONST.STATE.NOT_CONNECTED;
			} else {
				this.state = CONST.STATE.ERRORED;
			}
		}

		suicide() {
			this.emit('errored', this);
		}

		getReconnectTimeout(){
			if(this.connCount >= this.connCountMax){
				return CONST.CLIENT_RECONNECT_TIMEOUT_LONG;
			} else {
				return CONST.CLIENT_RECONNECT_TIMEOUT;
			}
		}

		scheduleReconnect(){
			if (!this.slave) {
				let timeout = this.getReconnectTimeout();
				this.emit('reconnectiningEvery', timeout);
				if (this.connectInterval) {
					clearInterval(this.connectInterval);
				}
				this.connectInterval = setInterval(this.performReconnect.bind(this), timeout);
			}
		}

		performReconnect(){
			if (!this.ws || this.ws.readyState === this.ws.CLOSED) {
				this.connect();
			}
		}

		reconnect() {
			if(!this.slave){
				if ([CONST.ACTIVITY.CONNECTING].indexOf(this.activity) > -1) {
					this.emit('concurentActivity', CONST.ACTIVITY[this.activity]);
					return;
				} else {
					this.scheduleReconnect();
				}
			}
		}

		/**
	  *  Требуется аутентификация или нет
	  */
		isSecure() {
			return this.options.secure;
		}

		isAutoReconnect(){
			if(this.slave){
				return false;
			}else {
				if (typeof this.options.reconnect !== 'undefined'){
					return this.options.reconnect;
				}else {
					return CONST.CLIENT_AUTO_RECONNECT;
				}
			}
		}

		/**
	   *  Returns true if user connected, if secure===true,
	   *  then client should be authentificated too
	   *  @params {boolean} secure      if user should be connected and authenticated
	   */
		isConnected(secure = true){
			if(this.ws && this.isAlive()){
				if(secure){
					return this.isConnectionSecure();
				}else {
					return true;
				}
			}else {
				return false;
			}
		}

		isConnectionSecure(){
			let state = CONST.STATE.CONNECTED;
			if (this.isSecure()) {
				state = CONST.STATE.AUTHORIZED;
			}
			return (this.state === state) && (this.ws.readyState === 1); // 1- OPEN
		}

		isOpen(){
			return this.ws && this.ws.readyState === 1;
		}

		isMessageTokenUpdateRequest(data){
			return data.type === '__service' && data.name === 'updateToken';
		}

		initPing(){
			//if server side client, only react on pong
			if(this.slave){
				this.on('pong', Func.heartbeat);
			}else {
				//if client send ping requests
				if(this.options.ping){
					if(this.pingInterval){
						clearInterval(this.pingInterval);
						this.pingInterval = false;
					}
					this.pingInterval = setInterval(this.sendPing.bind(this), this.options.pingTimeout || CONST.PING_TIMEOUT);
				}
			}
		}

		/**
	  * If not connected, reconnects, else sets connection isNotAlive and sends ping
	  */
		sendPing(){
			if(!this.isAlive()){
				this.emit('noPong');
				if(this.state === CONST.STATE.CONNECTED){
					this.state = CONST.STATE.NOT_CONNECTED;
				}
				return;
			}
			this.setHalfDead();
			this.ping();
		}

		pong(){
			if(this.isOpen()){
				this.wsSend('pong');
				this.emit('pong');
			}
		}

		/**
	  * Ping connection
	  */
		ping(){
			if(this.isOpen()){
	      
				this.wsSend('ping').catch(Func.noop);
	      
				this.emit('ping');
			}
		}

		/**
	  * If message is plain text 'pong', then it sets connections as isAlive
	  * @params {string}  msg   incoming message
	  * @returns {boolean}  if it 'pong' message
	  **/
		checkPingMsg(msg){
			if (msg === 'ping'){
				this.setAlive();
				this.emit('pinged');
				this.pong();
				return true;
			}
			if (msg === 'pong'){
				this.setAlive();
				this.emit('ponged');
				return true;
			}
			return false;
		}

	  

		/**
	  * Отправка сообщения
	  * @param  {object|string} данные в виде
	  *                         - строки, будут обернуты в соотвествии со спецификацией
	  *                         - объекта, будут переданы без изменений
	  * @return {Promise} resolve - удачно, reject - сбой
	  */
		async send(data, secure) {
			//Проверяем что клиент подключен
			try {
				if (this.isConnected(secure) || (this.isOpen() && this.isMessageTokenUpdateRequest(data))) {
					//Пытаемся отправить сообщение клиенту.
					await this.wsSend(JSON.stringify(data));
				} else {
					this.emit('messageNotSent', CONST.STATE_NAME[this.state]);
					this.addToHistory(data);
				}
			} catch (e) {
				this.state = CONST.STATE.ERRORED;
				throw e;
			}
		}

		addToHistory(data) {
			this.emit('addToHistory', data);
			this.history.push(data);
			if (this.history.length > MAX_HISTORY_DEPTH) {
				this.history.shift();
			}
		}

		sendAllFromHistory() {
			while (this.history.length) {
				let msg = this.history.shift();
				//sending out but only in secure manner, all messages for not auth users will be dropped
				this.send(msg, true).catch(this.onError.bind(this));
			}
		}

		/**
	  * Finite states machine
	  */

		get state() {
			return this[SYMBOL_STATE];
		}

		set state(state = CONST.STATE.NOT_CONNECTED) {
			if (Object.values(CONST.STATE).indexOf(state) > -1) {
				this.emit('stateChange', state, CONST.STATE_NAME[state]);
				//для каждого варианта, есть только ограниченное кол-во вариантов перехода
				//из "нет соединения" в "авторизован" не прыгнуть
				switch (this[SYMBOL_STATE]) {
				//можем только подключиться или вылететь с ошибкой подключения
				case CONST.STATE.NOT_CONNECTED:
					if ([CONST.STATE.CONNECTED, CONST.STATE.ERRORED].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
					//можем повиснуть, авторизоваться вылететь с ошибкой
				case CONST.STATE.CONNECTED:
					if (
						[
							CONST.STATE.AUTHORIZED,
							CONST.STATE.NO_PING,
							CONST.STATE.ERRORED,
							CONST.STATE.NOT_CONNECTED
						].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
					//можем потерять авторизацию, но продолжить висеть на линии
					//повиснуть
					//вылететь с ошибкой связи
				case CONST.STATE.AUTHORIZED:
					if (
						[
							CONST.STATE.CONNECTED,
							CONST.STATE.NO_PING,
							CONST.STATE.ERRORED,
							CONST.STATE.NOT_CONNECTED
						].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
					////из остояний разрыва связи, можно уйти только в "не подключен"
					//можем только отключиться
				case CONST.STATE.NO_PING:
					if ([CONST.STATE.NOT_CONNECTED].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
					//можем только отключиться
				case CONST.STATE.ERRORED:
					if ([
						CONST.STATE.NOT_CONNECTED,
						CONST.STATE.ERRORED
					].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
				}
				switch(this[SYMBOL_STATE]){
				case CONST.STATE.NOT_CONNECTED:
					//если идём на обрыв, то переподключение не запускаем
					this.emit('disconnected');
					if(this.isAlive()){
						this.emit('beforeReconnect');
						this.reconnect();
					}else {
						if(this.isAutoReconnect()){
							this.scheduleReconnect();
						}
					}
					break;
				case CONST.STATE.CONNECTED:  this.emit('connected');        break;
				case CONST.STATE.AUTHORIZED:  this.emit('authorized');      break;
				case CONST.STATE.NO_PING:
					this.emit('noPing');
					this.disconnectTimeout = setTimeout(this.disconnect.bind(this), 100);
					break;
				case CONST.STATE.ERRORED:
					this.emit('errored');
					this.disconnectTimeout = setTimeout(this.disconnect.bind(this), 100);
					break;
				}
			} else {
				throw new CONST.notWSException('set: Unknown notWSServerClient state: ' + state);
			}
		}

		get activity() {
			return this[SYMBOL_ACTIVITY];
		}

		//
		/*
	IDLE: 0,
	//идёт подключение
	CONNECTING: 1,
	//закрытие соединения
	CLOSING: 2,
	//разрыв соединения
	TERMINATING: 3,
	//авторизация по токену
	AUTHORIZING: 4
	*/
		set activity(activity = CONST.ACTIVITY.IDLE) {
			if (Object.values(CONST.ACTIVITY).indexOf(activity) > -1) {
				this.emit('changeActivity', activity, CONST.ACTIVITY_NAME[activity]);
				//для каждого варианта, есть только ограниченное кол-во вариантов перехода
				//из "нет соединения" в "авторизован" не прыгнуть
				switch (this[SYMBOL_ACTIVITY]) {
				//можем только подключиться
				case CONST.ACTIVITY.IDLE:
					if ([
						CONST.ACTIVITY.CONNECTING,
						CONST.ACTIVITY.CLOSING,
						CONST.ACTIVITY.TERMINATING,
						CONST.ACTIVITY.AUTHORIZING
					].indexOf(activity) > -1) {
						this[SYMBOL_ACTIVITY] = activity;
					}
					break;
				case CONST.ACTIVITY.CONNECTING:
				case CONST.ACTIVITY.CLOSING:
				case CONST.ACTIVITY.TERMINATING:
				case CONST.ACTIVITY.AUTHORIZING:
					if ([CONST.ACTIVITY.IDLE].indexOf(activity) > -1) {
						this[SYMBOL_ACTIVITY] = activity;
					}
					break;
				}
				switch(this[SYMBOL_ACTIVITY]){
				case CONST.ACTIVITY.IDLE:         this.emit('idle', this); break;
				case CONST.ACTIVITY.CONNECTING:   this.emit('connecting', this); break;
				case CONST.ACTIVITY.AUTHORIZING:  this.emit('authorizing', this); break;
				case CONST.ACTIVITY.CLOSING:      this.emit('closing', this); break;
				case CONST.ACTIVITY.TERMINATING:  this.emit('terminating', this); break;
				}
			} else {
				throw new CONST.notWSException('set: Unknown notWSServerClient activity: ' + activity);
			}
		}

		wsSend(msg){
			return new Promise((res, rej)=>{
				this.ws.send(this.countPassed(msg, 'out'), (err)=>{
					if(err){
						rej(err);
					}else {
						res();
					}
				});
			});

		}

		countPassed(input, where){
			this.passed[where] += this.options.count?this.getMessageSize(input):0;
			return input;
		}

		getMessageSize(input){
	    
			return new Blob([input]).size;
	    
		}

		destroy(){
			clearInterval(this.connectInterval);
			clearInterval(this.pingInterval);
			clearTimeout(this.disconnectTimeout);
			this.emit('destroyed');
			this.removeAllListeners();
		}
	}

	/**
	*
	* Client - main function is to connect and handle requests from/to server.
	*
	* Options
	* @params {string}          name              - client name, optional. default: WSCLient
	* @params {object}          connection        - object describing server and behaviour of this client
	*         {string}            host            - server address
	*         {string}            port            - server port
	*         {string}            path            - path on server
	*         {string}            protocol        - connection protocol, preffered over 'ssl' option
	*         {boolean}           ssl             - user ssl encryption for connection
	*         {boolean}           secure          - auth needed
	*         {boolean}           reconnect       - reconnect if disconnected
	*         {boolean}           ping            - ping server to indentify connection problems ASAP
	* @params {function}        getToken          - should return token for auth on server
	* @params {notWSMessenger}  messenger         - message handler or its config
	* @params {notWSRouter}     router            - request handler or its config
	* @params {object}          logger            - log interface {function:log, function:debug, function:error}
	* @params {boolean}         slave             - true - this is server child connection for remote client, false - it is connection to another server
	* @params {Array<string>}   debug             - list of features to debug and show more information
	*
	**/

	class notWSClient extends EventEmitter{
		constructor({
			name,
			connection,
			getToken,
			messenger,
			router,
			logger,
			identity,          //user information
			credentials,        //client creds for access
			slave = false,
			debug = []
		}){
			if(!router){
				throw new CONST.notWSException('Router is not set or is not instance of notWSRouter');
			}
			if(!(router instanceof notWSRouter)){
				router = new notWSRouter(router);
			}
			if(!messenger){
				throw new CONST.notWSException('Messenger is not set or is not instance of notWSMessenger');
			}
			if (!(messenger instanceof notWSMessenger)){
				messenger = new notWSMessenger(messenger);
			}
			super();
			//Основные параметры
			this.__name = name ? name : CONST.DEFAULT_CLIENT_NAME;
			//jwt
			this.jwtToken = null; //Токен авторизации.
			this.jwtExpire = null; //Время до истечения токена.
			this.jwtDate = null; //Дата создания токена.
			//setting envs
			this.tokenGetter = getToken;
			this.identity = identity;
			this.credentials = credentials;
			this.messenger = messenger;
			this.router =   router;
			this.slave = slave;
			this.debug = debug;
			//Подключение к WS
			this.initConnection(connection, this.slave);
			if(!this.slave){
				this.router.on('updateToken', this.renewToken.bind(this));
			}
			//common constructor part for client browser client, node client, node server client
			//logging
			this.logMsg = logger?logger.log:()=>{};
			this.logDebug = logger?logger.debug:()=>{};
			this.logError = logger?logger.error:()=>{};
			//requests processing
			this.requests = []; //Список текущих запросов к API.
			this.reqTimeout = 15000; //Таймаут для выполнения запросов.
			this.reqChkTimer = null; //Таймер для проверки таймаутов выполнения запросов.
			this.reqChkStep = 2000; //Таймер для проверки таймаутов выполнения запросов.
			//time off set from server time
			this._timeOffset = 0;
			this.getTimeOffsetInt = null;
			if(!this.slave){
				this.connect();
			}
			return this;
		}

		getIP(){
			return this.connection?this.connection.getIP():false;
		}

		initConnection(connection){
			this.connection = new notWSConnection(connection);
			this.connection.on('disconnected', ()=>{
				this.logMsg('disconnected');
				this.stopReqChckTimer();
				this.emit('close', this);
				this.emit('disconnected', this);
			});
			this.connection.on('connected', ()=>{
				this.logMsg('connected');
				//Запускаем таймер проверки списка запросов.
				this.startReqChckTimer();
				this.emit('open', this);
				this.emit('connected', this);
			});
			this.connection.on('connectURI', (e)=>{this.logMsg('connectURI', e);});
			this.connection.on('close', (e)=>{this.logMsg('close', e);});
			this.connection.on('error', (e)=>{
				this.logError(e);
			});
			this.connection.on('message', this.processMessage.bind(this));

			this.connection.on('ready', ()=>{
				this.logMsg('ready');
				this.emit('ready', this);
			});

			if(this.connect.debug && this.connect.debug.includes('ping')){
				this.connection.on('ping', ()=>{
					this.logDebug('ping');
				});
				this.connection.on('pong', ()=>{
					this.logDebug('pong');
				});

				this.connection.on('pinged', ()=>{
					this.logDebug('pinged');
				});
				this.connection.on('ponged', ()=>{
					this.logDebug('ponged');
				});
			}
		}

		async connect(){
			if(!this.slave){
				try{
					if(!this.isConnected()){
						//если нужна аутентификация
						if(this.connection.isSecure()){
							//получаем и сохраняем токен токен
							this.saveToken(await this.getToken());
						}
						//подключаемся
						this.connection.connect();
					}
				}catch(e){
					this.logError(e);
				}
			}
		}

		suicide() {
			this.emit('errored', this);
		}

		disconnect(){
			this.connection.disconnect();
		}

		terminate(){
			this.connection.terminate();
			this.connection.destroy();
		}

		destroy(){
			clearInterval(this.getTimeOffsetInt);
			this.emit('destroyed');
			this.removeAllListeners();
		}

		isDead() {
			return !this.connection.isAlive();
		}

		isAlive() {
			return this.connection.isAlive();
		}

		reconnect() {
			this.connection.reconnect();
		}

		isConnected(secure = true) {
			return this.connection.isConnected(secure);
		}

		isSecure() {
			return this.connection.isSecure();
		}

		isAutoReconnect(){
			return this.connection.isAutoReconnect();
		}

	  
		//Запуск таймера проверки запросов.
		startReqChckTimer() {
			clearTimeout(this.reqChkTimer);
			this.reqChkTimer = setTimeout(this.checkRequests.bind(this), this.reqChkStep);
		}

		stopReqChckTimer() {
			clearTimeout(this.reqChkTimer);
		}

		//Поиск запроса по uuid
		findRequest(id) {
			for (let i = 0; i < this.requests.length; i++) {
				if (this.requests[i].id === id) {
					return i;
				}
			}
			return false;
		}

		fullfillRequest(id){
			let reqIndex = this.findRequest(id);
			if(reqIndex === false) {
				this.logMsg(`failed to find request for response ${id}`);
				return null;
			}
			let request = this.requests[reqIndex];
			//Удаление элемента из списка запросов.
			this.requests.splice(reqIndex, 1);
			//Выполнение callback'а запроса.
			if(Func.isFunc(request.cb)) {
				return request;
			} else {
				return null;
			}
		}

		addRequest(id, callback) {
			this.requests.push({
				id, //Идентификатор запроса.
				time: Date.now(), //Время отправки запроса.
				cb: callback //callback для обработки результатов запроса.
			});
		}

		//Проверка списка запросов.
		checkRequests() {
			//Формирование списка запросов для удаления по таймауту.
			let list = [];
			let now = Date.now();
			this.requests.forEach((req) => {
				let reqAge = now - req.time;
				if (reqAge > this.reqTimeout) {
					list.push(req.id);
				}
			});
			//Удаление запросов по таймауту.
			list.forEach((reqId) => {
				let reqIndex = this.findRequest(reqId);
				if (reqIndex === false) {
					this.logMsg(`timeout check:failed to find request for response ${reqId}`);
					return;
				}
				let request = this.requests[reqIndex];
				if (Func.isFunc(request.cb)) {
					request.cb(CONST.ERR_MSG.REQUEST_TIMEOUT);
				} else {
					this.logMsg(`timeout check:Не задан callback для запроса с id: ${reqId}`);
				}
				this.requests.splice(reqIndex, 1);
			});
		}


	  

		//Получение токена.
		//Возможно реализовать разными способами, поэтому выделено в отдельный метод.
		getToken(renew = false){
	    
			let token = localStorage.getItem('token');
			if((typeof token !== 'undefined') && (token !== 'undefined') && token && !renew){
				return Promise.resolve(token);
			}else {
	    
				if(Func.isFunc(this.tokenGetter)){
					return this.tokenGetter();
				}else {
					return Promise.reject();
				}
	    
			}
	    
		}

		async renewToken(){
			if (!this.slave){
				try{
					let token = await this.getToken(true);
					if(token){
						this.saveToken(token);
					}else {
						throw new Error('Token isn\'t renewed');
					}
				}catch(e){
					this.logError(e);
				}
			}
		}

		saveToken(token){
			if (!this.slave){
	      
				localStorage.setItem('token', token);
	      
				this.jwtToken = token;
				this.messenger.setCredentials(token);
				this.connection.setToken(token);
				this.emit('tokenUpdated', token);
			}
		}

		clearToken(){
			this.saveToken(undefined);
		}

		ping(){
			this.connection.sendPing();
		}

		processMessage(data) {
			try{
				this.messenger.validate(data);
				let msg = this.messenger.unpack(data);
				this.emit('message', msg, this);
				this.emit(msg.service.type + ':' + msg.service.name, msg.service, msg.payload, this.connection.getSocket());
				//routing
				this.selectRoute(msg);
			}catch(e){
				this.logError(e, e.details);
	      
			}
		}

		selectRoute(msg){
			switch(msg.service.type){
			//couple of special types
			case CONST.MSG_TYPE.RESPONSE: this.routeResponse(msg);  break;
			case CONST.MSG_TYPE.REQUEST:   this.routeRequest(msg);  break;
			case CONST.MSG_TYPE.EVENT:    this.routeEvent(msg);     break;
				//all other
			default:                      this.routeCommon(msg);
			}
		}

		routeResponse(msg){
			let request = this.fullfillRequest(msg.service.id);
			if(request !== null){
				request.cb(msg);
			}
		}

		routeEvent(msg){
			this.router.route(msg.service, msg.payload, this)
				.catch((e)=>{
					this.logError(e);
				});
		}

		routeCommon(msg){
			this.router.route(msg.service, msg.payload, this)
				.catch((e)=>{
					this.logError(e);
					this.respond({}, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name}, e);
				});
		}

		routeRequest(msg){
			this.router.route(msg.service, msg.payload, this)
				.then((responseData)=>{
					this.respond(responseData, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name});
				})
				.catch((e)=>{
					this.logError(e);
					this.respond({}, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name}, e);
				});
		}

		/**
	  *  Отправка данных определенного типа и названия
	  *  @param {string}  type  тип данных
	  *  @param {string}  name  название
	  *  @param {object}  payload  данные
	  *  @returns  {Promise}
	  */
		send(type, name, payload){
			if(type === CONST.MSG_TYPE.REQUEST){
				return this.request(name, payload);
			}else {
				return this.message(type, name, payload);
			}
		}

		respond(resp, service = {}, error){
			if(typeof resp === 'object' && resp !== null){
				let msg = this.messenger.pack(resp, service, error);
				return this.connection.send(msg);
			}else {
				return true;
			}
		}

		__request(name, payload, cb, secure = true) {
			let message = this.messenger.pack(payload, {
				type: CONST.MSG_TYPE.REQUEST,
				timeOffset: this.timeOffset,
				name,
			});
			this.addRequest(this.messenger.getServiceData(message).id, cb);
			this.connection.send(message, secure).catch(this.logError.bind(this));
		}

		request(name, payload, secure = true) {
			return new Promise((resolve, reject) => {
				try {
					this.__request(name, payload, (response) => {
						if (response === CONST.ERR_MSG.REQUEST_TIMEOUT_MESSAGE) {
							return reject(response);
						}
						if (this.messenger.isErrored(response)) {
							return reject(response);
						}
						resolve(response);
					}, secure);
				} catch (e) {
					reject(e);
				}
			});
		}

		message(type, name, payload){
			if((payload!== 'pong') && ( payload!== 'ping')){
				this.logDebug('outgoing message', type, name);
			}
			let message = this.messenger.pack(payload, {
				type,
				timeOffset: this.timeOffset,
				name,
			});
			return this.connection.send(message).catch(this.logError.bind(this));
		}


		informClientAboutExperiedToken(){
			this.logMsg('force to update token');
			this.send('__service', 'updateToken', {}, false).catch(this.logError.bind(this));
		}


		/**
	  * Server time
	  */
		requestServerTime() {
			if (this.connection.isConnected()) {
				const sendTime = Date.now();
				this.request('getTime', {}, )
					.then((result)=>{
						const receiveTime = Date.now();
						const correction = Math.round((receiveTime - sendTime) / 2);
						const serverTime = parseInt(result, 10);
						const correctedTime = serverTime + correction;
						const offset = correctedTime - receiveTime;
						this.timeOffset = offset;
					})
					.catch((err)=>{
						this.logError(err);
					});
			}
		}

		set timeOffset(val) {
			this._timeOffset = val;
		}

		get timeOffset() {
			return this._timeOffset;
		}

		getTimeOnAuthorized(){
			if (this.getTimeOffsetInt) {
				clearInterval(this.getTimeOffsetInt);
				this.getTimeOffsetInt = null;
			}
			this.requestServerTime();
			this.getTimeOffsetInt = setInterval(this.requestServerTime.bind(this), CONST.TIME_OFFSET_REQUEST_INTERVAL);
		}

	}

	class nsWS {
	    constructor(app) {
	        this.app = app;
	        this.init();
	        app.on("token//updated", () => this.getTokenFromApp());
	    }

	    getTokenFromApp() {
	        const clients = this.app.getOptions("wsc", {});
	        for (let client in clients) {
	            this.app
	                .getWSClient(client)
	                .saveToken(this.app.getWorking("token"));
	            this.app.getWSClient(client).disconnect();
	            this.app.getWSClient(client).connect().catch(this.app.report);
	        }
	    }

	    init() {
	        const clients = this.app.getOptions("wsc", {});
	        for (let client in clients) {
	            this.initClient(client, clients[client]);
	        }
	        this.app.on("user.logout", this.clearMainToken.bind(this));
	    }

	    initClient(name, opts) {
	        try {
	            let options = {},
	                optionsFromAppConfig = false;
	            //integrating with collected from modules
	            for (let optName of [
	                "name",
	                "messenger",
	                "router",
	                "getToken",
	                "logger",
	                "debug",
	            ]) {
	                if (Object.hasOwn(opts, optName)) {
	                    options[optName] = opts[optName];
	                }
	            }
	            //copy opts from app wide config
	            optionsFromAppConfig = this.app.getOptions(
	                `modules.ws.clients.${name}`,
	                false
	            );
	            if (optionsFromAppConfig) {
	                if (!Object.hasOwn(options, "connection")) {
	                    options.connection = {};
	                }
	                options.connection = Object.assign(options.connection, {
	                    ...optionsFromAppConfig,
	                });
	            }
	            let client = new notWSClient(options);
	            client.once(
	                "ready",
	                this.app.emit.bind(this.app, `wsClient:${name}:ready`, client)
	            );
	            client.on(
	                "connected",
	                this.app.emit.bind(
	                    this.app,
	                    `wsClient:${name}:connected`,
	                    client
	                )
	            );
	            client.on(
	                "diconnected",
	                this.app.emit.bind(
	                    this.app,
	                    `wsClient:${name}:diconnected`,
	                    client
	                )
	            );
	            this.app.setWSClient(name, client);
	        } catch (e) {
	            this.app.error(e);
	        }
	    }

	    clearMainToken() {
	        const client = this.app.getWSClient("main");
	        if (client) {
	            client.clearToken();
	        }
	    }
	}

	const services$3 = {nsWS};

	var mod_6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		services: services$3
	});

	function cov_ae6gmhhgt(){var path="/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common/ws.client.main.js";var hash="c6afa87ea487e2f17f232f85325ec3bbc829358a";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common/ws.client.main.js",statementMap:{"0":{start:{line:2,column:15},end:{line:2,column:55}},"1":{start:{line:4,column:13},end:{line:35,column:1}},"2":{start:{line:7,column:8},end:{line:14,column:15}},"3":{start:{line:12,column:16},end:{line:12,column:67}},"4":{start:{line:13,column:16},end:{line:13,column:34}},"5":{start:{line:30,column:20},end:{line:30,column:46}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:6,column:14},end:{line:6,column:15}},loc:{start:{line:6,column:20},end:{line:15,column:5}},line:6},"1":{name:"(anonymous_1)",decl:{start:{line:11,column:18},end:{line:11,column:19}},loc:{start:{line:11,column:27},end:{line:14,column:13}},line:11},"2":{name:"(anonymous_2)",decl:{start:{line:29,column:16},end:{line:29,column:17}},loc:{start:{line:29,column:31},end:{line:31,column:17}},line:29}},branchMap:{},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0},f:{"0":0,"1":0,"2":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common/ws.client.main.js"],sourcesContent:["import { notCommon } from \"not-bulma\";\nconst logger = notCommon.createLogger(`WSClient(main)`);\n\nconst main = {\n    logger: logger,\n    getToken: () => {\n        return notCommon\n            .getApp()\n            .getModel(\"user\", {})\n            .$token({})\n            .then((res) => {\n                notCommon.getApp().setWorking(\"token\", res.result);\n                return res.result;\n            });\n    },\n    messenger: {\n        validateTypeAndName: false,\n        secure: false, //not secure, bc its not issuing tokens and has no secret key\n        types: {\n            __service: [\"updateToken\"],\n            request: [],\n            response: [],\n            event: [],\n        },\n    },\n    router: {\n        routes: {\n            event: {\n                notification() {\n                    console.log(...arguments);\n                },\n            },\n        },\n    },\n};\n\nexport default main;\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"c6afa87ea487e2f17f232f85325ec3bbc829358a"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_ae6gmhhgt=function(){return actualCoverage;};}return actualCoverage;}cov_ae6gmhhgt();const logger=(cov_ae6gmhhgt().s[0]++,notCommon$1.createLogger(`WSClient(main)`));const main=(cov_ae6gmhhgt().s[1]++,{logger:logger,getToken:()=>{cov_ae6gmhhgt().f[0]++;cov_ae6gmhhgt().s[2]++;return notCommon$1.getApp().getModel("user",{}).$token({}).then(res=>{cov_ae6gmhhgt().f[1]++;cov_ae6gmhhgt().s[3]++;notCommon$1.getApp().setWorking("token",res.result);cov_ae6gmhhgt().s[4]++;return res.result;});},messenger:{validateTypeAndName:false,secure:false,//not secure, bc its not issuing tokens and has no secret key
	types:{__service:["updateToken"],request:[],response:[],event:[]}},router:{routes:{event:{notification(){cov_ae6gmhhgt().f[2]++;cov_ae6gmhhgt().s[5]++;console.log(...arguments);}}}}});

	function cov_1r1uoudld(){var path="/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common/index.js";var hash="ec2caa2720e4fc7bc256b02ad8878cb157a7be57";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common/index.js",statementMap:{"0":{start:{line:3,column:15},end:{line:29,column:1}},"1":{start:{line:31,column:12},end:{line:33,column:1}}},fnMap:{},branchMap:{},s:{"0":0,"1":0},f:{},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common/index.js"],sourcesContent:["import main from \"./ws.client.main.js\";\n\nlet manifest = {\n    brand: {\n        icon: {\n            src: \"\",\n            width: 48,\n            height: 28,\n        },\n        title: \"notUserTestApp\",\n        url: \"/\",\n    },\n    modules: {\n        ws: {\n            clients: {\n                //options for ws client here\n                main: {\n                    host: `${window.location.hostname}:7358/`,\n                    path: \"\",\n                    secure: true,\n                    ssl: false,\n                },\n            },\n        },\n    },\n    crud: {\n        containerSelector: \".main-container\",\n    },\n};\n\nconst wsc = {\n    main,\n};\n\nexport { manifest, wsc };\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"ec2caa2720e4fc7bc256b02ad8878cb157a7be57"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1r1uoudld=function(){return actualCoverage;};}return actualCoverage;}cov_1r1uoudld();let manifest$3=(cov_1r1uoudld().s[0]++,{brand:{icon:{src:"",width:48,height:28},title:"notUserTestApp",url:"/"},modules:{ws:{clients:{//options for ws client here
	main:{host:`${window.location.hostname}:7358/`,path:"",secure:true,ssl:false}}}},crud:{containerSelector:".main-container"}});const wsc$2=(cov_1r1uoudld().s[1]++,{main});

	var mod_7 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$3,
		wsc: wsc$2
	});

	function cov_r8l1bfx4w(){var path="/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common/ncInit.js";var hash="c56eaffc5a8966e4c2a78e6e190d46c968c8e4d2";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common/ncInit.js",statementMap:{"0":{start:{line:3,column:51},end:{line:3,column:56}},"1":{start:{line:7,column:8},end:{line:7,column:19}},"2":{start:{line:8,column:8},end:{line:8,column:35}},"3":{start:{line:9,column:8},end:{line:9,column:29}},"4":{start:{line:10,column:8},end:{line:10,column:32}},"5":{start:{line:11,column:8},end:{line:11,column:31}},"6":{start:{line:12,column:8},end:{line:12,column:20}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:6,column:4},end:{line:6,column:5}},loc:{start:{line:6,column:21},end:{line:13,column:5}},line:6}},branchMap:{},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0},f:{"0":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common/ncInit.js"],sourcesContent:["import { Frame } from \"not-bulma\";\n\nconst { notSideMenu, notTopMenu, notController } = Frame;\n\nclass ncInit extends notController {\n    constructor(app) {\n        super(app);\n        this.setModuleName(\"init\");\n        this.log(\"init app\");\n        notSideMenu.render(app);\n        notTopMenu.render(app);\n        return this;\n    }\n}\n\nexport default ncInit;\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;AACD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"c56eaffc5a8966e4c2a78e6e190d46c968c8e4d2"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_r8l1bfx4w=function(){return actualCoverage;};}return actualCoverage;}cov_r8l1bfx4w();const{notSideMenu,notTopMenu,notController: notController$1}=(cov_r8l1bfx4w().s[0]++,Frame);class ncInit extends notController$1{constructor(app){cov_r8l1bfx4w().f[0]++;cov_r8l1bfx4w().s[1]++;super(app);cov_r8l1bfx4w().s[2]++;this.setModuleName("init");cov_r8l1bfx4w().s[3]++;this.log("init app");cov_r8l1bfx4w().s[4]++;notSideMenu.render(app);cov_r8l1bfx4w().s[5]++;notTopMenu.render(app);cov_r8l1bfx4w().s[6]++;return this;}}

	function cov_2ayk1lyqd0(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/common/ui.role.svelte";var hash="ef1b01a61bb3bc68ff2eeb097a23902f04c17b41";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/common/ui.role.svelte",statementMap:{"0":{start:{line:37,column:19},end:{line:37,column:30}},"1":{start:{line:38,column:1},end:{line:38,column:25}},"2":{start:{line:39,column:1},end:{line:39,column:18}},"3":{start:{line:43,column:19},end:{line:43,column:30}},"4":{start:{line:44,column:1},end:{line:44,column:25}},"5":{start:{line:45,column:1},end:{line:45,column:18}},"6":{start:{line:55,column:1},end:{line:82,column:3}},"7":{start:{line:57,column:3},end:{line:57,column:30}},"8":{start:{line:58,column:3},end:{line:58,column:71}},"9":{start:{line:59,column:3},end:{line:59,column:44}},"10":{start:{line:62,column:3},end:{line:62,column:34}},"11":{start:{line:64,column:3},end:{line:67,column:4}},"12":{start:{line:65,column:4},end:{line:65,column:58}},"13":{start:{line:66,column:4},end:{line:66,column:19}},"14":{start:{line:70,column:3},end:{line:72,column:4}},"15":{start:{line:71,column:4},end:{line:71,column:50}},"16":{start:{line:75,column:3},end:{line:77,column:4}},"17":{start:{line:76,column:4},end:{line:76,column:19}},"18":{start:{line:79,column:3},end:{line:79,column:19}},"19":{start:{line:80,column:3},end:{line:80,column:13}},"20":{start:{line:88,column:28},end:{line:88,column:63}},"21":{start:{line:93,column:16},end:{line:93,column:62}},"22":{start:{line:95,column:1},end:{line:138,column:3}},"23":{start:{line:97,column:3},end:{line:97,column:26}},"24":{start:{line:98,column:3},end:{line:98,column:23}},"25":{start:{line:99,column:3},end:{line:99,column:16}},"26":{start:{line:100,column:3},end:{line:100,column:30}},"27":{start:{line:100,column:17},end:{line:100,column:30}},"28":{start:{line:101,column:3},end:{line:101,column:16}},"29":{start:{line:102,column:3},end:{line:102,column:82}},"30":{start:{line:105,column:3},end:{line:105,column:32}},"31":{start:{line:106,column:3},end:{line:106,column:20}},"32":{start:{line:107,column:3},end:{line:107,column:20}},"33":{start:{line:108,column:3},end:{line:108,column:40}},"34":{start:{line:108,column:17},end:{line:108,column:40}},"35":{start:{line:109,column:3},end:{line:109,column:20}},"36":{start:{line:112,column:3},end:{line:112,column:143}},"37":{start:{line:112,column:120},end:{line:112,column:143}},"38":{start:{line:114,column:3},end:{line:125,column:4}},"39":{start:{line:115,column:4},end:{line:121,column:5}},"40":{start:{line:116,column:5},end:{line:116,column:28}},"41":{start:{line:118,column:5},end:{line:118,column:39}},"42":{start:{line:119,column:5},end:{line:119,column:18}},"43":{start:{line:120,column:5},end:{line:120,column:26}},"44":{start:{line:122,column:10},end:{line:125,column:4}},"45":{start:{line:123,column:4},end:{line:123,column:18}},"46":{start:{line:124,column:4},end:{line:124,column:20}},"47":{start:{line:127,column:3},end:{line:129,column:4}},"48":{start:{line:128,column:4},end:{line:128,column:42}},"49":{start:{line:132,column:3},end:{line:134,column:4}},"50":{start:{line:133,column:4},end:{line:133,column:17}},"51":{start:{line:136,column:3},end:{line:136,column:30}},"52":{start:{line:136,column:17},end:{line:136,column:30}},"53":{start:{line:148,column:28},end:{line:148,column:64}},"54":{start:{line:152,column:28},end:{line:152,column:51}},"55":{start:{line:162,column:18},end:{line:162,column:56}},"56":{start:{line:163,column:19},end:{line:163,column:21}},"57":{start:{line:165,column:1},end:{line:167,column:2}},"58":{start:{line:165,column:14},end:{line:165,column:15}},"59":{start:{line:166,column:2},end:{line:166,column:75}},"60":{start:{line:170,column:34},end:{line:170,column:49}},"61":{start:{line:174,column:32},end:{line:174,column:47}},"62":{start:{line:178,column:35},end:{line:178,column:50}},"63":{start:{line:181,column:26},end:{line:183,column:2}},"64":{start:{line:185,column:1},end:{line:187,column:2}},"65":{start:{line:186,column:2},end:{line:186,column:51}},"66":{start:{line:189,column:1},end:{line:191,column:2}},"67":{start:{line:190,column:2},end:{line:190,column:50}},"68":{start:{line:193,column:1},end:{line:195,column:2}},"69":{start:{line:194,column:2},end:{line:194,column:60}},"70":{start:{line:197,column:1},end:{line:197,column:75}},"71":{start:{line:198,column:1},end:{line:198,column:89}},"72":{start:{line:198,column:30},end:{line:198,column:87}},"73":{start:{line:199,column:1},end:{line:199,column:85}},"74":{start:{line:199,column:30},end:{line:199,column:83}},"75":{start:{line:200,column:1},end:{line:200,column:91}},"76":{start:{line:200,column:30},end:{line:200,column:89}},"77":{start:{line:202,column:1},end:{line:323,column:3}},"78":{start:{line:204,column:3},end:{line:204,column:25}},"79":{start:{line:205,column:3},end:{line:205,column:25}},"80":{start:{line:206,column:3},end:{line:206,column:25}},"81":{start:{line:207,column:3},end:{line:207,column:30}},"82":{start:{line:208,column:3},end:{line:208,column:30}},"83":{start:{line:209,column:3},end:{line:209,column:23}},"84":{start:{line:211,column:3},end:{line:213,column:4}},"85":{start:{line:211,column:16},end:{line:211,column:17}},"86":{start:{line:212,column:4},end:{line:212,column:23}},"87":{start:{line:215,column:3},end:{line:215,column:16}},"88":{start:{line:216,column:3},end:{line:216,column:30}},"89":{start:{line:217,column:3},end:{line:217,column:23}},"90":{start:{line:218,column:3},end:{line:218,column:16}},"91":{start:{line:219,column:3},end:{line:219,column:46}},"92":{start:{line:220,column:3},end:{line:220,column:25}},"93":{start:{line:221,column:3},end:{line:221,column:43}},"94":{start:{line:222,column:3},end:{line:222,column:26}},"95":{start:{line:223,column:3},end:{line:223,column:42}},"96":{start:{line:224,column:3},end:{line:224,column:55}},"97":{start:{line:225,column:3},end:{line:225,column:34}},"98":{start:{line:226,column:3},end:{line:226,column:33}},"99":{start:{line:229,column:3},end:{line:229,column:32}},"100":{start:{line:230,column:3},end:{line:230,column:22}},"101":{start:{line:231,column:3},end:{line:231,column:22}},"102":{start:{line:232,column:3},end:{line:232,column:24}},"103":{start:{line:233,column:3},end:{line:233,column:26}},"104":{start:{line:234,column:3},end:{line:234,column:22}},"105":{start:{line:236,column:3},end:{line:240,column:4}},"106":{start:{line:236,column:16},end:{line:236,column:17}},"107":{start:{line:237,column:4},end:{line:239,column:5}},"108":{start:{line:238,column:5},end:{line:238,column:36}},"109":{start:{line:242,column:3},end:{line:242,column:20}},"110":{start:{line:243,column:3},end:{line:243,column:24}},"111":{start:{line:244,column:3},end:{line:244,column:22}},"112":{start:{line:245,column:3},end:{line:245,column:20}},"113":{start:{line:246,column:3},end:{line:246,column:45}},"114":{start:{line:247,column:3},end:{line:247,column:18}},"115":{start:{line:249,column:3},end:{line:252,column:4}},"116":{start:{line:250,column:4},end:{line:250,column:55}},"117":{start:{line:251,column:4},end:{line:251,column:19}},"118":{start:{line:255,column:3},end:{line:255,column:150}},"119":{start:{line:255,column:127},end:{line:255,column:150}},"120":{start:{line:257,column:3},end:{line:278,column:4}},"121":{start:{line:258,column:4},end:{line:258,column:56}},"122":{start:{line:261,column:4},end:{line:271,column:5}},"123":{start:{line:262,column:23},end:{line:262,column:59}},"124":{start:{line:264,column:5},end:{line:270,column:6}},"125":{start:{line:265,column:6},end:{line:265,column:41}},"126":{start:{line:267,column:6},end:{line:267,column:52}},"127":{start:{line:268,column:6},end:{line:268,column:25}},"128":{start:{line:269,column:6},end:{line:269,column:37}},"129":{start:{line:273,column:4},end:{line:275,column:5}},"130":{start:{line:274,column:5},end:{line:274,column:25}},"131":{start:{line:277,column:4},end:{line:277,column:43}},"132":{start:{line:280,column:3},end:{line:280,column:137}},"133":{start:{line:280,column:114},end:{line:280,column:137}},"134":{start:{line:281,column:32},end:{line:281,column:34}},"135":{start:{line:282,column:3},end:{line:282,column:106}},"136":{start:{line:282,column:35},end:{line:282,column:106}},"137":{start:{line:284,column:3},end:{line:288,column:4}},"138":{start:{line:285,column:4},end:{line:285,column:27}},"139":{start:{line:286,column:4},end:{line:286,column:55}},"140":{start:{line:287,column:4},end:{line:287,column:54}},"141":{start:{line:287,column:29},end:{line:287,column:52}},"142":{start:{line:290,column:3},end:{line:294,column:4}},"143":{start:{line:291,column:4},end:{line:291,column:25}},"144":{start:{line:292,column:4},end:{line:292,column:54}},"145":{start:{line:293,column:4},end:{line:293,column:52}},"146":{start:{line:293,column:29},end:{line:293,column:50}},"147":{start:{line:296,column:3},end:{line:300,column:4}},"148":{start:{line:297,column:4},end:{line:297,column:28}},"149":{start:{line:298,column:4},end:{line:298,column:64}},"150":{start:{line:299,column:4},end:{line:299,column:55}},"151":{start:{line:299,column:29},end:{line:299,column:53}},"152":{start:{line:302,column:3},end:{line:302,column:43}},"153":{start:{line:305,column:3},end:{line:305,column:23}},"154":{start:{line:305,column:16},end:{line:305,column:23}},"155":{start:{line:306,column:3},end:{line:306,column:50}},"156":{start:{line:307,column:3},end:{line:307,column:18}},"157":{start:{line:310,column:3},end:{line:310,column:51}},"158":{start:{line:311,column:3},end:{line:311,column:19}},"159":{start:{line:314,column:3},end:{line:316,column:4}},"160":{start:{line:315,column:4},end:{line:315,column:17}},"161":{start:{line:318,column:3},end:{line:318,column:40}},"162":{start:{line:319,column:3},end:{line:319,column:35}},"163":{start:{line:320,column:3},end:{line:320,column:19}},"164":{start:{line:321,column:3},end:{line:321,column:13}},"165":{start:{line:329,column:27},end:{line:329,column:65}},"166":{start:{line:333,column:1},end:{line:357,column:3}},"167":{start:{line:335,column:3},end:{line:335,column:30}},"168":{start:{line:336,column:3},end:{line:336,column:21}},"169":{start:{line:337,column:3},end:{line:337,column:64}},"170":{start:{line:338,column:3},end:{line:338,column:43}},"171":{start:{line:341,column:3},end:{line:341,column:34}},"172":{start:{line:342,column:3},end:{line:342,column:21}},"173":{start:{line:345,column:3},end:{line:345,column:144}},"174":{start:{line:345,column:123},end:{line:345,column:144}},"175":{start:{line:347,column:3},end:{line:350,column:4}},"176":{start:{line:348,column:4},end:{line:348,column:40}},"177":{start:{line:349,column:4},end:{line:349,column:44}},"178":{start:{line:353,column:3},end:{line:355,column:4}},"179":{start:{line:354,column:4},end:{line:354,column:19}},"180":{start:{line:363,column:16},end:{line:363,column:76}},"181":{start:{line:365,column:1},end:{line:395,column:3}},"182":{start:{line:367,column:3},end:{line:367,column:30}},"183":{start:{line:367,column:17},end:{line:367,column:30}},"184":{start:{line:368,column:3},end:{line:368,column:29}},"185":{start:{line:371,column:3},end:{line:371,column:44}},"186":{start:{line:371,column:17},end:{line:371,column:44}},"187":{start:{line:372,column:3},end:{line:372,column:43}},"188":{start:{line:375,column:3},end:{line:386,column:4}},"189":{start:{line:376,column:4},end:{line:382,column:5}},"190":{start:{line:377,column:5},end:{line:377,column:28}},"191":{start:{line:379,column:5},end:{line:379,column:39}},"192":{start:{line:380,column:5},end:{line:380,column:18}},"193":{start:{line:381,column:5},end:{line:381,column:61}},"194":{start:{line:383,column:10},end:{line:386,column:4}},"195":{start:{line:384,column:4},end:{line:384,column:18}},"196":{start:{line:385,column:4},end:{line:385,column:20}},"197":{start:{line:389,column:3},end:{line:391,column:4}},"198":{start:{line:390,column:4},end:{line:390,column:28}},"199":{start:{line:393,column:3},end:{line:393,column:39}},"200":{start:{line:393,column:17},end:{line:393,column:39}},"201":{start:{line:404,column:20},end:{line:404,column:56}},"202":{start:{line:405,column:19},end:{line:405,column:21}},"203":{start:{line:407,column:1},end:{line:409,column:2}},"204":{start:{line:407,column:14},end:{line:407,column:15}},"205":{start:{line:408,column:2},end:{line:408,column:81}},"206":{start:{line:411,column:16},end:{line:411,column:60}},"207":{start:{line:413,column:1},end:{line:509,column:3}},"208":{start:{line:415,column:3},end:{line:415,column:25}},"209":{start:{line:416,column:3},end:{line:416,column:25}},"210":{start:{line:418,column:3},end:{line:420,column:4}},"211":{start:{line:418,column:16},end:{line:418,column:17}},"212":{start:{line:419,column:4},end:{line:419,column:23}},"213":{start:{line:422,column:3},end:{line:422,column:15}},"214":{start:{line:423,column:3},end:{line:423,column:30}},"215":{start:{line:423,column:17},end:{line:423,column:30}},"216":{start:{line:424,column:3},end:{line:424,column:74}},"217":{start:{line:425,column:3},end:{line:425,column:34}},"218":{start:{line:428,column:3},end:{line:428,column:32}},"219":{start:{line:429,column:3},end:{line:429,column:22}},"220":{start:{line:431,column:3},end:{line:435,column:4}},"221":{start:{line:431,column:16},end:{line:431,column:17}},"222":{start:{line:432,column:4},end:{line:434,column:5}},"223":{start:{line:433,column:5},end:{line:433,column:34}},"224":{start:{line:437,column:3},end:{line:437,column:19}},"225":{start:{line:438,column:3},end:{line:438,column:40}},"226":{start:{line:438,column:17},end:{line:438,column:40}},"227":{start:{line:439,column:3},end:{line:439,column:18}},"228":{start:{line:442,column:3},end:{line:463,column:4}},"229":{start:{line:443,column:4},end:{line:443,column:56}},"230":{start:{line:446,column:4},end:{line:456,column:5}},"231":{start:{line:447,column:23},end:{line:447,column:63}},"232":{start:{line:449,column:5},end:{line:455,column:6}},"233":{start:{line:450,column:6},end:{line:450,column:41}},"234":{start:{line:452,column:6},end:{line:452,column:54}},"235":{start:{line:453,column:6},end:{line:453,column:25}},"236":{start:{line:454,column:6},end:{line:454,column:35}},"237":{start:{line:458,column:4},end:{line:460,column:5}},"238":{start:{line:459,column:5},end:{line:459,column:25}},"239":{start:{line:462,column:4},end:{line:462,column:45}},"240":{start:{line:465,column:3},end:{line:467,column:4}},"241":{start:{line:466,column:4},end:{line:466,column:42}},"242":{start:{line:469,column:3},end:{line:490,column:4}},"243":{start:{line:470,column:4},end:{line:481,column:5}},"244":{start:{line:471,column:5},end:{line:471,column:28}},"245":{start:{line:473,column:5},end:{line:475,column:6}},"246":{start:{line:474,column:6},end:{line:474,column:33}},"247":{start:{line:477,column:5},end:{line:477,column:37}},"248":{start:{line:478,column:5},end:{line:478,column:18}},"249":{start:{line:479,column:5},end:{line:479,column:32}},"250":{start:{line:480,column:5},end:{line:480,column:28}},"251":{start:{line:482,column:10},end:{line:490,column:4}},"252":{start:{line:483,column:4},end:{line:483,column:19}},"253":{start:{line:485,column:4},end:{line:487,column:7}},"254":{start:{line:486,column:5},end:{line:486,column:21}},"255":{start:{line:489,column:4},end:{line:489,column:19}},"256":{start:{line:493,column:3},end:{line:493,column:23}},"257":{start:{line:493,column:16},end:{line:493,column:23}},"258":{start:{line:494,column:3},end:{line:494,column:27}},"259":{start:{line:495,column:3},end:{line:495,column:18}},"260":{start:{line:498,column:3},end:{line:498,column:28}},"261":{start:{line:499,column:3},end:{line:499,column:19}},"262":{start:{line:502,column:3},end:{line:504,column:4}},"263":{start:{line:503,column:4},end:{line:503,column:17}},"264":{start:{line:506,column:3},end:{line:506,column:40}},"265":{start:{line:507,column:3},end:{line:507,column:30}},"266":{start:{line:507,column:17},end:{line:507,column:30}},"267":{start:{line:513,column:1},end:{line:519,column:2}},"268":{start:{line:514,column:2},end:{line:516,column:47}},"269":{start:{line:515,column:3},end:{line:515,column:30}},"270":{start:{line:516,column:19},end:{line:516,column:45}},"271":{start:{line:518,column:2},end:{line:518,column:12}},"272":{start:{line:523,column:1},end:{line:529,column:2}},"273":{start:{line:524,column:2},end:{line:524,column:13}},"274":{start:{line:525,column:8},end:{line:529,column:2}},"275":{start:{line:526,column:2},end:{line:526,column:16}},"276":{start:{line:528,column:2},end:{line:528,column:19}},"277":{start:{line:539,column:1},end:{line:539,column:84}},"278":{start:{line:539,column:48},end:{line:539,column:82}},"279":{start:{line:540,column:26},end:{line:540,column:42}},"280":{start:{line:541,column:22},end:{line:541,column:30}},"281":{start:{line:542,column:16},end:{line:542,column:39}},"282":{start:{line:545,column:2},end:{line:551,column:3}},"283":{start:{line:546,column:3},end:{line:548,column:48}},"284":{start:{line:547,column:4},end:{line:547,column:34}},"285":{start:{line:548,column:20},end:{line:548,column:46}},"286":{start:{line:550,column:3},end:{line:550,column:13}},"287":{start:{line:555,column:2},end:{line:563,column:3}},"288":{start:{line:556,column:3},end:{line:560,column:4}},"289":{start:{line:557,column:4},end:{line:557,column:56}},"290":{start:{line:557,column:36},end:{line:557,column:54}},"291":{start:{line:559,column:4},end:{line:559,column:21}},"292":{start:{line:562,column:3},end:{line:562,column:14}},"293":{start:{line:566,column:1},end:{line:571,column:4}},"294":{start:{line:567,column:2},end:{line:567,column:42}},"295":{start:{line:568,column:2},end:{line:568,column:26}},"296":{start:{line:569,column:2},end:{line:569,column:43}},"297":{start:{line:570,column:2},end:{line:570,column:26}},"298":{start:{line:573,column:32},end:{line:573,column:39}},"299":{start:{line:574,column:22},end:{line:574,column:29}},"300":{start:{line:583,column:14},end:{line:583,column:16}},"301":{start:{line:585,column:25},end:{line:585,column:32}},"302":{start:{line:586,column:30},end:{line:586,column:37}},"303":{start:{line:587,column:28},end:{line:587,column:35}},"304":{start:{line:588,column:24},end:{line:588,column:31}},"305":{start:{line:589,column:29},end:{line:589,column:36}},"306":{start:{line:590,column:26},end:{line:590,column:33}},"307":{start:{line:591,column:30},end:{line:591,column:37}},"308":{start:{line:592,column:34},end:{line:592,column:41}},"309":{start:{line:595,column:2},end:{line:595,column:26}},"310":{start:{line:596,column:11},end:{line:596,column:37}},"311":{start:{line:597,column:13},end:{line:597,column:44}},"312":{start:{line:597,column:31},end:{line:597,column:43}},"313":{start:{line:599,column:2},end:{line:606,column:3}},"314":{start:{line:600,column:3},end:{line:600,column:42}},"315":{start:{line:601,column:3},end:{line:601,column:27}},"316":{start:{line:602,column:3},end:{line:602,column:45}},"317":{start:{line:603,column:3},end:{line:603,column:27}},"318":{start:{line:604,column:3},end:{line:604,column:41}},"319":{start:{line:605,column:3},end:{line:605,column:48}},"320":{start:{line:608,column:2},end:{line:608,column:15}},"321":{start:{line:612,column:2},end:{line:612,column:26}},"322":{start:{line:613,column:11},end:{line:613,column:67}},"323":{start:{line:615,column:13},end:{line:617,column:8}},"324":{start:{line:616,column:24},end:{line:616,column:36}},"325":{start:{line:619,column:2},end:{line:625,column:3}},"326":{start:{line:620,column:3},end:{line:620,column:21}},"327":{start:{line:621,column:3},end:{line:621,column:27}},"328":{start:{line:622,column:3},end:{line:622,column:45}},"329":{start:{line:623,column:3},end:{line:623,column:27}},"330":{start:{line:624,column:3},end:{line:624,column:48}},"331":{start:{line:627,column:2},end:{line:627,column:15}},"332":{start:{line:631,column:2},end:{line:631,column:20}},"333":{start:{line:632,column:2},end:{line:632,column:89}},"334":{start:{line:636,column:2},end:{line:636,column:21}},"335":{start:{line:637,column:2},end:{line:637,column:122}},"336":{start:{line:641,column:2},end:{line:641,column:28}},"337":{start:{line:642,column:2},end:{line:642,column:98}},"338":{start:{line:645,column:1},end:{line:656,column:3}},"339":{start:{line:646,column:2},end:{line:646,column:87}},"340":{start:{line:646,column:33},end:{line:646,column:87}},"341":{start:{line:647,column:2},end:{line:647,column:66}},"342":{start:{line:647,column:26},end:{line:647,column:66}},"343":{start:{line:648,column:2},end:{line:648,column:74}},"344":{start:{line:648,column:29},end:{line:648,column:74}},"345":{start:{line:649,column:2},end:{line:649,column:77}},"346":{start:{line:649,column:30},end:{line:649,column:77}},"347":{start:{line:650,column:2},end:{line:650,column:74}},"348":{start:{line:650,column:29},end:{line:650,column:74}},"349":{start:{line:651,column:2},end:{line:651,column:66}},"350":{start:{line:651,column:26},end:{line:651,column:66}},"351":{start:{line:652,column:2},end:{line:652,column:78}},"352":{start:{line:652,column:30},end:{line:652,column:78}},"353":{start:{line:653,column:2},end:{line:653,column:69}},"354":{start:{line:653,column:27},end:{line:653,column:69}},"355":{start:{line:654,column:2},end:{line:654,column:81}},"356":{start:{line:654,column:31},end:{line:654,column:81}},"357":{start:{line:655,column:2},end:{line:655,column:93}},"358":{start:{line:655,column:35},end:{line:655,column:93}},"359":{start:{line:658,column:1},end:{line:680,column:3}},"360":{start:{line:659,column:2},end:{line:661,column:3}},"361":{start:{line:660,column:3},end:{line:660,column:97}},"362":{start:{line:660,column:6},end:{line:660,column:97}},"363":{start:{line:663,column:2},end:{line:665,column:3}},"364":{start:{line:664,column:3},end:{line:664,column:74}},"365":{start:{line:664,column:6},end:{line:664,column:74}},"366":{start:{line:667,column:2},end:{line:669,column:3}},"367":{start:{line:668,column:3},end:{line:668,column:50}},"368":{start:{line:668,column:6},end:{line:668,column:50}},"369":{start:{line:671,column:2},end:{line:675,column:3}},"370":{start:{line:672,column:3},end:{line:674,column:25}},"371":{start:{line:672,column:6},end:{line:674,column:25}},"372":{start:{line:677,column:2},end:{line:679,column:3}},"373":{start:{line:678,column:3},end:{line:678,column:59}},"374":{start:{line:678,column:6},end:{line:678,column:59}},"375":{start:{line:682,column:1},end:{line:705,column:3}},"376":{start:{line:710,column:2},end:{line:710,column:10}},"377":{start:{line:712,column:2},end:{line:732,column:4}}},fnMap:{"0":{name:"get_each_context",decl:{start:{line:36,column:9},end:{line:36,column:25}},loc:{start:{line:36,column:40},end:{line:40,column:1}},line:36},"1":{name:"get_each_context_1",decl:{start:{line:42,column:9},end:{line:42,column:27}},loc:{start:{line:42,column:42},end:{line:46,column:1}},line:42},"2":{name:"create_if_block_2",decl:{start:{line:49,column:9},end:{line:49,column:26}},loc:{start:{line:49,column:32},end:{line:83,column:1}},line:49},"3":{name:"(anonymous_3)",decl:{start:{line:56,column:2},end:{line:56,column:3}},loc:{start:{line:56,column:6},end:{line:60,column:3}},line:56},"4":{name:"(anonymous_4)",decl:{start:{line:61,column:2},end:{line:61,column:3}},loc:{start:{line:61,column:20},end:{line:68,column:3}},line:61},"5":{name:"(anonymous_5)",decl:{start:{line:69,column:2},end:{line:69,column:3}},loc:{start:{line:69,column:16},end:{line:73,column:3}},line:69},"6":{name:"(anonymous_6)",decl:{start:{line:74,column:2},end:{line:74,column:3}},loc:{start:{line:74,column:15},end:{line:81,column:3}},line:74},"7":{name:"create_each_block_1",decl:{start:{line:86,column:9},end:{line:86,column:28}},loc:{start:{line:86,column:34},end:{line:139,column:1}},line:86},"8":{name:"(anonymous_8)",decl:{start:{line:96,column:2},end:{line:96,column:3}},loc:{start:{line:96,column:6},end:{line:103,column:3}},line:96},"9":{name:"(anonymous_9)",decl:{start:{line:104,column:2},end:{line:104,column:3}},loc:{start:{line:104,column:20},end:{line:110,column:3}},line:104},"10":{name:"(anonymous_10)",decl:{start:{line:111,column:2},end:{line:111,column:3}},loc:{start:{line:111,column:16},end:{line:130,column:3}},line:111},"11":{name:"(anonymous_11)",decl:{start:{line:131,column:2},end:{line:131,column:3}},loc:{start:{line:131,column:15},end:{line:137,column:3}},line:131},"12":{name:"create_if_block",decl:{start:{line:142,column:9},end:{line:142,column:24}},loc:{start:{line:142,column:30},end:{line:324,column:1}},line:142},"13":{name:"uierrorslist_errors_binding",decl:{start:{line:169,column:10},end:{line:169,column:37}},loc:{start:{line:169,column:45},end:{line:171,column:2}},line:169},"14":{name:"uierrorslist_show_binding",decl:{start:{line:173,column:10},end:{line:173,column:35}},loc:{start:{line:173,column:43},end:{line:175,column:2}},line:173},"15":{name:"uierrorslist_classes_binding",decl:{start:{line:177,column:10},end:{line:177,column:38}},loc:{start:{line:177,column:46},end:{line:179,column:2}},line:177},"16":{name:"(anonymous_16)",decl:{start:{line:198,column:24},end:{line:198,column:25}},loc:{start:{line:198,column:30},end:{line:198,column:87}},line:198},"17":{name:"(anonymous_17)",decl:{start:{line:199,column:24},end:{line:199,column:25}},loc:{start:{line:199,column:30},end:{line:199,column:83}},line:199},"18":{name:"(anonymous_18)",decl:{start:{line:200,column:24},end:{line:200,column:25}},loc:{start:{line:200,column:30},end:{line:200,column:89}},line:200},"19":{name:"(anonymous_19)",decl:{start:{line:203,column:2},end:{line:203,column:3}},loc:{start:{line:203,column:6},end:{line:227,column:3}},line:203},"20":{name:"(anonymous_20)",decl:{start:{line:228,column:2},end:{line:228,column:3}},loc:{start:{line:228,column:20},end:{line:253,column:3}},line:228},"21":{name:"(anonymous_21)",decl:{start:{line:254,column:2},end:{line:254,column:3}},loc:{start:{line:254,column:16},end:{line:303,column:3}},line:254},"22":{name:"(anonymous_22)",decl:{start:{line:287,column:23},end:{line:287,column:24}},loc:{start:{line:287,column:29},end:{line:287,column:52}},line:287},"23":{name:"(anonymous_23)",decl:{start:{line:293,column:23},end:{line:293,column:24}},loc:{start:{line:293,column:29},end:{line:293,column:50}},line:293},"24":{name:"(anonymous_24)",decl:{start:{line:299,column:23},end:{line:299,column:24}},loc:{start:{line:299,column:29},end:{line:299,column:53}},line:299},"25":{name:"(anonymous_25)",decl:{start:{line:304,column:2},end:{line:304,column:3}},loc:{start:{line:304,column:11},end:{line:308,column:3}},line:304},"26":{name:"(anonymous_26)",decl:{start:{line:309,column:2},end:{line:309,column:3}},loc:{start:{line:309,column:11},end:{line:312,column:3}},line:309},"27":{name:"(anonymous_27)",decl:{start:{line:313,column:2},end:{line:313,column:3}},loc:{start:{line:313,column:15},end:{line:322,column:3}},line:313},"28":{name:"create_if_block_1",decl:{start:{line:327,column:9},end:{line:327,column:26}},loc:{start:{line:327,column:32},end:{line:358,column:1}},line:327},"29":{name:"(anonymous_29)",decl:{start:{line:334,column:2},end:{line:334,column:3}},loc:{start:{line:334,column:6},end:{line:339,column:3}},line:334},"30":{name:"(anonymous_30)",decl:{start:{line:340,column:2},end:{line:340,column:3}},loc:{start:{line:340,column:20},end:{line:343,column:3}},line:340},"31":{name:"(anonymous_31)",decl:{start:{line:344,column:2},end:{line:344,column:3}},loc:{start:{line:344,column:16},end:{line:351,column:3}},line:344},"32":{name:"(anonymous_32)",decl:{start:{line:352,column:2},end:{line:352,column:3}},loc:{start:{line:352,column:15},end:{line:356,column:3}},line:352},"33":{name:"create_each_block",decl:{start:{line:361,column:9},end:{line:361,column:26}},loc:{start:{line:361,column:32},end:{line:396,column:1}},line:361},"34":{name:"(anonymous_34)",decl:{start:{line:366,column:2},end:{line:366,column:3}},loc:{start:{line:366,column:6},end:{line:369,column:3}},line:366},"35":{name:"(anonymous_35)",decl:{start:{line:370,column:2},end:{line:370,column:3}},loc:{start:{line:370,column:20},end:{line:373,column:3}},line:370},"36":{name:"(anonymous_36)",decl:{start:{line:374,column:2},end:{line:374,column:3}},loc:{start:{line:374,column:16},end:{line:387,column:3}},line:374},"37":{name:"(anonymous_37)",decl:{start:{line:388,column:2},end:{line:388,column:3}},loc:{start:{line:388,column:15},end:{line:394,column:3}},line:388},"38":{name:"create_fragment",decl:{start:{line:398,column:9},end:{line:398,column:24}},loc:{start:{line:398,column:30},end:{line:510,column:1}},line:398},"39":{name:"(anonymous_39)",decl:{start:{line:414,column:2},end:{line:414,column:3}},loc:{start:{line:414,column:6},end:{line:426,column:3}},line:414},"40":{name:"(anonymous_40)",decl:{start:{line:427,column:2},end:{line:427,column:3}},loc:{start:{line:427,column:20},end:{line:440,column:3}},line:427},"41":{name:"(anonymous_41)",decl:{start:{line:441,column:2},end:{line:441,column:3}},loc:{start:{line:441,column:16},end:{line:491,column:3}},line:441},"42":{name:"(anonymous_42)",decl:{start:{line:485,column:35},end:{line:485,column:36}},loc:{start:{line:485,column:41},end:{line:487,column:5}},line:485},"43":{name:"(anonymous_43)",decl:{start:{line:492,column:2},end:{line:492,column:3}},loc:{start:{line:492,column:11},end:{line:496,column:3}},line:492},"44":{name:"(anonymous_44)",decl:{start:{line:497,column:2},end:{line:497,column:3}},loc:{start:{line:497,column:11},end:{line:500,column:3}},line:497},"45":{name:"(anonymous_45)",decl:{start:{line:501,column:2},end:{line:501,column:3}},loc:{start:{line:501,column:15},end:{line:508,column:3}},line:501},"46":{name:"deplete",decl:{start:{line:512,column:9},end:{line:512,column:16}},loc:{start:{line:512,column:27},end:{line:520,column:1}},line:512},"47":{name:"(anonymous_47)",decl:{start:{line:514,column:17},end:{line:514,column:18}},loc:{start:{line:514,column:25},end:{line:516,column:3}},line:514},"48":{name:"(anonymous_48)",decl:{start:{line:516,column:12},end:{line:516,column:13}},loc:{start:{line:516,column:19},end:{line:516,column:45}},line:516},"49":{name:"getRoleString",decl:{start:{line:522,column:9},end:{line:522,column:22}},loc:{start:{line:522,column:28},end:{line:530,column:1}},line:522},"50":{name:"instance",decl:{start:{line:532,column:9},end:{line:532,column:17}},loc:{start:{line:532,column:49},end:{line:706,column:1}},line:532},"51":{name:"(anonymous_51)",decl:{start:{line:539,column:37},end:{line:539,column:38}},loc:{start:{line:539,column:48},end:{line:539,column:82}},line:539},"52":{name:"enrich",decl:{start:{line:544,column:10},end:{line:544,column:16}},loc:{start:{line:544,column:27},end:{line:552,column:2}},line:544},"53":{name:"(anonymous_53)",decl:{start:{line:546,column:18},end:{line:546,column:19}},loc:{start:{line:546,column:26},end:{line:548,column:4}},line:546},"54":{name:"(anonymous_54)",decl:{start:{line:548,column:13},end:{line:548,column:14}},loc:{start:{line:548,column:20},end:{line:548,column:46}},line:548},"55":{name:"getRoleTagObject",decl:{start:{line:554,column:10},end:{line:554,column:26}},loc:{start:{line:554,column:32},end:{line:564,column:2}},line:554},"56":{name:"(anonymous_56)",decl:{start:{line:557,column:25},end:{line:557,column:26}},loc:{start:{line:557,column:36},end:{line:557,column:54}},line:557},"57":{name:"(anonymous_57)",decl:{start:{line:566,column:9},end:{line:566,column:10}},loc:{start:{line:566,column:15},end:{line:571,column:2}},line:566},"58":{name:"remove",decl:{start:{line:594,column:10},end:{line:594,column:16}},loc:{start:{line:594,column:20},end:{line:609,column:2}},line:594},"59":{name:"(anonymous_59)",decl:{start:{line:597,column:25},end:{line:597,column:26}},loc:{start:{line:597,column:31},end:{line:597,column:43}},line:597},"60":{name:"add",decl:{start:{line:611,column:10},end:{line:611,column:13}},loc:{start:{line:611,column:17},end:{line:628,column:2}},line:611},"61":{name:"(anonymous_61)",decl:{start:{line:616,column:18},end:{line:616,column:19}},loc:{start:{line:616,column:24},end:{line:616,column:36}},line:616},"62":{name:"uierrorslist_errors_binding",decl:{start:{line:630,column:10},end:{line:630,column:37}},loc:{start:{line:630,column:45},end:{line:633,column:2}},line:630},"63":{name:"uierrorslist_show_binding",decl:{start:{line:635,column:10},end:{line:635,column:35}},loc:{start:{line:635,column:43},end:{line:638,column:2}},line:635},"64":{name:"uierrorslist_classes_binding",decl:{start:{line:640,column:10},end:{line:640,column:38}},loc:{start:{line:640,column:46},end:{line:643,column:2}},line:640},"65":{name:"(anonymous_65)",decl:{start:{line:645,column:16},end:{line:645,column:17}},loc:{start:{line:645,column:27},end:{line:656,column:2}},line:645},"66":{name:"(anonymous_66)",decl:{start:{line:658,column:20},end:{line:658,column:21}},loc:{start:{line:658,column:26},end:{line:680,column:2}},line:658},"67":{name:"(anonymous_67)",decl:{start:{line:709,column:1},end:{line:709,column:2}},loc:{start:{line:709,column:22},end:{line:733,column:2}},line:709}},branchMap:{"0":{loc:{start:{line:64,column:3},end:{line:67,column:4}},type:"if",locations:[{start:{line:64,column:3},end:{line:67,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:64},"1":{loc:{start:{line:70,column:3},end:{line:72,column:4}},type:"if",locations:[{start:{line:70,column:3},end:{line:72,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:70},"2":{loc:{start:{line:70,column:7},end:{line:70,column:103}},type:"binary-expr",locations:[{start:{line:70,column:7},end:{line:70,column:30}},{start:{line:70,column:34},end:{line:70,column:103}}],line:70},"3":{loc:{start:{line:75,column:3},end:{line:77,column:4}},type:"if",locations:[{start:{line:75,column:3},end:{line:77,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:75},"4":{loc:{start:{line:93,column:16},end:{line:93,column:62}},type:"binary-expr",locations:[{start:{line:93,column:16},end:{line:93,column:36}},{start:{line:93,column:40},end:{line:93,column:62}}],line:93},"5":{loc:{start:{line:100,column:3},end:{line:100,column:30}},type:"if",locations:[{start:{line:100,column:3},end:{line:100,column:30}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:100},"6":{loc:{start:{line:108,column:3},end:{line:108,column:40}},type:"if",locations:[{start:{line:108,column:3},end:{line:108,column:40}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:108},"7":{loc:{start:{line:112,column:3},end:{line:112,column:143}},type:"if",locations:[{start:{line:112,column:3},end:{line:112,column:143}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:112},"8":{loc:{start:{line:112,column:7},end:{line:112,column:118}},type:"binary-expr",locations:[{start:{line:112,column:7},end:{line:112,column:41}},{start:{line:112,column:45},end:{line:112,column:118}}],line:112},"9":{loc:{start:{line:114,column:3},end:{line:125,column:4}},type:"if",locations:[{start:{line:114,column:3},end:{line:125,column:4}},{start:{line:122,column:10},end:{line:125,column:4}}],line:114},"10":{loc:{start:{line:115,column:4},end:{line:121,column:5}},type:"if",locations:[{start:{line:115,column:4},end:{line:121,column:5}},{start:{line:117,column:11},end:{line:121,column:5}}],line:115},"11":{loc:{start:{line:122,column:10},end:{line:125,column:4}},type:"if",locations:[{start:{line:122,column:10},end:{line:125,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:122},"12":{loc:{start:{line:127,column:3},end:{line:129,column:4}},type:"if",locations:[{start:{line:127,column:3},end:{line:129,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:127},"13":{loc:{start:{line:127,column:7},end:{line:127,column:114}},type:"binary-expr",locations:[{start:{line:127,column:7},end:{line:127,column:30}},{start:{line:127,column:34},end:{line:127,column:114}}],line:127},"14":{loc:{start:{line:132,column:3},end:{line:134,column:4}},type:"if",locations:[{start:{line:132,column:3},end:{line:134,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:132},"15":{loc:{start:{line:136,column:3},end:{line:136,column:30}},type:"if",locations:[{start:{line:136,column:3},end:{line:136,column:30}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:136},"16":{loc:{start:{line:185,column:1},end:{line:187,column:2}},type:"if",locations:[{start:{line:185,column:1},end:{line:187,column:2}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:185},"17":{loc:{start:{line:189,column:1},end:{line:191,column:2}},type:"if",locations:[{start:{line:189,column:1},end:{line:191,column:2}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:189},"18":{loc:{start:{line:193,column:1},end:{line:195,column:2}},type:"if",locations:[{start:{line:193,column:1},end:{line:195,column:2}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:193},"19":{loc:{start:{line:237,column:4},end:{line:239,column:5}},type:"if",locations:[{start:{line:237,column:4},end:{line:239,column:5}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:237},"20":{loc:{start:{line:249,column:3},end:{line:252,column:4}},type:"if",locations:[{start:{line:249,column:3},end:{line:252,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:249},"21":{loc:{start:{line:255,column:3},end:{line:255,column:150}},type:"if",locations:[{start:{line:255,column:3},end:{line:255,column:150}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:255},"22":{loc:{start:{line:255,column:7},end:{line:255,column:125}},type:"binary-expr",locations:[{start:{line:255,column:8},end:{line:255,column:16}},{start:{line:255,column:20},end:{line:255,column:46}},{start:{line:255,column:51},end:{line:255,column:125}}],line:255},"23":{loc:{start:{line:257,column:3},end:{line:278,column:4}},type:"if",locations:[{start:{line:257,column:3},end:{line:278,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:257},"24":{loc:{start:{line:264,column:5},end:{line:270,column:6}},type:"if",locations:[{start:{line:264,column:5},end:{line:270,column:6}},{start:{line:266,column:12},end:{line:270,column:6}}],line:264},"25":{loc:{start:{line:280,column:3},end:{line:280,column:137}},type:"if",locations:[{start:{line:280,column:3},end:{line:280,column:137}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:280},"26":{loc:{start:{line:280,column:7},end:{line:280,column:112}},type:"binary-expr",locations:[{start:{line:280,column:8},end:{line:280,column:16}},{start:{line:280,column:20},end:{line:280,column:46}},{start:{line:280,column:51},end:{line:280,column:112}}],line:280},"27":{loc:{start:{line:282,column:3},end:{line:282,column:106}},type:"if",locations:[{start:{line:282,column:3},end:{line:282,column:106}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:282},"28":{loc:{start:{line:284,column:3},end:{line:288,column:4}},type:"if",locations:[{start:{line:284,column:3},end:{line:288,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:284},"29":{loc:{start:{line:284,column:7},end:{line:284,column:55}},type:"binary-expr",locations:[{start:{line:284,column:7},end:{line:284,column:23}},{start:{line:284,column:27},end:{line:284,column:55}}],line:284},"30":{loc:{start:{line:290,column:3},end:{line:294,column:4}},type:"if",locations:[{start:{line:290,column:3},end:{line:294,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:290},"31":{loc:{start:{line:290,column:7},end:{line:290,column:53}},type:"binary-expr",locations:[{start:{line:290,column:7},end:{line:290,column:21}},{start:{line:290,column:25},end:{line:290,column:53}}],line:290},"32":{loc:{start:{line:296,column:3},end:{line:300,column:4}},type:"if",locations:[{start:{line:296,column:3},end:{line:300,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:296},"33":{loc:{start:{line:296,column:7},end:{line:296,column:63}},type:"binary-expr",locations:[{start:{line:296,column:7},end:{line:296,column:24}},{start:{line:296,column:28},end:{line:296,column:63}}],line:296},"34":{loc:{start:{line:305,column:3},end:{line:305,column:23}},type:"if",locations:[{start:{line:305,column:3},end:{line:305,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:305},"35":{loc:{start:{line:314,column:3},end:{line:316,column:4}},type:"if",locations:[{start:{line:314,column:3},end:{line:316,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:314},"36":{loc:{start:{line:345,column:3},end:{line:345,column:144}},type:"if",locations:[{start:{line:345,column:3},end:{line:345,column:144}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:345},"37":{loc:{start:{line:345,column:7},end:{line:345,column:121}},type:"binary-expr",locations:[{start:{line:345,column:7},end:{line:345,column:43}},{start:{line:345,column:47},end:{line:345,column:121}}],line:345},"38":{loc:{start:{line:347,column:3},end:{line:350,column:4}},type:"if",locations:[{start:{line:347,column:3},end:{line:350,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:347},"39":{loc:{start:{line:347,column:7},end:{line:347,column:104}},type:"binary-expr",locations:[{start:{line:347,column:7},end:{line:347,column:32}},{start:{line:347,column:36},end:{line:347,column:104}}],line:347},"40":{loc:{start:{line:353,column:3},end:{line:355,column:4}},type:"if",locations:[{start:{line:353,column:3},end:{line:355,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:353},"41":{loc:{start:{line:363,column:16},end:{line:363,column:76}},type:"binary-expr",locations:[{start:{line:363,column:16},end:{line:363,column:50}},{start:{line:363,column:54},end:{line:363,column:76}}],line:363},"42":{loc:{start:{line:367,column:3},end:{line:367,column:30}},type:"if",locations:[{start:{line:367,column:3},end:{line:367,column:30}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:367},"43":{loc:{start:{line:371,column:3},end:{line:371,column:44}},type:"if",locations:[{start:{line:371,column:3},end:{line:371,column:44}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:371},"44":{loc:{start:{line:375,column:3},end:{line:386,column:4}},type:"if",locations:[{start:{line:375,column:3},end:{line:386,column:4}},{start:{line:383,column:10},end:{line:386,column:4}}],line:375},"45":{loc:{start:{line:376,column:4},end:{line:382,column:5}},type:"if",locations:[{start:{line:376,column:4},end:{line:382,column:5}},{start:{line:378,column:11},end:{line:382,column:5}}],line:376},"46":{loc:{start:{line:383,column:10},end:{line:386,column:4}},type:"if",locations:[{start:{line:383,column:10},end:{line:386,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:383},"47":{loc:{start:{line:389,column:3},end:{line:391,column:4}},type:"if",locations:[{start:{line:389,column:3},end:{line:391,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:389},"48":{loc:{start:{line:393,column:3},end:{line:393,column:39}},type:"if",locations:[{start:{line:393,column:3},end:{line:393,column:39}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:393},"49":{loc:{start:{line:411,column:16},end:{line:411,column:60}},type:"binary-expr",locations:[{start:{line:411,column:16},end:{line:411,column:36}},{start:{line:411,column:40},end:{line:411,column:60}}],line:411},"50":{loc:{start:{line:423,column:3},end:{line:423,column:30}},type:"if",locations:[{start:{line:423,column:3},end:{line:423,column:30}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:423},"51":{loc:{start:{line:432,column:4},end:{line:434,column:5}},type:"if",locations:[{start:{line:432,column:4},end:{line:434,column:5}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:432},"52":{loc:{start:{line:438,column:3},end:{line:438,column:40}},type:"if",locations:[{start:{line:438,column:3},end:{line:438,column:40}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:438},"53":{loc:{start:{line:442,column:3},end:{line:463,column:4}},type:"if",locations:[{start:{line:442,column:3},end:{line:463,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:442},"54":{loc:{start:{line:449,column:5},end:{line:455,column:6}},type:"if",locations:[{start:{line:449,column:5},end:{line:455,column:6}},{start:{line:451,column:12},end:{line:455,column:6}}],line:449},"55":{loc:{start:{line:465,column:3},end:{line:467,column:4}},type:"if",locations:[{start:{line:465,column:3},end:{line:467,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:465},"56":{loc:{start:{line:465,column:7},end:{line:465,column:120}},type:"binary-expr",locations:[{start:{line:465,column:7},end:{line:465,column:15}},{start:{line:465,column:19},end:{line:465,column:44}},{start:{line:465,column:48},end:{line:465,column:120}}],line:465},"57":{loc:{start:{line:469,column:3},end:{line:490,column:4}},type:"if",locations:[{start:{line:469,column:3},end:{line:490,column:4}},{start:{line:482,column:10},end:{line:490,column:4}}],line:469},"58":{loc:{start:{line:470,column:4},end:{line:481,column:5}},type:"if",locations:[{start:{line:470,column:4},end:{line:481,column:5}},{start:{line:476,column:11},end:{line:481,column:5}}],line:470},"59":{loc:{start:{line:473,column:5},end:{line:475,column:6}},type:"if",locations:[{start:{line:473,column:5},end:{line:475,column:6}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:473},"60":{loc:{start:{line:482,column:10},end:{line:490,column:4}},type:"if",locations:[{start:{line:482,column:10},end:{line:490,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:482},"61":{loc:{start:{line:493,column:3},end:{line:493,column:23}},type:"if",locations:[{start:{line:493,column:3},end:{line:493,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:493},"62":{loc:{start:{line:502,column:3},end:{line:504,column:4}},type:"if",locations:[{start:{line:502,column:3},end:{line:504,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:502},"63":{loc:{start:{line:507,column:3},end:{line:507,column:30}},type:"if",locations:[{start:{line:507,column:3},end:{line:507,column:30}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:507},"64":{loc:{start:{line:512,column:17},end:{line:512,column:25}},type:"default-arg",locations:[{start:{line:512,column:23},end:{line:512,column:25}}],line:512},"65":{loc:{start:{line:513,column:1},end:{line:519,column:2}},type:"if",locations:[{start:{line:513,column:1},end:{line:519,column:2}},{start:{line:517,column:8},end:{line:519,column:2}}],line:513},"66":{loc:{start:{line:523,column:1},end:{line:529,column:2}},type:"if",locations:[{start:{line:523,column:1},end:{line:529,column:2}},{start:{line:525,column:8},end:{line:529,column:2}}],line:523},"67":{loc:{start:{line:525,column:8},end:{line:529,column:2}},type:"if",locations:[{start:{line:525,column:8},end:{line:529,column:2}},{start:{line:527,column:8},end:{line:529,column:2}}],line:525},"68":{loc:{start:{line:525,column:12},end:{line:525,column:93}},type:"binary-expr",locations:[{start:{line:525,column:12},end:{line:525,column:35}},{start:{line:525,column:39},end:{line:525,column:63}},{start:{line:525,column:67},end:{line:525,column:93}}],line:525},"69":{loc:{start:{line:544,column:17},end:{line:544,column:25}},type:"default-arg",locations:[{start:{line:544,column:23},end:{line:544,column:25}}],line:544},"70":{loc:{start:{line:545,column:2},end:{line:551,column:3}},type:"if",locations:[{start:{line:545,column:2},end:{line:551,column:3}},{start:{line:549,column:9},end:{line:551,column:3}}],line:545},"71":{loc:{start:{line:555,column:2},end:{line:563,column:3}},type:"if",locations:[{start:{line:555,column:2},end:{line:563,column:3}},{start:{line:561,column:9},end:{line:563,column:3}}],line:555},"72":{loc:{start:{line:556,column:3},end:{line:560,column:4}},type:"if",locations:[{start:{line:556,column:3},end:{line:560,column:4}},{start:{line:558,column:10},end:{line:560,column:4}}],line:556},"73":{loc:{start:{line:573,column:7},end:{line:573,column:27}},type:"default-arg",locations:[{start:{line:573,column:22},end:{line:573,column:27}}],line:573},"74":{loc:{start:{line:574,column:7},end:{line:574,column:17}},type:"default-arg",locations:[{start:{line:574,column:15},end:{line:574,column:17}}],line:574},"75":{loc:{start:{line:585,column:7},end:{line:585,column:20}},type:"default-arg",locations:[{start:{line:585,column:18},end:{line:585,column:20}}],line:585},"76":{loc:{start:{line:586,column:7},end:{line:586,column:25}},type:"default-arg",locations:[{start:{line:586,column:19},end:{line:586,column:25}}],line:586},"77":{loc:{start:{line:587,column:7},end:{line:587,column:23}},type:"default-arg",locations:[{start:{line:587,column:18},end:{line:587,column:23}}],line:587},"78":{loc:{start:{line:588,column:7},end:{line:588,column:19}},type:"default-arg",locations:[{start:{line:588,column:15},end:{line:588,column:19}}],line:588},"79":{loc:{start:{line:589,column:7},end:{line:589,column:24}},type:"default-arg",locations:[{start:{line:589,column:19},end:{line:589,column:24}}],line:589},"80":{loc:{start:{line:590,column:7},end:{line:590,column:21}},type:"default-arg",locations:[{start:{line:590,column:16},end:{line:590,column:21}}],line:590},"81":{loc:{start:{line:591,column:7},end:{line:591,column:25}},type:"default-arg",locations:[{start:{line:591,column:20},end:{line:591,column:25}}],line:591},"82":{loc:{start:{line:592,column:7},end:{line:592,column:29}},type:"default-arg",locations:[{start:{line:592,column:24},end:{line:592,column:29}}],line:592},"83":{loc:{start:{line:595,column:2},end:{line:595,column:25}},type:"binary-expr",locations:[{start:{line:595,column:2},end:{line:595,column:3}},{start:{line:595,column:7},end:{line:595,column:25}}],line:595},"84":{loc:{start:{line:599,column:2},end:{line:606,column:3}},type:"if",locations:[{start:{line:599,column:2},end:{line:606,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:599},"85":{loc:{start:{line:612,column:2},end:{line:612,column:25}},type:"binary-expr",locations:[{start:{line:612,column:2},end:{line:612,column:3}},{start:{line:612,column:7},end:{line:612,column:25}}],line:612},"86":{loc:{start:{line:615,column:13},end:{line:617,column:8}},type:"cond-expr",locations:[{start:{line:616,column:4},end:{line:616,column:37}},{start:{line:617,column:4},end:{line:617,column:8}}],line:615},"87":{loc:{start:{line:619,column:2},end:{line:625,column:3}},type:"if",locations:[{start:{line:619,column:2},end:{line:625,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:619},"88":{loc:{start:{line:619,column:6},end:{line:619,column:41}},type:"binary-expr",locations:[{start:{line:619,column:6},end:{line:619,column:10}},{start:{line:619,column:14},end:{line:619,column:41}}],line:619},"89":{loc:{start:{line:646,column:2},end:{line:646,column:87}},type:"if",locations:[{start:{line:646,column:2},end:{line:646,column:87}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:646},"90":{loc:{start:{line:647,column:2},end:{line:647,column:66}},type:"if",locations:[{start:{line:647,column:2},end:{line:647,column:66}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:647},"91":{loc:{start:{line:648,column:2},end:{line:648,column:74}},type:"if",locations:[{start:{line:648,column:2},end:{line:648,column:74}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:648},"92":{loc:{start:{line:649,column:2},end:{line:649,column:77}},type:"if",locations:[{start:{line:649,column:2},end:{line:649,column:77}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:649},"93":{loc:{start:{line:650,column:2},end:{line:650,column:74}},type:"if",locations:[{start:{line:650,column:2},end:{line:650,column:74}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:650},"94":{loc:{start:{line:651,column:2},end:{line:651,column:66}},type:"if",locations:[{start:{line:651,column:2},end:{line:651,column:66}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:651},"95":{loc:{start:{line:652,column:2},end:{line:652,column:78}},type:"if",locations:[{start:{line:652,column:2},end:{line:652,column:78}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:652},"96":{loc:{start:{line:653,column:2},end:{line:653,column:69}},type:"if",locations:[{start:{line:653,column:2},end:{line:653,column:69}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:653},"97":{loc:{start:{line:654,column:2},end:{line:654,column:81}},type:"if",locations:[{start:{line:654,column:2},end:{line:654,column:81}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:654},"98":{loc:{start:{line:655,column:2},end:{line:655,column:93}},type:"if",locations:[{start:{line:655,column:2},end:{line:655,column:93}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:655},"99":{loc:{start:{line:659,column:2},end:{line:661,column:3}},type:"if",locations:[{start:{line:659,column:2},end:{line:661,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:659},"100":{loc:{start:{line:660,column:44},end:{line:660,column:64}},type:"cond-expr",locations:[{start:{line:660,column:53},end:{line:660,column:59}},{start:{line:660,column:62},end:{line:660,column:64}}],line:660},"101":{loc:{start:{line:660,column:66},end:{line:660,column:94}},type:"cond-expr",locations:[{start:{line:660,column:79},end:{line:660,column:89}},{start:{line:660,column:92},end:{line:660,column:94}}],line:660},"102":{loc:{start:{line:663,column:2},end:{line:665,column:3}},type:"if",locations:[{start:{line:663,column:2},end:{line:665,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:663},"103":{loc:{start:{line:664,column:35},end:{line:664,column:72}},type:"binary-expr",locations:[{start:{line:664,column:35},end:{line:664,column:56}},{start:{line:664,column:60},end:{line:664,column:72}}],line:664},"104":{loc:{start:{line:664,column:37},end:{line:664,column:55}},type:"binary-expr",locations:[{start:{line:664,column:37},end:{line:664,column:46}},{start:{line:664,column:50},end:{line:664,column:55}}],line:664},"105":{loc:{start:{line:667,column:2},end:{line:669,column:3}},type:"if",locations:[{start:{line:667,column:2},end:{line:669,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:667},"106":{loc:{start:{line:668,column:16},end:{line:668,column:49}},type:"binary-expr",locations:[{start:{line:668,column:16},end:{line:668,column:31}},{start:{line:668,column:35},end:{line:668,column:49}}],line:668},"107":{loc:{start:{line:671,column:2},end:{line:675,column:3}},type:"if",locations:[{start:{line:671,column:2},end:{line:675,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:671},"108":{loc:{start:{line:672,column:42},end:{line:674,column:23}},type:"cond-expr",locations:[{start:{line:673,column:5},end:{line:673,column:22}},{start:{line:674,column:5},end:{line:674,column:23}}],line:672},"109":{loc:{start:{line:672,column:42},end:{line:672,column:73}},type:"binary-expr",locations:[{start:{line:672,column:42},end:{line:672,column:56}},{start:{line:672,column:60},end:{line:672,column:73}}],line:672},"110":{loc:{start:{line:677,column:2},end:{line:679,column:3}},type:"if",locations:[{start:{line:677,column:2},end:{line:679,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:677},"111":{loc:{start:{line:678,column:32},end:{line:678,column:57}},type:"cond-expr",locations:[{start:{line:678,column:41},end:{line:678,column:52}},{start:{line:678,column:55},end:{line:678,column:57}}],line:678}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0,"50":0,"51":0,"52":0,"53":0,"54":0,"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"61":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":0,"68":0,"69":0,"70":0,"71":0,"72":0,"73":0,"74":0,"75":0,"76":0,"77":0,"78":0,"79":0,"80":0,"81":0,"82":0,"83":0,"84":0,"85":0,"86":0,"87":0,"88":0,"89":0,"90":0,"91":0,"92":0,"93":0,"94":0,"95":0,"96":0,"97":0,"98":0,"99":0,"100":0,"101":0,"102":0,"103":0,"104":0,"105":0,"106":0,"107":0,"108":0,"109":0,"110":0,"111":0,"112":0,"113":0,"114":0,"115":0,"116":0,"117":0,"118":0,"119":0,"120":0,"121":0,"122":0,"123":0,"124":0,"125":0,"126":0,"127":0,"128":0,"129":0,"130":0,"131":0,"132":0,"133":0,"134":0,"135":0,"136":0,"137":0,"138":0,"139":0,"140":0,"141":0,"142":0,"143":0,"144":0,"145":0,"146":0,"147":0,"148":0,"149":0,"150":0,"151":0,"152":0,"153":0,"154":0,"155":0,"156":0,"157":0,"158":0,"159":0,"160":0,"161":0,"162":0,"163":0,"164":0,"165":0,"166":0,"167":0,"168":0,"169":0,"170":0,"171":0,"172":0,"173":0,"174":0,"175":0,"176":0,"177":0,"178":0,"179":0,"180":0,"181":0,"182":0,"183":0,"184":0,"185":0,"186":0,"187":0,"188":0,"189":0,"190":0,"191":0,"192":0,"193":0,"194":0,"195":0,"196":0,"197":0,"198":0,"199":0,"200":0,"201":0,"202":0,"203":0,"204":0,"205":0,"206":0,"207":0,"208":0,"209":0,"210":0,"211":0,"212":0,"213":0,"214":0,"215":0,"216":0,"217":0,"218":0,"219":0,"220":0,"221":0,"222":0,"223":0,"224":0,"225":0,"226":0,"227":0,"228":0,"229":0,"230":0,"231":0,"232":0,"233":0,"234":0,"235":0,"236":0,"237":0,"238":0,"239":0,"240":0,"241":0,"242":0,"243":0,"244":0,"245":0,"246":0,"247":0,"248":0,"249":0,"250":0,"251":0,"252":0,"253":0,"254":0,"255":0,"256":0,"257":0,"258":0,"259":0,"260":0,"261":0,"262":0,"263":0,"264":0,"265":0,"266":0,"267":0,"268":0,"269":0,"270":0,"271":0,"272":0,"273":0,"274":0,"275":0,"276":0,"277":0,"278":0,"279":0,"280":0,"281":0,"282":0,"283":0,"284":0,"285":0,"286":0,"287":0,"288":0,"289":0,"290":0,"291":0,"292":0,"293":0,"294":0,"295":0,"296":0,"297":0,"298":0,"299":0,"300":0,"301":0,"302":0,"303":0,"304":0,"305":0,"306":0,"307":0,"308":0,"309":0,"310":0,"311":0,"312":0,"313":0,"314":0,"315":0,"316":0,"317":0,"318":0,"319":0,"320":0,"321":0,"322":0,"323":0,"324":0,"325":0,"326":0,"327":0,"328":0,"329":0,"330":0,"331":0,"332":0,"333":0,"334":0,"335":0,"336":0,"337":0,"338":0,"339":0,"340":0,"341":0,"342":0,"343":0,"344":0,"345":0,"346":0,"347":0,"348":0,"349":0,"350":0,"351":0,"352":0,"353":0,"354":0,"355":0,"356":0,"357":0,"358":0,"359":0,"360":0,"361":0,"362":0,"363":0,"364":0,"365":0,"366":0,"367":0,"368":0,"369":0,"370":0,"371":0,"372":0,"373":0,"374":0,"375":0,"376":0,"377":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0,"50":0,"51":0,"52":0,"53":0,"54":0,"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"61":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":0},b:{"0":[0,0],"1":[0,0],"2":[0,0],"3":[0,0],"4":[0,0],"5":[0,0],"6":[0,0],"7":[0,0],"8":[0,0],"9":[0,0],"10":[0,0],"11":[0,0],"12":[0,0],"13":[0,0],"14":[0,0],"15":[0,0],"16":[0,0],"17":[0,0],"18":[0,0],"19":[0,0],"20":[0,0],"21":[0,0],"22":[0,0,0],"23":[0,0],"24":[0,0],"25":[0,0],"26":[0,0,0],"27":[0,0],"28":[0,0],"29":[0,0],"30":[0,0],"31":[0,0],"32":[0,0],"33":[0,0],"34":[0,0],"35":[0,0],"36":[0,0],"37":[0,0],"38":[0,0],"39":[0,0],"40":[0,0],"41":[0,0],"42":[0,0],"43":[0,0],"44":[0,0],"45":[0,0],"46":[0,0],"47":[0,0],"48":[0,0],"49":[0,0],"50":[0,0],"51":[0,0],"52":[0,0],"53":[0,0],"54":[0,0],"55":[0,0],"56":[0,0,0],"57":[0,0],"58":[0,0],"59":[0,0],"60":[0,0],"61":[0,0],"62":[0,0],"63":[0,0],"64":[0],"65":[0,0],"66":[0,0],"67":[0,0],"68":[0,0,0],"69":[0],"70":[0,0],"71":[0,0],"72":[0,0],"73":[0],"74":[0],"75":[0],"76":[0],"77":[0],"78":[0],"79":[0],"80":[0],"81":[0],"82":[0],"83":[0,0],"84":[0,0],"85":[0,0],"86":[0,0],"87":[0,0],"88":[0,0],"89":[0,0],"90":[0,0],"91":[0,0],"92":[0,0],"93":[0,0],"94":[0,0],"95":[0,0],"96":[0,0],"97":[0,0],"98":[0,0],"99":[0,0],"100":[0,0],"101":[0,0],"102":[0,0],"103":[0,0],"104":[0,0],"105":[0,0],"106":[0,0],"107":[0,0],"108":[0,0],"109":[0,0],"110":[0,0],"111":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/common/ui.role.svelte"],sourcesContent:["<script>\n    import { LOCALE, Elements } from \"not-bulma\";\n\n    const { UIErrorsList } = Elements.Various;\n\n    const { UICommon } = Elements;\n\n    import { createEventDispatcher, onMount } from \"svelte\";\n\n    let dispatch = createEventDispatcher();\n\n    function enrich(val = []) {\n        if (Array.isArray(val)) {\n            return val\n                .map((role) => {\n                    return getRoleTagObject(role);\n                })\n                .filter((itm) => typeof itm !== \"undefined\");\n        } else {\n            return [];\n        }\n    }\n\n    function getRoleTagObject(itm) {\n        if (typeof itm === \"string\") {\n            if (Array.isArray(variants)) {\n                return variants.find((variant) => variant.id === itm);\n            } else {\n                return undefined;\n            }\n        } else {\n            return itm;\n        }\n    }\n\n    function deplete(val = []) {\n        if (Array.isArray(val)) {\n            return val\n                .map((role) => {\n                    return getRoleString(role);\n                })\n                .filter((itm) => typeof itm !== \"undefined\");\n        } else {\n            return [];\n        }\n    }\n\n    function getRoleString(itm) {\n        if (typeof itm === \"string\") {\n            return itm;\n        } else if (\n            typeof itm === \"object\" &&\n            Object.hasOwn(itm, \"id\") &&\n            typeof itm.id === \"string\"\n        ) {\n            return itm.id;\n        } else {\n            return undefined;\n        }\n    }\n\n    onMount(() => {\n        _value = enrich(value);\n        _value = _value;\n        value = deplete(value);\n        value = value;\n    });\n\n    export let inputStarted = false;\n    export let value = []; //exposed true form\n    /**\n  item = {\n    id,        //unique\n    title,     //some text\n    type       //for coloring items, usual html template names danger, success, etc\n  }\n  **/\n    let _value = []; //local copy enriched with data for gui\n    export let variants = [];\n    //export let placeholder = 'placeholder';\n    export let fieldname = \"role\";\n    //export let required = true;\n    export let readonly = false;\n    export let valid = true;\n    export let validated = false;\n    export let errors = false;\n    export let formErrors = false;\n    export let formLevelError = false;\n\n    $: allErrors = [].concat(\n        errors ? errors : [],\n        formErrors ? formErrors : []\n    );\n    $: showErrors = !(validated && valid) && inputStarted;\n    $: invalid = valid === false || formLevelError;\n    $: validationClasses =\n        valid === true || !inputStarted\n            ? UICommon.CLASS_OK\n            : UICommon.CLASS_ERR;\n\n    function remove(e) {\n        e && e.preventDefault();\n        let id = e.currentTarget.dataset.id;\n        let item = _value.find((el) => el.id === id);\n        if (item) {\n            _value.splice(_value.indexOf(item), 1);\n            _value = _value;\n            value = deplete(_value);\n            value = value;\n            inputStarted = true;\n            dispatch(\"change\", {\n                field: \"role\",\n                value: value,\n            });\n        }\n        return false;\n    }\n\n    function add(e) {\n        e && e.preventDefault();\n        let id = e.currentTarget.parentNode.querySelector(\"select\").value;\n        let item = Array.isArray(variants)\n            ? variants.find((el) => el.id === id)\n            : null;\n        if (item && _value.indexOf(item) === -1) {\n            _value.push(item);\n            _value = _value;\n            value = deplete(_value);\n            value = value;\n            dispatch(\"change\", {\n                field: \"role\",\n                value: value,\n            });\n        }\n        return false;\n    }\n\n    $: classes = errors ? \"is-danger\" : \"\";\n</script>\n\n<div class=\"columns\">\n    <div class=\"column {classes}\">\n        {#each _value as item}\n            <span class=\"mx-1 tag is-{item.type}\"\n                >{$LOCALE[item.title]}\n                {#if !readonly}\n                    <button\n                        data-id={item.id}\n                        class=\"delete is-small\"\n                        on:click={remove}\n                    />\n                {/if}\n            </span>\n        {/each}\n    </div>\n    {#if !readonly}\n        <div class=\"column\">\n            <div class=\"control\">\n                <div class=\"select is-small\">\n                    <select>\n                        <option value=\"-1\" selected\n                            >{$LOCALE[\"\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0437 \u0441\u043F\u0438\u0441\u043A\u0430...\"]}</option\n                        >\n                        {#each variants as variant}\n                            {#if !variant.notSelectable}\n                                <option value={variant.id}\n                                    >{$LOCALE[variant.title]}</option\n                                >\n                            {/if}\n                        {/each}\n                    </select>\n                </div>\n                <button class=\"button is-primary is-small\" on:click={add}\n                    >{$LOCALE[\"\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C\"]}</button\n                >\n            </div>\n            <UIErrorsList\n                bind:errors={allErrors}\n                bind:show={showErrors}\n                bind:classes={validationClasses}\n                id=\"input-field-helper-{fieldname}\"\n            />\n        </div>\n    {/if}\n</div>\n"],names:[],mappings:";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SACa,MAAM,EAAE,QAAQ,QAAQ,WAAW;SAMnC,qBAAqB,EAAE,OAAO,QAAQ,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;2DA4I1B,GAAI,KAAC,EAAE;;;;GADpB,MAIE;;;iDADY,GAAM;;;;;4FAFP,GAAI,KAAC,EAAE;;;;;;;;;;;;;;;;;;4BAHtB,GAAO,aAAC,GAAI,KAAC,KAAK;;;;;8BACd,GAAQ;;;;;;;;;oEAFQ,GAAI,KAAC,IAAI;;;GAAnC,MASO;;;;;;;kFARD,GAAO,aAAC,GAAI,KAAC,KAAK;;qBACd,GAAQ;;;;;;;;;;;;;qGAFQ,GAAI,KAAC,IAAI;;;;;;;;;;;;;;;;;;;;;4BAkBjB,GAAO,IAAC,uBAAuB;;;;4BAYvC,GAAO,IAAC,UAAU;;;;;;;;;;iDAVT,GAAQ;;;gCAAb,MAAI;;;;;;;;;;;;;;;;;4CAiBU,GAAS;;;mBAHpB,GAAS;4CAAT,GAAS;;;oBACX,GAAU;2CAAV,GAAU;;;2BACP,GAAiB;qDAAjB,GAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAvBvC,MA0BM;GAzBF,MAkBM;GAjBF,MAaM;GAZF,MAWS;GAVL,MAEC;;;;;;;;;;GAUT,MAEC;;;;;;;8CAFoD,GAAG;;;;;wFAX1C,GAAO,IAAC,uBAAuB;;;gDAE9B,GAAQ;;;+BAAb,MAAI;;;;;;;;;;;;;;;;oCAAJ,MAAI;;;wFAUR,GAAO,IAAC,UAAU;;mGAOA,GAAS;;;;gDAHpB,GAAS;;;;;;+CACX,GAAU;;;;;;yDACP,GAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BAbT,GAAO,gBAAC,GAAO,KAAC,KAAK;;;;;;;;qDADZ,GAAO,KAAC,EAAE;;;;GAAzB,MAEC;;;;kFADK,GAAO,gBAAC,GAAO,KAAC,KAAK;;6FADZ,GAAO,KAAC,EAAE;;;;;;;;;;;;;;;;6BADvB,GAAO,KAAC,aAAa;;;;;;;;;;;;oBAArB,GAAO,KAAC,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAtBxC,GAAM;;;kCAAX,MAAI;;;;8BAaJ,GAAQ;;;;;;;;;;;;;kEAdM,GAAO;;;;GAD/B,MA4CM;GA3CF,MAaM;;;;;;;;;;;;;;gDAZK,GAAM;;;iCAAX,MAAI;;;;;;;;;;;;;;;;sCAAJ,MAAI;;;iHADU,GAAO;;;;qBAcrB,GAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAxHL,OAAO,CAAC,GAAG;KACZ,KAAK,CAAC,OAAO,CAAC,GAAG;SACV,GAAG,CACL,GAAG,CAAE,IAAI;UACC,aAAa,CAAC,IAAI;KAE5B,MAAM,CAAE,GAAG,WAAY,GAAG,KAAK,WAAW;;;;;;SAM9C,aAAa,CAAC,GAAG;YACX,GAAG,KAAK,QAAQ;SAChB,GAAG;mBAEH,GAAG,KAAK,QAAQ,IACvB,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,YAChB,GAAG,CAAC,EAAE,KAAK,QAAQ;SAEnB,GAAG,CAAC,EAAE;;SAEN,SAAS;;;;;;;;;;;;SAtDhB,YAAY,KAAK,QAAQ,CAAC,OAAO;SAEjC,QAAQ,KAAK,QAAQ;KAIzB,QAAQ,GAAG,qBAAqB;;UAE3B,MAAM,CAAC,GAAG;MACX,KAAK,CAAC,OAAO,CAAC,GAAG;UACV,GAAG,CACL,GAAG,CAAE,IAAI;WACC,gBAAgB,CAAC,IAAI;MAE/B,MAAM,CAAE,GAAG,WAAY,GAAG,KAAK,WAAW;;;;;;UAM9C,gBAAgB,CAAC,GAAG;aACd,GAAG,KAAK,QAAQ;OACnB,KAAK,CAAC,OAAO,CAAC,QAAQ;WACf,QAAQ,CAAC,IAAI,CAAE,OAAO,IAAK,OAAO,CAAC,EAAE,KAAK,GAAG;;WAE7C,SAAS;;;UAGb,GAAG;;;;CA8BlB,OAAO;kBACH,MAAM,GAAG,MAAM,CAAC,KAAK;;mBAErB,KAAK,GAAG,OAAO,CAAC,KAAK;;;;OAId,YAAY,GAAG,KAAK;OACpB,KAAK;;;;;;;;;KAQZ,MAAM;;OACC,QAAQ;OAER,SAAS,GAAG,MAAM;OAElB,QAAQ,GAAG,KAAK;OAChB,KAAK,GAAG,IAAI;OACZ,SAAS,GAAG,KAAK;OACjB,MAAM,GAAG,KAAK;OACd,UAAU,GAAG,KAAK;OAClB,cAAc,GAAG,KAAK;;UAaxB,MAAM,CAAC,CAAC;EACb,CAAC,IAAI,CAAC,CAAC,cAAc;MACjB,EAAE,GAAG,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE;MAC/B,IAAI,GAAG,MAAM,CAAC,IAAI,CAAE,EAAE,IAAK,EAAE,CAAC,EAAE,KAAK,EAAE;;MACvC,IAAI;GACJ,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC;;oBAErC,KAAK,GAAG,OAAO,CAAC,MAAM;;oBAEtB,YAAY,GAAG,IAAI;GACnB,QAAQ,CAAC,QAAQ,IACb,KAAK,EAAE,MAAM,EACN,KAAK;;;SAGb,KAAK;;;UAGP,GAAG,CAAC,CAAC;EACV,CAAC,IAAI,CAAC,CAAC,cAAc;MACjB,EAAE,GAAG,CAAC,CAAC,aAAa,CAAC,UAAU,CAAC,aAAa,CAAC,QAAQ,EAAE,KAAK;;MAC7D,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,QAAQ;IAC3B,QAAQ,CAAC,IAAI,CAAE,EAAE,IAAK,EAAE,CAAC,EAAE,KAAK,EAAE;IAClC,IAAI;;MACN,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC;GACnC,MAAM,CAAC,IAAI,CAAC,IAAI;;oBAEhB,KAAK,GAAG,OAAO,CAAC,MAAM;;GAEtB,QAAQ,CAAC,QAAQ,IACb,KAAK,EAAE,MAAM,EACN,KAAK;;;SAGb,KAAK;;;;EA2CS,SAAS;;;;;EACX,UAAU;;;;;EACP,iBAAiB;;;;;;;;;;;;;;;;;;;GA1F3C,CAAC,kBAAE,SAAS,MAAM,MAAM,CACpB,MAAM,GAAG,MAAM,OACf,UAAU,GAAG,UAAU;;;;GAE3B,CAAC,kBAAE,UAAU,KAAK,SAAS,IAAI,KAAK,KAAK,YAAY;;;;GACrD,CAAC,EAAE,OAAO,GAAG,KAAK,KAAK,KAAK,IAAI,cAAc;;;;GAC9C,CAAC,kBAAE,iBAAiB,GAChB,KAAK,KAAK,IAAI,KAAK,YAAY;KACzB,QAAQ,CAAC,QAAQ;KACjB,QAAQ,CAAC,SAAS;;;;GAuC5B,CAAC,kBAAE,OAAO,GAAG,MAAM,GAAG,WAAW,GAAG,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"ef1b01a61bb3bc68ff2eeb097a23902f04c17b41"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_2ayk1lyqd0=function(){return actualCoverage;};}return actualCoverage;}cov_2ayk1lyqd0();function get_each_context(ctx,list,i){cov_2ayk1lyqd0().f[0]++;const child_ctx=(cov_2ayk1lyqd0().s[0]++,ctx.slice());cov_2ayk1lyqd0().s[1]++;child_ctx[27]=list[i];cov_2ayk1lyqd0().s[2]++;return child_ctx;}function get_each_context_1(ctx,list,i){cov_2ayk1lyqd0().f[1]++;const child_ctx=(cov_2ayk1lyqd0().s[3]++,ctx.slice());cov_2ayk1lyqd0().s[4]++;child_ctx[30]=list[i];cov_2ayk1lyqd0().s[5]++;return child_ctx;}// (146:16) {#if !readonly}
	function create_if_block_2$1(ctx){cov_2ayk1lyqd0().f[2]++;let button;let button_data_id_value;let mounted;let dispose;cov_2ayk1lyqd0().s[6]++;return {c(){cov_2ayk1lyqd0().f[3]++;cov_2ayk1lyqd0().s[7]++;button=element("button");cov_2ayk1lyqd0().s[8]++;attr(button,"data-id",button_data_id_value=/*item*/ctx[30].id);cov_2ayk1lyqd0().s[9]++;attr(button,"class","delete is-small");},m(target,anchor){cov_2ayk1lyqd0().f[4]++;cov_2ayk1lyqd0().s[10]++;insert(target,button,anchor);cov_2ayk1lyqd0().s[11]++;if(!mounted){cov_2ayk1lyqd0().b[0][0]++;cov_2ayk1lyqd0().s[12]++;dispose=listen(button,"click",/*remove*/ctx[10]);cov_2ayk1lyqd0().s[13]++;mounted=true;}else {cov_2ayk1lyqd0().b[0][1]++;}},p(ctx,dirty){cov_2ayk1lyqd0().f[5]++;cov_2ayk1lyqd0().s[14]++;if((cov_2ayk1lyqd0().b[2][0]++,dirty[0]&/*_value*/8)&&(cov_2ayk1lyqd0().b[2][1]++,button_data_id_value!==(button_data_id_value=/*item*/ctx[30].id))){cov_2ayk1lyqd0().b[1][0]++;cov_2ayk1lyqd0().s[15]++;attr(button,"data-id",button_data_id_value);}else {cov_2ayk1lyqd0().b[1][1]++;}},d(detaching){cov_2ayk1lyqd0().f[6]++;cov_2ayk1lyqd0().s[16]++;if(detaching){cov_2ayk1lyqd0().b[3][0]++;cov_2ayk1lyqd0().s[17]++;detach(button);}else {cov_2ayk1lyqd0().b[3][1]++;}cov_2ayk1lyqd0().s[18]++;mounted=false;cov_2ayk1lyqd0().s[19]++;dispose();}};}// (143:8) {#each _value as item}
	function create_each_block_1(ctx){cov_2ayk1lyqd0().f[7]++;let span;let t0_value=(/*$LOCALE*/cov_2ayk1lyqd0().s[20]++,ctx[8][/*item*/ctx[30].title]+"");let t0;let t1;let t2;let span_class_value;let if_block=(cov_2ayk1lyqd0().s[21]++,(cov_2ayk1lyqd0().b[4][0]++,!/*readonly*/ctx[2])&&(cov_2ayk1lyqd0().b[4][1]++,create_if_block_2$1(ctx)));cov_2ayk1lyqd0().s[22]++;return {c(){cov_2ayk1lyqd0().f[8]++;cov_2ayk1lyqd0().s[23]++;span=element("span");cov_2ayk1lyqd0().s[24]++;t0=text(t0_value);cov_2ayk1lyqd0().s[25]++;t1=space();cov_2ayk1lyqd0().s[26]++;if(if_block){cov_2ayk1lyqd0().b[5][0]++;cov_2ayk1lyqd0().s[27]++;if_block.c();}else {cov_2ayk1lyqd0().b[5][1]++;}cov_2ayk1lyqd0().s[28]++;t2=space();cov_2ayk1lyqd0().s[29]++;attr(span,"class",span_class_value="mx-1 tag is-"+/*item*/ctx[30].type);},m(target,anchor){cov_2ayk1lyqd0().f[9]++;cov_2ayk1lyqd0().s[30]++;insert(target,span,anchor);cov_2ayk1lyqd0().s[31]++;append(span,t0);cov_2ayk1lyqd0().s[32]++;append(span,t1);cov_2ayk1lyqd0().s[33]++;if(if_block){cov_2ayk1lyqd0().b[6][0]++;cov_2ayk1lyqd0().s[34]++;if_block.m(span,null);}else {cov_2ayk1lyqd0().b[6][1]++;}cov_2ayk1lyqd0().s[35]++;append(span,t2);},p(ctx,dirty){cov_2ayk1lyqd0().f[10]++;cov_2ayk1lyqd0().s[36]++;if((cov_2ayk1lyqd0().b[8][0]++,dirty[0]&/*$LOCALE, _value*/264)&&(cov_2ayk1lyqd0().b[8][1]++,t0_value!==(t0_value=/*$LOCALE*/ctx[8][/*item*/ctx[30].title]+""))){cov_2ayk1lyqd0().b[7][0]++;cov_2ayk1lyqd0().s[37]++;set_data(t0,t0_value);}else {cov_2ayk1lyqd0().b[7][1]++;}cov_2ayk1lyqd0().s[38]++;if(!/*readonly*/ctx[2]){cov_2ayk1lyqd0().b[9][0]++;cov_2ayk1lyqd0().s[39]++;if(if_block){cov_2ayk1lyqd0().b[10][0]++;cov_2ayk1lyqd0().s[40]++;if_block.p(ctx,dirty);}else {cov_2ayk1lyqd0().b[10][1]++;cov_2ayk1lyqd0().s[41]++;if_block=create_if_block_2$1(ctx);cov_2ayk1lyqd0().s[42]++;if_block.c();cov_2ayk1lyqd0().s[43]++;if_block.m(span,t2);}}else {cov_2ayk1lyqd0().b[9][1]++;cov_2ayk1lyqd0().s[44]++;if(if_block){cov_2ayk1lyqd0().b[11][0]++;cov_2ayk1lyqd0().s[45]++;if_block.d(1);cov_2ayk1lyqd0().s[46]++;if_block=null;}else {cov_2ayk1lyqd0().b[11][1]++;}}cov_2ayk1lyqd0().s[47]++;if((cov_2ayk1lyqd0().b[13][0]++,dirty[0]&/*_value*/8)&&(cov_2ayk1lyqd0().b[13][1]++,span_class_value!==(span_class_value="mx-1 tag is-"+/*item*/ctx[30].type))){cov_2ayk1lyqd0().b[12][0]++;cov_2ayk1lyqd0().s[48]++;attr(span,"class",span_class_value);}else {cov_2ayk1lyqd0().b[12][1]++;}},d(detaching){cov_2ayk1lyqd0().f[11]++;cov_2ayk1lyqd0().s[49]++;if(detaching){cov_2ayk1lyqd0().b[14][0]++;cov_2ayk1lyqd0().s[50]++;detach(span);}else {cov_2ayk1lyqd0().b[14][1]++;}cov_2ayk1lyqd0().s[51]++;if(if_block){cov_2ayk1lyqd0().b[15][0]++;cov_2ayk1lyqd0().s[52]++;if_block.d();}else {cov_2ayk1lyqd0().b[15][1]++;}}};}// (156:4) {#if !readonly}
	function create_if_block$1(ctx){cov_2ayk1lyqd0().f[12]++;let div2;let div1;let div0;let select;let option;let t0_value=(/*$LOCALE*/cov_2ayk1lyqd0().s[53]++,ctx[8]["Выберите из списка..."]+"");let t0;let t1;let button;let t2_value=(/*$LOCALE*/cov_2ayk1lyqd0().s[54]++,ctx[8]["Добавить"]+"");let t2;let t3;let uierrorslist;let updating_errors;let updating_show;let updating_classes;let current;let mounted;let dispose;let each_value=(cov_2ayk1lyqd0().s[55]++,ensure_array_like(/*variants*/ctx[0]));let each_blocks=(cov_2ayk1lyqd0().s[56]++,[]);cov_2ayk1lyqd0().s[57]++;for(let i=(cov_2ayk1lyqd0().s[58]++,0);i<each_value.length;i+=1){cov_2ayk1lyqd0().s[59]++;each_blocks[i]=create_each_block(get_each_context(ctx,each_value,i));}function uierrorslist_errors_binding(value){cov_2ayk1lyqd0().f[13]++;cov_2ayk1lyqd0().s[60]++;/*uierrorslist_errors_binding*/ctx[19](value);}function uierrorslist_show_binding(value){cov_2ayk1lyqd0().f[14]++;cov_2ayk1lyqd0().s[61]++;/*uierrorslist_show_binding*/ctx[20](value);}function uierrorslist_classes_binding(value){cov_2ayk1lyqd0().f[15]++;cov_2ayk1lyqd0().s[62]++;/*uierrorslist_classes_binding*/ctx[21](value);}let uierrorslist_props=(cov_2ayk1lyqd0().s[63]++,{id:"input-field-helper-"+/*fieldname*/ctx[1]});cov_2ayk1lyqd0().s[64]++;if(/*allErrors*/ctx[7]!==void 0){cov_2ayk1lyqd0().b[16][0]++;cov_2ayk1lyqd0().s[65]++;uierrorslist_props.errors=/*allErrors*/ctx[7];}else {cov_2ayk1lyqd0().b[16][1]++;}cov_2ayk1lyqd0().s[66]++;if(/*showErrors*/ctx[6]!==void 0){cov_2ayk1lyqd0().b[17][0]++;cov_2ayk1lyqd0().s[67]++;uierrorslist_props.show=/*showErrors*/ctx[6];}else {cov_2ayk1lyqd0().b[17][1]++;}cov_2ayk1lyqd0().s[68]++;if(/*validationClasses*/ctx[5]!==void 0){cov_2ayk1lyqd0().b[18][0]++;cov_2ayk1lyqd0().s[69]++;uierrorslist_props.classes=/*validationClasses*/ctx[5];}else {cov_2ayk1lyqd0().b[18][1]++;}cov_2ayk1lyqd0().s[70]++;uierrorslist=new/*UIErrorsList*/ctx[9]({props:uierrorslist_props});cov_2ayk1lyqd0().s[71]++;binding_callbacks.push(()=>{cov_2ayk1lyqd0().f[16]++;cov_2ayk1lyqd0().s[72]++;return bind(uierrorslist,'errors',uierrorslist_errors_binding);});cov_2ayk1lyqd0().s[73]++;binding_callbacks.push(()=>{cov_2ayk1lyqd0().f[17]++;cov_2ayk1lyqd0().s[74]++;return bind(uierrorslist,'show',uierrorslist_show_binding);});cov_2ayk1lyqd0().s[75]++;binding_callbacks.push(()=>{cov_2ayk1lyqd0().f[18]++;cov_2ayk1lyqd0().s[76]++;return bind(uierrorslist,'classes',uierrorslist_classes_binding);});cov_2ayk1lyqd0().s[77]++;return {c(){cov_2ayk1lyqd0().f[19]++;cov_2ayk1lyqd0().s[78]++;div2=element("div");cov_2ayk1lyqd0().s[79]++;div1=element("div");cov_2ayk1lyqd0().s[80]++;div0=element("div");cov_2ayk1lyqd0().s[81]++;select=element("select");cov_2ayk1lyqd0().s[82]++;option=element("option");cov_2ayk1lyqd0().s[83]++;t0=text(t0_value);cov_2ayk1lyqd0().s[84]++;for(let i=(cov_2ayk1lyqd0().s[85]++,0);i<each_blocks.length;i+=1){cov_2ayk1lyqd0().s[86]++;each_blocks[i].c();}cov_2ayk1lyqd0().s[87]++;t1=space();cov_2ayk1lyqd0().s[88]++;button=element("button");cov_2ayk1lyqd0().s[89]++;t2=text(t2_value);cov_2ayk1lyqd0().s[90]++;t3=space();cov_2ayk1lyqd0().s[91]++;create_component(uierrorslist.$$.fragment);cov_2ayk1lyqd0().s[92]++;option.__value="-1";cov_2ayk1lyqd0().s[93]++;set_input_value(option,option.__value);cov_2ayk1lyqd0().s[94]++;option.selected=true;cov_2ayk1lyqd0().s[95]++;attr(div0,"class","select is-small");cov_2ayk1lyqd0().s[96]++;attr(button,"class","button is-primary is-small");cov_2ayk1lyqd0().s[97]++;attr(div1,"class","control");cov_2ayk1lyqd0().s[98]++;attr(div2,"class","column");},m(target,anchor){cov_2ayk1lyqd0().f[20]++;cov_2ayk1lyqd0().s[99]++;insert(target,div2,anchor);cov_2ayk1lyqd0().s[100]++;append(div2,div1);cov_2ayk1lyqd0().s[101]++;append(div1,div0);cov_2ayk1lyqd0().s[102]++;append(div0,select);cov_2ayk1lyqd0().s[103]++;append(select,option);cov_2ayk1lyqd0().s[104]++;append(option,t0);cov_2ayk1lyqd0().s[105]++;for(let i=(cov_2ayk1lyqd0().s[106]++,0);i<each_blocks.length;i+=1){cov_2ayk1lyqd0().s[107]++;if(each_blocks[i]){cov_2ayk1lyqd0().b[19][0]++;cov_2ayk1lyqd0().s[108]++;each_blocks[i].m(select,null);}else {cov_2ayk1lyqd0().b[19][1]++;}}cov_2ayk1lyqd0().s[109]++;append(div1,t1);cov_2ayk1lyqd0().s[110]++;append(div1,button);cov_2ayk1lyqd0().s[111]++;append(button,t2);cov_2ayk1lyqd0().s[112]++;append(div2,t3);cov_2ayk1lyqd0().s[113]++;mount_component(uierrorslist,div2,null);cov_2ayk1lyqd0().s[114]++;current=true;cov_2ayk1lyqd0().s[115]++;if(!mounted){cov_2ayk1lyqd0().b[20][0]++;cov_2ayk1lyqd0().s[116]++;dispose=listen(button,"click",/*add*/ctx[11]);cov_2ayk1lyqd0().s[117]++;mounted=true;}else {cov_2ayk1lyqd0().b[20][1]++;}},p(ctx,dirty){cov_2ayk1lyqd0().f[21]++;cov_2ayk1lyqd0().s[118]++;if(((cov_2ayk1lyqd0().b[22][0]++,!current)||(cov_2ayk1lyqd0().b[22][1]++,dirty[0]&/*$LOCALE*/256))&&(cov_2ayk1lyqd0().b[22][2]++,t0_value!==(t0_value=/*$LOCALE*/ctx[8]["Выберите из списка..."]+""))){cov_2ayk1lyqd0().b[21][0]++;cov_2ayk1lyqd0().s[119]++;set_data(t0,t0_value);}else {cov_2ayk1lyqd0().b[21][1]++;}cov_2ayk1lyqd0().s[120]++;if(dirty[0]&/*variants, $LOCALE*/257){cov_2ayk1lyqd0().b[23][0]++;cov_2ayk1lyqd0().s[121]++;each_value=ensure_array_like(/*variants*/ctx[0]);let i;cov_2ayk1lyqd0().s[122]++;for(i=0;i<each_value.length;i+=1){const child_ctx=(cov_2ayk1lyqd0().s[123]++,get_each_context(ctx,each_value,i));cov_2ayk1lyqd0().s[124]++;if(each_blocks[i]){cov_2ayk1lyqd0().b[24][0]++;cov_2ayk1lyqd0().s[125]++;each_blocks[i].p(child_ctx,dirty);}else {cov_2ayk1lyqd0().b[24][1]++;cov_2ayk1lyqd0().s[126]++;each_blocks[i]=create_each_block(child_ctx);cov_2ayk1lyqd0().s[127]++;each_blocks[i].c();cov_2ayk1lyqd0().s[128]++;each_blocks[i].m(select,null);}}cov_2ayk1lyqd0().s[129]++;for(;i<each_blocks.length;i+=1){cov_2ayk1lyqd0().s[130]++;each_blocks[i].d(1);}cov_2ayk1lyqd0().s[131]++;each_blocks.length=each_value.length;}else {cov_2ayk1lyqd0().b[23][1]++;}cov_2ayk1lyqd0().s[132]++;if(((cov_2ayk1lyqd0().b[26][0]++,!current)||(cov_2ayk1lyqd0().b[26][1]++,dirty[0]&/*$LOCALE*/256))&&(cov_2ayk1lyqd0().b[26][2]++,t2_value!==(t2_value=/*$LOCALE*/ctx[8]["Добавить"]+""))){cov_2ayk1lyqd0().b[25][0]++;cov_2ayk1lyqd0().s[133]++;set_data(t2,t2_value);}else {cov_2ayk1lyqd0().b[25][1]++;}const uierrorslist_changes=(cov_2ayk1lyqd0().s[134]++,{});cov_2ayk1lyqd0().s[135]++;if(dirty[0]&/*fieldname*/2){cov_2ayk1lyqd0().b[27][0]++;cov_2ayk1lyqd0().s[136]++;uierrorslist_changes.id="input-field-helper-"+/*fieldname*/ctx[1];}else {cov_2ayk1lyqd0().b[27][1]++;}cov_2ayk1lyqd0().s[137]++;if((cov_2ayk1lyqd0().b[29][0]++,!updating_errors)&&(cov_2ayk1lyqd0().b[29][1]++,dirty[0]&/*allErrors*/128)){cov_2ayk1lyqd0().b[28][0]++;cov_2ayk1lyqd0().s[138]++;updating_errors=true;cov_2ayk1lyqd0().s[139]++;uierrorslist_changes.errors=/*allErrors*/ctx[7];cov_2ayk1lyqd0().s[140]++;add_flush_callback(()=>{cov_2ayk1lyqd0().f[22]++;cov_2ayk1lyqd0().s[141]++;return updating_errors=false;});}else {cov_2ayk1lyqd0().b[28][1]++;}cov_2ayk1lyqd0().s[142]++;if((cov_2ayk1lyqd0().b[31][0]++,!updating_show)&&(cov_2ayk1lyqd0().b[31][1]++,dirty[0]&/*showErrors*/64)){cov_2ayk1lyqd0().b[30][0]++;cov_2ayk1lyqd0().s[143]++;updating_show=true;cov_2ayk1lyqd0().s[144]++;uierrorslist_changes.show=/*showErrors*/ctx[6];cov_2ayk1lyqd0().s[145]++;add_flush_callback(()=>{cov_2ayk1lyqd0().f[23]++;cov_2ayk1lyqd0().s[146]++;return updating_show=false;});}else {cov_2ayk1lyqd0().b[30][1]++;}cov_2ayk1lyqd0().s[147]++;if((cov_2ayk1lyqd0().b[33][0]++,!updating_classes)&&(cov_2ayk1lyqd0().b[33][1]++,dirty[0]&/*validationClasses*/32)){cov_2ayk1lyqd0().b[32][0]++;cov_2ayk1lyqd0().s[148]++;updating_classes=true;cov_2ayk1lyqd0().s[149]++;uierrorslist_changes.classes=/*validationClasses*/ctx[5];cov_2ayk1lyqd0().s[150]++;add_flush_callback(()=>{cov_2ayk1lyqd0().f[24]++;cov_2ayk1lyqd0().s[151]++;return updating_classes=false;});}else {cov_2ayk1lyqd0().b[32][1]++;}cov_2ayk1lyqd0().s[152]++;uierrorslist.$set(uierrorslist_changes);},i(local){cov_2ayk1lyqd0().f[25]++;cov_2ayk1lyqd0().s[153]++;if(current){cov_2ayk1lyqd0().b[34][0]++;cov_2ayk1lyqd0().s[154]++;return;}else {cov_2ayk1lyqd0().b[34][1]++;}cov_2ayk1lyqd0().s[155]++;transition_in(uierrorslist.$$.fragment,local);cov_2ayk1lyqd0().s[156]++;current=true;},o(local){cov_2ayk1lyqd0().f[26]++;cov_2ayk1lyqd0().s[157]++;transition_out(uierrorslist.$$.fragment,local);cov_2ayk1lyqd0().s[158]++;current=false;},d(detaching){cov_2ayk1lyqd0().f[27]++;cov_2ayk1lyqd0().s[159]++;if(detaching){cov_2ayk1lyqd0().b[35][0]++;cov_2ayk1lyqd0().s[160]++;detach(div2);}else {cov_2ayk1lyqd0().b[35][1]++;}cov_2ayk1lyqd0().s[161]++;destroy_each(each_blocks,detaching);cov_2ayk1lyqd0().s[162]++;destroy_component(uierrorslist);cov_2ayk1lyqd0().s[163]++;mounted=false;cov_2ayk1lyqd0().s[164]++;dispose();}};}// (165:28) {#if !variant.notSelectable}
	function create_if_block_1$1(ctx){cov_2ayk1lyqd0().f[28]++;let option;let t_value=(/*$LOCALE*/cov_2ayk1lyqd0().s[165]++,ctx[8][/*variant*/ctx[27].title]+"");let t;let option_value_value;cov_2ayk1lyqd0().s[166]++;return {c(){cov_2ayk1lyqd0().f[29]++;cov_2ayk1lyqd0().s[167]++;option=element("option");cov_2ayk1lyqd0().s[168]++;t=text(t_value);cov_2ayk1lyqd0().s[169]++;option.__value=option_value_value=/*variant*/ctx[27].id;cov_2ayk1lyqd0().s[170]++;set_input_value(option,option.__value);},m(target,anchor){cov_2ayk1lyqd0().f[30]++;cov_2ayk1lyqd0().s[171]++;insert(target,option,anchor);cov_2ayk1lyqd0().s[172]++;append(option,t);},p(ctx,dirty){cov_2ayk1lyqd0().f[31]++;cov_2ayk1lyqd0().s[173]++;if((cov_2ayk1lyqd0().b[37][0]++,dirty[0]&/*$LOCALE, variants*/257)&&(cov_2ayk1lyqd0().b[37][1]++,t_value!==(t_value=/*$LOCALE*/ctx[8][/*variant*/ctx[27].title]+""))){cov_2ayk1lyqd0().b[36][0]++;cov_2ayk1lyqd0().s[174]++;set_data(t,t_value);}else {cov_2ayk1lyqd0().b[36][1]++;}cov_2ayk1lyqd0().s[175]++;if((cov_2ayk1lyqd0().b[39][0]++,dirty[0]&/*variants*/1)&&(cov_2ayk1lyqd0().b[39][1]++,option_value_value!==(option_value_value=/*variant*/ctx[27].id))){cov_2ayk1lyqd0().b[38][0]++;cov_2ayk1lyqd0().s[176]++;option.__value=option_value_value;cov_2ayk1lyqd0().s[177]++;set_input_value(option,option.__value);}else {cov_2ayk1lyqd0().b[38][1]++;}},d(detaching){cov_2ayk1lyqd0().f[32]++;cov_2ayk1lyqd0().s[178]++;if(detaching){cov_2ayk1lyqd0().b[40][0]++;cov_2ayk1lyqd0().s[179]++;detach(option);}else {cov_2ayk1lyqd0().b[40][1]++;}}};}// (164:24) {#each variants as variant}
	function create_each_block(ctx){cov_2ayk1lyqd0().f[33]++;let if_block_anchor;let if_block=(cov_2ayk1lyqd0().s[180]++,(cov_2ayk1lyqd0().b[41][0]++,!/*variant*/ctx[27].notSelectable)&&(cov_2ayk1lyqd0().b[41][1]++,create_if_block_1$1(ctx)));cov_2ayk1lyqd0().s[181]++;return {c(){cov_2ayk1lyqd0().f[34]++;cov_2ayk1lyqd0().s[182]++;if(if_block){cov_2ayk1lyqd0().b[42][0]++;cov_2ayk1lyqd0().s[183]++;if_block.c();}else {cov_2ayk1lyqd0().b[42][1]++;}cov_2ayk1lyqd0().s[184]++;if_block_anchor=empty();},m(target,anchor){cov_2ayk1lyqd0().f[35]++;cov_2ayk1lyqd0().s[185]++;if(if_block){cov_2ayk1lyqd0().b[43][0]++;cov_2ayk1lyqd0().s[186]++;if_block.m(target,anchor);}else {cov_2ayk1lyqd0().b[43][1]++;}cov_2ayk1lyqd0().s[187]++;insert(target,if_block_anchor,anchor);},p(ctx,dirty){cov_2ayk1lyqd0().f[36]++;cov_2ayk1lyqd0().s[188]++;if(!/*variant*/ctx[27].notSelectable){cov_2ayk1lyqd0().b[44][0]++;cov_2ayk1lyqd0().s[189]++;if(if_block){cov_2ayk1lyqd0().b[45][0]++;cov_2ayk1lyqd0().s[190]++;if_block.p(ctx,dirty);}else {cov_2ayk1lyqd0().b[45][1]++;cov_2ayk1lyqd0().s[191]++;if_block=create_if_block_1$1(ctx);cov_2ayk1lyqd0().s[192]++;if_block.c();cov_2ayk1lyqd0().s[193]++;if_block.m(if_block_anchor.parentNode,if_block_anchor);}}else {cov_2ayk1lyqd0().b[44][1]++;cov_2ayk1lyqd0().s[194]++;if(if_block){cov_2ayk1lyqd0().b[46][0]++;cov_2ayk1lyqd0().s[195]++;if_block.d(1);cov_2ayk1lyqd0().s[196]++;if_block=null;}else {cov_2ayk1lyqd0().b[46][1]++;}}},d(detaching){cov_2ayk1lyqd0().f[37]++;cov_2ayk1lyqd0().s[197]++;if(detaching){cov_2ayk1lyqd0().b[47][0]++;cov_2ayk1lyqd0().s[198]++;detach(if_block_anchor);}else {cov_2ayk1lyqd0().b[47][1]++;}cov_2ayk1lyqd0().s[199]++;if(if_block){cov_2ayk1lyqd0().b[48][0]++;cov_2ayk1lyqd0().s[200]++;if_block.d(detaching);}else {cov_2ayk1lyqd0().b[48][1]++;}}};}function create_fragment$3(ctx){cov_2ayk1lyqd0().f[38]++;let div1;let div0;let div0_class_value;let t;let current;let each_value_1=(cov_2ayk1lyqd0().s[201]++,ensure_array_like(/*_value*/ctx[3]));let each_blocks=(cov_2ayk1lyqd0().s[202]++,[]);cov_2ayk1lyqd0().s[203]++;for(let i=(cov_2ayk1lyqd0().s[204]++,0);i<each_value_1.length;i+=1){cov_2ayk1lyqd0().s[205]++;each_blocks[i]=create_each_block_1(get_each_context_1(ctx,each_value_1,i));}let if_block=(cov_2ayk1lyqd0().s[206]++,(cov_2ayk1lyqd0().b[49][0]++,!/*readonly*/ctx[2])&&(cov_2ayk1lyqd0().b[49][1]++,create_if_block$1(ctx)));cov_2ayk1lyqd0().s[207]++;return {c(){cov_2ayk1lyqd0().f[39]++;cov_2ayk1lyqd0().s[208]++;div1=element("div");cov_2ayk1lyqd0().s[209]++;div0=element("div");cov_2ayk1lyqd0().s[210]++;for(let i=(cov_2ayk1lyqd0().s[211]++,0);i<each_blocks.length;i+=1){cov_2ayk1lyqd0().s[212]++;each_blocks[i].c();}cov_2ayk1lyqd0().s[213]++;t=space();cov_2ayk1lyqd0().s[214]++;if(if_block){cov_2ayk1lyqd0().b[50][0]++;cov_2ayk1lyqd0().s[215]++;if_block.c();}else {cov_2ayk1lyqd0().b[50][1]++;}cov_2ayk1lyqd0().s[216]++;attr(div0,"class",div0_class_value="column "+/*classes*/ctx[4]);cov_2ayk1lyqd0().s[217]++;attr(div1,"class","columns");},m(target,anchor){cov_2ayk1lyqd0().f[40]++;cov_2ayk1lyqd0().s[218]++;insert(target,div1,anchor);cov_2ayk1lyqd0().s[219]++;append(div1,div0);cov_2ayk1lyqd0().s[220]++;for(let i=(cov_2ayk1lyqd0().s[221]++,0);i<each_blocks.length;i+=1){cov_2ayk1lyqd0().s[222]++;if(each_blocks[i]){cov_2ayk1lyqd0().b[51][0]++;cov_2ayk1lyqd0().s[223]++;each_blocks[i].m(div0,null);}else {cov_2ayk1lyqd0().b[51][1]++;}}cov_2ayk1lyqd0().s[224]++;append(div1,t);cov_2ayk1lyqd0().s[225]++;if(if_block){cov_2ayk1lyqd0().b[52][0]++;cov_2ayk1lyqd0().s[226]++;if_block.m(div1,null);}else {cov_2ayk1lyqd0().b[52][1]++;}cov_2ayk1lyqd0().s[227]++;current=true;},p(ctx,dirty){cov_2ayk1lyqd0().f[41]++;cov_2ayk1lyqd0().s[228]++;if(dirty[0]&/*_value, remove, readonly, $LOCALE*/1292){cov_2ayk1lyqd0().b[53][0]++;cov_2ayk1lyqd0().s[229]++;each_value_1=ensure_array_like(/*_value*/ctx[3]);let i;cov_2ayk1lyqd0().s[230]++;for(i=0;i<each_value_1.length;i+=1){const child_ctx=(cov_2ayk1lyqd0().s[231]++,get_each_context_1(ctx,each_value_1,i));cov_2ayk1lyqd0().s[232]++;if(each_blocks[i]){cov_2ayk1lyqd0().b[54][0]++;cov_2ayk1lyqd0().s[233]++;each_blocks[i].p(child_ctx,dirty);}else {cov_2ayk1lyqd0().b[54][1]++;cov_2ayk1lyqd0().s[234]++;each_blocks[i]=create_each_block_1(child_ctx);cov_2ayk1lyqd0().s[235]++;each_blocks[i].c();cov_2ayk1lyqd0().s[236]++;each_blocks[i].m(div0,null);}}cov_2ayk1lyqd0().s[237]++;for(;i<each_blocks.length;i+=1){cov_2ayk1lyqd0().s[238]++;each_blocks[i].d(1);}cov_2ayk1lyqd0().s[239]++;each_blocks.length=each_value_1.length;}else {cov_2ayk1lyqd0().b[53][1]++;}cov_2ayk1lyqd0().s[240]++;if((cov_2ayk1lyqd0().b[56][0]++,!current)||(cov_2ayk1lyqd0().b[56][1]++,dirty[0]&/*classes*/16)&&(cov_2ayk1lyqd0().b[56][2]++,div0_class_value!==(div0_class_value="column "+/*classes*/ctx[4]))){cov_2ayk1lyqd0().b[55][0]++;cov_2ayk1lyqd0().s[241]++;attr(div0,"class",div0_class_value);}else {cov_2ayk1lyqd0().b[55][1]++;}cov_2ayk1lyqd0().s[242]++;if(!/*readonly*/ctx[2]){cov_2ayk1lyqd0().b[57][0]++;cov_2ayk1lyqd0().s[243]++;if(if_block){cov_2ayk1lyqd0().b[58][0]++;cov_2ayk1lyqd0().s[244]++;if_block.p(ctx,dirty);cov_2ayk1lyqd0().s[245]++;if(dirty[0]&/*readonly*/4){cov_2ayk1lyqd0().b[59][0]++;cov_2ayk1lyqd0().s[246]++;transition_in(if_block,1);}else {cov_2ayk1lyqd0().b[59][1]++;}}else {cov_2ayk1lyqd0().b[58][1]++;cov_2ayk1lyqd0().s[247]++;if_block=create_if_block$1(ctx);cov_2ayk1lyqd0().s[248]++;if_block.c();cov_2ayk1lyqd0().s[249]++;transition_in(if_block,1);cov_2ayk1lyqd0().s[250]++;if_block.m(div1,null);}}else {cov_2ayk1lyqd0().b[57][1]++;cov_2ayk1lyqd0().s[251]++;if(if_block){cov_2ayk1lyqd0().b[60][0]++;cov_2ayk1lyqd0().s[252]++;group_outros();cov_2ayk1lyqd0().s[253]++;transition_out(if_block,1,1,()=>{cov_2ayk1lyqd0().f[42]++;cov_2ayk1lyqd0().s[254]++;if_block=null;});cov_2ayk1lyqd0().s[255]++;check_outros();}else {cov_2ayk1lyqd0().b[60][1]++;}}},i(local){cov_2ayk1lyqd0().f[43]++;cov_2ayk1lyqd0().s[256]++;if(current){cov_2ayk1lyqd0().b[61][0]++;cov_2ayk1lyqd0().s[257]++;return;}else {cov_2ayk1lyqd0().b[61][1]++;}cov_2ayk1lyqd0().s[258]++;transition_in(if_block);cov_2ayk1lyqd0().s[259]++;current=true;},o(local){cov_2ayk1lyqd0().f[44]++;cov_2ayk1lyqd0().s[260]++;transition_out(if_block);cov_2ayk1lyqd0().s[261]++;current=false;},d(detaching){cov_2ayk1lyqd0().f[45]++;cov_2ayk1lyqd0().s[262]++;if(detaching){cov_2ayk1lyqd0().b[62][0]++;cov_2ayk1lyqd0().s[263]++;detach(div1);}else {cov_2ayk1lyqd0().b[62][1]++;}cov_2ayk1lyqd0().s[264]++;destroy_each(each_blocks,detaching);cov_2ayk1lyqd0().s[265]++;if(if_block){cov_2ayk1lyqd0().b[63][0]++;cov_2ayk1lyqd0().s[266]++;if_block.d();}else {cov_2ayk1lyqd0().b[63][1]++;}}};}function deplete(val=(cov_2ayk1lyqd0().b[64][0]++,[])){cov_2ayk1lyqd0().f[46]++;cov_2ayk1lyqd0().s[267]++;if(Array.isArray(val)){cov_2ayk1lyqd0().b[65][0]++;cov_2ayk1lyqd0().s[268]++;return val.map(role=>{cov_2ayk1lyqd0().f[47]++;cov_2ayk1lyqd0().s[269]++;return getRoleString(role);}).filter(itm=>{cov_2ayk1lyqd0().f[48]++;cov_2ayk1lyqd0().s[270]++;return typeof itm!=="undefined";});}else {cov_2ayk1lyqd0().b[65][1]++;cov_2ayk1lyqd0().s[271]++;return [];}}function getRoleString(itm){cov_2ayk1lyqd0().f[49]++;cov_2ayk1lyqd0().s[272]++;if(typeof itm==="string"){cov_2ayk1lyqd0().b[66][0]++;cov_2ayk1lyqd0().s[273]++;return itm;}else {cov_2ayk1lyqd0().b[66][1]++;cov_2ayk1lyqd0().s[274]++;if((cov_2ayk1lyqd0().b[68][0]++,typeof itm==="object")&&(cov_2ayk1lyqd0().b[68][1]++,Object.hasOwn(itm,"id"))&&(cov_2ayk1lyqd0().b[68][2]++,typeof itm.id==="string")){cov_2ayk1lyqd0().b[67][0]++;cov_2ayk1lyqd0().s[275]++;return itm.id;}else {cov_2ayk1lyqd0().b[67][1]++;cov_2ayk1lyqd0().s[276]++;return undefined;}}}function instance$3($$self,$$props,$$invalidate){cov_2ayk1lyqd0().f[50]++;let allErrors;let showErrors;let validationClasses;let classes;let $LOCALE;cov_2ayk1lyqd0().s[277]++;component_subscribe($$self,LOCALE,$$value=>{cov_2ayk1lyqd0().f[51]++;cov_2ayk1lyqd0().s[278]++;return $$invalidate(8,$LOCALE=$$value);});const{UIErrorsList}=(cov_2ayk1lyqd0().s[279]++,index$9);const{UICommon}=(cov_2ayk1lyqd0().s[280]++,Elements);let dispatch=(cov_2ayk1lyqd0().s[281]++,createEventDispatcher());function enrich(val=(cov_2ayk1lyqd0().b[69][0]++,[])){cov_2ayk1lyqd0().f[52]++;cov_2ayk1lyqd0().s[282]++;if(Array.isArray(val)){cov_2ayk1lyqd0().b[70][0]++;cov_2ayk1lyqd0().s[283]++;return val.map(role=>{cov_2ayk1lyqd0().f[53]++;cov_2ayk1lyqd0().s[284]++;return getRoleTagObject(role);}).filter(itm=>{cov_2ayk1lyqd0().f[54]++;cov_2ayk1lyqd0().s[285]++;return typeof itm!=="undefined";});}else {cov_2ayk1lyqd0().b[70][1]++;cov_2ayk1lyqd0().s[286]++;return [];}}function getRoleTagObject(itm){cov_2ayk1lyqd0().f[55]++;cov_2ayk1lyqd0().s[287]++;if(typeof itm==="string"){cov_2ayk1lyqd0().b[71][0]++;cov_2ayk1lyqd0().s[288]++;if(Array.isArray(variants)){cov_2ayk1lyqd0().b[72][0]++;cov_2ayk1lyqd0().s[289]++;return variants.find(variant=>{cov_2ayk1lyqd0().f[56]++;cov_2ayk1lyqd0().s[290]++;return variant.id===itm;});}else {cov_2ayk1lyqd0().b[72][1]++;cov_2ayk1lyqd0().s[291]++;return undefined;}}else {cov_2ayk1lyqd0().b[71][1]++;cov_2ayk1lyqd0().s[292]++;return itm;}}cov_2ayk1lyqd0().s[293]++;onMount(()=>{cov_2ayk1lyqd0().f[57]++;cov_2ayk1lyqd0().s[294]++;$$invalidate(3,_value=enrich(value));cov_2ayk1lyqd0().s[295]++;$$invalidate(3,_value);cov_2ayk1lyqd0().s[296]++;$$invalidate(13,value=deplete(value));cov_2ayk1lyqd0().s[297]++;$$invalidate(13,value);});let{inputStarted=(cov_2ayk1lyqd0().b[73][0]++,false)}=(cov_2ayk1lyqd0().s[298]++,$$props);let{value=(cov_2ayk1lyqd0().b[74][0]++,[])}=(cov_2ayk1lyqd0().s[299]++,$$props);/**
	  item = {
	id,        //unique
	title,     //some text
	type       //for coloring items, usual html template names danger, success, etc
	  }
	  **/let _value=(cov_2ayk1lyqd0().s[300]++,[]);//local copy enriched with data for gui
	let{variants=(cov_2ayk1lyqd0().b[75][0]++,[])}=(cov_2ayk1lyqd0().s[301]++,$$props);let{fieldname=(cov_2ayk1lyqd0().b[76][0]++,"role")}=(cov_2ayk1lyqd0().s[302]++,$$props);let{readonly=(cov_2ayk1lyqd0().b[77][0]++,false)}=(cov_2ayk1lyqd0().s[303]++,$$props);let{valid=(cov_2ayk1lyqd0().b[78][0]++,true)}=(cov_2ayk1lyqd0().s[304]++,$$props);let{validated=(cov_2ayk1lyqd0().b[79][0]++,false)}=(cov_2ayk1lyqd0().s[305]++,$$props);let{errors=(cov_2ayk1lyqd0().b[80][0]++,false)}=(cov_2ayk1lyqd0().s[306]++,$$props);let{formErrors=(cov_2ayk1lyqd0().b[81][0]++,false)}=(cov_2ayk1lyqd0().s[307]++,$$props);let{formLevelError=(cov_2ayk1lyqd0().b[82][0]++,false)}=(cov_2ayk1lyqd0().s[308]++,$$props);function remove(e){cov_2ayk1lyqd0().f[58]++;cov_2ayk1lyqd0().s[309]++;(cov_2ayk1lyqd0().b[83][0]++,e)&&(cov_2ayk1lyqd0().b[83][1]++,e.preventDefault());let id=(cov_2ayk1lyqd0().s[310]++,e.currentTarget.dataset.id);let item=(cov_2ayk1lyqd0().s[311]++,_value.find(el=>{cov_2ayk1lyqd0().f[59]++;cov_2ayk1lyqd0().s[312]++;return el.id===id;}));cov_2ayk1lyqd0().s[313]++;if(item){cov_2ayk1lyqd0().b[84][0]++;cov_2ayk1lyqd0().s[314]++;_value.splice(_value.indexOf(item),1);cov_2ayk1lyqd0().s[315]++;$$invalidate(3,_value);cov_2ayk1lyqd0().s[316]++;$$invalidate(13,value=deplete(_value));cov_2ayk1lyqd0().s[317]++;$$invalidate(13,value);cov_2ayk1lyqd0().s[318]++;$$invalidate(12,inputStarted=true);cov_2ayk1lyqd0().s[319]++;dispatch("change",{field:"role",value});}else {cov_2ayk1lyqd0().b[84][1]++;}cov_2ayk1lyqd0().s[320]++;return false;}function add(e){cov_2ayk1lyqd0().f[60]++;cov_2ayk1lyqd0().s[321]++;(cov_2ayk1lyqd0().b[85][0]++,e)&&(cov_2ayk1lyqd0().b[85][1]++,e.preventDefault());let id=(cov_2ayk1lyqd0().s[322]++,e.currentTarget.parentNode.querySelector("select").value);let item=(cov_2ayk1lyqd0().s[323]++,Array.isArray(variants)?(cov_2ayk1lyqd0().b[86][0]++,variants.find(el=>{cov_2ayk1lyqd0().f[61]++;cov_2ayk1lyqd0().s[324]++;return el.id===id;})):(cov_2ayk1lyqd0().b[86][1]++,null));cov_2ayk1lyqd0().s[325]++;if((cov_2ayk1lyqd0().b[88][0]++,item)&&(cov_2ayk1lyqd0().b[88][1]++,_value.indexOf(item)===-1)){cov_2ayk1lyqd0().b[87][0]++;cov_2ayk1lyqd0().s[326]++;_value.push(item);cov_2ayk1lyqd0().s[327]++;$$invalidate(3,_value);cov_2ayk1lyqd0().s[328]++;$$invalidate(13,value=deplete(_value));cov_2ayk1lyqd0().s[329]++;$$invalidate(13,value);cov_2ayk1lyqd0().s[330]++;dispatch("change",{field:"role",value});}else {cov_2ayk1lyqd0().b[87][1]++;}cov_2ayk1lyqd0().s[331]++;return false;}function uierrorslist_errors_binding(value){cov_2ayk1lyqd0().f[62]++;cov_2ayk1lyqd0().s[332]++;allErrors=value;cov_2ayk1lyqd0().s[333]++;$$invalidate(7,allErrors),$$invalidate(16,errors),$$invalidate(17,formErrors);}function uierrorslist_show_binding(value){cov_2ayk1lyqd0().f[63]++;cov_2ayk1lyqd0().s[334]++;showErrors=value;cov_2ayk1lyqd0().s[335]++;$$invalidate(6,showErrors),$$invalidate(15,validated),$$invalidate(14,valid),$$invalidate(12,inputStarted);}function uierrorslist_classes_binding(value){cov_2ayk1lyqd0().f[64]++;cov_2ayk1lyqd0().s[336]++;validationClasses=value;cov_2ayk1lyqd0().s[337]++;$$invalidate(5,validationClasses),$$invalidate(14,valid),$$invalidate(12,inputStarted);}cov_2ayk1lyqd0().s[338]++;$$self.$$set=$$props=>{cov_2ayk1lyqd0().f[65]++;cov_2ayk1lyqd0().s[339]++;if('inputStarted'in $$props){cov_2ayk1lyqd0().b[89][0]++;cov_2ayk1lyqd0().s[340]++;$$invalidate(12,inputStarted=$$props.inputStarted);}else {cov_2ayk1lyqd0().b[89][1]++;}cov_2ayk1lyqd0().s[341]++;if('value'in $$props){cov_2ayk1lyqd0().b[90][0]++;cov_2ayk1lyqd0().s[342]++;$$invalidate(13,value=$$props.value);}else {cov_2ayk1lyqd0().b[90][1]++;}cov_2ayk1lyqd0().s[343]++;if('variants'in $$props){cov_2ayk1lyqd0().b[91][0]++;cov_2ayk1lyqd0().s[344]++;$$invalidate(0,variants=$$props.variants);}else {cov_2ayk1lyqd0().b[91][1]++;}cov_2ayk1lyqd0().s[345]++;if('fieldname'in $$props){cov_2ayk1lyqd0().b[92][0]++;cov_2ayk1lyqd0().s[346]++;$$invalidate(1,fieldname=$$props.fieldname);}else {cov_2ayk1lyqd0().b[92][1]++;}cov_2ayk1lyqd0().s[347]++;if('readonly'in $$props){cov_2ayk1lyqd0().b[93][0]++;cov_2ayk1lyqd0().s[348]++;$$invalidate(2,readonly=$$props.readonly);}else {cov_2ayk1lyqd0().b[93][1]++;}cov_2ayk1lyqd0().s[349]++;if('valid'in $$props){cov_2ayk1lyqd0().b[94][0]++;cov_2ayk1lyqd0().s[350]++;$$invalidate(14,valid=$$props.valid);}else {cov_2ayk1lyqd0().b[94][1]++;}cov_2ayk1lyqd0().s[351]++;if('validated'in $$props){cov_2ayk1lyqd0().b[95][0]++;cov_2ayk1lyqd0().s[352]++;$$invalidate(15,validated=$$props.validated);}else {cov_2ayk1lyqd0().b[95][1]++;}cov_2ayk1lyqd0().s[353]++;if('errors'in $$props){cov_2ayk1lyqd0().b[96][0]++;cov_2ayk1lyqd0().s[354]++;$$invalidate(16,errors=$$props.errors);}else {cov_2ayk1lyqd0().b[96][1]++;}cov_2ayk1lyqd0().s[355]++;if('formErrors'in $$props){cov_2ayk1lyqd0().b[97][0]++;cov_2ayk1lyqd0().s[356]++;$$invalidate(17,formErrors=$$props.formErrors);}else {cov_2ayk1lyqd0().b[97][1]++;}cov_2ayk1lyqd0().s[357]++;if('formLevelError'in $$props){cov_2ayk1lyqd0().b[98][0]++;cov_2ayk1lyqd0().s[358]++;$$invalidate(18,formLevelError=$$props.formLevelError);}else {cov_2ayk1lyqd0().b[98][1]++;}};cov_2ayk1lyqd0().s[359]++;$$self.$$.update=()=>{cov_2ayk1lyqd0().f[66]++;cov_2ayk1lyqd0().s[360]++;if($$self.$$.dirty[0]&/*errors, formErrors*/196608){cov_2ayk1lyqd0().b[99][0]++;cov_2ayk1lyqd0().s[361]++;cov_2ayk1lyqd0().s[362]++;$$invalidate(7,allErrors=[].concat(errors?(cov_2ayk1lyqd0().b[100][0]++,errors):(cov_2ayk1lyqd0().b[100][1]++,[]),formErrors?(cov_2ayk1lyqd0().b[101][0]++,formErrors):(cov_2ayk1lyqd0().b[101][1]++,[])));}else {cov_2ayk1lyqd0().b[99][1]++;}cov_2ayk1lyqd0().s[363]++;if($$self.$$.dirty[0]&/*validated, valid, inputStarted*/53248){cov_2ayk1lyqd0().b[102][0]++;cov_2ayk1lyqd0().s[364]++;cov_2ayk1lyqd0().s[365]++;$$invalidate(6,showErrors=(cov_2ayk1lyqd0().b[103][0]++,!((cov_2ayk1lyqd0().b[104][0]++,validated)&&(cov_2ayk1lyqd0().b[104][1]++,valid)))&&(cov_2ayk1lyqd0().b[103][1]++,inputStarted));}else {cov_2ayk1lyqd0().b[102][1]++;}cov_2ayk1lyqd0().s[366]++;if($$self.$$.dirty[0]&/*valid, formLevelError*/278528){cov_2ayk1lyqd0().b[105][0]++;cov_2ayk1lyqd0().s[367]++;cov_2ayk1lyqd0().s[368]++;(cov_2ayk1lyqd0().b[106][0]++,valid===false)||(cov_2ayk1lyqd0().b[106][1]++,formLevelError);}else {cov_2ayk1lyqd0().b[105][1]++;}cov_2ayk1lyqd0().s[369]++;if($$self.$$.dirty[0]&/*valid, inputStarted*/20480){cov_2ayk1lyqd0().b[107][0]++;cov_2ayk1lyqd0().s[370]++;cov_2ayk1lyqd0().s[371]++;$$invalidate(5,validationClasses=(cov_2ayk1lyqd0().b[109][0]++,valid===true)||(cov_2ayk1lyqd0().b[109][1]++,!inputStarted)?(cov_2ayk1lyqd0().b[108][0]++,UICommon.CLASS_OK):(cov_2ayk1lyqd0().b[108][1]++,UICommon.CLASS_ERR));}else {cov_2ayk1lyqd0().b[107][1]++;}cov_2ayk1lyqd0().s[372]++;if($$self.$$.dirty[0]&/*errors*/65536){cov_2ayk1lyqd0().b[110][0]++;cov_2ayk1lyqd0().s[373]++;cov_2ayk1lyqd0().s[374]++;$$invalidate(4,classes=errors?(cov_2ayk1lyqd0().b[111][0]++,"is-danger"):(cov_2ayk1lyqd0().b[111][1]++,""));}else {cov_2ayk1lyqd0().b[110][1]++;}};cov_2ayk1lyqd0().s[375]++;return [variants,fieldname,readonly,_value,classes,validationClasses,showErrors,allErrors,$LOCALE,UIErrorsList,remove,add,inputStarted,value,valid,validated,errors,formErrors,formLevelError,uierrorslist_errors_binding,uierrorslist_show_binding,uierrorslist_classes_binding];}class Ui_role extends SvelteComponent{constructor(options){cov_2ayk1lyqd0().f[67]++;cov_2ayk1lyqd0().s[376]++;super();cov_2ayk1lyqd0().s[377]++;init(this,options,instance$3,create_fragment$3,safe_not_equal,{inputStarted:12,value:13,variants:0,fieldname:1,readonly:2,valid:14,validated:15,errors:16,formErrors:17,formLevelError:18},null,[-1,-1]);}}

	function cov_27mkdstec8(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/common/UIUserInlineInfo.svelte";var hash="d7c456a4dbf2916ce4c5890f6fdca0304bd53d84";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/common/UIUserInlineInfo.svelte",statementMap:{"0":{start:{line:23,column:1},end:{line:30,column:5}},"1":{start:{line:32,column:1},end:{line:32,column:49}},"2":{start:{line:34,column:1},end:{line:59,column:3}},"3":{start:{line:36,column:3},end:{line:36,column:42}},"4":{start:{line:39,column:3},end:{line:39,column:45}},"5":{start:{line:40,column:3},end:{line:40,column:18}},"6":{start:{line:43,column:28},end:{line:43,column:30}},"7":{start:{line:44,column:3},end:{line:44,column:88}},"8":{start:{line:44,column:37},end:{line:44,column:88}},"9":{start:{line:45,column:3},end:{line:45,column:35}},"10":{start:{line:48,column:3},end:{line:48,column:23}},"11":{start:{line:48,column:16},end:{line:48,column:23}},"12":{start:{line:49,column:3},end:{line:49,column:46}},"13":{start:{line:50,column:3},end:{line:50,column:18}},"14":{start:{line:53,column:3},end:{line:53,column:47}},"15":{start:{line:54,column:3},end:{line:54,column:19}},"16":{start:{line:57,column:3},end:{line:57,column:42}},"17":{start:{line:64,column:18},end:{line:64,column:41}},"18":{start:{line:65,column:23},end:{line:65,column:30}},"19":{start:{line:66,column:32},end:{line:66,column:39}},"20":{start:{line:67,column:73},end:{line:67,column:80}},"21":{start:{line:67,column:35},end:{line:67,column:68}},"22":{start:{line:70,column:2},end:{line:70,column:35}},"23":{start:{line:73,column:1},end:{line:77,column:3}},"24":{start:{line:74,column:2},end:{line:74,column:68}},"25":{start:{line:74,column:27},end:{line:74,column:68}},"26":{start:{line:75,column:2},end:{line:75,column:74}},"27":{start:{line:75,column:29},end:{line:75,column:74}},"28":{start:{line:76,column:2},end:{line:76,column:101}},"29":{start:{line:76,column:38},end:{line:76,column:101}},"30":{start:{line:79,column:1},end:{line:83,column:3}},"31":{start:{line:80,column:2},end:{line:82,column:3}},"32":{start:{line:81,column:3},end:{line:81,column:80}},"33":{start:{line:81,column:6},end:{line:81,column:80}},"34":{start:{line:85,column:1},end:{line:85,column:77}},"35":{start:{line:90,column:2},end:{line:90,column:10}},"36":{start:{line:92,column:2},end:{line:96,column:5}}},fnMap:{"0":{name:"create_fragment",decl:{start:{line:19,column:9},end:{line:19,column:24}},loc:{start:{line:19,column:30},end:{line:60,column:1}},line:19},"1":{name:"(anonymous_1)",decl:{start:{line:35,column:2},end:{line:35,column:3}},loc:{start:{line:35,column:6},end:{line:37,column:3}},line:35},"2":{name:"(anonymous_2)",decl:{start:{line:38,column:2},end:{line:38,column:3}},loc:{start:{line:38,column:20},end:{line:41,column:3}},line:38},"3":{name:"(anonymous_3)",decl:{start:{line:42,column:2},end:{line:42,column:3}},loc:{start:{line:42,column:18},end:{line:46,column:3}},line:42},"4":{name:"(anonymous_4)",decl:{start:{line:47,column:2},end:{line:47,column:3}},loc:{start:{line:47,column:11},end:{line:51,column:3}},line:47},"5":{name:"(anonymous_5)",decl:{start:{line:52,column:2},end:{line:52,column:3}},loc:{start:{line:52,column:11},end:{line:55,column:3}},line:52},"6":{name:"(anonymous_6)",decl:{start:{line:56,column:2},end:{line:56,column:3}},loc:{start:{line:56,column:15},end:{line:58,column:3}},line:56},"7":{name:"instance",decl:{start:{line:62,column:9},end:{line:62,column:17}},loc:{start:{line:62,column:49},end:{line:86,column:1}},line:62},"8":{name:"(anonymous_8)",decl:{start:{line:67,column:27},end:{line:67,column:28}},loc:{start:{line:67,column:35},end:{line:67,column:68}},line:67},"9":{name:"click_handler",decl:{start:{line:69,column:10},end:{line:69,column:23}},loc:{start:{line:69,column:31},end:{line:71,column:2}},line:69},"10":{name:"(anonymous_10)",decl:{start:{line:73,column:16},end:{line:73,column:17}},loc:{start:{line:73,column:27},end:{line:77,column:2}},line:73},"11":{name:"(anonymous_11)",decl:{start:{line:79,column:20},end:{line:79,column:21}},loc:{start:{line:79,column:26},end:{line:83,column:2}},line:79},"12":{name:"(anonymous_12)",decl:{start:{line:89,column:1},end:{line:89,column:2}},loc:{start:{line:89,column:22},end:{line:97,column:2}},line:89}},branchMap:{"0":{loc:{start:{line:44,column:3},end:{line:44,column:88}},type:"if",locations:[{start:{line:44,column:3},end:{line:44,column:88}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:44},"1":{loc:{start:{line:48,column:3},end:{line:48,column:23}},type:"if",locations:[{start:{line:48,column:3},end:{line:48,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:48},"2":{loc:{start:{line:65,column:7},end:{line:65,column:18}},type:"default-arg",locations:[{start:{line:65,column:16},end:{line:65,column:18}}],line:65},"3":{loc:{start:{line:66,column:7},end:{line:66,column:27}},type:"default-arg",locations:[{start:{line:66,column:18},end:{line:66,column:27}}],line:66},"4":{loc:{start:{line:67,column:7},end:{line:67,column:68}},type:"default-arg",locations:[{start:{line:67,column:27},end:{line:67,column:68}}],line:67},"5":{loc:{start:{line:74,column:2},end:{line:74,column:68}},type:"if",locations:[{start:{line:74,column:2},end:{line:74,column:68}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:74},"6":{loc:{start:{line:75,column:2},end:{line:75,column:74}},type:"if",locations:[{start:{line:75,column:2},end:{line:75,column:74}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:75},"7":{loc:{start:{line:76,column:2},end:{line:76,column:101}},type:"if",locations:[{start:{line:76,column:2},end:{line:76,column:101}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:76},"8":{loc:{start:{line:80,column:2},end:{line:82,column:3}},type:"if",locations:[{start:{line:80,column:2},end:{line:82,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:80}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0},b:{"0":[0,0],"1":[0,0],"2":[0],"3":[0],"4":[0],"5":[0,0],"6":[0,0],"7":[0,0],"8":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/common/UIUserInlineInfo.svelte"],sourcesContent:["<script>\n    import { createEventDispatcher } from \"svelte\";\n    const dispatch = createEventDispatcher();\n\n    import { UIButton } from \"not-bulma/src/elements/button\";\n    import { UITitle } from \"not-bulma/src/elements/various\";\n\n    export let userID = -1;\n    export let username = \"no_name\";\n    export let usernameFormatter = (data) => `${data.userID}#${data.username}`;\n\n    $: usernameString = usernameFormatter({ username, userID });\n</script>\n\n<UIButton\n    classes=\"user-inline-info\"\n    on:click\n    icon={\"user\"}\n    iconSide={\"left\"}\n    title={usernameString}\n/>\n"],names:[],mappings:";;;;;;;;;;;;;;SACa,qBAAqB,QAAQ,QAAQ;SAGrC,QAAQ,QAAQ,+BAA+B;SAC/C,OAAO,QAAQ,gCAAgC;;;;;;;;;UAYlD,MAAM;cACF,MAAM;8BACT,GAAc;;;;;;;;;;;;;;;;iFAAd,GAAc;;;;;;;;;;;;;;;;;;;;OAjBf,QAAQ,GAAG,qBAAqB;OAK3B,MAAM,IAAI,CAAC;OACX,QAAQ,GAAG,SAAS;OACpB,iBAAiB,GAAI,IAAI,OAAQ,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ;;;;;;;;;;;;;;GAExE,CAAC,kBAAE,cAAc,GAAG,iBAAiB,GAAG,QAAQ,EAAE,MAAM;;;;;;;;;;;;;;;;;;;",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"d7c456a4dbf2916ce4c5890f6fdca0304bd53d84"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_27mkdstec8=function(){return actualCoverage;};}return actualCoverage;}cov_27mkdstec8();function create_fragment$2(ctx){cov_27mkdstec8().f[0]++;let uibutton;let current;cov_27mkdstec8().s[0]++;uibutton=new Ui_button({props:{classes:"user-inline-info",icon:"user",iconSide:"left",title:/*usernameString*/ctx[0]}});cov_27mkdstec8().s[1]++;uibutton.$on("click",/*click_handler*/ctx[4]);cov_27mkdstec8().s[2]++;return {c(){cov_27mkdstec8().f[1]++;cov_27mkdstec8().s[3]++;create_component(uibutton.$$.fragment);},m(target,anchor){cov_27mkdstec8().f[2]++;cov_27mkdstec8().s[4]++;mount_component(uibutton,target,anchor);cov_27mkdstec8().s[5]++;current=true;},p(ctx,[dirty]){cov_27mkdstec8().f[3]++;const uibutton_changes=(cov_27mkdstec8().s[6]++,{});cov_27mkdstec8().s[7]++;if(dirty&/*usernameString*/1){cov_27mkdstec8().b[0][0]++;cov_27mkdstec8().s[8]++;uibutton_changes.title=/*usernameString*/ctx[0];}else {cov_27mkdstec8().b[0][1]++;}cov_27mkdstec8().s[9]++;uibutton.$set(uibutton_changes);},i(local){cov_27mkdstec8().f[4]++;cov_27mkdstec8().s[10]++;if(current){cov_27mkdstec8().b[1][0]++;cov_27mkdstec8().s[11]++;return;}else {cov_27mkdstec8().b[1][1]++;}cov_27mkdstec8().s[12]++;transition_in(uibutton.$$.fragment,local);cov_27mkdstec8().s[13]++;current=true;},o(local){cov_27mkdstec8().f[5]++;cov_27mkdstec8().s[14]++;transition_out(uibutton.$$.fragment,local);cov_27mkdstec8().s[15]++;current=false;},d(detaching){cov_27mkdstec8().f[6]++;cov_27mkdstec8().s[16]++;destroy_component(uibutton,detaching);}};}function instance$2($$self,$$props,$$invalidate){cov_27mkdstec8().f[7]++;let usernameString;(cov_27mkdstec8().s[17]++,createEventDispatcher());let{userID=(cov_27mkdstec8().b[2][0]++,-1)}=(cov_27mkdstec8().s[18]++,$$props);let{username=(cov_27mkdstec8().b[3][0]++,"no_name")}=(cov_27mkdstec8().s[19]++,$$props);let{usernameFormatter=(cov_27mkdstec8().b[4][0]++,data=>{cov_27mkdstec8().f[8]++;cov_27mkdstec8().s[21]++;return `${data.userID}#${data.username}`;})}=(cov_27mkdstec8().s[20]++,$$props);function click_handler(event){cov_27mkdstec8().f[9]++;cov_27mkdstec8().s[22]++;bubble.call(this,$$self,event);}cov_27mkdstec8().s[23]++;$$self.$$set=$$props=>{cov_27mkdstec8().f[10]++;cov_27mkdstec8().s[24]++;if('userID'in $$props){cov_27mkdstec8().b[5][0]++;cov_27mkdstec8().s[25]++;$$invalidate(1,userID=$$props.userID);}else {cov_27mkdstec8().b[5][1]++;}cov_27mkdstec8().s[26]++;if('username'in $$props){cov_27mkdstec8().b[6][0]++;cov_27mkdstec8().s[27]++;$$invalidate(2,username=$$props.username);}else {cov_27mkdstec8().b[6][1]++;}cov_27mkdstec8().s[28]++;if('usernameFormatter'in $$props){cov_27mkdstec8().b[7][0]++;cov_27mkdstec8().s[29]++;$$invalidate(3,usernameFormatter=$$props.usernameFormatter);}else {cov_27mkdstec8().b[7][1]++;}};cov_27mkdstec8().s[30]++;$$self.$$.update=()=>{cov_27mkdstec8().f[11]++;cov_27mkdstec8().s[31]++;if($$self.$$.dirty&/*usernameFormatter, username, userID*/14){cov_27mkdstec8().b[8][0]++;cov_27mkdstec8().s[32]++;cov_27mkdstec8().s[33]++;$$invalidate(0,usernameString=usernameFormatter({username,userID}));}else {cov_27mkdstec8().b[8][1]++;}};cov_27mkdstec8().s[34]++;return [usernameString,userID,username,usernameFormatter,click_handler];}class UIUserInlineInfo extends SvelteComponent{constructor(options){cov_27mkdstec8().f[12]++;cov_27mkdstec8().s[35]++;super();cov_27mkdstec8().s[36]++;init(this,options,instance$2,create_fragment$2,safe_not_equal,{userID:1,username:2,usernameFormatter:3});}}

	function cov_1j72yc5n81(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/common/UISelectUser.svelte";var hash="5848d53392501aa016f655f3be4ddcb8da4458db";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/common/UISelectUser.svelte",statementMap:{"0":{start:{line:38,column:1},end:{line:45,column:5}},"1":{start:{line:47,column:1},end:{line:68,column:3}},"2":{start:{line:49,column:3},end:{line:49,column:42}},"3":{start:{line:52,column:3},end:{line:52,column:45}},"4":{start:{line:53,column:3},end:{line:53,column:18}},"5":{start:{line:57,column:3},end:{line:57,column:23}},"6":{start:{line:57,column:16},end:{line:57,column:23}},"7":{start:{line:58,column:3},end:{line:58,column:46}},"8":{start:{line:59,column:3},end:{line:59,column:18}},"9":{start:{line:62,column:3},end:{line:62,column:47}},"10":{start:{line:63,column:3},end:{line:63,column:19}},"11":{start:{line:66,column:3},end:{line:66,column:42}},"12":{start:{line:75,column:40},end:{line:75,column:61}},"13":{start:{line:76,column:30},end:{line:76,column:32}},"14":{start:{line:78,column:1},end:{line:80,column:2}},"15":{start:{line:78,column:14},end:{line:78,column:15}},"16":{start:{line:79,column:2},end:{line:79,column:93}},"17":{start:{line:82,column:1},end:{line:82,column:76}},"18":{start:{line:84,column:1},end:{line:111,column:3}},"19":{start:{line:86,column:3},end:{line:86,column:50}},"20":{start:{line:89,column:3},end:{line:89,column:53}},"21":{start:{line:90,column:3},end:{line:90,column:18}},"22":{start:{line:93,column:36},end:{line:95,column:7}},"23":{start:{line:97,column:3},end:{line:97,column:51}},"24":{start:{line:100,column:3},end:{line:100,column:23}},"25":{start:{line:100,column:16},end:{line:100,column:23}},"26":{start:{line:101,column:3},end:{line:101,column:54}},"27":{start:{line:102,column:3},end:{line:102,column:18}},"28":{start:{line:105,column:3},end:{line:105,column:55}},"29":{start:{line:106,column:3},end:{line:106,column:19}},"30":{start:{line:109,column:3},end:{line:109,column:50}},"31":{start:{line:119,column:1},end:{line:127,column:5}},"32":{start:{line:129,column:1},end:{line:150,column:3}},"33":{start:{line:131,column:3},end:{line:131,column:42}},"34":{start:{line:134,column:3},end:{line:134,column:45}},"35":{start:{line:135,column:3},end:{line:135,column:18}},"36":{start:{line:139,column:3},end:{line:139,column:23}},"37":{start:{line:139,column:16},end:{line:139,column:23}},"38":{start:{line:140,column:3},end:{line:140,column:46}},"39":{start:{line:141,column:3},end:{line:141,column:18}},"40":{start:{line:144,column:3},end:{line:144,column:47}},"41":{start:{line:145,column:3},end:{line:145,column:19}},"42":{start:{line:148,column:3},end:{line:148,column:42}},"43":{start:{line:159,column:27},end:{line:159,column:84}},"44":{start:{line:160,column:19},end:{line:160,column:21}},"45":{start:{line:163,column:2},end:{line:163,column:35}},"46":{start:{line:163,column:26},end:{line:163,column:35}},"47":{start:{line:164,column:2},end:{line:164,column:44}},"48":{start:{line:164,column:35},end:{line:164,column:44}},"49":{start:{line:165,column:2},end:{line:165,column:11}},"50":{start:{line:168,column:1},end:{line:168,column:61}},"51":{start:{line:169,column:1},end:{line:169,column:99}},"52":{start:{line:171,column:1},end:{line:225,column:3}},"53":{start:{line:173,column:3},end:{line:173,column:24}},"54":{start:{line:174,column:3},end:{line:174,column:16}},"55":{start:{line:175,column:3},end:{line:175,column:33}},"56":{start:{line:178,column:3},end:{line:178,column:31}},"57":{start:{line:179,column:3},end:{line:179,column:52}},"58":{start:{line:180,column:3},end:{line:180,column:18}},"59":{start:{line:183,column:30},end:{line:183,column:54}},"60":{start:{line:184,column:3},end:{line:184,column:60}},"61":{start:{line:186,column:3},end:{line:207,column:4}},"62":{start:{line:187,column:4},end:{line:187,column:54}},"63":{start:{line:189,column:4},end:{line:189,column:19}},"64":{start:{line:191,column:4},end:{line:193,column:7}},"65":{start:{line:192,column:5},end:{line:192,column:44}},"66":{start:{line:195,column:4},end:{line:195,column:19}},"67":{start:{line:196,column:4},end:{line:196,column:51}},"68":{start:{line:198,column:4},end:{line:203,column:5}},"69":{start:{line:199,column:5},end:{line:199,column:103}},"70":{start:{line:200,column:5},end:{line:200,column:18}},"71":{start:{line:202,column:5},end:{line:202,column:28}},"72":{start:{line:205,column:4},end:{line:205,column:31}},"73":{start:{line:206,column:4},end:{line:206,column:26}},"74":{start:{line:210,column:3},end:{line:210,column:23}},"75":{start:{line:210,column:16},end:{line:210,column:23}},"76":{start:{line:211,column:3},end:{line:211,column:27}},"77":{start:{line:212,column:3},end:{line:212,column:18}},"78":{start:{line:215,column:3},end:{line:215,column:28}},"79":{start:{line:216,column:3},end:{line:216,column:19}},"80":{start:{line:219,column:3},end:{line:221,column:4}},"81":{start:{line:220,column:4},end:{line:220,column:16}},"82":{start:{line:223,column:3},end:{line:223,column:43}},"83":{start:{line:233,column:1},end:{line:240,column:5}},"84":{start:{line:242,column:1},end:{line:272,column:3}},"85":{start:{line:244,column:3},end:{line:244,column:42}},"86":{start:{line:247,column:3},end:{line:247,column:45}},"87":{start:{line:248,column:3},end:{line:248,column:18}},"88":{start:{line:251,column:28},end:{line:251,column:30}},"89":{start:{line:252,column:3},end:{line:252,column:77}},"90":{start:{line:252,column:33},end:{line:252,column:77}},"91":{start:{line:254,column:3},end:{line:256,column:4}},"92":{start:{line:255,column:4},end:{line:255,column:46}},"93":{start:{line:258,column:3},end:{line:258,column:35}},"94":{start:{line:261,column:3},end:{line:261,column:23}},"95":{start:{line:261,column:16},end:{line:261,column:23}},"96":{start:{line:262,column:3},end:{line:262,column:46}},"97":{start:{line:263,column:3},end:{line:263,column:18}},"98":{start:{line:266,column:3},end:{line:266,column:47}},"99":{start:{line:267,column:3},end:{line:267,column:19}},"100":{start:{line:270,column:3},end:{line:270,column:42}},"101":{start:{line:286,column:1},end:{line:288,column:5}},"102":{start:{line:291,column:34},end:{line:291,column:49}},"103":{start:{line:295,column:32},end:{line:295,column:47}},"104":{start:{line:299,column:35},end:{line:299,column:50}},"105":{start:{line:302,column:26},end:{line:304,column:2}},"106":{start:{line:306,column:1},end:{line:308,column:2}},"107":{start:{line:307,column:2},end:{line:307,column:51}},"108":{start:{line:310,column:1},end:{line:312,column:2}},"109":{start:{line:311,column:2},end:{line:311,column:50}},"110":{start:{line:314,column:1},end:{line:316,column:2}},"111":{start:{line:315,column:2},end:{line:315,column:60}},"112":{start:{line:318,column:1},end:{line:318,column:76}},"113":{start:{line:319,column:1},end:{line:319,column:89}},"114":{start:{line:319,column:30},end:{line:319,column:87}},"115":{start:{line:320,column:1},end:{line:320,column:85}},"116":{start:{line:320,column:30},end:{line:320,column:83}},"117":{start:{line:321,column:1},end:{line:321,column:91}},"118":{start:{line:321,column:30},end:{line:321,column:89}},"119":{start:{line:323,column:1},end:{line:385,column:3}},"120":{start:{line:325,column:3},end:{line:325,column:24}},"121":{start:{line:326,column:3},end:{line:326,column:43}},"122":{start:{line:327,column:3},end:{line:327,column:15}},"123":{start:{line:328,column:3},end:{line:328,column:46}},"124":{start:{line:329,column:3},end:{line:329,column:33}},"125":{start:{line:332,column:3},end:{line:332,column:31}},"126":{start:{line:333,column:3},end:{line:333,column:41}},"127":{start:{line:334,column:3},end:{line:334,column:29}},"128":{start:{line:335,column:3},end:{line:335,column:49}},"129":{start:{line:336,column:3},end:{line:336,column:18}},"130":{start:{line:339,column:29},end:{line:339,column:31}},"131":{start:{line:340,column:3},end:{line:340,column:96}},"132":{start:{line:340,column:42},end:{line:340,column:96}},"133":{start:{line:341,column:3},end:{line:341,column:37}},"134":{start:{line:342,column:32},end:{line:342,column:34}},"135":{start:{line:343,column:3},end:{line:343,column:106}},"136":{start:{line:343,column:35},end:{line:343,column:106}},"137":{start:{line:345,column:3},end:{line:349,column:4}},"138":{start:{line:346,column:4},end:{line:346,column:27}},"139":{start:{line:347,column:4},end:{line:347,column:55}},"140":{start:{line:348,column:4},end:{line:348,column:54}},"141":{start:{line:348,column:29},end:{line:348,column:52}},"142":{start:{line:351,column:3},end:{line:355,column:4}},"143":{start:{line:352,column:4},end:{line:352,column:25}},"144":{start:{line:353,column:4},end:{line:353,column:54}},"145":{start:{line:354,column:4},end:{line:354,column:52}},"146":{start:{line:354,column:29},end:{line:354,column:50}},"147":{start:{line:357,column:3},end:{line:361,column:4}},"148":{start:{line:358,column:4},end:{line:358,column:28}},"149":{start:{line:359,column:4},end:{line:359,column:64}},"150":{start:{line:360,column:4},end:{line:360,column:55}},"151":{start:{line:360,column:29},end:{line:360,column:53}},"152":{start:{line:363,column:3},end:{line:363,column:43}},"153":{start:{line:366,column:3},end:{line:366,column:23}},"154":{start:{line:366,column:16},end:{line:366,column:23}},"155":{start:{line:367,column:3},end:{line:367,column:47}},"156":{start:{line:368,column:3},end:{line:368,column:50}},"157":{start:{line:369,column:3},end:{line:369,column:18}},"158":{start:{line:372,column:3},end:{line:372,column:48}},"159":{start:{line:373,column:3},end:{line:373,column:51}},"160":{start:{line:374,column:3},end:{line:374,column:19}},"161":{start:{line:377,column:3},end:{line:380,column:4}},"162":{start:{line:378,column:4},end:{line:378,column:16}},"163":{start:{line:379,column:4},end:{line:379,column:14}},"164":{start:{line:382,column:3},end:{line:382,column:32}},"165":{start:{line:383,column:3},end:{line:383,column:46}},"166":{start:{line:395,column:1},end:{line:402,column:5}},"167":{start:{line:404,column:16},end:{line:404,column:60}},"168":{start:{line:406,column:1},end:{line:474,column:3}},"169":{start:{line:408,column:3},end:{line:408,column:42}},"170":{start:{line:409,column:3},end:{line:409,column:15}},"171":{start:{line:410,column:3},end:{line:410,column:30}},"172":{start:{line:410,column:17},end:{line:410,column:30}},"173":{start:{line:411,column:3},end:{line:411,column:29}},"174":{start:{line:414,column:3},end:{line:414,column:45}},"175":{start:{line:415,column:3},end:{line:415,column:29}},"176":{start:{line:416,column:3},end:{line:416,column:44}},"177":{start:{line:416,column:17},end:{line:416,column:44}},"178":{start:{line:417,column:3},end:{line:417,column:43}},"179":{start:{line:418,column:3},end:{line:418,column:18}},"180":{start:{line:421,column:28},end:{line:421,column:30}},"181":{start:{line:422,column:3},end:{line:422,column:100}},"182":{start:{line:422,column:44},end:{line:422,column:100}},"183":{start:{line:423,column:3},end:{line:423,column:77}},"184":{start:{line:423,column:33},end:{line:423,column:77}},"185":{start:{line:425,column:3},end:{line:427,column:4}},"186":{start:{line:426,column:4},end:{line:426,column:46}},"187":{start:{line:429,column:3},end:{line:429,column:35}},"188":{start:{line:431,column:3},end:{line:452,column:4}},"189":{start:{line:432,column:4},end:{line:443,column:5}},"190":{start:{line:433,column:5},end:{line:433,column:28}},"191":{start:{line:435,column:5},end:{line:437,column:6}},"192":{start:{line:436,column:6},end:{line:436,column:33}},"193":{start:{line:439,column:5},end:{line:439,column:37}},"194":{start:{line:440,column:5},end:{line:440,column:18}},"195":{start:{line:441,column:5},end:{line:441,column:32}},"196":{start:{line:442,column:5},end:{line:442,column:61}},"197":{start:{line:444,column:10},end:{line:452,column:4}},"198":{start:{line:445,column:4},end:{line:445,column:19}},"199":{start:{line:447,column:4},end:{line:449,column:7}},"200":{start:{line:448,column:5},end:{line:448,column:21}},"201":{start:{line:451,column:4},end:{line:451,column:19}},"202":{start:{line:455,column:3},end:{line:455,column:23}},"203":{start:{line:455,column:16},end:{line:455,column:23}},"204":{start:{line:456,column:3},end:{line:456,column:46}},"205":{start:{line:457,column:3},end:{line:457,column:27}},"206":{start:{line:458,column:3},end:{line:458,column:18}},"207":{start:{line:461,column:3},end:{line:461,column:47}},"208":{start:{line:462,column:3},end:{line:462,column:28}},"209":{start:{line:463,column:3},end:{line:463,column:19}},"210":{start:{line:466,column:3},end:{line:469,column:4}},"211":{start:{line:467,column:4},end:{line:467,column:14}},"212":{start:{line:468,column:4},end:{line:468,column:28}},"213":{start:{line:471,column:3},end:{line:471,column:42}},"214":{start:{line:472,column:3},end:{line:472,column:39}},"215":{start:{line:472,column:17},end:{line:472,column:39}},"216":{start:{line:481,column:1},end:{line:486,column:5}},"217":{start:{line:488,column:1},end:{line:517,column:3}},"218":{start:{line:490,column:3},end:{line:490,column:43}},"219":{start:{line:493,column:3},end:{line:493,column:46}},"220":{start:{line:494,column:3},end:{line:494,column:18}},"221":{start:{line:497,column:29},end:{line:497,column:31}},"222":{start:{line:499,column:3},end:{line:501,column:4}},"223":{start:{line:500,column:4},end:{line:500,column:47}},"224":{start:{line:503,column:3},end:{line:503,column:37}},"225":{start:{line:506,column:3},end:{line:506,column:23}},"226":{start:{line:506,column:16},end:{line:506,column:23}},"227":{start:{line:507,column:3},end:{line:507,column:47}},"228":{start:{line:508,column:3},end:{line:508,column:18}},"229":{start:{line:511,column:3},end:{line:511,column:48}},"230":{start:{line:512,column:3},end:{line:512,column:19}},"231":{start:{line:515,column:3},end:{line:515,column:43}},"232":{start:{line:525,column:23},end:{line:525,column:39}},"233":{start:{line:526,column:26},end:{line:526,column:42}},"234":{start:{line:527,column:33},end:{line:527,column:49}},"235":{start:{line:528,column:22},end:{line:528,column:30}},"236":{start:{line:529,column:16},end:{line:529,column:39}},"237":{start:{line:530,column:17},end:{line:530,column:24}},"238":{start:{line:531,column:32},end:{line:531,column:39}},"239":{start:{line:532,column:30},end:{line:532,column:37}},"240":{start:{line:533,column:28},end:{line:533,column:35}},"241":{start:{line:534,column:24},end:{line:534,column:31}},"242":{start:{line:535,column:29},end:{line:535,column:36}},"243":{start:{line:536,column:26},end:{line:536,column:33}},"244":{start:{line:537,column:30},end:{line:537,column:37}},"245":{start:{line:538,column:34},end:{line:538,column:41}},"246":{start:{line:539,column:34},end:{line:539,column:41}},"247":{start:{line:540,column:27},end:{line:540,column:34}},"248":{start:{line:541,column:27},end:{line:541,column:34}},"249":{start:{line:542,column:26},end:{line:542,column:33}},"250":{start:{line:545,column:2},end:{line:545,column:52}},"251":{start:{line:549,column:2},end:{line:558,column:5}},"252":{start:{line:550,column:3},end:{line:550,column:41}},"253":{start:{line:551,column:3},end:{line:551,column:39}},"254":{start:{line:552,column:3},end:{line:552,column:16}},"255":{start:{line:554,column:3},end:{line:554,column:41}},"256":{start:{line:555,column:3},end:{line:555,column:51}},"257":{start:{line:557,column:3},end:{line:557,column:23}},"258":{start:{line:562,column:2},end:{line:562,column:38}},"259":{start:{line:563,column:2},end:{line:563,column:35}},"260":{start:{line:564,column:2},end:{line:564,column:50}},"261":{start:{line:568,column:2},end:{line:577,column:3}},"262":{start:{line:569,column:3},end:{line:572,column:4}},"263":{start:{line:570,column:4},end:{line:570,column:36}},"264":{start:{line:571,column:4},end:{line:571,column:71}},"265":{start:{line:574,column:3},end:{line:574,column:23}},"266":{start:{line:576,column:3},end:{line:576,column:36}},"267":{start:{line:580,column:1},end:{line:582,column:4}},"268":{start:{line:581,column:2},end:{line:581,column:17}},"269":{start:{line:584,column:27},end:{line:596,column:2}},"270":{start:{line:598,column:23},end:{line:598,column:25}},"271":{start:{line:601,column:2},end:{line:601,column:20}},"272":{start:{line:602,column:2},end:{line:602,column:89}},"273":{start:{line:606,column:2},end:{line:606,column:21}},"274":{start:{line:607,column:2},end:{line:607,column:122}},"275":{start:{line:611,column:2},end:{line:611,column:28}},"276":{start:{line:612,column:2},end:{line:612,column:98}},"277":{start:{line:615,column:1},end:{line:629,column:3}},"278":{start:{line:616,column:2},end:{line:616,column:66}},"279":{start:{line:616,column:26},end:{line:616,column:66}},"280":{start:{line:617,column:2},end:{line:617,column:87}},"281":{start:{line:617,column:33},end:{line:617,column:87}},"282":{start:{line:618,column:2},end:{line:618,column:77}},"283":{start:{line:618,column:30},end:{line:618,column:77}},"284":{start:{line:619,column:2},end:{line:619,column:74}},"285":{start:{line:619,column:29},end:{line:619,column:74}},"286":{start:{line:620,column:2},end:{line:620,column:66}},"287":{start:{line:620,column:26},end:{line:620,column:66}},"288":{start:{line:621,column:2},end:{line:621,column:78}},"289":{start:{line:621,column:30},end:{line:621,column:78}},"290":{start:{line:622,column:2},end:{line:622,column:69}},"291":{start:{line:622,column:27},end:{line:622,column:69}},"292":{start:{line:623,column:2},end:{line:623,column:81}},"293":{start:{line:623,column:31},end:{line:623,column:81}},"294":{start:{line:624,column:2},end:{line:624,column:93}},"295":{start:{line:624,column:35},end:{line:624,column:93}},"296":{start:{line:625,column:2},end:{line:625,column:84}},"297":{start:{line:625,column:32},end:{line:625,column:84}},"298":{start:{line:626,column:2},end:{line:626,column:74}},"299":{start:{line:626,column:29},end:{line:626,column:74}},"300":{start:{line:627,column:2},end:{line:627,column:71}},"301":{start:{line:627,column:28},end:{line:627,column:71}},"302":{start:{line:628,column:2},end:{line:628,column:68}},"303":{start:{line:628,column:27},end:{line:628,column:68}},"304":{start:{line:631,column:1},end:{line:659,column:3}},"305":{start:{line:632,column:2},end:{line:634,column:3}},"306":{start:{line:633,column:3},end:{line:633,column:97}},"307":{start:{line:633,column:6},end:{line:633,column:97}},"308":{start:{line:636,column:2},end:{line:638,column:3}},"309":{start:{line:637,column:3},end:{line:637,column:74}},"310":{start:{line:637,column:6},end:{line:637,column:74}},"311":{start:{line:640,column:2},end:{line:642,column:3}},"312":{start:{line:641,column:3},end:{line:641,column:50}},"313":{start:{line:641,column:6},end:{line:641,column:50}},"314":{start:{line:644,column:2},end:{line:648,column:3}},"315":{start:{line:645,column:3},end:{line:647,column:25}},"316":{start:{line:645,column:6},end:{line:647,column:25}},"317":{start:{line:650,column:2},end:{line:658,column:3}},"318":{start:{line:651,column:3},end:{line:657,column:4}},"319":{start:{line:652,column:4},end:{line:656,column:5}},"320":{start:{line:653,column:5},end:{line:653,column:63}},"321":{start:{line:655,column:5},end:{line:655,column:63}},"322":{start:{line:661,column:1},end:{line:686,column:3}},"323":{start:{line:691,column:2},end:{line:691,column:10}},"324":{start:{line:693,column:2},end:{line:716,column:4}}},fnMap:{"0":{name:"create_else_block",decl:{start:{line:34,column:9},end:{line:34,column:26}},loc:{start:{line:34,column:32},end:{line:69,column:1}},line:34},"1":{name:"(anonymous_1)",decl:{start:{line:48,column:2},end:{line:48,column:3}},loc:{start:{line:48,column:6},end:{line:50,column:3}},line:48},"2":{name:"(anonymous_2)",decl:{start:{line:51,column:2},end:{line:51,column:3}},loc:{start:{line:51,column:20},end:{line:54,column:3}},line:51},"3":{name:"(anonymous_3)",decl:{start:{line:56,column:2},end:{line:56,column:3}},loc:{start:{line:56,column:11},end:{line:60,column:3}},line:56},"4":{name:"(anonymous_4)",decl:{start:{line:61,column:2},end:{line:61,column:3}},loc:{start:{line:61,column:11},end:{line:64,column:3}},line:61},"5":{name:"(anonymous_5)",decl:{start:{line:65,column:2},end:{line:65,column:3}},loc:{start:{line:65,column:15},end:{line:67,column:3}},line:65},"6":{name:"create_if_block_2",decl:{start:{line:72,column:9},end:{line:72,column:26}},loc:{start:{line:72,column:32},end:{line:112,column:1}},line:72},"7":{name:"(anonymous_7)",decl:{start:{line:85,column:2},end:{line:85,column:3}},loc:{start:{line:85,column:6},end:{line:87,column:3}},line:85},"8":{name:"(anonymous_8)",decl:{start:{line:88,column:2},end:{line:88,column:3}},loc:{start:{line:88,column:20},end:{line:91,column:3}},line:88},"9":{name:"(anonymous_9)",decl:{start:{line:92,column:2},end:{line:92,column:3}},loc:{start:{line:92,column:16},end:{line:98,column:3}},line:92},"10":{name:"(anonymous_10)",decl:{start:{line:99,column:2},end:{line:99,column:3}},loc:{start:{line:99,column:11},end:{line:103,column:3}},line:99},"11":{name:"(anonymous_11)",decl:{start:{line:104,column:2},end:{line:104,column:3}},loc:{start:{line:104,column:11},end:{line:107,column:3}},line:104},"12":{name:"(anonymous_12)",decl:{start:{line:108,column:2},end:{line:108,column:3}},loc:{start:{line:108,column:15},end:{line:110,column:3}},line:108},"13":{name:"create_if_block_1",decl:{start:{line:115,column:9},end:{line:115,column:26}},loc:{start:{line:115,column:32},end:{line:151,column:1}},line:115},"14":{name:"(anonymous_14)",decl:{start:{line:130,column:2},end:{line:130,column:3}},loc:{start:{line:130,column:6},end:{line:132,column:3}},line:130},"15":{name:"(anonymous_15)",decl:{start:{line:133,column:2},end:{line:133,column:3}},loc:{start:{line:133,column:20},end:{line:136,column:3}},line:133},"16":{name:"(anonymous_16)",decl:{start:{line:138,column:2},end:{line:138,column:3}},loc:{start:{line:138,column:11},end:{line:142,column:3}},line:138},"17":{name:"(anonymous_17)",decl:{start:{line:143,column:2},end:{line:143,column:3}},loc:{start:{line:143,column:11},end:{line:146,column:3}},line:143},"18":{name:"(anonymous_18)",decl:{start:{line:147,column:2},end:{line:147,column:3}},loc:{start:{line:147,column:15},end:{line:149,column:3}},line:147},"19":{name:"create_default_slot_2",decl:{start:{line:154,column:9},end:{line:154,column:30}},loc:{start:{line:154,column:36},end:{line:226,column:1}},line:154},"20":{name:"select_block_type",decl:{start:{line:162,column:10},end:{line:162,column:27}},loc:{start:{line:162,column:40},end:{line:166,column:2}},line:162},"21":{name:"(anonymous_21)",decl:{start:{line:172,column:2},end:{line:172,column:3}},loc:{start:{line:172,column:6},end:{line:176,column:3}},line:172},"22":{name:"(anonymous_22)",decl:{start:{line:177,column:2},end:{line:177,column:3}},loc:{start:{line:177,column:20},end:{line:181,column:3}},line:177},"23":{name:"(anonymous_23)",decl:{start:{line:182,column:2},end:{line:182,column:3}},loc:{start:{line:182,column:16},end:{line:208,column:3}},line:182},"24":{name:"(anonymous_24)",decl:{start:{line:191,column:58},end:{line:191,column:59}},loc:{start:{line:191,column:64},end:{line:193,column:5}},line:191},"25":{name:"(anonymous_25)",decl:{start:{line:209,column:2},end:{line:209,column:3}},loc:{start:{line:209,column:11},end:{line:213,column:3}},line:209},"26":{name:"(anonymous_26)",decl:{start:{line:214,column:2},end:{line:214,column:3}},loc:{start:{line:214,column:11},end:{line:217,column:3}},line:214},"27":{name:"(anonymous_27)",decl:{start:{line:218,column:2},end:{line:218,column:3}},loc:{start:{line:218,column:15},end:{line:224,column:3}},line:218},"28":{name:"create_if_block",decl:{start:{line:229,column:9},end:{line:229,column:24}},loc:{start:{line:229,column:30},end:{line:273,column:1}},line:229},"29":{name:"(anonymous_29)",decl:{start:{line:243,column:2},end:{line:243,column:3}},loc:{start:{line:243,column:6},end:{line:245,column:3}},line:243},"30":{name:"(anonymous_30)",decl:{start:{line:246,column:2},end:{line:246,column:3}},loc:{start:{line:246,column:20},end:{line:249,column:3}},line:246},"31":{name:"(anonymous_31)",decl:{start:{line:250,column:2},end:{line:250,column:3}},loc:{start:{line:250,column:16},end:{line:259,column:3}},line:250},"32":{name:"(anonymous_32)",decl:{start:{line:260,column:2},end:{line:260,column:3}},loc:{start:{line:260,column:11},end:{line:264,column:3}},line:260},"33":{name:"(anonymous_33)",decl:{start:{line:265,column:2},end:{line:265,column:3}},loc:{start:{line:265,column:11},end:{line:268,column:3}},line:265},"34":{name:"(anonymous_34)",decl:{start:{line:269,column:2},end:{line:269,column:3}},loc:{start:{line:269,column:15},end:{line:271,column:3}},line:269},"35":{name:"create_default_slot_1",decl:{start:{line:276,column:9},end:{line:276,column:30}},loc:{start:{line:276,column:36},end:{line:386,column:1}},line:276},"36":{name:"uierrorslist_errors_binding",decl:{start:{line:290,column:10},end:{line:290,column:37}},loc:{start:{line:290,column:45},end:{line:292,column:2}},line:290},"37":{name:"uierrorslist_show_binding",decl:{start:{line:294,column:10},end:{line:294,column:35}},loc:{start:{line:294,column:43},end:{line:296,column:2}},line:294},"38":{name:"uierrorslist_classes_binding",decl:{start:{line:298,column:10},end:{line:298,column:38}},loc:{start:{line:298,column:46},end:{line:300,column:2}},line:298},"39":{name:"(anonymous_39)",decl:{start:{line:319,column:24},end:{line:319,column:25}},loc:{start:{line:319,column:30},end:{line:319,column:87}},line:319},"40":{name:"(anonymous_40)",decl:{start:{line:320,column:24},end:{line:320,column:25}},loc:{start:{line:320,column:30},end:{line:320,column:83}},line:320},"41":{name:"(anonymous_41)",decl:{start:{line:321,column:24},end:{line:321,column:25}},loc:{start:{line:321,column:30},end:{line:321,column:89}},line:321},"42":{name:"(anonymous_42)",decl:{start:{line:324,column:2},end:{line:324,column:3}},loc:{start:{line:324,column:6},end:{line:330,column:3}},line:324},"43":{name:"(anonymous_43)",decl:{start:{line:331,column:2},end:{line:331,column:3}},loc:{start:{line:331,column:20},end:{line:337,column:3}},line:331},"44":{name:"(anonymous_44)",decl:{start:{line:338,column:2},end:{line:338,column:3}},loc:{start:{line:338,column:16},end:{line:364,column:3}},line:338},"45":{name:"(anonymous_45)",decl:{start:{line:348,column:23},end:{line:348,column:24}},loc:{start:{line:348,column:29},end:{line:348,column:52}},line:348},"46":{name:"(anonymous_46)",decl:{start:{line:354,column:23},end:{line:354,column:24}},loc:{start:{line:354,column:29},end:{line:354,column:50}},line:354},"47":{name:"(anonymous_47)",decl:{start:{line:360,column:23},end:{line:360,column:24}},loc:{start:{line:360,column:29},end:{line:360,column:53}},line:360},"48":{name:"(anonymous_48)",decl:{start:{line:365,column:2},end:{line:365,column:3}},loc:{start:{line:365,column:11},end:{line:370,column:3}},line:365},"49":{name:"(anonymous_49)",decl:{start:{line:371,column:2},end:{line:371,column:3}},loc:{start:{line:371,column:11},end:{line:375,column:3}},line:371},"50":{name:"(anonymous_50)",decl:{start:{line:376,column:2},end:{line:376,column:3}},loc:{start:{line:376,column:15},end:{line:384,column:3}},line:376},"51":{name:"create_default_slot",decl:{start:{line:389,column:9},end:{line:389,column:28}},loc:{start:{line:389,column:34},end:{line:475,column:1}},line:389},"52":{name:"(anonymous_52)",decl:{start:{line:407,column:2},end:{line:407,column:3}},loc:{start:{line:407,column:6},end:{line:412,column:3}},line:407},"53":{name:"(anonymous_53)",decl:{start:{line:413,column:2},end:{line:413,column:3}},loc:{start:{line:413,column:20},end:{line:419,column:3}},line:413},"54":{name:"(anonymous_54)",decl:{start:{line:420,column:2},end:{line:420,column:3}},loc:{start:{line:420,column:16},end:{line:453,column:3}},line:420},"55":{name:"(anonymous_55)",decl:{start:{line:447,column:35},end:{line:447,column:36}},loc:{start:{line:447,column:41},end:{line:449,column:5}},line:447},"56":{name:"(anonymous_56)",decl:{start:{line:454,column:2},end:{line:454,column:3}},loc:{start:{line:454,column:11},end:{line:459,column:3}},line:454},"57":{name:"(anonymous_57)",decl:{start:{line:460,column:2},end:{line:460,column:3}},loc:{start:{line:460,column:11},end:{line:464,column:3}},line:460},"58":{name:"(anonymous_58)",decl:{start:{line:465,column:2},end:{line:465,column:3}},loc:{start:{line:465,column:15},end:{line:473,column:3}},line:465},"59":{name:"create_fragment",decl:{start:{line:477,column:9},end:{line:477,column:24}},loc:{start:{line:477,column:30},end:{line:518,column:1}},line:477},"60":{name:"(anonymous_60)",decl:{start:{line:489,column:2},end:{line:489,column:3}},loc:{start:{line:489,column:6},end:{line:491,column:3}},line:489},"61":{name:"(anonymous_61)",decl:{start:{line:492,column:2},end:{line:492,column:3}},loc:{start:{line:492,column:20},end:{line:495,column:3}},line:492},"62":{name:"(anonymous_62)",decl:{start:{line:496,column:2},end:{line:496,column:3}},loc:{start:{line:496,column:16},end:{line:504,column:3}},line:496},"63":{name:"(anonymous_63)",decl:{start:{line:505,column:2},end:{line:505,column:3}},loc:{start:{line:505,column:11},end:{line:509,column:3}},line:505},"64":{name:"(anonymous_64)",decl:{start:{line:510,column:2},end:{line:510,column:3}},loc:{start:{line:510,column:11},end:{line:513,column:3}},line:510},"65":{name:"(anonymous_65)",decl:{start:{line:514,column:2},end:{line:514,column:3}},loc:{start:{line:514,column:15},end:{line:516,column:3}},line:514},"66":{name:"instance",decl:{start:{line:520,column:9},end:{line:520,column:17}},loc:{start:{line:520,column:49},end:{line:687,column:1}},line:520},"67":{name:"getService",decl:{start:{line:544,column:10},end:{line:544,column:20}},loc:{start:{line:544,column:23},end:{line:546,column:2}},line:544},"68":{name:"openUserSearchAndSelect",decl:{start:{line:548,column:10},end:{line:548,column:33}},loc:{start:{line:548,column:36},end:{line:559,column:2}},line:548},"69":{name:"(anonymous_69)",decl:{start:{line:549,column:35},end:{line:549,column:36}},loc:{start:{line:549,column:46},end:{line:553,column:3}},line:549},"70":{name:"(anonymous_70)",decl:{start:{line:553,column:10},end:{line:553,column:11}},loc:{start:{line:553,column:19},end:{line:556,column:3}},line:553},"71":{name:"(anonymous_71)",decl:{start:{line:556,column:11},end:{line:556,column:12}},loc:{start:{line:556,column:16},end:{line:558,column:3}},line:556},"72":{name:"resetUser",decl:{start:{line:561,column:10},end:{line:561,column:19}},loc:{start:{line:561,column:22},end:{line:565,column:2}},line:561},"73":{name:"loadUserData",decl:{start:{line:567,column:16},end:{line:567,column:28}},loc:{start:{line:567,column:31},end:{line:578,column:2}},line:567},"74":{name:"(anonymous_74)",decl:{start:{line:580,column:9},end:{line:580,column:10}},loc:{start:{line:580,column:15},end:{line:582,column:2}},line:580},"75":{name:"uierrorslist_errors_binding",decl:{start:{line:600,column:10},end:{line:600,column:37}},loc:{start:{line:600,column:45},end:{line:603,column:2}},line:600},"76":{name:"uierrorslist_show_binding",decl:{start:{line:605,column:10},end:{line:605,column:35}},loc:{start:{line:605,column:43},end:{line:608,column:2}},line:605},"77":{name:"uierrorslist_classes_binding",decl:{start:{line:610,column:10},end:{line:610,column:38}},loc:{start:{line:610,column:46},end:{line:613,column:2}},line:610},"78":{name:"(anonymous_78)",decl:{start:{line:615,column:16},end:{line:615,column:17}},loc:{start:{line:615,column:27},end:{line:629,column:2}},line:615},"79":{name:"(anonymous_79)",decl:{start:{line:631,column:20},end:{line:631,column:21}},loc:{start:{line:631,column:26},end:{line:659,column:2}},line:631},"80":{name:"(anonymous_80)",decl:{start:{line:690,column:1},end:{line:690,column:2}},loc:{start:{line:690,column:22},end:{line:717,column:2}},line:690}},branchMap:{"0":{loc:{start:{line:57,column:3},end:{line:57,column:23}},type:"if",locations:[{start:{line:57,column:3},end:{line:57,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:57},"1":{loc:{start:{line:93,column:36},end:{line:95,column:7}},type:"cond-expr",locations:[{start:{line:94,column:5},end:{line:94,column:96}},{start:{line:95,column:5},end:{line:95,column:7}}],line:93},"2":{loc:{start:{line:100,column:3},end:{line:100,column:23}},type:"if",locations:[{start:{line:100,column:3},end:{line:100,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:100},"3":{loc:{start:{line:139,column:3},end:{line:139,column:23}},type:"if",locations:[{start:{line:139,column:3},end:{line:139,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:139},"4":{loc:{start:{line:163,column:2},end:{line:163,column:35}},type:"if",locations:[{start:{line:163,column:2},end:{line:163,column:35}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:163},"5":{loc:{start:{line:164,column:2},end:{line:164,column:44}},type:"if",locations:[{start:{line:164,column:2},end:{line:164,column:44}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:164},"6":{loc:{start:{line:186,column:3},end:{line:207,column:4}},type:"if",locations:[{start:{line:186,column:3},end:{line:207,column:4}},{start:{line:188,column:10},end:{line:207,column:4}}],line:186},"7":{loc:{start:{line:198,column:4},end:{line:203,column:5}},type:"if",locations:[{start:{line:198,column:4},end:{line:203,column:5}},{start:{line:201,column:11},end:{line:203,column:5}}],line:198},"8":{loc:{start:{line:210,column:3},end:{line:210,column:23}},type:"if",locations:[{start:{line:210,column:3},end:{line:210,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:210},"9":{loc:{start:{line:219,column:3},end:{line:221,column:4}},type:"if",locations:[{start:{line:219,column:3},end:{line:221,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:219},"10":{loc:{start:{line:252,column:3},end:{line:252,column:77}},type:"if",locations:[{start:{line:252,column:3},end:{line:252,column:77}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:252},"11":{loc:{start:{line:254,column:3},end:{line:256,column:4}},type:"if",locations:[{start:{line:254,column:3},end:{line:256,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:254},"12":{loc:{start:{line:261,column:3},end:{line:261,column:23}},type:"if",locations:[{start:{line:261,column:3},end:{line:261,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:261},"13":{loc:{start:{line:306,column:1},end:{line:308,column:2}},type:"if",locations:[{start:{line:306,column:1},end:{line:308,column:2}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:306},"14":{loc:{start:{line:310,column:1},end:{line:312,column:2}},type:"if",locations:[{start:{line:310,column:1},end:{line:312,column:2}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:310},"15":{loc:{start:{line:314,column:1},end:{line:316,column:2}},type:"if",locations:[{start:{line:314,column:1},end:{line:316,column:2}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:314},"16":{loc:{start:{line:340,column:3},end:{line:340,column:96}},type:"if",locations:[{start:{line:340,column:3},end:{line:340,column:96}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:340},"17":{loc:{start:{line:343,column:3},end:{line:343,column:106}},type:"if",locations:[{start:{line:343,column:3},end:{line:343,column:106}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:343},"18":{loc:{start:{line:345,column:3},end:{line:349,column:4}},type:"if",locations:[{start:{line:345,column:3},end:{line:349,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:345},"19":{loc:{start:{line:345,column:7},end:{line:345,column:55}},type:"binary-expr",locations:[{start:{line:345,column:7},end:{line:345,column:23}},{start:{line:345,column:27},end:{line:345,column:55}}],line:345},"20":{loc:{start:{line:351,column:3},end:{line:355,column:4}},type:"if",locations:[{start:{line:351,column:3},end:{line:355,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:351},"21":{loc:{start:{line:351,column:7},end:{line:351,column:54}},type:"binary-expr",locations:[{start:{line:351,column:7},end:{line:351,column:21}},{start:{line:351,column:25},end:{line:351,column:54}}],line:351},"22":{loc:{start:{line:357,column:3},end:{line:361,column:4}},type:"if",locations:[{start:{line:357,column:3},end:{line:361,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:357},"23":{loc:{start:{line:357,column:7},end:{line:357,column:63}},type:"binary-expr",locations:[{start:{line:357,column:7},end:{line:357,column:24}},{start:{line:357,column:28},end:{line:357,column:63}}],line:357},"24":{loc:{start:{line:366,column:3},end:{line:366,column:23}},type:"if",locations:[{start:{line:366,column:3},end:{line:366,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:366},"25":{loc:{start:{line:377,column:3},end:{line:380,column:4}},type:"if",locations:[{start:{line:377,column:3},end:{line:380,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:377},"26":{loc:{start:{line:404,column:16},end:{line:404,column:60}},type:"binary-expr",locations:[{start:{line:404,column:16},end:{line:404,column:36}},{start:{line:404,column:40},end:{line:404,column:60}}],line:404},"27":{loc:{start:{line:410,column:3},end:{line:410,column:30}},type:"if",locations:[{start:{line:410,column:3},end:{line:410,column:30}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:410},"28":{loc:{start:{line:416,column:3},end:{line:416,column:44}},type:"if",locations:[{start:{line:416,column:3},end:{line:416,column:44}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:416},"29":{loc:{start:{line:422,column:3},end:{line:422,column:100}},type:"if",locations:[{start:{line:422,column:3},end:{line:422,column:100}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:422},"30":{loc:{start:{line:423,column:3},end:{line:423,column:77}},type:"if",locations:[{start:{line:423,column:3},end:{line:423,column:77}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:423},"31":{loc:{start:{line:425,column:3},end:{line:427,column:4}},type:"if",locations:[{start:{line:425,column:3},end:{line:427,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:425},"32":{loc:{start:{line:431,column:3},end:{line:452,column:4}},type:"if",locations:[{start:{line:431,column:3},end:{line:452,column:4}},{start:{line:444,column:10},end:{line:452,column:4}}],line:431},"33":{loc:{start:{line:432,column:4},end:{line:443,column:5}},type:"if",locations:[{start:{line:432,column:4},end:{line:443,column:5}},{start:{line:438,column:11},end:{line:443,column:5}}],line:432},"34":{loc:{start:{line:435,column:5},end:{line:437,column:6}},type:"if",locations:[{start:{line:435,column:5},end:{line:437,column:6}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:435},"35":{loc:{start:{line:444,column:10},end:{line:452,column:4}},type:"if",locations:[{start:{line:444,column:10},end:{line:452,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:444},"36":{loc:{start:{line:455,column:3},end:{line:455,column:23}},type:"if",locations:[{start:{line:455,column:3},end:{line:455,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:455},"37":{loc:{start:{line:466,column:3},end:{line:469,column:4}},type:"if",locations:[{start:{line:466,column:3},end:{line:469,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:466},"38":{loc:{start:{line:472,column:3},end:{line:472,column:39}},type:"if",locations:[{start:{line:472,column:3},end:{line:472,column:39}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:472},"39":{loc:{start:{line:499,column:3},end:{line:501,column:4}},type:"if",locations:[{start:{line:499,column:3},end:{line:501,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:499},"40":{loc:{start:{line:506,column:3},end:{line:506,column:23}},type:"if",locations:[{start:{line:506,column:3},end:{line:506,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:506},"41":{loc:{start:{line:531,column:7},end:{line:531,column:27}},type:"default-arg",locations:[{start:{line:531,column:22},end:{line:531,column:27}}],line:531},"42":{loc:{start:{line:532,column:7},end:{line:532,column:25}},type:"default-arg",locations:[{start:{line:532,column:19},end:{line:532,column:25}}],line:532},"43":{loc:{start:{line:533,column:7},end:{line:533,column:23}},type:"default-arg",locations:[{start:{line:533,column:18},end:{line:533,column:23}}],line:533},"44":{loc:{start:{line:534,column:7},end:{line:534,column:19}},type:"default-arg",locations:[{start:{line:534,column:15},end:{line:534,column:19}}],line:534},"45":{loc:{start:{line:535,column:7},end:{line:535,column:24}},type:"default-arg",locations:[{start:{line:535,column:19},end:{line:535,column:24}}],line:535},"46":{loc:{start:{line:536,column:7},end:{line:536,column:21}},type:"default-arg",locations:[{start:{line:536,column:16},end:{line:536,column:21}}],line:536},"47":{loc:{start:{line:537,column:7},end:{line:537,column:25}},type:"default-arg",locations:[{start:{line:537,column:20},end:{line:537,column:25}}],line:537},"48":{loc:{start:{line:538,column:7},end:{line:538,column:29}},type:"default-arg",locations:[{start:{line:538,column:24},end:{line:538,column:29}}],line:538},"49":{loc:{start:{line:539,column:7},end:{line:539,column:29}},type:"default-arg",locations:[{start:{line:539,column:21},end:{line:539,column:29}}],line:539},"50":{loc:{start:{line:540,column:7},end:{line:540,column:22}},type:"default-arg",locations:[{start:{line:540,column:18},end:{line:540,column:22}}],line:540},"51":{loc:{start:{line:541,column:7},end:{line:541,column:22}},type:"default-arg",locations:[{start:{line:541,column:17},end:{line:541,column:22}}],line:541},"52":{loc:{start:{line:542,column:7},end:{line:542,column:21}},type:"default-arg",locations:[{start:{line:542,column:16},end:{line:542,column:21}}],line:542},"53":{loc:{start:{line:569,column:3},end:{line:572,column:4}},type:"if",locations:[{start:{line:569,column:3},end:{line:572,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:569},"54":{loc:{start:{line:616,column:2},end:{line:616,column:66}},type:"if",locations:[{start:{line:616,column:2},end:{line:616,column:66}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:616},"55":{loc:{start:{line:617,column:2},end:{line:617,column:87}},type:"if",locations:[{start:{line:617,column:2},end:{line:617,column:87}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:617},"56":{loc:{start:{line:618,column:2},end:{line:618,column:77}},type:"if",locations:[{start:{line:618,column:2},end:{line:618,column:77}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:618},"57":{loc:{start:{line:619,column:2},end:{line:619,column:74}},type:"if",locations:[{start:{line:619,column:2},end:{line:619,column:74}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:619},"58":{loc:{start:{line:620,column:2},end:{line:620,column:66}},type:"if",locations:[{start:{line:620,column:2},end:{line:620,column:66}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:620},"59":{loc:{start:{line:621,column:2},end:{line:621,column:78}},type:"if",locations:[{start:{line:621,column:2},end:{line:621,column:78}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:621},"60":{loc:{start:{line:622,column:2},end:{line:622,column:69}},type:"if",locations:[{start:{line:622,column:2},end:{line:622,column:69}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:622},"61":{loc:{start:{line:623,column:2},end:{line:623,column:81}},type:"if",locations:[{start:{line:623,column:2},end:{line:623,column:81}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:623},"62":{loc:{start:{line:624,column:2},end:{line:624,column:93}},type:"if",locations:[{start:{line:624,column:2},end:{line:624,column:93}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:624},"63":{loc:{start:{line:625,column:2},end:{line:625,column:84}},type:"if",locations:[{start:{line:625,column:2},end:{line:625,column:84}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:625},"64":{loc:{start:{line:626,column:2},end:{line:626,column:74}},type:"if",locations:[{start:{line:626,column:2},end:{line:626,column:74}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:626},"65":{loc:{start:{line:627,column:2},end:{line:627,column:71}},type:"if",locations:[{start:{line:627,column:2},end:{line:627,column:71}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:627},"66":{loc:{start:{line:628,column:2},end:{line:628,column:68}},type:"if",locations:[{start:{line:628,column:2},end:{line:628,column:68}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:628},"67":{loc:{start:{line:632,column:2},end:{line:634,column:3}},type:"if",locations:[{start:{line:632,column:2},end:{line:634,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:632},"68":{loc:{start:{line:633,column:44},end:{line:633,column:64}},type:"cond-expr",locations:[{start:{line:633,column:53},end:{line:633,column:59}},{start:{line:633,column:62},end:{line:633,column:64}}],line:633},"69":{loc:{start:{line:633,column:66},end:{line:633,column:94}},type:"cond-expr",locations:[{start:{line:633,column:79},end:{line:633,column:89}},{start:{line:633,column:92},end:{line:633,column:94}}],line:633},"70":{loc:{start:{line:636,column:2},end:{line:638,column:3}},type:"if",locations:[{start:{line:636,column:2},end:{line:638,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:636},"71":{loc:{start:{line:637,column:35},end:{line:637,column:72}},type:"binary-expr",locations:[{start:{line:637,column:35},end:{line:637,column:56}},{start:{line:637,column:60},end:{line:637,column:72}}],line:637},"72":{loc:{start:{line:637,column:37},end:{line:637,column:55}},type:"binary-expr",locations:[{start:{line:637,column:37},end:{line:637,column:46}},{start:{line:637,column:50},end:{line:637,column:55}}],line:637},"73":{loc:{start:{line:640,column:2},end:{line:642,column:3}},type:"if",locations:[{start:{line:640,column:2},end:{line:642,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:640},"74":{loc:{start:{line:641,column:16},end:{line:641,column:49}},type:"binary-expr",locations:[{start:{line:641,column:16},end:{line:641,column:31}},{start:{line:641,column:35},end:{line:641,column:49}}],line:641},"75":{loc:{start:{line:644,column:2},end:{line:648,column:3}},type:"if",locations:[{start:{line:644,column:2},end:{line:648,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:644},"76":{loc:{start:{line:645,column:42},end:{line:647,column:23}},type:"cond-expr",locations:[{start:{line:646,column:5},end:{line:646,column:22}},{start:{line:647,column:5},end:{line:647,column:23}}],line:645},"77":{loc:{start:{line:645,column:42},end:{line:645,column:73}},type:"binary-expr",locations:[{start:{line:645,column:42},end:{line:645,column:56}},{start:{line:645,column:60},end:{line:645,column:73}}],line:645},"78":{loc:{start:{line:650,column:2},end:{line:658,column:3}},type:"if",locations:[{start:{line:650,column:2},end:{line:658,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:650},"79":{loc:{start:{line:652,column:4},end:{line:656,column:5}},type:"if",locations:[{start:{line:652,column:4},end:{line:656,column:5}},{start:{line:654,column:11},end:{line:656,column:5}}],line:652}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0,"50":0,"51":0,"52":0,"53":0,"54":0,"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"61":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":0,"68":0,"69":0,"70":0,"71":0,"72":0,"73":0,"74":0,"75":0,"76":0,"77":0,"78":0,"79":0,"80":0,"81":0,"82":0,"83":0,"84":0,"85":0,"86":0,"87":0,"88":0,"89":0,"90":0,"91":0,"92":0,"93":0,"94":0,"95":0,"96":0,"97":0,"98":0,"99":0,"100":0,"101":0,"102":0,"103":0,"104":0,"105":0,"106":0,"107":0,"108":0,"109":0,"110":0,"111":0,"112":0,"113":0,"114":0,"115":0,"116":0,"117":0,"118":0,"119":0,"120":0,"121":0,"122":0,"123":0,"124":0,"125":0,"126":0,"127":0,"128":0,"129":0,"130":0,"131":0,"132":0,"133":0,"134":0,"135":0,"136":0,"137":0,"138":0,"139":0,"140":0,"141":0,"142":0,"143":0,"144":0,"145":0,"146":0,"147":0,"148":0,"149":0,"150":0,"151":0,"152":0,"153":0,"154":0,"155":0,"156":0,"157":0,"158":0,"159":0,"160":0,"161":0,"162":0,"163":0,"164":0,"165":0,"166":0,"167":0,"168":0,"169":0,"170":0,"171":0,"172":0,"173":0,"174":0,"175":0,"176":0,"177":0,"178":0,"179":0,"180":0,"181":0,"182":0,"183":0,"184":0,"185":0,"186":0,"187":0,"188":0,"189":0,"190":0,"191":0,"192":0,"193":0,"194":0,"195":0,"196":0,"197":0,"198":0,"199":0,"200":0,"201":0,"202":0,"203":0,"204":0,"205":0,"206":0,"207":0,"208":0,"209":0,"210":0,"211":0,"212":0,"213":0,"214":0,"215":0,"216":0,"217":0,"218":0,"219":0,"220":0,"221":0,"222":0,"223":0,"224":0,"225":0,"226":0,"227":0,"228":0,"229":0,"230":0,"231":0,"232":0,"233":0,"234":0,"235":0,"236":0,"237":0,"238":0,"239":0,"240":0,"241":0,"242":0,"243":0,"244":0,"245":0,"246":0,"247":0,"248":0,"249":0,"250":0,"251":0,"252":0,"253":0,"254":0,"255":0,"256":0,"257":0,"258":0,"259":0,"260":0,"261":0,"262":0,"263":0,"264":0,"265":0,"266":0,"267":0,"268":0,"269":0,"270":0,"271":0,"272":0,"273":0,"274":0,"275":0,"276":0,"277":0,"278":0,"279":0,"280":0,"281":0,"282":0,"283":0,"284":0,"285":0,"286":0,"287":0,"288":0,"289":0,"290":0,"291":0,"292":0,"293":0,"294":0,"295":0,"296":0,"297":0,"298":0,"299":0,"300":0,"301":0,"302":0,"303":0,"304":0,"305":0,"306":0,"307":0,"308":0,"309":0,"310":0,"311":0,"312":0,"313":0,"314":0,"315":0,"316":0,"317":0,"318":0,"319":0,"320":0,"321":0,"322":0,"323":0,"324":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0,"50":0,"51":0,"52":0,"53":0,"54":0,"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"61":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":0,"68":0,"69":0,"70":0,"71":0,"72":0,"73":0,"74":0,"75":0,"76":0,"77":0,"78":0,"79":0,"80":0},b:{"0":[0,0],"1":[0,0],"2":[0,0],"3":[0,0],"4":[0,0],"5":[0,0],"6":[0,0],"7":[0,0],"8":[0,0],"9":[0,0],"10":[0,0],"11":[0,0],"12":[0,0],"13":[0,0],"14":[0,0],"15":[0,0],"16":[0,0],"17":[0,0],"18":[0,0],"19":[0,0],"20":[0,0],"21":[0,0],"22":[0,0],"23":[0,0],"24":[0,0],"25":[0,0],"26":[0,0],"27":[0,0],"28":[0,0],"29":[0,0],"30":[0,0],"31":[0,0],"32":[0,0],"33":[0,0],"34":[0,0],"35":[0,0],"36":[0,0],"37":[0,0],"38":[0,0],"39":[0,0],"40":[0,0],"41":[0],"42":[0],"43":[0],"44":[0],"45":[0],"46":[0],"47":[0],"48":[0],"49":[0],"50":[0],"51":[0],"52":[0],"53":[0,0],"54":[0,0],"55":[0,0],"56":[0,0],"57":[0,0],"58":[0,0],"59":[0,0],"60":[0,0],"61":[0,0],"62":[0,0],"63":[0,0],"64":[0,0],"65":[0,0],"66":[0,0],"67":[0,0],"68":[0,0],"69":[0,0],"70":[0,0],"71":[0,0],"72":[0,0],"73":[0,0],"74":[0,0],"75":[0,0],"76":[0,0],"77":[0,0],"78":[0,0],"79":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/common/UISelectUser.svelte"],sourcesContent:["<script>\n    import { Elements, notCommon } from \"not-bulma\";\n\n    const { UIButtons } = Elements.Buttons;\n    const { UIErrorsList } = Elements.Various;\n    const { UIColumn, UIColumns } = Elements.Layouts;\n\n    const { UICommon } = Elements;\n\n    import UIUserInlineInfo from \"./UIUserInlineInfo.svelte\";\n\n    import { createEventDispatcher, onMount } from \"svelte\";\n    import { UIButton } from \"not-bulma/src/elements/button\";\n    let dispatch = createEventDispatcher();\n\n    export let value;\n    export let inputStarted = false;\n    export let fieldname = \"user\";\n\n    //export let required = true;\n    export let readonly = false;\n    export let valid = true;\n    export let validated = false;\n    export let errors = false;\n    export let formErrors = false;\n    export let formLevelError = false;\n    export let serviceName = \"nsUser\";\n    export let userData = null;\n    export let loading = false;\n\n    export let narrow = false;\n\n    function getService() {\n        return notCommon.getApp().getService(serviceName);\n    }\n\n    $: allErrors = [].concat(\n        errors ? errors : [],\n        formErrors ? formErrors : []\n    );\n    $: showErrors = !(validated && valid) && inputStarted;\n    $: invalid = valid === false || formLevelError;\n    $: validationClasses =\n        valid === true || !inputStarted\n            ? UICommon.CLASS_OK\n            : UICommon.CLASS_ERR;\n\n    function openUserSearchAndSelect() {\n        getService()\n            .openSelector()\n            .then((results) => {\n                value = results._id;\n                userData = results;\n                return value;\n            })\n            .then((value) => {\n                inputStarted = true;\n                dispatch(\"change\", {\n                    field: fieldname,\n                    value,\n                });\n            })\n            .catch((e) => {\n                notCommon.report(e);\n            });\n    }\n\n    function resetUser() {\n        value = undefined;\n        userData = null;\n        dispatch(\"change\", {\n            field: fieldname,\n            value,\n        });\n    }\n\n    async function loadUserData() {\n        try {\n            if (value) {\n                loading = true;\n                userData = await getService().loadUserData(value);\n            }\n        } catch (e) {\n            notCommon.report(e);\n        } finally {\n            loading = false;\n        }\n    }\n\n    onMount(() => {\n        loadUserData();\n    });\n\n    const AVAILABLE_BUTTONS = [\n        {\n            id: 1,\n            action: openUserSearchAndSelect,\n            title: \"not-node:field_select_label\",\n        },\n        {\n            id: 2,\n            action: resetUser,\n            icon: \"times\",\n            color: \"danger\",\n        },\n    ];\n\n    let VISIBLE_BUTTONS = [];\n    $: {\n        if (value) {\n            VISIBLE_BUTTONS = [...AVAILABLE_BUTTONS];\n        } else {\n            VISIBLE_BUTTONS = [AVAILABLE_BUTTONS[0]];\n        }\n    }\n</script>\n\n<UIColumns>\n    <UIColumn classes={validationClasses} {narrow}>\n        <div class=\"control\">\n            {#if loading}\n                <UIButton\n                    loading={true}\n                    disabled={true}\n                    icon={\"user\"}\n                    iconSide={\"left\"}\n                    title={\"not-node:loading_label\"}\n                />\n            {:else if userData != null}\n                <UIUserInlineInfo {...userData} />\n            {:else}\n                <UIButton\n                    disabled={true}\n                    icon={\"user\"}\n                    iconSide={\"left\"}\n                    title={\"not-node:field_value_is_empty_placeholder\"}\n                />\n            {/if}\n        </div>\n    </UIColumn>\n    {#if !readonly}\n        <UIColumn {narrow} +>\n            <div class=\"control\">\n                <UIButtons values={VISIBLE_BUTTONS}></UIButtons>\n            </div>\n            <UIErrorsList\n                bind:errors={allErrors}\n                bind:show={showErrors}\n                bind:classes={validationClasses}\n                id=\"input-field-helper-{fieldname}\"\n            />\n        </UIColumn>\n    {/if}\n</UIColumns>\n"],names:[],mappings:";;;;;;;;;;;;;;;;;;;;;;;;;;;;SACa,QAAQ,EAAE,SAAS,QAAQ,WAAW;OAQxC,gBAAgB,MAAM,2BAA2B;SAE/C,qBAAqB,EAAE,OAAO,QAAQ,QAAQ;SAC9C,QAAQ,QAAQ,+BAA+B;;;;;;;;cAwH9B,IAAI;UACR,MAAM;cACF,MAAM;WACT,2CAA2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDANhC,GAAQ;;;;;;;;;;;;;;;;;;;uFAAR,GAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;aAPjB,IAAI;cACH,IAAI;UACR,MAAM;cACF,MAAM;WACT,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBANlC,GAAO;mBAQF,GAAQ,OAAI,IAAI;;;;;;;;;;;;;;GAT9B,MAmBM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCAKqB,GAAe;;;;;;;;;;;;;;;;4CAMV,GAAS;;;mBAHpB,GAAS;4CAAT,GAAS;;;oBACX,GAAU;2CAAV,GAAU;;;2BACP,GAAiB;qDAAjB,GAAiB;;;;;;;;;;;;;;;;;GANnC,MAEM;;;;;;;;yFADiB,GAAe;;;mGAMV,GAAS;;;;gDAHpB,GAAS;;;;;;+CACX,GAAU;;;;;;yDACP,GAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCA9BxB,GAAiB;;;;;;;8BAsB9B,GAAQ;;;;;;;;;;;;;;;;;;6FAtBK,GAAiB;;;;;;;;;qBAsB9B,GAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAzIN,SAAS,KAAK,QAAQ,CAAC,OAAO;SAC9B,YAAY,KAAK,QAAQ,CAAC,OAAO;SACjC,QAAQ,EAAE,SAAS,KAAK,QAAQ,CAAC,OAAO;SAExC,QAAQ,KAAK,QAAQ;KAMzB,QAAQ,GAAG,qBAAqB;OAEzB,KAAK;OACL,YAAY,GAAG,KAAK;OACpB,SAAS,GAAG,MAAM;OAGlB,QAAQ,GAAG,KAAK;OAChB,KAAK,GAAG,IAAI;OACZ,SAAS,GAAG,KAAK;OACjB,MAAM,GAAG,KAAK;OACd,UAAU,GAAG,KAAK;OAClB,cAAc,GAAG,KAAK;OACtB,WAAW,GAAG,QAAQ;OACtB,QAAQ,GAAG,IAAI;OACf,OAAO,GAAG,KAAK;OAEf,MAAM,GAAG,KAAK;;UAEhB,UAAU;SACR,SAAS,CAAC,MAAM,GAAG,UAAU,CAAC,WAAW;;;UAc3C,uBAAuB;EAC5B,UAAU,GACL,YAAY,GACZ,IAAI,CAAE,OAAO;oBACV,KAAK,GAAG,OAAO,CAAC,GAAG;mBACnB,QAAQ,GAAG,OAAO;UACX,KAAK;KAEf,IAAI,CAAE,KAAK;oBACR,YAAY,GAAG,IAAI;GACnB,QAAQ,CAAC,QAAQ,IACb,KAAK,EAAE,SAAS,EAChB,KAAK;KAGZ,KAAK,CAAE,CAAC;GACL,SAAS,CAAC,MAAM,CAAC,CAAC;;;;UAIrB,SAAS;mBACd,KAAK,GAAG,SAAS;kBACjB,QAAQ,GAAG,IAAI;EACf,QAAQ,CAAC,QAAQ,IACb,KAAK,EAAE,SAAS,EAChB,KAAK;;;gBAIE,YAAY;;OAEf,KAAK;oBACL,OAAO,GAAG,IAAI;oBACd,QAAQ,SAAS,UAAU,GAAG,YAAY,CAAC,KAAK;;UAE/C,CAAC;GACN,SAAS,CAAC,MAAM,CAAC,CAAC;;mBAElB,OAAO,GAAG,KAAK;;;;CAIvB,OAAO;EACH,YAAY;;;OAGV,iBAAiB;;GAEf,EAAE,EAAE,CAAC;GACL,MAAM,EAAE,uBAAuB;GAC/B,KAAK,EAAE,6BAA6B;;;GAGpC,EAAE,EAAE,CAAC;GACL,MAAM,EAAE,SAAS;GACjB,IAAI,EAAE,OAAO;GACb,KAAK,EAAE,QAAQ;;;;KAInB,eAAe;;;EAuCM,SAAS;;;;;EACX,UAAU;;;;;EACP,iBAAiB;;;;;;;;;;;;;;;;;;;;;;GAhH3C,CAAC,kBAAE,SAAS,MAAM,MAAM,CACpB,MAAM,GAAG,MAAM,OACf,UAAU,GAAG,UAAU;;;;GAE3B,CAAC,kBAAE,UAAU,KAAK,SAAS,IAAI,KAAK,KAAK,YAAY;;;;GACrD,CAAC,EAAE,OAAO,GAAG,KAAK,KAAK,KAAK,IAAI,cAAc;;;;GAC9C,CAAC,kBAAE,iBAAiB,GAChB,KAAK,KAAK,IAAI,KAAK,YAAY;KACzB,QAAQ,CAAC,QAAQ;KACjB,QAAQ,CAAC,SAAS;;;;GA+D5B,CAAC;QACO,KAAK;qBACL,eAAe,OAAO,iBAAiB;;qBAEvC,eAAe,IAAI,iBAAiB,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"5848d53392501aa016f655f3be4ddcb8da4458db"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1j72yc5n81=function(){return actualCoverage;};}return actualCoverage;}cov_1j72yc5n81();function create_else_block(ctx){cov_1j72yc5n81().f[0]++;let uibutton;let current;cov_1j72yc5n81().s[0]++;uibutton=new Ui_button({props:{disabled:true,icon:"user",iconSide:"left",title:"not-node:field_value_is_empty_placeholder"}});cov_1j72yc5n81().s[1]++;return {c(){cov_1j72yc5n81().f[1]++;cov_1j72yc5n81().s[2]++;create_component(uibutton.$$.fragment);},m(target,anchor){cov_1j72yc5n81().f[2]++;cov_1j72yc5n81().s[3]++;mount_component(uibutton,target,anchor);cov_1j72yc5n81().s[4]++;current=true;},p:noop$1,i(local){cov_1j72yc5n81().f[3]++;cov_1j72yc5n81().s[5]++;if(current){cov_1j72yc5n81().b[0][0]++;cov_1j72yc5n81().s[6]++;return;}else {cov_1j72yc5n81().b[0][1]++;}cov_1j72yc5n81().s[7]++;transition_in(uibutton.$$.fragment,local);cov_1j72yc5n81().s[8]++;current=true;},o(local){cov_1j72yc5n81().f[4]++;cov_1j72yc5n81().s[9]++;transition_out(uibutton.$$.fragment,local);cov_1j72yc5n81().s[10]++;current=false;},d(detaching){cov_1j72yc5n81().f[5]++;cov_1j72yc5n81().s[11]++;destroy_component(uibutton,detaching);}};}// (129:39) 
	function create_if_block_2(ctx){cov_1j72yc5n81().f[6]++;let uiuserinlineinfo;let current;const uiuserinlineinfo_spread_levels=(cov_1j72yc5n81().s[12]++,[/*userData*/ctx[0]]);let uiuserinlineinfo_props=(cov_1j72yc5n81().s[13]++,{});cov_1j72yc5n81().s[14]++;for(let i=(cov_1j72yc5n81().s[15]++,0);i<uiuserinlineinfo_spread_levels.length;i+=1){cov_1j72yc5n81().s[16]++;uiuserinlineinfo_props=assign(uiuserinlineinfo_props,uiuserinlineinfo_spread_levels[i]);}cov_1j72yc5n81().s[17]++;uiuserinlineinfo=new UIUserInlineInfo({props:uiuserinlineinfo_props});cov_1j72yc5n81().s[18]++;return {c(){cov_1j72yc5n81().f[7]++;cov_1j72yc5n81().s[19]++;create_component(uiuserinlineinfo.$$.fragment);},m(target,anchor){cov_1j72yc5n81().f[8]++;cov_1j72yc5n81().s[20]++;mount_component(uiuserinlineinfo,target,anchor);cov_1j72yc5n81().s[21]++;current=true;},p(ctx,dirty){cov_1j72yc5n81().f[9]++;const uiuserinlineinfo_changes=(cov_1j72yc5n81().s[22]++,dirty[0]&/*userData*/1?(cov_1j72yc5n81().b[1][0]++,get_spread_update(uiuserinlineinfo_spread_levels,[get_spread_object(/*userData*/ctx[0])])):(cov_1j72yc5n81().b[1][1]++,{}));cov_1j72yc5n81().s[23]++;uiuserinlineinfo.$set(uiuserinlineinfo_changes);},i(local){cov_1j72yc5n81().f[10]++;cov_1j72yc5n81().s[24]++;if(current){cov_1j72yc5n81().b[2][0]++;cov_1j72yc5n81().s[25]++;return;}else {cov_1j72yc5n81().b[2][1]++;}cov_1j72yc5n81().s[26]++;transition_in(uiuserinlineinfo.$$.fragment,local);cov_1j72yc5n81().s[27]++;current=true;},o(local){cov_1j72yc5n81().f[11]++;cov_1j72yc5n81().s[28]++;transition_out(uiuserinlineinfo.$$.fragment,local);cov_1j72yc5n81().s[29]++;current=false;},d(detaching){cov_1j72yc5n81().f[12]++;cov_1j72yc5n81().s[30]++;destroy_component(uiuserinlineinfo,detaching);}};}// (121:12) {#if loading}
	function create_if_block_1(ctx){cov_1j72yc5n81().f[13]++;let uibutton;let current;cov_1j72yc5n81().s[31]++;uibutton=new Ui_button({props:{loading:true,disabled:true,icon:"user",iconSide:"left",title:"not-node:loading_label"}});cov_1j72yc5n81().s[32]++;return {c(){cov_1j72yc5n81().f[14]++;cov_1j72yc5n81().s[33]++;create_component(uibutton.$$.fragment);},m(target,anchor){cov_1j72yc5n81().f[15]++;cov_1j72yc5n81().s[34]++;mount_component(uibutton,target,anchor);cov_1j72yc5n81().s[35]++;current=true;},p:noop$1,i(local){cov_1j72yc5n81().f[16]++;cov_1j72yc5n81().s[36]++;if(current){cov_1j72yc5n81().b[3][0]++;cov_1j72yc5n81().s[37]++;return;}else {cov_1j72yc5n81().b[3][1]++;}cov_1j72yc5n81().s[38]++;transition_in(uibutton.$$.fragment,local);cov_1j72yc5n81().s[39]++;current=true;},o(local){cov_1j72yc5n81().f[17]++;cov_1j72yc5n81().s[40]++;transition_out(uibutton.$$.fragment,local);cov_1j72yc5n81().s[41]++;current=false;},d(detaching){cov_1j72yc5n81().f[18]++;cov_1j72yc5n81().s[42]++;destroy_component(uibutton,detaching);}};}// (119:4) <UIColumn classes={validationClasses} {narrow}>
	function create_default_slot_2(ctx){cov_1j72yc5n81().f[19]++;let div;let current_block_type_index;let if_block;let current;const if_block_creators=(cov_1j72yc5n81().s[43]++,[create_if_block_1,create_if_block_2,create_else_block]);const if_blocks=(cov_1j72yc5n81().s[44]++,[]);function select_block_type(ctx,dirty){cov_1j72yc5n81().f[20]++;cov_1j72yc5n81().s[45]++;if(/*loading*/ctx[1]){cov_1j72yc5n81().b[4][0]++;cov_1j72yc5n81().s[46]++;return 0;}else {cov_1j72yc5n81().b[4][1]++;}cov_1j72yc5n81().s[47]++;if(/*userData*/ctx[0]!=null){cov_1j72yc5n81().b[5][0]++;cov_1j72yc5n81().s[48]++;return 1;}else {cov_1j72yc5n81().b[5][1]++;}cov_1j72yc5n81().s[49]++;return 2;}cov_1j72yc5n81().s[50]++;current_block_type_index=select_block_type(ctx);cov_1j72yc5n81().s[51]++;if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);cov_1j72yc5n81().s[52]++;return {c(){cov_1j72yc5n81().f[21]++;cov_1j72yc5n81().s[53]++;div=element("div");cov_1j72yc5n81().s[54]++;if_block.c();cov_1j72yc5n81().s[55]++;attr(div,"class","control");},m(target,anchor){cov_1j72yc5n81().f[22]++;cov_1j72yc5n81().s[56]++;insert(target,div,anchor);cov_1j72yc5n81().s[57]++;if_blocks[current_block_type_index].m(div,null);cov_1j72yc5n81().s[58]++;current=true;},p(ctx,dirty){cov_1j72yc5n81().f[23]++;let previous_block_index=(cov_1j72yc5n81().s[59]++,current_block_type_index);cov_1j72yc5n81().s[60]++;current_block_type_index=select_block_type(ctx);cov_1j72yc5n81().s[61]++;if(current_block_type_index===previous_block_index){cov_1j72yc5n81().b[6][0]++;cov_1j72yc5n81().s[62]++;if_blocks[current_block_type_index].p(ctx,dirty);}else {cov_1j72yc5n81().b[6][1]++;cov_1j72yc5n81().s[63]++;group_outros();cov_1j72yc5n81().s[64]++;transition_out(if_blocks[previous_block_index],1,1,()=>{cov_1j72yc5n81().f[24]++;cov_1j72yc5n81().s[65]++;if_blocks[previous_block_index]=null;});cov_1j72yc5n81().s[66]++;check_outros();cov_1j72yc5n81().s[67]++;if_block=if_blocks[current_block_type_index];cov_1j72yc5n81().s[68]++;if(!if_block){cov_1j72yc5n81().b[7][0]++;cov_1j72yc5n81().s[69]++;if_block=if_blocks[current_block_type_index]=if_block_creators[current_block_type_index](ctx);cov_1j72yc5n81().s[70]++;if_block.c();}else {cov_1j72yc5n81().b[7][1]++;cov_1j72yc5n81().s[71]++;if_block.p(ctx,dirty);}cov_1j72yc5n81().s[72]++;transition_in(if_block,1);cov_1j72yc5n81().s[73]++;if_block.m(div,null);}},i(local){cov_1j72yc5n81().f[25]++;cov_1j72yc5n81().s[74]++;if(current){cov_1j72yc5n81().b[8][0]++;cov_1j72yc5n81().s[75]++;return;}else {cov_1j72yc5n81().b[8][1]++;}cov_1j72yc5n81().s[76]++;transition_in(if_block);cov_1j72yc5n81().s[77]++;current=true;},o(local){cov_1j72yc5n81().f[26]++;cov_1j72yc5n81().s[78]++;transition_out(if_block);cov_1j72yc5n81().s[79]++;current=false;},d(detaching){cov_1j72yc5n81().f[27]++;cov_1j72yc5n81().s[80]++;if(detaching){cov_1j72yc5n81().b[9][0]++;cov_1j72yc5n81().s[81]++;detach(div);}else {cov_1j72yc5n81().b[9][1]++;}cov_1j72yc5n81().s[82]++;if_blocks[current_block_type_index].d();}};}// (141:4) {#if !readonly}
	function create_if_block(ctx){cov_1j72yc5n81().f[28]++;let uicolumn;let current;cov_1j72yc5n81().s[83]++;uicolumn=new/*UIColumn*/ctx[11]({props:{narrow:/*narrow*/ctx[4],"+":true,$$slots:{default:[create_default_slot_1]},$$scope:{ctx}}});cov_1j72yc5n81().s[84]++;return {c(){cov_1j72yc5n81().f[29]++;cov_1j72yc5n81().s[85]++;create_component(uicolumn.$$.fragment);},m(target,anchor){cov_1j72yc5n81().f[30]++;cov_1j72yc5n81().s[86]++;mount_component(uicolumn,target,anchor);cov_1j72yc5n81().s[87]++;current=true;},p(ctx,dirty){cov_1j72yc5n81().f[31]++;const uicolumn_changes=(cov_1j72yc5n81().s[88]++,{});cov_1j72yc5n81().s[89]++;if(dirty[0]&/*narrow*/16){cov_1j72yc5n81().b[10][0]++;cov_1j72yc5n81().s[90]++;uicolumn_changes.narrow=/*narrow*/ctx[4];}else {cov_1j72yc5n81().b[10][1]++;}cov_1j72yc5n81().s[91]++;if(dirty[0]&/*fieldname, allErrors, showErrors, validationClasses, VISIBLE_BUTTONS*/484|dirty[1]&/*$$scope*/2){cov_1j72yc5n81().b[11][0]++;cov_1j72yc5n81().s[92]++;uicolumn_changes.$$scope={dirty,ctx};}else {cov_1j72yc5n81().b[11][1]++;}cov_1j72yc5n81().s[93]++;uicolumn.$set(uicolumn_changes);},i(local){cov_1j72yc5n81().f[32]++;cov_1j72yc5n81().s[94]++;if(current){cov_1j72yc5n81().b[12][0]++;cov_1j72yc5n81().s[95]++;return;}else {cov_1j72yc5n81().b[12][1]++;}cov_1j72yc5n81().s[96]++;transition_in(uicolumn.$$.fragment,local);cov_1j72yc5n81().s[97]++;current=true;},o(local){cov_1j72yc5n81().f[33]++;cov_1j72yc5n81().s[98]++;transition_out(uicolumn.$$.fragment,local);cov_1j72yc5n81().s[99]++;current=false;},d(detaching){cov_1j72yc5n81().f[34]++;cov_1j72yc5n81().s[100]++;destroy_component(uicolumn,detaching);}};}// (142:8) <UIColumn {narrow} +>
	function create_default_slot_1(ctx){cov_1j72yc5n81().f[35]++;let div;let uibuttons;let t;let uierrorslist;let updating_errors;let updating_show;let updating_classes;let current;cov_1j72yc5n81().s[101]++;uibuttons=new/*UIButtons*/ctx[9]({props:{values:/*VISIBLE_BUTTONS*/ctx[5]}});function uierrorslist_errors_binding(value){cov_1j72yc5n81().f[36]++;cov_1j72yc5n81().s[102]++;/*uierrorslist_errors_binding*/ctx[21](value);}function uierrorslist_show_binding(value){cov_1j72yc5n81().f[37]++;cov_1j72yc5n81().s[103]++;/*uierrorslist_show_binding*/ctx[22](value);}function uierrorslist_classes_binding(value){cov_1j72yc5n81().f[38]++;cov_1j72yc5n81().s[104]++;/*uierrorslist_classes_binding*/ctx[23](value);}let uierrorslist_props=(cov_1j72yc5n81().s[105]++,{id:"input-field-helper-"+/*fieldname*/ctx[2]});cov_1j72yc5n81().s[106]++;if(/*allErrors*/ctx[8]!==void 0){cov_1j72yc5n81().b[13][0]++;cov_1j72yc5n81().s[107]++;uierrorslist_props.errors=/*allErrors*/ctx[8];}else {cov_1j72yc5n81().b[13][1]++;}cov_1j72yc5n81().s[108]++;if(/*showErrors*/ctx[7]!==void 0){cov_1j72yc5n81().b[14][0]++;cov_1j72yc5n81().s[109]++;uierrorslist_props.show=/*showErrors*/ctx[7];}else {cov_1j72yc5n81().b[14][1]++;}cov_1j72yc5n81().s[110]++;if(/*validationClasses*/ctx[6]!==void 0){cov_1j72yc5n81().b[15][0]++;cov_1j72yc5n81().s[111]++;uierrorslist_props.classes=/*validationClasses*/ctx[6];}else {cov_1j72yc5n81().b[15][1]++;}cov_1j72yc5n81().s[112]++;uierrorslist=new/*UIErrorsList*/ctx[10]({props:uierrorslist_props});cov_1j72yc5n81().s[113]++;binding_callbacks.push(()=>{cov_1j72yc5n81().f[39]++;cov_1j72yc5n81().s[114]++;return bind(uierrorslist,'errors',uierrorslist_errors_binding);});cov_1j72yc5n81().s[115]++;binding_callbacks.push(()=>{cov_1j72yc5n81().f[40]++;cov_1j72yc5n81().s[116]++;return bind(uierrorslist,'show',uierrorslist_show_binding);});cov_1j72yc5n81().s[117]++;binding_callbacks.push(()=>{cov_1j72yc5n81().f[41]++;cov_1j72yc5n81().s[118]++;return bind(uierrorslist,'classes',uierrorslist_classes_binding);});cov_1j72yc5n81().s[119]++;return {c(){cov_1j72yc5n81().f[42]++;cov_1j72yc5n81().s[120]++;div=element("div");cov_1j72yc5n81().s[121]++;create_component(uibuttons.$$.fragment);cov_1j72yc5n81().s[122]++;t=space();cov_1j72yc5n81().s[123]++;create_component(uierrorslist.$$.fragment);cov_1j72yc5n81().s[124]++;attr(div,"class","control");},m(target,anchor){cov_1j72yc5n81().f[43]++;cov_1j72yc5n81().s[125]++;insert(target,div,anchor);cov_1j72yc5n81().s[126]++;mount_component(uibuttons,div,null);cov_1j72yc5n81().s[127]++;insert(target,t,anchor);cov_1j72yc5n81().s[128]++;mount_component(uierrorslist,target,anchor);cov_1j72yc5n81().s[129]++;current=true;},p(ctx,dirty){cov_1j72yc5n81().f[44]++;const uibuttons_changes=(cov_1j72yc5n81().s[130]++,{});cov_1j72yc5n81().s[131]++;if(dirty[0]&/*VISIBLE_BUTTONS*/32){cov_1j72yc5n81().b[16][0]++;cov_1j72yc5n81().s[132]++;uibuttons_changes.values=/*VISIBLE_BUTTONS*/ctx[5];}else {cov_1j72yc5n81().b[16][1]++;}cov_1j72yc5n81().s[133]++;uibuttons.$set(uibuttons_changes);const uierrorslist_changes=(cov_1j72yc5n81().s[134]++,{});cov_1j72yc5n81().s[135]++;if(dirty[0]&/*fieldname*/4){cov_1j72yc5n81().b[17][0]++;cov_1j72yc5n81().s[136]++;uierrorslist_changes.id="input-field-helper-"+/*fieldname*/ctx[2];}else {cov_1j72yc5n81().b[17][1]++;}cov_1j72yc5n81().s[137]++;if((cov_1j72yc5n81().b[19][0]++,!updating_errors)&&(cov_1j72yc5n81().b[19][1]++,dirty[0]&/*allErrors*/256)){cov_1j72yc5n81().b[18][0]++;cov_1j72yc5n81().s[138]++;updating_errors=true;cov_1j72yc5n81().s[139]++;uierrorslist_changes.errors=/*allErrors*/ctx[8];cov_1j72yc5n81().s[140]++;add_flush_callback(()=>{cov_1j72yc5n81().f[45]++;cov_1j72yc5n81().s[141]++;return updating_errors=false;});}else {cov_1j72yc5n81().b[18][1]++;}cov_1j72yc5n81().s[142]++;if((cov_1j72yc5n81().b[21][0]++,!updating_show)&&(cov_1j72yc5n81().b[21][1]++,dirty[0]&/*showErrors*/128)){cov_1j72yc5n81().b[20][0]++;cov_1j72yc5n81().s[143]++;updating_show=true;cov_1j72yc5n81().s[144]++;uierrorslist_changes.show=/*showErrors*/ctx[7];cov_1j72yc5n81().s[145]++;add_flush_callback(()=>{cov_1j72yc5n81().f[46]++;cov_1j72yc5n81().s[146]++;return updating_show=false;});}else {cov_1j72yc5n81().b[20][1]++;}cov_1j72yc5n81().s[147]++;if((cov_1j72yc5n81().b[23][0]++,!updating_classes)&&(cov_1j72yc5n81().b[23][1]++,dirty[0]&/*validationClasses*/64)){cov_1j72yc5n81().b[22][0]++;cov_1j72yc5n81().s[148]++;updating_classes=true;cov_1j72yc5n81().s[149]++;uierrorslist_changes.classes=/*validationClasses*/ctx[6];cov_1j72yc5n81().s[150]++;add_flush_callback(()=>{cov_1j72yc5n81().f[47]++;cov_1j72yc5n81().s[151]++;return updating_classes=false;});}else {cov_1j72yc5n81().b[22][1]++;}cov_1j72yc5n81().s[152]++;uierrorslist.$set(uierrorslist_changes);},i(local){cov_1j72yc5n81().f[48]++;cov_1j72yc5n81().s[153]++;if(current){cov_1j72yc5n81().b[24][0]++;cov_1j72yc5n81().s[154]++;return;}else {cov_1j72yc5n81().b[24][1]++;}cov_1j72yc5n81().s[155]++;transition_in(uibuttons.$$.fragment,local);cov_1j72yc5n81().s[156]++;transition_in(uierrorslist.$$.fragment,local);cov_1j72yc5n81().s[157]++;current=true;},o(local){cov_1j72yc5n81().f[49]++;cov_1j72yc5n81().s[158]++;transition_out(uibuttons.$$.fragment,local);cov_1j72yc5n81().s[159]++;transition_out(uierrorslist.$$.fragment,local);cov_1j72yc5n81().s[160]++;current=false;},d(detaching){cov_1j72yc5n81().f[50]++;cov_1j72yc5n81().s[161]++;if(detaching){cov_1j72yc5n81().b[25][0]++;cov_1j72yc5n81().s[162]++;detach(div);cov_1j72yc5n81().s[163]++;detach(t);}else {cov_1j72yc5n81().b[25][1]++;}cov_1j72yc5n81().s[164]++;destroy_component(uibuttons);cov_1j72yc5n81().s[165]++;destroy_component(uierrorslist,detaching);}};}// (118:0) <UIColumns>
	function create_default_slot(ctx){cov_1j72yc5n81().f[51]++;let uicolumn;let t;let if_block_anchor;let current;cov_1j72yc5n81().s[166]++;uicolumn=new/*UIColumn*/ctx[11]({props:{classes:/*validationClasses*/ctx[6],narrow:/*narrow*/ctx[4],$$slots:{default:[create_default_slot_2]},$$scope:{ctx}}});let if_block=(cov_1j72yc5n81().s[167]++,(cov_1j72yc5n81().b[26][0]++,!/*readonly*/ctx[3])&&(cov_1j72yc5n81().b[26][1]++,create_if_block(ctx)));cov_1j72yc5n81().s[168]++;return {c(){cov_1j72yc5n81().f[52]++;cov_1j72yc5n81().s[169]++;create_component(uicolumn.$$.fragment);cov_1j72yc5n81().s[170]++;t=space();cov_1j72yc5n81().s[171]++;if(if_block){cov_1j72yc5n81().b[27][0]++;cov_1j72yc5n81().s[172]++;if_block.c();}else {cov_1j72yc5n81().b[27][1]++;}cov_1j72yc5n81().s[173]++;if_block_anchor=empty();},m(target,anchor){cov_1j72yc5n81().f[53]++;cov_1j72yc5n81().s[174]++;mount_component(uicolumn,target,anchor);cov_1j72yc5n81().s[175]++;insert(target,t,anchor);cov_1j72yc5n81().s[176]++;if(if_block){cov_1j72yc5n81().b[28][0]++;cov_1j72yc5n81().s[177]++;if_block.m(target,anchor);}else {cov_1j72yc5n81().b[28][1]++;}cov_1j72yc5n81().s[178]++;insert(target,if_block_anchor,anchor);cov_1j72yc5n81().s[179]++;current=true;},p(ctx,dirty){cov_1j72yc5n81().f[54]++;const uicolumn_changes=(cov_1j72yc5n81().s[180]++,{});cov_1j72yc5n81().s[181]++;if(dirty[0]&/*validationClasses*/64){cov_1j72yc5n81().b[29][0]++;cov_1j72yc5n81().s[182]++;uicolumn_changes.classes=/*validationClasses*/ctx[6];}else {cov_1j72yc5n81().b[29][1]++;}cov_1j72yc5n81().s[183]++;if(dirty[0]&/*narrow*/16){cov_1j72yc5n81().b[30][0]++;cov_1j72yc5n81().s[184]++;uicolumn_changes.narrow=/*narrow*/ctx[4];}else {cov_1j72yc5n81().b[30][1]++;}cov_1j72yc5n81().s[185]++;if(dirty[0]&/*loading, userData*/3|dirty[1]&/*$$scope*/2){cov_1j72yc5n81().b[31][0]++;cov_1j72yc5n81().s[186]++;uicolumn_changes.$$scope={dirty,ctx};}else {cov_1j72yc5n81().b[31][1]++;}cov_1j72yc5n81().s[187]++;uicolumn.$set(uicolumn_changes);cov_1j72yc5n81().s[188]++;if(!/*readonly*/ctx[3]){cov_1j72yc5n81().b[32][0]++;cov_1j72yc5n81().s[189]++;if(if_block){cov_1j72yc5n81().b[33][0]++;cov_1j72yc5n81().s[190]++;if_block.p(ctx,dirty);cov_1j72yc5n81().s[191]++;if(dirty[0]&/*readonly*/8){cov_1j72yc5n81().b[34][0]++;cov_1j72yc5n81().s[192]++;transition_in(if_block,1);}else {cov_1j72yc5n81().b[34][1]++;}}else {cov_1j72yc5n81().b[33][1]++;cov_1j72yc5n81().s[193]++;if_block=create_if_block(ctx);cov_1j72yc5n81().s[194]++;if_block.c();cov_1j72yc5n81().s[195]++;transition_in(if_block,1);cov_1j72yc5n81().s[196]++;if_block.m(if_block_anchor.parentNode,if_block_anchor);}}else {cov_1j72yc5n81().b[32][1]++;cov_1j72yc5n81().s[197]++;if(if_block){cov_1j72yc5n81().b[35][0]++;cov_1j72yc5n81().s[198]++;group_outros();cov_1j72yc5n81().s[199]++;transition_out(if_block,1,1,()=>{cov_1j72yc5n81().f[55]++;cov_1j72yc5n81().s[200]++;if_block=null;});cov_1j72yc5n81().s[201]++;check_outros();}else {cov_1j72yc5n81().b[35][1]++;}}},i(local){cov_1j72yc5n81().f[56]++;cov_1j72yc5n81().s[202]++;if(current){cov_1j72yc5n81().b[36][0]++;cov_1j72yc5n81().s[203]++;return;}else {cov_1j72yc5n81().b[36][1]++;}cov_1j72yc5n81().s[204]++;transition_in(uicolumn.$$.fragment,local);cov_1j72yc5n81().s[205]++;transition_in(if_block);cov_1j72yc5n81().s[206]++;current=true;},o(local){cov_1j72yc5n81().f[57]++;cov_1j72yc5n81().s[207]++;transition_out(uicolumn.$$.fragment,local);cov_1j72yc5n81().s[208]++;transition_out(if_block);cov_1j72yc5n81().s[209]++;current=false;},d(detaching){cov_1j72yc5n81().f[58]++;cov_1j72yc5n81().s[210]++;if(detaching){cov_1j72yc5n81().b[37][0]++;cov_1j72yc5n81().s[211]++;detach(t);cov_1j72yc5n81().s[212]++;detach(if_block_anchor);}else {cov_1j72yc5n81().b[37][1]++;}cov_1j72yc5n81().s[213]++;destroy_component(uicolumn,detaching);cov_1j72yc5n81().s[214]++;if(if_block){cov_1j72yc5n81().b[38][0]++;cov_1j72yc5n81().s[215]++;if_block.d(detaching);}else {cov_1j72yc5n81().b[38][1]++;}}};}function create_fragment$1(ctx){cov_1j72yc5n81().f[59]++;let uicolumns;let current;cov_1j72yc5n81().s[216]++;uicolumns=new/*UIColumns*/ctx[12]({props:{$$slots:{default:[create_default_slot]},$$scope:{ctx}}});cov_1j72yc5n81().s[217]++;return {c(){cov_1j72yc5n81().f[60]++;cov_1j72yc5n81().s[218]++;create_component(uicolumns.$$.fragment);},m(target,anchor){cov_1j72yc5n81().f[61]++;cov_1j72yc5n81().s[219]++;mount_component(uicolumns,target,anchor);cov_1j72yc5n81().s[220]++;current=true;},p(ctx,dirty){cov_1j72yc5n81().f[62]++;const uicolumns_changes=(cov_1j72yc5n81().s[221]++,{});cov_1j72yc5n81().s[222]++;if(dirty[0]&/*narrow, fieldname, allErrors, showErrors, validationClasses, VISIBLE_BUTTONS, readonly, loading, userData*/511|dirty[1]&/*$$scope*/2){cov_1j72yc5n81().b[39][0]++;cov_1j72yc5n81().s[223]++;uicolumns_changes.$$scope={dirty,ctx};}else {cov_1j72yc5n81().b[39][1]++;}cov_1j72yc5n81().s[224]++;uicolumns.$set(uicolumns_changes);},i(local){cov_1j72yc5n81().f[63]++;cov_1j72yc5n81().s[225]++;if(current){cov_1j72yc5n81().b[40][0]++;cov_1j72yc5n81().s[226]++;return;}else {cov_1j72yc5n81().b[40][1]++;}cov_1j72yc5n81().s[227]++;transition_in(uicolumns.$$.fragment,local);cov_1j72yc5n81().s[228]++;current=true;},o(local){cov_1j72yc5n81().f[64]++;cov_1j72yc5n81().s[229]++;transition_out(uicolumns.$$.fragment,local);cov_1j72yc5n81().s[230]++;current=false;},d(detaching){cov_1j72yc5n81().f[65]++;cov_1j72yc5n81().s[231]++;destroy_component(uicolumns,detaching);}};}function instance$1($$self,$$props,$$invalidate){cov_1j72yc5n81().f[66]++;let allErrors;let showErrors;let validationClasses;const{UIButtons}=(cov_1j72yc5n81().s[232]++,index$a);const{UIErrorsList}=(cov_1j72yc5n81().s[233]++,index$9);const{UIColumn,UIColumns}=(cov_1j72yc5n81().s[234]++,index$8);const{UICommon}=(cov_1j72yc5n81().s[235]++,Elements);let dispatch=(cov_1j72yc5n81().s[236]++,createEventDispatcher());let{value}=(cov_1j72yc5n81().s[237]++,$$props);let{inputStarted=(cov_1j72yc5n81().b[41][0]++,false)}=(cov_1j72yc5n81().s[238]++,$$props);let{fieldname=(cov_1j72yc5n81().b[42][0]++,"user")}=(cov_1j72yc5n81().s[239]++,$$props);let{readonly=(cov_1j72yc5n81().b[43][0]++,false)}=(cov_1j72yc5n81().s[240]++,$$props);let{valid=(cov_1j72yc5n81().b[44][0]++,true)}=(cov_1j72yc5n81().s[241]++,$$props);let{validated=(cov_1j72yc5n81().b[45][0]++,false)}=(cov_1j72yc5n81().s[242]++,$$props);let{errors=(cov_1j72yc5n81().b[46][0]++,false)}=(cov_1j72yc5n81().s[243]++,$$props);let{formErrors=(cov_1j72yc5n81().b[47][0]++,false)}=(cov_1j72yc5n81().s[244]++,$$props);let{formLevelError=(cov_1j72yc5n81().b[48][0]++,false)}=(cov_1j72yc5n81().s[245]++,$$props);let{serviceName=(cov_1j72yc5n81().b[49][0]++,"nsUser")}=(cov_1j72yc5n81().s[246]++,$$props);let{userData=(cov_1j72yc5n81().b[50][0]++,null)}=(cov_1j72yc5n81().s[247]++,$$props);let{loading=(cov_1j72yc5n81().b[51][0]++,false)}=(cov_1j72yc5n81().s[248]++,$$props);let{narrow=(cov_1j72yc5n81().b[52][0]++,false)}=(cov_1j72yc5n81().s[249]++,$$props);function getService(){cov_1j72yc5n81().f[67]++;cov_1j72yc5n81().s[250]++;return notCommon$1.getApp().getService(serviceName);}function openUserSearchAndSelect(){cov_1j72yc5n81().f[68]++;cov_1j72yc5n81().s[251]++;getService().openSelector().then(results=>{cov_1j72yc5n81().f[69]++;cov_1j72yc5n81().s[252]++;$$invalidate(13,value=results._id);cov_1j72yc5n81().s[253]++;$$invalidate(0,userData=results);cov_1j72yc5n81().s[254]++;return value;}).then(value=>{cov_1j72yc5n81().f[70]++;cov_1j72yc5n81().s[255]++;$$invalidate(14,inputStarted=true);cov_1j72yc5n81().s[256]++;dispatch("change",{field:fieldname,value});}).catch(e=>{cov_1j72yc5n81().f[71]++;cov_1j72yc5n81().s[257]++;notCommon$1.report(e);});}function resetUser(){cov_1j72yc5n81().f[72]++;cov_1j72yc5n81().s[258]++;$$invalidate(13,value=undefined);cov_1j72yc5n81().s[259]++;$$invalidate(0,userData=null);cov_1j72yc5n81().s[260]++;dispatch("change",{field:fieldname,value});}async function loadUserData(){cov_1j72yc5n81().f[73]++;cov_1j72yc5n81().s[261]++;try{cov_1j72yc5n81().s[262]++;if(value){cov_1j72yc5n81().b[53][0]++;cov_1j72yc5n81().s[263]++;$$invalidate(1,loading=true);cov_1j72yc5n81().s[264]++;$$invalidate(0,userData=await getService().loadUserData(value));}else {cov_1j72yc5n81().b[53][1]++;}}catch(e){cov_1j72yc5n81().s[265]++;notCommon$1.report(e);}finally{cov_1j72yc5n81().s[266]++;$$invalidate(1,loading=false);}}cov_1j72yc5n81().s[267]++;onMount(()=>{cov_1j72yc5n81().f[74]++;cov_1j72yc5n81().s[268]++;loadUserData();});const AVAILABLE_BUTTONS=(cov_1j72yc5n81().s[269]++,[{id:1,action:openUserSearchAndSelect,title:"not-node:field_select_label"},{id:2,action:resetUser,icon:"times",color:"danger"}]);let VISIBLE_BUTTONS=(cov_1j72yc5n81().s[270]++,[]);function uierrorslist_errors_binding(value){cov_1j72yc5n81().f[75]++;cov_1j72yc5n81().s[271]++;allErrors=value;cov_1j72yc5n81().s[272]++;$$invalidate(8,allErrors),$$invalidate(17,errors),$$invalidate(18,formErrors);}function uierrorslist_show_binding(value){cov_1j72yc5n81().f[76]++;cov_1j72yc5n81().s[273]++;showErrors=value;cov_1j72yc5n81().s[274]++;$$invalidate(7,showErrors),$$invalidate(16,validated),$$invalidate(15,valid),$$invalidate(14,inputStarted);}function uierrorslist_classes_binding(value){cov_1j72yc5n81().f[77]++;cov_1j72yc5n81().s[275]++;validationClasses=value;cov_1j72yc5n81().s[276]++;$$invalidate(6,validationClasses),$$invalidate(15,valid),$$invalidate(14,inputStarted);}cov_1j72yc5n81().s[277]++;$$self.$$set=$$props=>{cov_1j72yc5n81().f[78]++;cov_1j72yc5n81().s[278]++;if('value'in $$props){cov_1j72yc5n81().b[54][0]++;cov_1j72yc5n81().s[279]++;$$invalidate(13,value=$$props.value);}else {cov_1j72yc5n81().b[54][1]++;}cov_1j72yc5n81().s[280]++;if('inputStarted'in $$props){cov_1j72yc5n81().b[55][0]++;cov_1j72yc5n81().s[281]++;$$invalidate(14,inputStarted=$$props.inputStarted);}else {cov_1j72yc5n81().b[55][1]++;}cov_1j72yc5n81().s[282]++;if('fieldname'in $$props){cov_1j72yc5n81().b[56][0]++;cov_1j72yc5n81().s[283]++;$$invalidate(2,fieldname=$$props.fieldname);}else {cov_1j72yc5n81().b[56][1]++;}cov_1j72yc5n81().s[284]++;if('readonly'in $$props){cov_1j72yc5n81().b[57][0]++;cov_1j72yc5n81().s[285]++;$$invalidate(3,readonly=$$props.readonly);}else {cov_1j72yc5n81().b[57][1]++;}cov_1j72yc5n81().s[286]++;if('valid'in $$props){cov_1j72yc5n81().b[58][0]++;cov_1j72yc5n81().s[287]++;$$invalidate(15,valid=$$props.valid);}else {cov_1j72yc5n81().b[58][1]++;}cov_1j72yc5n81().s[288]++;if('validated'in $$props){cov_1j72yc5n81().b[59][0]++;cov_1j72yc5n81().s[289]++;$$invalidate(16,validated=$$props.validated);}else {cov_1j72yc5n81().b[59][1]++;}cov_1j72yc5n81().s[290]++;if('errors'in $$props){cov_1j72yc5n81().b[60][0]++;cov_1j72yc5n81().s[291]++;$$invalidate(17,errors=$$props.errors);}else {cov_1j72yc5n81().b[60][1]++;}cov_1j72yc5n81().s[292]++;if('formErrors'in $$props){cov_1j72yc5n81().b[61][0]++;cov_1j72yc5n81().s[293]++;$$invalidate(18,formErrors=$$props.formErrors);}else {cov_1j72yc5n81().b[61][1]++;}cov_1j72yc5n81().s[294]++;if('formLevelError'in $$props){cov_1j72yc5n81().b[62][0]++;cov_1j72yc5n81().s[295]++;$$invalidate(19,formLevelError=$$props.formLevelError);}else {cov_1j72yc5n81().b[62][1]++;}cov_1j72yc5n81().s[296]++;if('serviceName'in $$props){cov_1j72yc5n81().b[63][0]++;cov_1j72yc5n81().s[297]++;$$invalidate(20,serviceName=$$props.serviceName);}else {cov_1j72yc5n81().b[63][1]++;}cov_1j72yc5n81().s[298]++;if('userData'in $$props){cov_1j72yc5n81().b[64][0]++;cov_1j72yc5n81().s[299]++;$$invalidate(0,userData=$$props.userData);}else {cov_1j72yc5n81().b[64][1]++;}cov_1j72yc5n81().s[300]++;if('loading'in $$props){cov_1j72yc5n81().b[65][0]++;cov_1j72yc5n81().s[301]++;$$invalidate(1,loading=$$props.loading);}else {cov_1j72yc5n81().b[65][1]++;}cov_1j72yc5n81().s[302]++;if('narrow'in $$props){cov_1j72yc5n81().b[66][0]++;cov_1j72yc5n81().s[303]++;$$invalidate(4,narrow=$$props.narrow);}else {cov_1j72yc5n81().b[66][1]++;}};cov_1j72yc5n81().s[304]++;$$self.$$.update=()=>{cov_1j72yc5n81().f[79]++;cov_1j72yc5n81().s[305]++;if($$self.$$.dirty[0]&/*errors, formErrors*/393216){cov_1j72yc5n81().b[67][0]++;cov_1j72yc5n81().s[306]++;cov_1j72yc5n81().s[307]++;$$invalidate(8,allErrors=[].concat(errors?(cov_1j72yc5n81().b[68][0]++,errors):(cov_1j72yc5n81().b[68][1]++,[]),formErrors?(cov_1j72yc5n81().b[69][0]++,formErrors):(cov_1j72yc5n81().b[69][1]++,[])));}else {cov_1j72yc5n81().b[67][1]++;}cov_1j72yc5n81().s[308]++;if($$self.$$.dirty[0]&/*validated, valid, inputStarted*/114688){cov_1j72yc5n81().b[70][0]++;cov_1j72yc5n81().s[309]++;cov_1j72yc5n81().s[310]++;$$invalidate(7,showErrors=(cov_1j72yc5n81().b[71][0]++,!((cov_1j72yc5n81().b[72][0]++,validated)&&(cov_1j72yc5n81().b[72][1]++,valid)))&&(cov_1j72yc5n81().b[71][1]++,inputStarted));}else {cov_1j72yc5n81().b[70][1]++;}cov_1j72yc5n81().s[311]++;if($$self.$$.dirty[0]&/*valid, formLevelError*/557056){cov_1j72yc5n81().b[73][0]++;cov_1j72yc5n81().s[312]++;cov_1j72yc5n81().s[313]++;(cov_1j72yc5n81().b[74][0]++,valid===false)||(cov_1j72yc5n81().b[74][1]++,formLevelError);}else {cov_1j72yc5n81().b[73][1]++;}cov_1j72yc5n81().s[314]++;if($$self.$$.dirty[0]&/*valid, inputStarted*/49152){cov_1j72yc5n81().b[75][0]++;cov_1j72yc5n81().s[315]++;cov_1j72yc5n81().s[316]++;$$invalidate(6,validationClasses=(cov_1j72yc5n81().b[77][0]++,valid===true)||(cov_1j72yc5n81().b[77][1]++,!inputStarted)?(cov_1j72yc5n81().b[76][0]++,UICommon.CLASS_OK):(cov_1j72yc5n81().b[76][1]++,UICommon.CLASS_ERR));}else {cov_1j72yc5n81().b[75][1]++;}cov_1j72yc5n81().s[317]++;if($$self.$$.dirty[0]&/*value*/8192){cov_1j72yc5n81().b[78][0]++;cov_1j72yc5n81().s[318]++;{cov_1j72yc5n81().s[319]++;if(value){cov_1j72yc5n81().b[79][0]++;cov_1j72yc5n81().s[320]++;$$invalidate(5,VISIBLE_BUTTONS=[...AVAILABLE_BUTTONS]);}else {cov_1j72yc5n81().b[79][1]++;cov_1j72yc5n81().s[321]++;$$invalidate(5,VISIBLE_BUTTONS=[AVAILABLE_BUTTONS[0]]);}}}else {cov_1j72yc5n81().b[78][1]++;}};cov_1j72yc5n81().s[322]++;return [userData,loading,fieldname,readonly,narrow,VISIBLE_BUTTONS,validationClasses,showErrors,allErrors,UIButtons,UIErrorsList,UIColumn,UIColumns,value,inputStarted,valid,validated,errors,formErrors,formLevelError,serviceName,uierrorslist_errors_binding,uierrorslist_show_binding,uierrorslist_classes_binding];}class UISelectUser extends SvelteComponent{constructor(options){cov_1j72yc5n81().f[80]++;cov_1j72yc5n81().s[323]++;super();cov_1j72yc5n81().s[324]++;init(this,options,instance$1,create_fragment$1,safe_not_equal,{value:13,inputStarted:14,fieldname:2,readonly:3,valid:15,validated:16,errors:17,formErrors:18,formLevelError:19,serviceName:20,userData:0,loading:1,narrow:4},null,[-1,-1]);}}

	function cov_1gp5eeevjy(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/common/UISelectUserInline.svelte";var hash="93fe0fe5d0422ab0b982c88a2fe53427918a2996";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/common/UISelectUserInline.svelte",statementMap:{"0":{start:{line:26,column:1},end:{line:28,column:5}},"1":{start:{line:30,column:1},end:{line:62,column:3}},"2":{start:{line:32,column:3},end:{line:32,column:24}},"3":{start:{line:33,column:3},end:{line:33,column:43}},"4":{start:{line:34,column:3},end:{line:34,column:33}},"5":{start:{line:37,column:3},end:{line:37,column:31}},"6":{start:{line:38,column:3},end:{line:38,column:41}},"7":{start:{line:39,column:3},end:{line:39,column:18}},"8":{start:{line:42,column:29},end:{line:42,column:31}},"9":{start:{line:43,column:3},end:{line:43,column:92}},"10":{start:{line:43,column:38},end:{line:43,column:92}},"11":{start:{line:44,column:3},end:{line:44,column:37}},"12":{start:{line:47,column:3},end:{line:47,column:23}},"13":{start:{line:47,column:16},end:{line:47,column:23}},"14":{start:{line:48,column:3},end:{line:48,column:47}},"15":{start:{line:49,column:3},end:{line:49,column:18}},"16":{start:{line:52,column:3},end:{line:52,column:48}},"17":{start:{line:53,column:3},end:{line:53,column:19}},"18":{start:{line:56,column:3},end:{line:58,column:4}},"19":{start:{line:57,column:4},end:{line:57,column:16}},"20":{start:{line:60,column:3},end:{line:60,column:32}},"21":{start:{line:66,column:23},end:{line:66,column:39}},"22":{start:{line:67,column:16},end:{line:67,column:39}},"23":{start:{line:68,column:17},end:{line:68,column:24}},"24":{start:{line:69,column:32},end:{line:69,column:39}},"25":{start:{line:70,column:30},end:{line:70,column:37}},"26":{start:{line:71,column:28},end:{line:71,column:35}},"27":{start:{line:72,column:34},end:{line:72,column:41}},"28":{start:{line:73,column:27},end:{line:73,column:34}},"29":{start:{line:74,column:27},end:{line:74,column:34}},"30":{start:{line:75,column:73},end:{line:75,column:80}},"31":{start:{line:75,column:35},end:{line:75,column:68}},"32":{start:{line:78,column:2},end:{line:78,column:52}},"33":{start:{line:82,column:2},end:{line:91,column:5}},"34":{start:{line:83,column:3},end:{line:83,column:40}},"35":{start:{line:84,column:3},end:{line:84,column:39}},"36":{start:{line:85,column:3},end:{line:85,column:16}},"37":{start:{line:87,column:3},end:{line:87,column:40}},"38":{start:{line:88,column:3},end:{line:88,column:51}},"39":{start:{line:90,column:3},end:{line:90,column:23}},"40":{start:{line:95,column:2},end:{line:95,column:37}},"41":{start:{line:96,column:2},end:{line:96,column:35}},"42":{start:{line:97,column:2},end:{line:97,column:50}},"43":{start:{line:101,column:2},end:{line:110,column:3}},"44":{start:{line:102,column:3},end:{line:105,column:4}},"45":{start:{line:103,column:4},end:{line:103,column:36}},"46":{start:{line:104,column:4},end:{line:104,column:71}},"47":{start:{line:107,column:3},end:{line:107,column:23}},"48":{start:{line:109,column:3},end:{line:109,column:36}},"49":{start:{line:113,column:1},end:{line:115,column:4}},"50":{start:{line:114,column:2},end:{line:114,column:17}},"51":{start:{line:117,column:27},end:{line:130,column:2}},"52":{start:{line:133,column:2},end:{line:152,column:3}},"53":{start:{line:134,column:3},end:{line:138,column:5}},"54":{start:{line:140,column:3},end:{line:151,column:4}},"55":{start:{line:141,column:4},end:{line:145,column:6}},"56":{start:{line:147,column:4},end:{line:150,column:6}},"57":{start:{line:155,column:23},end:{line:155,column:25}},"58":{start:{line:157,column:1},end:{line:166,column:3}},"59":{start:{line:158,column:2},end:{line:158,column:65}},"60":{start:{line:158,column:26},end:{line:158,column:65}},"61":{start:{line:159,column:2},end:{line:159,column:86}},"62":{start:{line:159,column:33},end:{line:159,column:86}},"63":{start:{line:160,column:2},end:{line:160,column:77}},"64":{start:{line:160,column:30},end:{line:160,column:77}},"65":{start:{line:161,column:2},end:{line:161,column:74}},"66":{start:{line:161,column:29},end:{line:161,column:74}},"67":{start:{line:162,column:2},end:{line:162,column:83}},"68":{start:{line:162,column:32},end:{line:162,column:83}},"69":{start:{line:163,column:2},end:{line:163,column:74}},"70":{start:{line:163,column:29},end:{line:163,column:74}},"71":{start:{line:164,column:2},end:{line:164,column:71}},"72":{start:{line:164,column:28},end:{line:164,column:71}},"73":{start:{line:165,column:2},end:{line:165,column:101}},"74":{start:{line:165,column:38},end:{line:165,column:101}},"75":{start:{line:168,column:1},end:{line:178,column:3}},"76":{start:{line:169,column:2},end:{line:177,column:3}},"77":{start:{line:170,column:3},end:{line:176,column:4}},"78":{start:{line:171,column:4},end:{line:175,column:5}},"79":{start:{line:172,column:5},end:{line:172,column:96}},"80":{start:{line:174,column:5},end:{line:174,column:101}},"81":{start:{line:180,column:1},end:{line:191,column:3}},"82":{start:{line:196,column:2},end:{line:196,column:10}},"83":{start:{line:198,column:2},end:{line:207,column:5}}},fnMap:{"0":{name:"create_fragment",decl:{start:{line:21,column:9},end:{line:21,column:24}},loc:{start:{line:21,column:30},end:{line:63,column:1}},line:21},"1":{name:"(anonymous_1)",decl:{start:{line:31,column:2},end:{line:31,column:3}},loc:{start:{line:31,column:6},end:{line:35,column:3}},line:31},"2":{name:"(anonymous_2)",decl:{start:{line:36,column:2},end:{line:36,column:3}},loc:{start:{line:36,column:20},end:{line:40,column:3}},line:36},"3":{name:"(anonymous_3)",decl:{start:{line:41,column:2},end:{line:41,column:3}},loc:{start:{line:41,column:18},end:{line:45,column:3}},line:41},"4":{name:"(anonymous_4)",decl:{start:{line:46,column:2},end:{line:46,column:3}},loc:{start:{line:46,column:11},end:{line:50,column:3}},line:46},"5":{name:"(anonymous_5)",decl:{start:{line:51,column:2},end:{line:51,column:3}},loc:{start:{line:51,column:11},end:{line:54,column:3}},line:51},"6":{name:"(anonymous_6)",decl:{start:{line:55,column:2},end:{line:55,column:3}},loc:{start:{line:55,column:15},end:{line:61,column:3}},line:55},"7":{name:"instance",decl:{start:{line:65,column:9},end:{line:65,column:17}},loc:{start:{line:65,column:49},end:{line:192,column:1}},line:65},"8":{name:"(anonymous_8)",decl:{start:{line:75,column:27},end:{line:75,column:28}},loc:{start:{line:75,column:35},end:{line:75,column:68}},line:75},"9":{name:"getService",decl:{start:{line:77,column:10},end:{line:77,column:20}},loc:{start:{line:77,column:23},end:{line:79,column:2}},line:77},"10":{name:"openUserSearchAndSelect",decl:{start:{line:81,column:10},end:{line:81,column:33}},loc:{start:{line:81,column:36},end:{line:92,column:2}},line:81},"11":{name:"(anonymous_11)",decl:{start:{line:82,column:35},end:{line:82,column:36}},loc:{start:{line:82,column:46},end:{line:86,column:3}},line:82},"12":{name:"(anonymous_12)",decl:{start:{line:86,column:10},end:{line:86,column:11}},loc:{start:{line:86,column:19},end:{line:89,column:3}},line:86},"13":{name:"(anonymous_13)",decl:{start:{line:89,column:11},end:{line:89,column:12}},loc:{start:{line:89,column:16},end:{line:91,column:3}},line:89},"14":{name:"resetUser",decl:{start:{line:94,column:10},end:{line:94,column:19}},loc:{start:{line:94,column:22},end:{line:98,column:2}},line:94},"15":{name:"loadUserData",decl:{start:{line:100,column:16},end:{line:100,column:28}},loc:{start:{line:100,column:31},end:{line:111,column:2}},line:100},"16":{name:"(anonymous_16)",decl:{start:{line:113,column:9},end:{line:113,column:10}},loc:{start:{line:113,column:15},end:{line:115,column:2}},line:113},"17":{name:"getUserButton",decl:{start:{line:132,column:10},end:{line:132,column:23}},loc:{start:{line:132,column:26},end:{line:153,column:2}},line:132},"18":{name:"(anonymous_18)",decl:{start:{line:157,column:16},end:{line:157,column:17}},loc:{start:{line:157,column:27},end:{line:166,column:2}},line:157},"19":{name:"(anonymous_19)",decl:{start:{line:168,column:20},end:{line:168,column:21}},loc:{start:{line:168,column:26},end:{line:178,column:2}},line:168},"20":{name:"(anonymous_20)",decl:{start:{line:195,column:1},end:{line:195,column:2}},loc:{start:{line:195,column:22},end:{line:208,column:2}},line:195}},branchMap:{"0":{loc:{start:{line:43,column:3},end:{line:43,column:92}},type:"if",locations:[{start:{line:43,column:3},end:{line:43,column:92}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:43},"1":{loc:{start:{line:47,column:3},end:{line:47,column:23}},type:"if",locations:[{start:{line:47,column:3},end:{line:47,column:23}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:47},"2":{loc:{start:{line:56,column:3},end:{line:58,column:4}},type:"if",locations:[{start:{line:56,column:3},end:{line:58,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:56},"3":{loc:{start:{line:69,column:7},end:{line:69,column:27}},type:"default-arg",locations:[{start:{line:69,column:22},end:{line:69,column:27}}],line:69},"4":{loc:{start:{line:70,column:7},end:{line:70,column:25}},type:"default-arg",locations:[{start:{line:70,column:19},end:{line:70,column:25}}],line:70},"5":{loc:{start:{line:71,column:7},end:{line:71,column:23}},type:"default-arg",locations:[{start:{line:71,column:18},end:{line:71,column:23}}],line:71},"6":{loc:{start:{line:72,column:7},end:{line:72,column:29}},type:"default-arg",locations:[{start:{line:72,column:21},end:{line:72,column:29}}],line:72},"7":{loc:{start:{line:73,column:7},end:{line:73,column:22}},type:"default-arg",locations:[{start:{line:73,column:18},end:{line:73,column:22}}],line:73},"8":{loc:{start:{line:74,column:7},end:{line:74,column:22}},type:"default-arg",locations:[{start:{line:74,column:17},end:{line:74,column:22}}],line:74},"9":{loc:{start:{line:75,column:7},end:{line:75,column:68}},type:"default-arg",locations:[{start:{line:75,column:27},end:{line:75,column:68}}],line:75},"10":{loc:{start:{line:102,column:3},end:{line:105,column:4}},type:"if",locations:[{start:{line:102,column:3},end:{line:105,column:4}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:102},"11":{loc:{start:{line:133,column:2},end:{line:152,column:3}},type:"if",locations:[{start:{line:133,column:2},end:{line:152,column:3}},{start:{line:139,column:9},end:{line:152,column:3}}],line:133},"12":{loc:{start:{line:140,column:3},end:{line:151,column:4}},type:"if",locations:[{start:{line:140,column:3},end:{line:151,column:4}},{start:{line:146,column:10},end:{line:151,column:4}}],line:140},"13":{loc:{start:{line:158,column:2},end:{line:158,column:65}},type:"if",locations:[{start:{line:158,column:2},end:{line:158,column:65}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:158},"14":{loc:{start:{line:159,column:2},end:{line:159,column:86}},type:"if",locations:[{start:{line:159,column:2},end:{line:159,column:86}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:159},"15":{loc:{start:{line:160,column:2},end:{line:160,column:77}},type:"if",locations:[{start:{line:160,column:2},end:{line:160,column:77}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:160},"16":{loc:{start:{line:161,column:2},end:{line:161,column:74}},type:"if",locations:[{start:{line:161,column:2},end:{line:161,column:74}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:161},"17":{loc:{start:{line:162,column:2},end:{line:162,column:83}},type:"if",locations:[{start:{line:162,column:2},end:{line:162,column:83}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:162},"18":{loc:{start:{line:163,column:2},end:{line:163,column:74}},type:"if",locations:[{start:{line:163,column:2},end:{line:163,column:74}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:163},"19":{loc:{start:{line:164,column:2},end:{line:164,column:71}},type:"if",locations:[{start:{line:164,column:2},end:{line:164,column:71}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:164},"20":{loc:{start:{line:165,column:2},end:{line:165,column:101}},type:"if",locations:[{start:{line:165,column:2},end:{line:165,column:101}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:165},"21":{loc:{start:{line:169,column:2},end:{line:177,column:3}},type:"if",locations:[{start:{line:169,column:2},end:{line:177,column:3}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:169},"22":{loc:{start:{line:171,column:4},end:{line:175,column:5}},type:"if",locations:[{start:{line:171,column:4},end:{line:175,column:5}},{start:{line:173,column:11},end:{line:175,column:5}}],line:171},"23":{loc:{start:{line:172,column:60},end:{line:172,column:93}},type:"cond-expr",locations:[{start:{line:172,column:71},end:{line:172,column:73}},{start:{line:172,column:76},end:{line:172,column:93}}],line:172},"24":{loc:{start:{line:174,column:60},end:{line:174,column:98}},type:"cond-expr",locations:[{start:{line:174,column:71},end:{line:174,column:73}},{start:{line:174,column:76},end:{line:174,column:98}}],line:174}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0,"50":0,"51":0,"52":0,"53":0,"54":0,"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"61":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":0,"68":0,"69":0,"70":0,"71":0,"72":0,"73":0,"74":0,"75":0,"76":0,"77":0,"78":0,"79":0,"80":0,"81":0,"82":0,"83":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0},b:{"0":[0,0],"1":[0,0],"2":[0,0],"3":[0],"4":[0],"5":[0],"6":[0],"7":[0],"8":[0],"9":[0],"10":[0,0],"11":[0,0],"12":[0,0],"13":[0,0],"14":[0,0],"15":[0,0],"16":[0,0],"17":[0,0],"18":[0,0],"19":[0,0],"20":[0,0],"21":[0,0],"22":[0,0],"23":[0,0],"24":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/common/UISelectUserInline.svelte"],sourcesContent:["<script>\n    import { Elements, notCommon } from \"not-bulma\";\n\n    const { UIButtons } = Elements.Buttons;\n\n    import { createEventDispatcher, onMount } from \"svelte\";\n    let dispatch = createEventDispatcher();\n\n    export let value;\n    export let inputStarted = false;\n    export let fieldname = \"user\";\n    //export let required = true;\n    export let readonly = false;\n\n    export let serviceName = \"nsUser\";\n    export let userData = null;\n    export let loading = false;\n    export let usernameFormatter = (data) => `${data.userID}#${data.username}`;\n\n    function getService() {\n        return notCommon.getApp().getService(serviceName);\n    }\n\n    function openUserSearchAndSelect() {\n        getService()\n            .openSelector()\n            .then((results) => {\n                value = results._id;\n                userData = results;\n                return value;\n            })\n            .then((value) => {\n                inputStarted = true;\n                dispatch(\"change\", {\n                    field: fieldname,\n                    value,\n                });\n            })\n            .catch((e) => {\n                notCommon.report(e);\n            });\n    }\n\n    function resetUser() {\n        value = undefined;\n        userData = null;\n        dispatch(\"change\", {\n            field: fieldname,\n            value,\n        });\n    }\n\n    async function loadUserData() {\n        try {\n            if (value) {\n                loading = true;\n                userData = await getService().loadUserData(value);\n            }\n        } catch (e) {\n            notCommon.report(e);\n        } finally {\n            loading = false;\n        }\n    }\n\n    onMount(() => {\n        loadUserData();\n    });\n\n    const AVAILABLE_BUTTONS = [\n        {\n            id: 1,\n            action: openUserSearchAndSelect,\n            icon: \"user-edit\",\n            color: \"warning\",\n        },\n        {\n            id: 2,\n            action: resetUser,\n            icon: \"times\",\n            color: \"danger\",\n        },\n    ];\n\n    function getUserButton() {\n        if (loading) {\n            return {\n                disabled: true,\n                loading,\n                title: \"not-node:loading_label\",\n            };\n        } else {\n            if (userData) {\n                return {\n                    disabled: readonly,\n                    action: openUserSearchAndSelect,\n                    title: usernameFormatter(userData),\n                };\n            } else {\n                return {\n                    disabled: true,\n                    title: \"not-node:field_value_is_empty_placeholder\",\n                };\n            }\n        }\n    }\n\n    let VISIBLE_BUTTONS = [];\n    $: {\n        if (value) {\n            VISIBLE_BUTTONS = [\n                getUserButton(),\n                ...(readonly ? [] : AVAILABLE_BUTTONS),\n            ];\n        } else {\n            VISIBLE_BUTTONS = [\n                getUserButton(),\n                ...(readonly ? [] : [AVAILABLE_BUTTONS[0]]),\n            ];\n        }\n    }\n</script>\n\n<div class=\"control\">\n    <UIButtons values={VISIBLE_BUTTONS}></UIButtons>\n</div>\n"],names:[],mappings:";;;;;;;;;;;;;;;;;SACa,QAAQ,EAAE,SAAS,QAAQ,WAAW;SAItC,qBAAqB,EAAE,OAAO,QAAQ,QAAQ;;;;;;;;wCAuHpC,GAAe;;;;;;;;;;GADtC,MAEM;;;;;;qFADiB,GAAe;;;;;;;;;;;;;;;;;;;;;;;SAzH1B,SAAS,KAAK,QAAQ,CAAC,OAAO;KAGlC,QAAQ,GAAG,qBAAqB;OAEzB,KAAK;OACL,YAAY,GAAG,KAAK;OACpB,SAAS,GAAG,MAAM;OAElB,QAAQ,GAAG,KAAK;OAEhB,WAAW,GAAG,QAAQ;OACtB,QAAQ,GAAG,IAAI;OACf,OAAO,GAAG,KAAK;OACf,iBAAiB,GAAI,IAAI,OAAQ,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ;;UAE/D,UAAU;SACR,SAAS,CAAC,MAAM,GAAG,UAAU,CAAC,WAAW;;;UAG3C,uBAAuB;EAC5B,UAAU,GACL,YAAY,GACZ,IAAI,CAAE,OAAO;mBACV,KAAK,GAAG,OAAO,CAAC,GAAG;mBACnB,QAAQ,GAAG,OAAO;UACX,KAAK;KAEf,IAAI,CAAE,KAAK;mBACR,YAAY,GAAG,IAAI;GACnB,QAAQ,CAAC,QAAQ,IACb,KAAK,EAAE,SAAS,EAChB,KAAK;KAGZ,KAAK,CAAE,CAAC;GACL,SAAS,CAAC,MAAM,CAAC,CAAC;;;;UAIrB,SAAS;kBACd,KAAK,GAAG,SAAS;kBACjB,QAAQ,GAAG,IAAI;EACf,QAAQ,CAAC,QAAQ,IACb,KAAK,EAAE,SAAS,EAChB,KAAK;;;gBAIE,YAAY;;OAEf,KAAK;oBACL,OAAO,GAAG,IAAI;oBACd,QAAQ,SAAS,UAAU,GAAG,YAAY,CAAC,KAAK;;UAE/C,CAAC;GACN,SAAS,CAAC,MAAM,CAAC,CAAC;;mBAElB,OAAO,GAAG,KAAK;;;;CAIvB,OAAO;EACH,YAAY;;;OAGV,iBAAiB;;GAEf,EAAE,EAAE,CAAC;GACL,MAAM,EAAE,uBAAuB;GAC/B,IAAI,EAAE,WAAW;GACjB,KAAK,EAAE,SAAS;;;GAGhB,EAAE,EAAE,CAAC;GACL,MAAM,EAAE,SAAS;GACjB,IAAI,EAAE,OAAO;GACb,KAAK,EAAE,QAAQ;;;;UAId,aAAa;MACd,OAAO;;IAEH,QAAQ,EAAE,IAAI;IACd,OAAO;IACP,KAAK,EAAE,wBAAwB;;;OAG/B,QAAQ;;KAEJ,QAAQ,EAAE,QAAQ;KAClB,MAAM,EAAE,uBAAuB;KAC/B,KAAK,EAAE,iBAAiB,CAAC,QAAQ;;;;KAIjC,QAAQ,EAAE,IAAI;KACd,KAAK,EAAE,2CAA2C;;;;;;KAM9D,eAAe;;;;;;;;;;;;;;;GACnB,CAAC;QACO,KAAK;qBACL,eAAe,IACX,aAAa,OACT,QAAQ,QAAQ,iBAAiB;;qBAGzC,eAAe,IACX,aAAa,OACT,QAAQ,SAAS,iBAAiB,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"93fe0fe5d0422ab0b982c88a2fe53427918a2996"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1gp5eeevjy=function(){return actualCoverage;};}return actualCoverage;}cov_1gp5eeevjy();function create_fragment(ctx){cov_1gp5eeevjy().f[0]++;let div;let uibuttons;let current;cov_1gp5eeevjy().s[0]++;uibuttons=new/*UIButtons*/ctx[1]({props:{values:/*VISIBLE_BUTTONS*/ctx[0]}});cov_1gp5eeevjy().s[1]++;return {c(){cov_1gp5eeevjy().f[1]++;cov_1gp5eeevjy().s[2]++;div=element("div");cov_1gp5eeevjy().s[3]++;create_component(uibuttons.$$.fragment);cov_1gp5eeevjy().s[4]++;attr(div,"class","control");},m(target,anchor){cov_1gp5eeevjy().f[2]++;cov_1gp5eeevjy().s[5]++;insert(target,div,anchor);cov_1gp5eeevjy().s[6]++;mount_component(uibuttons,div,null);cov_1gp5eeevjy().s[7]++;current=true;},p(ctx,[dirty]){cov_1gp5eeevjy().f[3]++;const uibuttons_changes=(cov_1gp5eeevjy().s[8]++,{});cov_1gp5eeevjy().s[9]++;if(dirty&/*VISIBLE_BUTTONS*/1){cov_1gp5eeevjy().b[0][0]++;cov_1gp5eeevjy().s[10]++;uibuttons_changes.values=/*VISIBLE_BUTTONS*/ctx[0];}else {cov_1gp5eeevjy().b[0][1]++;}cov_1gp5eeevjy().s[11]++;uibuttons.$set(uibuttons_changes);},i(local){cov_1gp5eeevjy().f[4]++;cov_1gp5eeevjy().s[12]++;if(current){cov_1gp5eeevjy().b[1][0]++;cov_1gp5eeevjy().s[13]++;return;}else {cov_1gp5eeevjy().b[1][1]++;}cov_1gp5eeevjy().s[14]++;transition_in(uibuttons.$$.fragment,local);cov_1gp5eeevjy().s[15]++;current=true;},o(local){cov_1gp5eeevjy().f[5]++;cov_1gp5eeevjy().s[16]++;transition_out(uibuttons.$$.fragment,local);cov_1gp5eeevjy().s[17]++;current=false;},d(detaching){cov_1gp5eeevjy().f[6]++;cov_1gp5eeevjy().s[18]++;if(detaching){cov_1gp5eeevjy().b[2][0]++;cov_1gp5eeevjy().s[19]++;detach(div);}else {cov_1gp5eeevjy().b[2][1]++;}cov_1gp5eeevjy().s[20]++;destroy_component(uibuttons);}};}function instance($$self,$$props,$$invalidate){cov_1gp5eeevjy().f[7]++;const{UIButtons}=(cov_1gp5eeevjy().s[21]++,index$a);let dispatch=(cov_1gp5eeevjy().s[22]++,createEventDispatcher());let{value}=(cov_1gp5eeevjy().s[23]++,$$props);let{inputStarted=(cov_1gp5eeevjy().b[3][0]++,false)}=(cov_1gp5eeevjy().s[24]++,$$props);let{fieldname=(cov_1gp5eeevjy().b[4][0]++,"user")}=(cov_1gp5eeevjy().s[25]++,$$props);let{readonly=(cov_1gp5eeevjy().b[5][0]++,false)}=(cov_1gp5eeevjy().s[26]++,$$props);let{serviceName=(cov_1gp5eeevjy().b[6][0]++,"nsUser")}=(cov_1gp5eeevjy().s[27]++,$$props);let{userData=(cov_1gp5eeevjy().b[7][0]++,null)}=(cov_1gp5eeevjy().s[28]++,$$props);let{loading=(cov_1gp5eeevjy().b[8][0]++,false)}=(cov_1gp5eeevjy().s[29]++,$$props);let{usernameFormatter=(cov_1gp5eeevjy().b[9][0]++,data=>{cov_1gp5eeevjy().f[8]++;cov_1gp5eeevjy().s[31]++;return `${data.userID}#${data.username}`;})}=(cov_1gp5eeevjy().s[30]++,$$props);function getService(){cov_1gp5eeevjy().f[9]++;cov_1gp5eeevjy().s[32]++;return notCommon$1.getApp().getService(serviceName);}function openUserSearchAndSelect(){cov_1gp5eeevjy().f[10]++;cov_1gp5eeevjy().s[33]++;getService().openSelector().then(results=>{cov_1gp5eeevjy().f[11]++;cov_1gp5eeevjy().s[34]++;$$invalidate(2,value=results._id);cov_1gp5eeevjy().s[35]++;$$invalidate(4,userData=results);cov_1gp5eeevjy().s[36]++;return value;}).then(value=>{cov_1gp5eeevjy().f[12]++;cov_1gp5eeevjy().s[37]++;$$invalidate(3,inputStarted=true);cov_1gp5eeevjy().s[38]++;dispatch("change",{field:fieldname,value});}).catch(e=>{cov_1gp5eeevjy().f[13]++;cov_1gp5eeevjy().s[39]++;notCommon$1.report(e);});}function resetUser(){cov_1gp5eeevjy().f[14]++;cov_1gp5eeevjy().s[40]++;$$invalidate(2,value=undefined);cov_1gp5eeevjy().s[41]++;$$invalidate(4,userData=null);cov_1gp5eeevjy().s[42]++;dispatch("change",{field:fieldname,value});}async function loadUserData(){cov_1gp5eeevjy().f[15]++;cov_1gp5eeevjy().s[43]++;try{cov_1gp5eeevjy().s[44]++;if(value){cov_1gp5eeevjy().b[10][0]++;cov_1gp5eeevjy().s[45]++;$$invalidate(5,loading=true);cov_1gp5eeevjy().s[46]++;$$invalidate(4,userData=await getService().loadUserData(value));}else {cov_1gp5eeevjy().b[10][1]++;}}catch(e){cov_1gp5eeevjy().s[47]++;notCommon$1.report(e);}finally{cov_1gp5eeevjy().s[48]++;$$invalidate(5,loading=false);}}cov_1gp5eeevjy().s[49]++;onMount(()=>{cov_1gp5eeevjy().f[16]++;cov_1gp5eeevjy().s[50]++;loadUserData();});const AVAILABLE_BUTTONS=(cov_1gp5eeevjy().s[51]++,[{id:1,action:openUserSearchAndSelect,icon:"user-edit",color:"warning"},{id:2,action:resetUser,icon:"times",color:"danger"}]);function getUserButton(){cov_1gp5eeevjy().f[17]++;cov_1gp5eeevjy().s[52]++;if(loading){cov_1gp5eeevjy().b[11][0]++;cov_1gp5eeevjy().s[53]++;return {disabled:true,loading,title:"not-node:loading_label"};}else {cov_1gp5eeevjy().b[11][1]++;cov_1gp5eeevjy().s[54]++;if(userData){cov_1gp5eeevjy().b[12][0]++;cov_1gp5eeevjy().s[55]++;return {disabled:readonly,action:openUserSearchAndSelect,title:usernameFormatter(userData)};}else {cov_1gp5eeevjy().b[12][1]++;cov_1gp5eeevjy().s[56]++;return {disabled:true,title:"not-node:field_value_is_empty_placeholder"};}}}let VISIBLE_BUTTONS=(cov_1gp5eeevjy().s[57]++,[]);cov_1gp5eeevjy().s[58]++;$$self.$$set=$$props=>{cov_1gp5eeevjy().f[18]++;cov_1gp5eeevjy().s[59]++;if('value'in $$props){cov_1gp5eeevjy().b[13][0]++;cov_1gp5eeevjy().s[60]++;$$invalidate(2,value=$$props.value);}else {cov_1gp5eeevjy().b[13][1]++;}cov_1gp5eeevjy().s[61]++;if('inputStarted'in $$props){cov_1gp5eeevjy().b[14][0]++;cov_1gp5eeevjy().s[62]++;$$invalidate(3,inputStarted=$$props.inputStarted);}else {cov_1gp5eeevjy().b[14][1]++;}cov_1gp5eeevjy().s[63]++;if('fieldname'in $$props){cov_1gp5eeevjy().b[15][0]++;cov_1gp5eeevjy().s[64]++;$$invalidate(6,fieldname=$$props.fieldname);}else {cov_1gp5eeevjy().b[15][1]++;}cov_1gp5eeevjy().s[65]++;if('readonly'in $$props){cov_1gp5eeevjy().b[16][0]++;cov_1gp5eeevjy().s[66]++;$$invalidate(7,readonly=$$props.readonly);}else {cov_1gp5eeevjy().b[16][1]++;}cov_1gp5eeevjy().s[67]++;if('serviceName'in $$props){cov_1gp5eeevjy().b[17][0]++;cov_1gp5eeevjy().s[68]++;$$invalidate(8,serviceName=$$props.serviceName);}else {cov_1gp5eeevjy().b[17][1]++;}cov_1gp5eeevjy().s[69]++;if('userData'in $$props){cov_1gp5eeevjy().b[18][0]++;cov_1gp5eeevjy().s[70]++;$$invalidate(4,userData=$$props.userData);}else {cov_1gp5eeevjy().b[18][1]++;}cov_1gp5eeevjy().s[71]++;if('loading'in $$props){cov_1gp5eeevjy().b[19][0]++;cov_1gp5eeevjy().s[72]++;$$invalidate(5,loading=$$props.loading);}else {cov_1gp5eeevjy().b[19][1]++;}cov_1gp5eeevjy().s[73]++;if('usernameFormatter'in $$props){cov_1gp5eeevjy().b[20][0]++;cov_1gp5eeevjy().s[74]++;$$invalidate(9,usernameFormatter=$$props.usernameFormatter);}else {cov_1gp5eeevjy().b[20][1]++;}};cov_1gp5eeevjy().s[75]++;$$self.$$.update=()=>{cov_1gp5eeevjy().f[19]++;cov_1gp5eeevjy().s[76]++;if($$self.$$.dirty&/*value, readonly*/132){cov_1gp5eeevjy().b[21][0]++;cov_1gp5eeevjy().s[77]++;{cov_1gp5eeevjy().s[78]++;if(value){cov_1gp5eeevjy().b[22][0]++;cov_1gp5eeevjy().s[79]++;$$invalidate(0,VISIBLE_BUTTONS=[getUserButton(),...(readonly?(cov_1gp5eeevjy().b[23][0]++,[]):(cov_1gp5eeevjy().b[23][1]++,AVAILABLE_BUTTONS))]);}else {cov_1gp5eeevjy().b[22][1]++;cov_1gp5eeevjy().s[80]++;$$invalidate(0,VISIBLE_BUTTONS=[getUserButton(),...(readonly?(cov_1gp5eeevjy().b[24][0]++,[]):(cov_1gp5eeevjy().b[24][1]++,[AVAILABLE_BUTTONS[0]]))]);}}}else {cov_1gp5eeevjy().b[21][1]++;}};cov_1gp5eeevjy().s[81]++;return [VISIBLE_BUTTONS,UIButtons,value,inputStarted,userData,loading,fieldname,readonly,serviceName,usernameFormatter];}class UISelectUserInline extends SvelteComponent{constructor(options){cov_1gp5eeevjy().f[20]++;cov_1gp5eeevjy().s[82]++;super();cov_1gp5eeevjy().s[83]++;init(this,options,instance,create_fragment,safe_not_equal,{value:2,inputStarted:3,fieldname:6,readonly:7,serviceName:8,userData:4,loading:5,usernameFormatter:9});}}

	function cov_2i5eg19rfj(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/common/nsUser.js";var hash="1cc4c58da8daed333ed7cd098e17031b41f27390";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/common/nsUser.js",statementMap:{"0":{start:{line:7,column:20},end:{line:15,column:1}},"1":{start:{line:8,column:4},end:{line:14,column:6}},"2":{start:{line:19,column:8},end:{line:19,column:23}},"3":{start:{line:20,column:8},end:{line:20,column:25}},"4":{start:{line:24,column:8},end:{line:24,column:24}},"5":{start:{line:28,column:8},end:{line:28,column:65}},"6":{start:{line:28,column:41},end:{line:28,column:63}},"7":{start:{line:32,column:8},end:{line:35,column:10}},"8":{start:{line:39,column:8},end:{line:61,column:9}},"9":{start:{line:40,column:12},end:{line:58,column:13}},"10":{start:{line:41,column:30},end:{line:41,column:55}},"11":{start:{line:42,column:16},end:{line:42,column:44}},"12":{start:{line:43,column:33},end:{line:43,column:60}},"13":{start:{line:44,column:16},end:{line:55,column:17}},"14":{start:{line:45,column:20},end:{line:51,column:23}},"15":{start:{line:46,column:24},end:{line:50,column:26}},"16":{start:{line:52,column:20},end:{line:52,column:43}},"17":{start:{line:54,column:20},end:{line:54,column:41}},"18":{start:{line:57,column:16},end:{line:57,column:37}},"19":{start:{line:60,column:12},end:{line:60,column:33}},"20":{start:{line:65,column:8},end:{line:101,column:11}},"21":{start:{line:66,column:12},end:{line:100,column:13}},"22":{start:{line:67,column:27},end:{line:70,column:18}},"23":{start:{line:71,column:16},end:{line:74,column:19}},"24":{start:{line:72,column:36},end:{line:72,column:71}},"25":{start:{line:73,column:20},end:{line:73,column:41}},"26":{start:{line:76,column:16},end:{line:78,column:19}},"27":{start:{line:77,column:20},end:{line:77,column:40}},"28":{start:{line:80,column:16},end:{line:82,column:19}},"29":{start:{line:81,column:20},end:{line:81,column:40}},"30":{start:{line:84,column:16},end:{line:88,column:19}},"31":{start:{line:85,column:20},end:{line:85,column:42}},"32":{start:{line:86,column:20},end:{line:86,column:34}},"33":{start:{line:87,column:20},end:{line:87,column:29}},"34":{start:{line:89,column:16},end:{line:97,column:19}},"35":{start:{line:90,column:20},end:{line:90,column:43}},"36":{start:{line:91,column:20},end:{line:91,column:34}},"37":{start:{line:92,column:20},end:{line:96,column:23}},"38":{start:{line:99,column:16},end:{line:99,column:26}},"39":{start:{line:105,column:8},end:{line:120,column:9}},"40":{start:{line:106,column:12},end:{line:116,column:13}},"41":{start:{line:107,column:30},end:{line:107,column:64}},"42":{start:{line:108,column:33},end:{line:108,column:51}},"43":{start:{line:109,column:16},end:{line:113,column:17}},"44":{start:{line:110,column:20},end:{line:110,column:43}},"45":{start:{line:112,column:20},end:{line:112,column:32}},"46":{start:{line:115,column:16},end:{line:115,column:28}},"47":{start:{line:118,column:12},end:{line:118,column:29}},"48":{start:{line:119,column:12},end:{line:119,column:24}},"49":{start:{line:124,column:8},end:{line:133,column:37}},"50":{start:{line:129,column:16},end:{line:129,column:67}},"51":{start:{line:130,column:16},end:{line:130,column:58}},"52":{start:{line:131,column:16},end:{line:131,column:34}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:7,column:20},end:{line:7,column:21}},loc:{start:{line:7,column:26},end:{line:15,column:1}},line:7},"1":{name:"(anonymous_1)",decl:{start:{line:18,column:4},end:{line:18,column:5}},loc:{start:{line:18,column:21},end:{line:21,column:5}},line:18},"2":{name:"(anonymous_2)",decl:{start:{line:23,column:4},end:{line:23,column:5}},loc:{start:{line:23,column:14},end:{line:25,column:5}},line:23},"3":{name:"(anonymous_3)",decl:{start:{line:27,column:4},end:{line:27,column:5}},loc:{start:{line:27,column:34},end:{line:29,column:5}},line:27},"4":{name:"(anonymous_4)",decl:{start:{line:28,column:35},end:{line:28,column:36}},loc:{start:{line:28,column:41},end:{line:28,column:63}},line:28},"5":{name:"(anonymous_5)",decl:{start:{line:31,column:4},end:{line:31,column:5}},loc:{start:{line:31,column:22},end:{line:36,column:5}},line:31},"6":{name:"(anonymous_6)",decl:{start:{line:38,column:4},end:{line:38,column:5}},loc:{start:{line:38,column:33},end:{line:62,column:5}},line:38},"7":{name:"(anonymous_7)",decl:{start:{line:45,column:68},end:{line:45,column:69}},loc:{start:{line:45,column:78},end:{line:51,column:21}},line:45},"8":{name:"(anonymous_8)",decl:{start:{line:64,column:4},end:{line:64,column:5}},loc:{start:{line:64,column:19},end:{line:102,column:5}},line:64},"9":{name:"(anonymous_9)",decl:{start:{line:65,column:27},end:{line:65,column:28}},loc:{start:{line:65,column:48},end:{line:101,column:9}},line:65},"10":{name:"(anonymous_10)",decl:{start:{line:71,column:37},end:{line:71,column:38}},loc:{start:{line:71,column:59},end:{line:74,column:17}},line:71},"11":{name:"(anonymous_11)",decl:{start:{line:76,column:31},end:{line:76,column:32}},loc:{start:{line:76,column:37},end:{line:78,column:17}},line:76},"12":{name:"(anonymous_12)",decl:{start:{line:80,column:31},end:{line:80,column:32}},loc:{start:{line:80,column:37},end:{line:82,column:17}},line:80},"13":{name:"(anonymous_13)",decl:{start:{line:84,column:33},end:{line:84,column:34}},loc:{start:{line:84,column:39},end:{line:88,column:17}},line:84},"14":{name:"(anonymous_14)",decl:{start:{line:89,column:34},end:{line:89,column:35}},loc:{start:{line:89,column:50},end:{line:97,column:17}},line:89},"15":{name:"(anonymous_15)",decl:{start:{line:104,column:4},end:{line:104,column:5}},loc:{start:{line:104,column:28},end:{line:121,column:5}},line:104},"16":{name:"(anonymous_16)",decl:{start:{line:123,column:4},end:{line:123,column:5}},loc:{start:{line:123,column:16},end:{line:134,column:5}},line:123},"17":{name:"(anonymous_17)",decl:{start:{line:128,column:18},end:{line:128,column:19}},loc:{start:{line:128,column:27},end:{line:132,column:13}},line:128}},branchMap:{"0":{loc:{start:{line:40,column:12},end:{line:58,column:13}},type:"if",locations:[{start:{line:40,column:12},end:{line:58,column:13}},{start:{line:56,column:19},end:{line:58,column:13}}],line:40},"1":{loc:{start:{line:44,column:16},end:{line:55,column:17}},type:"if",locations:[{start:{line:44,column:16},end:{line:55,column:17}},{start:{line:53,column:23},end:{line:55,column:17}}],line:44},"2":{loc:{start:{line:106,column:12},end:{line:116,column:13}},type:"if",locations:[{start:{line:106,column:12},end:{line:116,column:13}},{start:{line:114,column:19},end:{line:116,column:13}}],line:106},"3":{loc:{start:{line:106,column:16},end:{line:106,column:38}},type:"binary-expr",locations:[{start:{line:106,column:16},end:{line:106,column:19}},{start:{line:106,column:23},end:{line:106,column:38}}],line:106},"4":{loc:{start:{line:109,column:16},end:{line:113,column:17}},type:"if",locations:[{start:{line:109,column:16},end:{line:113,column:17}},{start:{line:111,column:23},end:{line:113,column:17}}],line:109}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0,"50":0,"51":0,"52":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0},b:{"0":[0,0],"1":[0,0],"2":[0,0],"3":[0,0],"4":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/common/nsUser.js"],sourcesContent:["import { notCommon } from \"not-bulma\";\nimport { Builder } from \"not-validation\";\nimport Validator from \"validator\";\n\nimport UIGenericSelector from \"not-bulma/src/elements/modal/ui.generic.selector.svelte\";\n\nconst emptyResult = () => {\n    return {\n        list: [],\n        count: 0,\n        page: 0,\n        pages: 0,\n        skip: 0,\n    };\n};\n\nexport default class nsUser {\n    constructor(app) {\n        this.app = app;\n        this.loadToken();\n    }\n\n    destroy() {\n        delete this.app;\n    }\n\n    augmentValidators(validators) {\n        return Builder(validators, () => this.getValidatorEnv());\n    }\n\n    getValidatorEnv() {\n        return {\n            config: this.app.getConfigReaderForModule(\"user\"),\n            validator: Validator,\n        };\n    }\n\n    async searchUserByTerm(term) {\n        try {\n            if (term.value.length > 2) {\n                const model = this.app.getModel(\"user\");\n                model.setSearch(term.value);\n                const response = await model.$listAndCount();\n                if (response.status === \"ok\") {\n                    response.result.list = response.result.list.map((item) => {\n                        return {\n                            _id: item._id,\n                            id: item.userID,\n                            title: item.username,\n                        };\n                    });\n                    return response.result;\n                } else {\n                    return emptyResult();\n                }\n            } else {\n                return emptyResult();\n            }\n        } catch (e) {\n            return emptyResult();\n        }\n    }\n\n    openSelector() {\n        return new Promise((resolve, reject) => {\n            try {\n                const el = new UIGenericSelector({\n                    target: document.body,\n                    props: {},\n                });\n                el.$on(\"termChange\", async ({ detail }) => {\n                    const results = await this.searchUserByTerm(detail);\n                    el.$set({ results });\n                });\n\n                el.$on(\"next\", () => {\n                    console.log(\"next\");\n                });\n\n                el.$on(\"prev\", () => {\n                    console.log(\"prev\");\n                });\n\n                el.$on(\"reject\", () => {\n                    console.log(\"reject\");\n                    el.$destroy();\n                    reject();\n                });\n                el.$on(\"resolve\", ({ detail }) => {\n                    console.log(\"resolve\");\n                    el.$destroy();\n                    resolve({\n                        _id: detail._id,\n                        userID: detail.id,\n                        username: detail.title,\n                    });\n                });\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    async loadUserData(_id) {\n        try {\n            if (_id && _id.length > 10) {\n                const model = this.app.getModel(\"user\", { _id });\n                const response = await model.$get();\n                if (response.status === \"ok\") {\n                    return response.result;\n                } else {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        } catch (e) {\n            console.error(e);\n            return null;\n        }\n    }\n\n    loadToken() {\n        return notCommon\n            .getApp()\n            .getModel(\"user\", {})\n            .$token({})\n            .then((res) => {\n                notCommon.getApp().setWorking(\"token\", res.result);\n                notCommon.getApp().emit(\"token//updated\");\n                return res.result;\n            })\n            .catch(notCommon.report);\n    }\n}\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjE,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"1cc4c58da8daed333ed7cd098e17031b41f27390"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_2i5eg19rfj=function(){return actualCoverage;};}return actualCoverage;}cov_2i5eg19rfj();cov_2i5eg19rfj().s[0]++;const emptyResult=()=>{cov_2i5eg19rfj().f[0]++;cov_2i5eg19rfj().s[1]++;return {list:[],count:0,page:0,pages:0,skip:0};};class nsUser{constructor(app){cov_2i5eg19rfj().f[1]++;cov_2i5eg19rfj().s[2]++;this.app=app;cov_2i5eg19rfj().s[3]++;this.loadToken();}destroy(){cov_2i5eg19rfj().f[2]++;cov_2i5eg19rfj().s[4]++;delete this.app;}augmentValidators(validators){cov_2i5eg19rfj().f[3]++;cov_2i5eg19rfj().s[5]++;return src.Builder(validators,()=>{cov_2i5eg19rfj().f[4]++;cov_2i5eg19rfj().s[6]++;return this.getValidatorEnv();});}getValidatorEnv(){cov_2i5eg19rfj().f[5]++;cov_2i5eg19rfj().s[7]++;return {config:this.app.getConfigReaderForModule("user"),validator:Validator};}async searchUserByTerm(term){cov_2i5eg19rfj().f[6]++;cov_2i5eg19rfj().s[8]++;try{cov_2i5eg19rfj().s[9]++;if(term.value.length>2){cov_2i5eg19rfj().b[0][0]++;const model=(cov_2i5eg19rfj().s[10]++,this.app.getModel("user"));cov_2i5eg19rfj().s[11]++;model.setSearch(term.value);const response=(cov_2i5eg19rfj().s[12]++,await model.$listAndCount());cov_2i5eg19rfj().s[13]++;if(response.status==="ok"){cov_2i5eg19rfj().b[1][0]++;cov_2i5eg19rfj().s[14]++;response.result.list=response.result.list.map(item=>{cov_2i5eg19rfj().f[7]++;cov_2i5eg19rfj().s[15]++;return {_id:item._id,id:item.userID,title:item.username};});cov_2i5eg19rfj().s[16]++;return response.result;}else {cov_2i5eg19rfj().b[1][1]++;cov_2i5eg19rfj().s[17]++;return emptyResult();}}else {cov_2i5eg19rfj().b[0][1]++;cov_2i5eg19rfj().s[18]++;return emptyResult();}}catch(e){cov_2i5eg19rfj().s[19]++;return emptyResult();}}openSelector(){cov_2i5eg19rfj().f[8]++;cov_2i5eg19rfj().s[20]++;return new Promise((resolve,reject)=>{cov_2i5eg19rfj().f[9]++;cov_2i5eg19rfj().s[21]++;try{const el=(cov_2i5eg19rfj().s[22]++,new Ui_generic_selector({target:document.body,props:{}}));cov_2i5eg19rfj().s[23]++;el.$on("termChange",async({detail})=>{cov_2i5eg19rfj().f[10]++;const results=(cov_2i5eg19rfj().s[24]++,await this.searchUserByTerm(detail));cov_2i5eg19rfj().s[25]++;el.$set({results});});cov_2i5eg19rfj().s[26]++;el.$on("next",()=>{cov_2i5eg19rfj().f[11]++;cov_2i5eg19rfj().s[27]++;console.log("next");});cov_2i5eg19rfj().s[28]++;el.$on("prev",()=>{cov_2i5eg19rfj().f[12]++;cov_2i5eg19rfj().s[29]++;console.log("prev");});cov_2i5eg19rfj().s[30]++;el.$on("reject",()=>{cov_2i5eg19rfj().f[13]++;cov_2i5eg19rfj().s[31]++;console.log("reject");cov_2i5eg19rfj().s[32]++;el.$destroy();cov_2i5eg19rfj().s[33]++;reject();});cov_2i5eg19rfj().s[34]++;el.$on("resolve",({detail})=>{cov_2i5eg19rfj().f[14]++;cov_2i5eg19rfj().s[35]++;console.log("resolve");cov_2i5eg19rfj().s[36]++;el.$destroy();cov_2i5eg19rfj().s[37]++;resolve({_id:detail._id,userID:detail.id,username:detail.title});});}catch(e){cov_2i5eg19rfj().s[38]++;reject(e);}});}async loadUserData(_id){cov_2i5eg19rfj().f[15]++;cov_2i5eg19rfj().s[39]++;try{cov_2i5eg19rfj().s[40]++;if((cov_2i5eg19rfj().b[3][0]++,_id)&&(cov_2i5eg19rfj().b[3][1]++,_id.length>10)){cov_2i5eg19rfj().b[2][0]++;const model=(cov_2i5eg19rfj().s[41]++,this.app.getModel("user",{_id}));const response=(cov_2i5eg19rfj().s[42]++,await model.$get());cov_2i5eg19rfj().s[43]++;if(response.status==="ok"){cov_2i5eg19rfj().b[4][0]++;cov_2i5eg19rfj().s[44]++;return response.result;}else {cov_2i5eg19rfj().b[4][1]++;cov_2i5eg19rfj().s[45]++;return null;}}else {cov_2i5eg19rfj().b[2][1]++;cov_2i5eg19rfj().s[46]++;return null;}}catch(e){cov_2i5eg19rfj().s[47]++;console.error(e);cov_2i5eg19rfj().s[48]++;return null;}}loadToken(){cov_2i5eg19rfj().f[16]++;cov_2i5eg19rfj().s[49]++;return notCommon$1.getApp().getModel("user",{}).$token({}).then(res=>{cov_2i5eg19rfj().f[17]++;cov_2i5eg19rfj().s[50]++;notCommon$1.getApp().setWorking("token",res.result);cov_2i5eg19rfj().s[51]++;notCommon$1.getApp().emit("token//updated");cov_2i5eg19rfj().s[52]++;return res.result;}).catch(notCommon$1.report);}}

	function cov_18xmra43mh(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/common/user.js";var hash="b9fa732f0e6c801739b9f8e747f3e82c9293598e";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/common/user.js",statementMap:{"0":{start:{line:2,column:42},end:{line:2,column:54}},"1":{start:{line:3,column:49},end:{line:3,column:52}},"2":{start:{line:4,column:38},end:{line:4,column:42}},"3":{start:{line:6,column:22},end:{line:6,column:34}},"4":{start:{line:7,column:23},end:{line:7,column:34}},"5":{start:{line:10,column:8},end:{line:13,column:10}},"6":{start:{line:16,column:8},end:{line:19,column:10}},"7":{start:{line:22,column:8},end:{line:22,column:47}},"8":{start:{line:25,column:8},end:{line:25,column:43}},"9":{start:{line:28,column:8},end:{line:28,column:46}},"10":{start:{line:31,column:8},end:{line:31,column:45}},"11":{start:{line:34,column:8},end:{line:34,column:44}},"12":{start:{line:37,column:8},end:{line:37,column:34}},"13":{start:{line:39,column:19},end:{line:75,column:5}},"14":{start:{line:76,column:20},end:{line:115,column:5}},"15":{start:{line:117,column:20},end:{line:125,column:9}},"16":{start:{line:126,column:8},end:{line:128,column:9}},"17":{start:{line:127,column:12},end:{line:127,column:52}},"18":{start:{line:129,column:8},end:{line:131,column:9}},"19":{start:{line:130,column:12},end:{line:130,column:43}},"20":{start:{line:132,column:8},end:{line:132,column:21}},"21":{start:{line:134,column:23},end:{line:139,column:5}},"22":{start:{line:143,column:22},end:{line:143,column:55}},"23":{start:{line:144,column:21},end:{line:144,column:43}},"24":{start:{line:146,column:8},end:{line:152,column:9}},"25":{start:{line:147,column:20},end:{line:147,column:38}},"26":{start:{line:148,column:12},end:{line:151,column:13}},"27":{start:{line:149,column:16},end:{line:149,column:20}},"28":{start:{line:150,column:16},end:{line:150,column:33}},"29":{start:{line:153,column:20},end:{line:153,column:40}},"30":{start:{line:154,column:8},end:{line:157,column:11}},"31":{start:{line:155,column:23},end:{line:155,column:35}},"32":{start:{line:156,column:12},end:{line:156,column:54}},"33":{start:{line:158,column:8},end:{line:158,column:80}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:9,column:4},end:{line:9,column:5}},loc:{start:{line:9,column:45},end:{line:14,column:5}},line:9},"1":{name:"(anonymous_1)",decl:{start:{line:15,column:4},end:{line:15,column:5}},loc:{start:{line:15,column:35},end:{line:20,column:5}},line:15},"2":{name:"(anonymous_2)",decl:{start:{line:21,column:4},end:{line:21,column:5}},loc:{start:{line:21,column:25},end:{line:23,column:5}},line:21},"3":{name:"(anonymous_3)",decl:{start:{line:24,column:4},end:{line:24,column:5}},loc:{start:{line:24,column:24},end:{line:26,column:5}},line:24},"4":{name:"(anonymous_4)",decl:{start:{line:27,column:4},end:{line:27,column:5}},loc:{start:{line:27,column:24},end:{line:29,column:5}},line:27},"5":{name:"(anonymous_5)",decl:{start:{line:30,column:4},end:{line:30,column:5}},loc:{start:{line:30,column:23},end:{line:32,column:5}},line:30},"6":{name:"(anonymous_6)",decl:{start:{line:33,column:4},end:{line:33,column:5}},loc:{start:{line:33,column:22},end:{line:35,column:5}},line:33},"7":{name:"(anonymous_7)",decl:{start:{line:36,column:4},end:{line:36,column:5}},loc:{start:{line:36,column:22},end:{line:38,column:5}},line:36},"8":{name:"(anonymous_8)",decl:{start:{line:116,column:4},end:{line:116,column:5}},loc:{start:{line:116,column:42},end:{line:133,column:5}},line:116},"9":{name:"(anonymous_9)",decl:{start:{line:141,column:4},end:{line:141,column:5}},loc:{start:{line:141,column:28},end:{line:159,column:5}},line:141},"10":{name:"(anonymous_10)",decl:{start:{line:154,column:35},end:{line:154,column:36}},loc:{start:{line:154,column:53},end:{line:157,column:9}},line:154}},branchMap:{"0":{loc:{start:{line:116,column:27},end:{line:116,column:40}},type:"default-arg",locations:[{start:{line:116,column:38},end:{line:116,column:40}}],line:116},"1":{loc:{start:{line:126,column:8},end:{line:128,column:9}},type:"if",locations:[{start:{line:126,column:8},end:{line:128,column:9}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:126},"2":{loc:{start:{line:129,column:8},end:{line:131,column:9}},type:"if",locations:[{start:{line:129,column:8},end:{line:131,column:9}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:129},"3":{loc:{start:{line:146,column:8},end:{line:152,column:9}},type:"if",locations:[{start:{line:146,column:8},end:{line:152,column:9}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:146}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0},b:{"0":[0],"1":[0,0],"2":[0,0],"3":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/common/user.js"],sourcesContent:["export default class UserCommon {\n    static DEFAULT_USER_AFTER_LOGIN_URL = \"/dashboard\";\n    static DEFAULT_USER_AFTER_LOGIN_FAILED_URL = \"/\";\n    static DEFAULT_REDIRECT_TIMEOUT = 2000;\n\n    static CLASS_OK = \"is-success\";\n    static CLASS_ERR = \"is-danger\";\n\n    static getUserAfterLoginRedirectURL(app) {\n        return app.getOptions(\n            \"modules.user.afterLoginURL\",\n            this.DEFAULT_USER_AFTER_LOGIN_URL\n        );\n    }\n    static getRedirectTimeout(app) {\n        return app.getOptions(\n            \"modules.user.redirectTimout\",\n            this.DEFAULT_REDIRECT_TIMEOUT\n        );\n    }\n    static goDashboard() {\n        document.location.assign(\"/dashboard\");\n    }\n    static goLogin(app) {\n        document.location.assign(\"/login\");\n    }\n    static goRegister() {\n        document.location.assign(\"/register\");\n    }\n    static goRestore() {\n        document.location.assign(\"/restore\");\n    }\n    static goLogout() {\n        document.location.assign(\"/logout\");\n    }\n    static isError(e) {\n        return e instanceof Error;\n    }\n    static ROLES = [\n        {\n            id: 1,\n            title: \"root\",\n            type: \"danger\",\n        },\n        {\n            id: 2,\n            title: \"admin\",\n            type: \"warning\",\n        },\n        {\n            id: 3,\n            title: \"client\",\n            type: \"success\",\n        },\n        {\n            id: 4,\n            title: \"user\",\n            type: \"info\",\n        },\n        {\n            id: 5,\n            title: \"manager\",\n            type: \"primary\",\n        },\n        {\n            id: 6,\n            title: \"logist\",\n            type: \"primary\",\n        },\n        {\n            id: 7,\n            title: \"hr\",\n            type: \"primary\",\n        },\n    ];\n    static FIELDS = {\n        username: {\n            label: \"\u041B\u043E\u0433\u0438\u043D\",\n            placeholder: \"\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F\",\n        },\n        password: {\n            label: \"\u041F\u0430\u0440\u043E\u043B\u044C\",\n            placeholder: \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u0430\u0440\u043E\u043B\u044C\",\n            minLength: 8,\n        },\n        password2: {\n            label: \"\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u0430\u0440\u043E\u043B\u044C\",\n            placeholder: \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u0430\u0440\u043E\u043B\u044C \u0435\u0449\u0435 \u0440\u0430\u0437\",\n            minLength: 8,\n        },\n        email: {\n            label: \"Email\",\n            placeholder: \"\u0412\u0430\u0448 email \u0430\u0434\u0440\u0435\u0441\",\n        },\n        tel: {\n            label: \"\u0412\u0430\u0448 \u043D\u043E\u043C\u0435\u0440 \u0442\u0435\u043B\u0435\u0444\u043E\u043D\u0430\",\n            placeholder: \"\",\n        },\n        active: {\n            label: \"\u0410\u043A\u0442\u0438\u0432\u043D\u0430\",\n            placeholder: \"\",\n        },\n        role: {\n            label: \"\u0420\u043E\u043B\u0438 \u0432 \u0441\u0438\u0441\u0442\u0435\u043C\u0435\",\n            placeholder: \"\",\n        },\n        country: {\n            label: \"\u041E\u0441\u043D\u043E\u0432\u043D\u043E\u0439 \u044F\u0437\u044B\u043A\",\n            placeholder: \"\",\n        },\n        code: {\n            label: \"\u041A\u043E\u0434 \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u044F\",\n            placeholder: \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043D\u044B\u0439 \u043A\u043E\u0434.\",\n        },\n    };\n    static fieldInit(type, mutation = {}) {\n        let field = {\n            label: \"\",\n            placeholder: \"\",\n            enabled: true,\n            value: \"\",\n            required: true,\n            validated: false,\n            valid: false,\n        };\n        if (Object.prototype.hasOwnProperty.call(this.FIELDS, type)) {\n            Object.assign(field, this.FIELDS[type]);\n        }\n        if (mutation) {\n            Object.assign(field, mutation);\n        }\n        return field;\n    }\n    static COUNTRIES = [\n        {\n            id: \"ru\",\n            title: \"\u0420\u043E\u0441\u0441\u0438\u044F\",\n        },\n    ];\n\n    static formatPhone(val) {\n        //starting from 11 digits in phone number\n        const slots = [1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5];\n        let digits = val.replace(/\\D/g, \"\");\n        //if there are more, move them to country code slot\n        if (digits.length > 11) {\n            let d = digits.length - 11;\n            while (d > 0) {\n                d--;\n                slots.unshift(1);\n            }\n        }\n        let stack = [\"\", \"\", \"\", \"\", \"\"];\n        Array.from(digits).forEach((digit, index) => {\n            let slot = slots[index];\n            stack[slot - 1] = stack[slot - 1] + digit;\n        });\n        return `+${stack[0]} (${stack[1]}) ${stack[2]}-${stack[3]}-${stack[4]}`;\n    }\n}\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChF,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"b9fa732f0e6c801739b9f8e747f3e82c9293598e"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_18xmra43mh=function(){return actualCoverage;};}return actualCoverage;}cov_18xmra43mh();class UserCommon{static DEFAULT_USER_AFTER_LOGIN_URL=(cov_18xmra43mh().s[0]++,"/dashboard");static DEFAULT_USER_AFTER_LOGIN_FAILED_URL=(cov_18xmra43mh().s[1]++,"/");static DEFAULT_REDIRECT_TIMEOUT=(cov_18xmra43mh().s[2]++,2000);static CLASS_OK=(cov_18xmra43mh().s[3]++,"is-success");static CLASS_ERR=(cov_18xmra43mh().s[4]++,"is-danger");static getUserAfterLoginRedirectURL(app){cov_18xmra43mh().f[0]++;cov_18xmra43mh().s[5]++;return app.getOptions("modules.user.afterLoginURL",this.DEFAULT_USER_AFTER_LOGIN_URL);}static getRedirectTimeout(app){cov_18xmra43mh().f[1]++;cov_18xmra43mh().s[6]++;return app.getOptions("modules.user.redirectTimout",this.DEFAULT_REDIRECT_TIMEOUT);}static goDashboard(){cov_18xmra43mh().f[2]++;cov_18xmra43mh().s[7]++;document.location.assign("/dashboard");}static goLogin(app){cov_18xmra43mh().f[3]++;cov_18xmra43mh().s[8]++;document.location.assign("/login");}static goRegister(){cov_18xmra43mh().f[4]++;cov_18xmra43mh().s[9]++;document.location.assign("/register");}static goRestore(){cov_18xmra43mh().f[5]++;cov_18xmra43mh().s[10]++;document.location.assign("/restore");}static goLogout(){cov_18xmra43mh().f[6]++;cov_18xmra43mh().s[11]++;document.location.assign("/logout");}static isError(e){cov_18xmra43mh().f[7]++;cov_18xmra43mh().s[12]++;return e instanceof Error;}static ROLES=(cov_18xmra43mh().s[13]++,[{id:1,title:"root",type:"danger"},{id:2,title:"admin",type:"warning"},{id:3,title:"client",type:"success"},{id:4,title:"user",type:"info"},{id:5,title:"manager",type:"primary"},{id:6,title:"logist",type:"primary"},{id:7,title:"hr",type:"primary"}]);static FIELDS=(cov_18xmra43mh().s[14]++,{username:{label:"Логин",placeholder:"Имя пользователя"},password:{label:"Пароль",placeholder:"Введите пароль",minLength:8},password2:{label:"Повторите пароль",placeholder:"Введите пароль еще раз",minLength:8},email:{label:"Email",placeholder:"Ваш email адрес"},tel:{label:"Ваш номер телефона",placeholder:""},active:{label:"Активна",placeholder:""},role:{label:"Роли в системе",placeholder:""},country:{label:"Основной язык",placeholder:""},code:{label:"Код подтверждения",placeholder:"Введите полученный код."}});static fieldInit(type,mutation=(cov_18xmra43mh().b[0][0]++,{})){cov_18xmra43mh().f[8]++;let field=(cov_18xmra43mh().s[15]++,{label:"",placeholder:"",enabled:true,value:"",required:true,validated:false,valid:false});cov_18xmra43mh().s[16]++;if(Object.prototype.hasOwnProperty.call(this.FIELDS,type)){cov_18xmra43mh().b[1][0]++;cov_18xmra43mh().s[17]++;Object.assign(field,this.FIELDS[type]);}else {cov_18xmra43mh().b[1][1]++;}cov_18xmra43mh().s[18]++;if(mutation){cov_18xmra43mh().b[2][0]++;cov_18xmra43mh().s[19]++;Object.assign(field,mutation);}else {cov_18xmra43mh().b[2][1]++;}cov_18xmra43mh().s[20]++;return field;}static COUNTRIES=(cov_18xmra43mh().s[21]++,[{id:"ru",title:"Россия"}]);static formatPhone(val){cov_18xmra43mh().f[9]++;//starting from 11 digits in phone number
	const slots=(cov_18xmra43mh().s[22]++,[1,2,2,2,3,3,3,4,4,5,5]);let digits=(cov_18xmra43mh().s[23]++,val.replace(/\D/g,""));//if there are more, move them to country code slot
	cov_18xmra43mh().s[24]++;if(digits.length>11){cov_18xmra43mh().b[3][0]++;let d=(cov_18xmra43mh().s[25]++,digits.length-11);cov_18xmra43mh().s[26]++;while(d>0){cov_18xmra43mh().s[27]++;d--;cov_18xmra43mh().s[28]++;slots.unshift(1);}}else {cov_18xmra43mh().b[3][1]++;}let stack=(cov_18xmra43mh().s[29]++,["","","","",""]);cov_18xmra43mh().s[30]++;Array.from(digits).forEach((digit,index)=>{cov_18xmra43mh().f[10]++;let slot=(cov_18xmra43mh().s[31]++,slots[index]);cov_18xmra43mh().s[32]++;stack[slot-1]=stack[slot-1]+digit;});cov_18xmra43mh().s[33]++;return `+${stack[0]} (${stack[1]}) ${stack[2]}-${stack[3]}-${stack[4]}`;}}

	var user = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: UserCommon
	});

	function cov_21lw0gwirb(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/common/index.js";var hash="f84f113db33fbb7dc8ddd20014cb7c540ffcbb17";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/common/index.js",statementMap:{"0":{start:{line:6,column:12},end:{line:6,column:74}},"1":{start:{line:10,column:17},end:{line:10,column:27}},"2":{start:{line:11,column:17},end:{line:11,column:19}}},fnMap:{},branchMap:{},s:{"0":0,"1":0,"2":0},f:{},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/common/index.js"],sourcesContent:["import UIRole from \"./ui.role.svelte\";\nimport UISelectUser from \"./UISelectUser.svelte\";\nimport UISelectUserInline from \"./UISelectUserInline.svelte\";\nimport UIUserInlineInfo from \"./UIUserInlineInfo.svelte\";\n\nconst uis = { UIRole, UISelectUser, UISelectUserInline, UIUserInlineInfo };\n\nimport nsUser from \"./nsUser.js\";\n\nconst services = { nsUser };\nconst manifest = {};\n\nimport * as User from \"./user.js\";\nexport { uis, services, manifest, User };\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3E;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"f84f113db33fbb7dc8ddd20014cb7c540ffcbb17"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_21lw0gwirb=function(){return actualCoverage;};}return actualCoverage;}cov_21lw0gwirb();const uis$2=(cov_21lw0gwirb().s[0]++,{UIRole: Ui_role,UISelectUser,UISelectUserInline,UIUserInlineInfo});const services$2=(cov_21lw0gwirb().s[1]++,{nsUser});const manifest$2=(cov_21lw0gwirb().s[2]++,{});

	var notUserCommon = /*#__PURE__*/Object.freeze({
		__proto__: null,
		User: user,
		manifest: manifest$2,
		services: services$2,
		uis: uis$2
	});

	function cov_s7f5o4tdx(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/guest/ncFormFrame.js";var hash="c525d220d150b1b2db2fc315715cef32990451a8";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/guest/ncFormFrame.js",statementMap:{"0":{start:{line:2,column:38},end:{line:2,column:43}},"1":{start:{line:5,column:15},end:{line:5,column:19}},"2":{start:{line:7,column:8},end:{line:7,column:34}},"3":{start:{line:8,column:8},end:{line:8,column:34}},"4":{start:{line:9,column:8},end:{line:9,column:30}},"5":{start:{line:10,column:8},end:{line:10,column:20}},"6":{start:{line:14,column:23},end:{line:14,column:48}},"7":{start:{line:15,column:8},end:{line:17,column:9}},"8":{start:{line:16,column:12},end:{line:16,column:46}},"9":{start:{line:18,column:8},end:{line:25,column:11}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:6,column:4},end:{line:6,column:5}},loc:{start:{line:6,column:37},end:{line:11,column:5}},line:6},"1":{name:"(anonymous_1)",decl:{start:{line:13,column:4},end:{line:13,column:5}},loc:{start:{line:13,column:21},end:{line:26,column:5}},line:13}},branchMap:{"0":{loc:{start:{line:15,column:8},end:{line:17,column:9}},type:"if",locations:[{start:{line:15,column:8},end:{line:17,column:9}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:15}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0},f:{"0":0,"1":0},b:{"0":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/guest/ncFormFrame.js"],sourcesContent:["import { Frame } from \"not-bulma\";\nconst { notController, notFormSet } = Frame;\n\nclass ncFormFrame extends notController {\n    #formSet = null;\n    constructor({ app, name, mode }) {\n        super(app, `${name}Form`);\n        this.setModelName(\"user\");\n        this.buildFrame(mode);\n        return this;\n    }\n\n    buildFrame(mode) {\n        const target = this.getTargetContainer();\n        if (!target) {\n            location.href = this.getMainURL();\n        }\n        this.#formSet = new notFormSet({\n            options: {\n                name: this.getWorking(\"name\"),\n                target,\n                mode: mode,\n                forms: this.getFormsSet(),\n            },\n        });\n    }\n}\n\nexport default ncFormFrame;\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;AACD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"c525d220d150b1b2db2fc315715cef32990451a8"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_s7f5o4tdx=function(){return actualCoverage;};}return actualCoverage;}cov_s7f5o4tdx();const{notController,notFormSet}=(cov_s7f5o4tdx().s[0]++,Frame);class ncFormFrame extends notController{#formSet=(cov_s7f5o4tdx().s[1]++,null);constructor({app,name,mode}){cov_s7f5o4tdx().f[0]++;cov_s7f5o4tdx().s[2]++;super(app,`${name}Form`);cov_s7f5o4tdx().s[3]++;this.setModelName("user");cov_s7f5o4tdx().s[4]++;this.buildFrame(mode);cov_s7f5o4tdx().s[5]++;return this;}buildFrame(mode){cov_s7f5o4tdx().f[1]++;const target=(cov_s7f5o4tdx().s[6]++,this.getTargetContainer());cov_s7f5o4tdx().s[7]++;if(!target){cov_s7f5o4tdx().b[0][0]++;cov_s7f5o4tdx().s[8]++;location.href=this.getMainURL();}else {cov_s7f5o4tdx().b[0][1]++;}cov_s7f5o4tdx().s[9]++;this.#formSet=new notFormSet({options:{name:this.getWorking("name"),target,mode:mode,forms:this.getFormsSet()}});}}

	var _const = {};

	function cov_2rqf2kohg2(){var path="/home/cypher/proj/not-lib/not-user/src/const.js";var hash="fff0a7ba2c32eec7c8f6f94dc45df842ae45f6d6";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/const.js",statementMap:{"0":{start:{line:4,column:20},end:{line:4,column:30}},"1":{start:{line:5,column:20},end:{line:5,column:52}},"2":{start:{line:7,column:28},end:{line:7,column:29}},"3":{start:{line:8,column:28},end:{line:8,column:30}},"4":{start:{line:9,column:28},end:{line:9,column:76}},"5":{start:{line:10,column:28},end:{line:10,column:76}},"6":{start:{line:12,column:20},end:{line:12,column:21}},"7":{start:{line:13,column:24},end:{line:13,column:25}},"8":{start:{line:14,column:24},end:{line:14,column:26}},"9":{start:{line:16,column:20},end:{line:16,column:52}},"10":{start:{line:17,column:24},end:{line:17,column:64}},"11":{start:{line:18,column:24},end:{line:18,column:64}},"12":{start:{line:21,column:27},end:{line:21,column:71}},"13":{start:{line:22,column:27},end:{line:22,column:73}},"14":{start:{line:24,column:29},end:{line:24,column:46}},"15":{start:{line:25,column:29},end:{line:25,column:79}},"16":{start:{line:27,column:25},end:{line:27,column:38}},"17":{start:{line:28,column:25},end:{line:28,column:67}},"18":{start:{line:30,column:24},end:{line:30,column:59}},"19":{start:{line:33,column:18},end:{line:33,column:22}},"20":{start:{line:34,column:18},end:{line:34,column:46}},"21":{start:{line:35,column:28},end:{line:35,column:30}},"22":{start:{line:36,column:28},end:{line:36,column:76}},"23":{start:{line:39,column:23},end:{line:42,column:1}},"24":{start:{line:44,column:23},end:{line:44,column:61}}},fnMap:{},branchMap:{},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0},f:{},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/const.js"],sourcesContent:["const MODULE_NAME = \"not-user\";\nmodule.exports.MODULE_NAME = MODULE_NAME;\n\nconst USERNAME_LENGTH_MIN = 4;\nconst USERNAME_LENGTH_MAX = 40;\nmodule.exports.USERNAME_LENGTH_MIN = USERNAME_LENGTH_MIN;\nmodule.exports.USERNAME_LENGTH_MAX = USERNAME_LENGTH_MAX;\n\nconst DEFAULT_TTL = 3; //in minutes\nconst DEFAULT_TTL_MIN = 1; //in minutes\nconst DEFAULT_TTL_MAX = 60; //in minutes\n\nmodule.exports.DEFAULT_TTL = DEFAULT_TTL;\nmodule.exports.DEFAULT_TTL_MIN = DEFAULT_TTL_MIN;\nmodule.exports.DEFAULT_TTL_MAX = DEFAULT_TTL_MAX;\n\n//stronger -> weaker\nconst DEFAULT_ROLES_LIST = [\"root\", \"admin\", \"client\", \"user\", \"guest\"];\nmodule.exports.DEFAULT_ROLES_LIST = DEFAULT_ROLES_LIST;\n\nconst ROLES_NOT_SELECTABLE = [\"root\", \"guest\"];\nmodule.exports.ROLES_NOT_SELECTABLE = ROLES_NOT_SELECTABLE;\n\nconst EXTRA_ROLES_LIST = [\"confirmed\"];\nmodule.exports.EXTRA_ROLES_LIST = EXTRA_ROLES_LIST;\n\nmodule.exports.DEFAULT_HASH_ALGO = \"sha256\";\n\n//TOKEN IDENTITY\nconst TOKEN_TTL = 3600;\nmodule.exports.TOKEN_TTL = TOKEN_TTL;\nconst TOKEN_SECRET_LENGTH = 20;\nmodule.exports.TOKEN_SECRET_LENGTH = TOKEN_SECRET_LENGTH;\n\n//styling\nconst DEFAULT_COLORS = {\n    mainBackgroundColor: \"info\",\n    secondaryBackgroundColor: \"light\",\n};\n\nmodule.exports.DEFAULT_COLORS = DEFAULT_COLORS;\n"],names:[],mappings:";;;AAAA,MAAM,WAAW,GAAG,UAAU,CAAC;AAC/B,sCAA0B,GAAG,WAAW,CAAC;AACzC;AACA,MAAM,mBAAmB,GAAG,CAAC,CAAC;AAC9B,MAAM,mBAAmB,GAAG,EAAE,CAAC;AAC/B,sDAAkC,GAAG,mBAAmB,CAAC;AACzD,sDAAkC,GAAG,mBAAmB,CAAC;AACzD;AACA,MAAM,WAAW,GAAG,CAAC,CAAC;AACtB,MAAM,eAAe,GAAG,CAAC,CAAC;AAC1B,MAAM,eAAe,GAAG,EAAE,CAAC;AAC3B;AACA,sCAA0B,GAAG,WAAW,CAAC;AACzC,8CAA8B,GAAG,eAAe,CAAC;AACjD,8CAA8B,GAAG,eAAe,CAAC;AACjD;AACA;AACA,MAAM,kBAAkB,GAAG,CAAC,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;AACxE,oDAAiC,GAAG,kBAAkB,CAAC;AACvD;AACA,MAAM,oBAAoB,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC/C,wDAAmC,GAAG,oBAAoB,CAAC;AAC3D;AACA,MAAM,gBAAgB,GAAG,CAAC,WAAW,CAAC,CAAC;AACvC,gDAA+B,GAAG,gBAAgB,CAAC;AACnD;AACA,gDAAgC,GAAG,QAAQ,CAAC;AAC5C;AACA;AACA,MAAM,SAAS,GAAG,IAAI,CAAC;AACvB,kCAAwB,GAAG,SAAS,CAAC;AACrC,MAAM,mBAAmB,GAAG,EAAE,CAAC;AAC/B,sDAAkC,GAAG,mBAAmB,CAAC;AACzD;AACA;AACA,MAAM,cAAc,GAAG;AACvB,IAAI,mBAAmB,EAAE,MAAM;AAC/B,IAAI,wBAAwB,EAAE,OAAO;AACrC,CAAC,CAAC;AACF;AACA,4CAA6B,GAAG,cAAc",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"fff0a7ba2c32eec7c8f6f94dc45df842ae45f6d6"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_2rqf2kohg2=function(){return actualCoverage;};}return actualCoverage;}cov_2rqf2kohg2();const MODULE_NAME$8=(cov_2rqf2kohg2().s[0]++,"not-user");(cov_2rqf2kohg2().s[1]++,_const.MODULE_NAME=MODULE_NAME$8);const USERNAME_LENGTH_MIN$1=(cov_2rqf2kohg2().s[2]++,4);const USERNAME_LENGTH_MAX$1=(cov_2rqf2kohg2().s[3]++,40);(cov_2rqf2kohg2().s[4]++,_const.USERNAME_LENGTH_MIN=USERNAME_LENGTH_MIN$1);(cov_2rqf2kohg2().s[5]++,_const.USERNAME_LENGTH_MAX=USERNAME_LENGTH_MAX$1);const DEFAULT_TTL=(cov_2rqf2kohg2().s[6]++,3);//in minutes
	const DEFAULT_TTL_MIN=(cov_2rqf2kohg2().s[7]++,1);//in minutes
	const DEFAULT_TTL_MAX=(cov_2rqf2kohg2().s[8]++,60);//in minutes
	(cov_2rqf2kohg2().s[9]++,_const.DEFAULT_TTL=DEFAULT_TTL);(cov_2rqf2kohg2().s[10]++,_const.DEFAULT_TTL_MIN=DEFAULT_TTL_MIN);(cov_2rqf2kohg2().s[11]++,_const.DEFAULT_TTL_MAX=DEFAULT_TTL_MAX);//stronger -> weaker
	const DEFAULT_ROLES_LIST$1=(cov_2rqf2kohg2().s[12]++,["root","admin","client","user","guest"]);(cov_2rqf2kohg2().s[13]++,_const.DEFAULT_ROLES_LIST=DEFAULT_ROLES_LIST$1);const ROLES_NOT_SELECTABLE=(cov_2rqf2kohg2().s[14]++,["root","guest"]);(cov_2rqf2kohg2().s[15]++,_const.ROLES_NOT_SELECTABLE=ROLES_NOT_SELECTABLE);const EXTRA_ROLES_LIST$1=(cov_2rqf2kohg2().s[16]++,["confirmed"]);(cov_2rqf2kohg2().s[17]++,_const.EXTRA_ROLES_LIST=EXTRA_ROLES_LIST$1);(cov_2rqf2kohg2().s[18]++,_const.DEFAULT_HASH_ALGO="sha256");//TOKEN IDENTITY
	const TOKEN_TTL=(cov_2rqf2kohg2().s[19]++,3600);(cov_2rqf2kohg2().s[20]++,_const.TOKEN_TTL=TOKEN_TTL);const TOKEN_SECRET_LENGTH=(cov_2rqf2kohg2().s[21]++,20);(cov_2rqf2kohg2().s[22]++,_const.TOKEN_SECRET_LENGTH=TOKEN_SECRET_LENGTH);//styling
	const DEFAULT_COLORS=(cov_2rqf2kohg2().s[23]++,{mainBackgroundColor:"info",secondaryBackgroundColor:"light"});(cov_2rqf2kohg2().s[24]++,_const.DEFAULT_COLORS=DEFAULT_COLORS);

	function cov_lvu25oqfe(){var path="/home/cypher/proj/not-lib/not-user/src/fields/validators/username.js";var hash="4526323df7aaf6bc6523c82449bcedfecbc83f9f";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/fields/validators/username.js",statementMap:{"0":{start:{line:8,column:4},end:{line:8,column:14}},"1":{start:{line:10,column:15},end:{line:26,column:1}},"2":{start:{line:13,column:12},end:{line:16,column:15}},"3":{start:{line:22,column:12},end:{line:22,column:43}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:12,column:19},end:{line:12,column:20}},loc:{start:{line:12,column:43},end:{line:17,column:9}},line:12},"1":{name:"(anonymous_1)",decl:{start:{line:21,column:8},end:{line:21,column:9}},loc:{start:{line:21,column:38},end:{line:23,column:9}},line:21}},branchMap:{},s:{"0":0,"1":0,"2":0,"3":0},f:{"0":0,"1":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/fields/validators/username.js"],sourcesContent:["const {\n    MODULE_NAME,\n    USERNAME_LENGTH_MIN,\n    USERNAME_LENGTH_MAX,\n} = require(\"../../const\");\n\nmodule.exports = [\n    {\n        validator: (val, { validator }) => {\n            return validator.isLength(val, {\n                min: USERNAME_LENGTH_MIN,\n                max: USERNAME_LENGTH_MAX,\n            });\n        },\n        message: `${MODULE_NAME}:username_length_is_not_valid`,\n    },\n    {\n        validator(val, { validator }) {\n            return !validator.isEmail(val);\n        },\n        message: `${MODULE_NAME}:username_cant_be_email`,\n    },\n];\n"],names:[],mappings:";;;AAAA,MAAM;AACN,IAAI,WAAW;AACf,IAAI,mBAAmB;AACvB,IAAI,mBAAmB;AACvB,CAAC,GAAG,UAAsB,CAAC;AAC3B;IACA,QAAc,GAAG;AACjB,IAAI;AACJ,QAAQ,SAAS,EAAE,CAAC,GAAG,EAAE,EAAE,SAAS,EAAE,KAAK;AAC3C,YAAY,OAAO,SAAS,CAAC,QAAQ,CAAC,GAAG,EAAE;AAC3C,gBAAgB,GAAG,EAAE,mBAAmB;AACxC,gBAAgB,GAAG,EAAE,mBAAmB;AACxC,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,6BAA6B,CAAC;AAC9D,KAAK;AACL,IAAI;AACJ,QAAQ,SAAS,CAAC,GAAG,EAAE,EAAE,SAAS,EAAE,EAAE;AACtC,YAAY,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AAC3C,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,uBAAuB,CAAC;AACxD,KAAK;AACL,CAAC",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"4526323df7aaf6bc6523c82449bcedfecbc83f9f"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_lvu25oqfe=function(){return actualCoverage;};}return actualCoverage;}cov_lvu25oqfe();const{MODULE_NAME: MODULE_NAME$7,USERNAME_LENGTH_MIN,USERNAME_LENGTH_MAX}=(cov_lvu25oqfe().s[0]++,_const);var username=(cov_lvu25oqfe().s[1]++,[{validator:(val,{validator})=>{cov_lvu25oqfe().f[0]++;cov_lvu25oqfe().s[2]++;return validator.isLength(val,{min:USERNAME_LENGTH_MIN,max:USERNAME_LENGTH_MAX});},message:`${MODULE_NAME$7}:username_length_is_not_valid`},{validator(val,{validator}){cov_lvu25oqfe().f[1]++;cov_lvu25oqfe().s[3]++;return !validator.isEmail(val);},message:`${MODULE_NAME$7}:username_cant_be_email`}]);var vUsername = /*@__PURE__*/getDefaultExportFromCjs(username);

	function cov_8lmtgiajx(){var path="/home/cypher/proj/not-lib/not-user/src/fields/validators/email.js";var hash="88ce79d0cc70ec7e0c428effea2633a75d5cb26a";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/fields/validators/email.js",statementMap:{"0":{start:{line:4,column:24},end:{line:4,column:34}},"1":{start:{line:6,column:12},end:{line:13,column:1}},"2":{start:{line:9,column:12},end:{line:9,column:42}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:8,column:19},end:{line:8,column:20}},loc:{start:{line:8,column:43},end:{line:10,column:9}},line:8}},branchMap:{},s:{"0":0,"1":0,"2":0},f:{"0":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/fields/validators/email.js"],sourcesContent:["const { MODULE_NAME } = require(\"../../const\");\n\nmodule.exports = [\n    {\n        validator: (val, { validator }) => {\n            return validator.isEmail(val);\n        },\n        message: `${MODULE_NAME}:email_is_not_valid`,\n    },\n];\n"],names:[],mappings:";;;AAAA,MAAM,EAAE,WAAW,EAAE,GAAG,UAAsB,CAAC;AAC/C;IACA,KAAc,GAAG;AACjB,IAAI;AACJ,QAAQ,SAAS,EAAE,CAAC,GAAG,EAAE,EAAE,SAAS,EAAE,KAAK;AAC3C,YAAY,OAAO,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AAC1C,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,mBAAmB,CAAC;AACpD,KAAK;AACL,CAAC",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"88ce79d0cc70ec7e0c428effea2633a75d5cb26a"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_8lmtgiajx=function(){return actualCoverage;};}return actualCoverage;}cov_8lmtgiajx();const{MODULE_NAME: MODULE_NAME$6}=(cov_8lmtgiajx().s[0]++,_const);var email=(cov_8lmtgiajx().s[1]++,[{validator:(val,{validator})=>{cov_8lmtgiajx().f[0]++;cov_8lmtgiajx().s[2]++;return validator.isEmail(val);},message:`${MODULE_NAME$6}:email_is_not_valid`}]);var vEmail = /*@__PURE__*/getDefaultExportFromCjs(email);

	function cov_286zi90wae(){var path="/home/cypher/proj/not-lib/not-user/src/fields/validators/telephone.js";var hash="8c8af24fe547dd99d25564587afdab61e340ba07";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/fields/validators/telephone.js",statementMap:{"0":{start:{line:4,column:24},end:{line:4,column:34}},"1":{start:{line:6,column:16},end:{line:13,column:1}},"2":{start:{line:9,column:12},end:{line:9,column:67}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:8,column:8},end:{line:8,column:9}},loc:{start:{line:8,column:38},end:{line:10,column:9}},line:8}},branchMap:{},s:{"0":0,"1":0,"2":0},f:{"0":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/fields/validators/telephone.js"],sourcesContent:["const { MODULE_NAME } = require(\"../../const\");\n\nmodule.exports = [\n    {\n        validator(val, { validator }) {\n            return validator.isMobilePhone(val.replace(/\\D/g, \"\"));\n        },\n        message: `${MODULE_NAME}:telephone_value_is_not_valid`,\n    },\n];\n"],names:[],mappings:";;;AAAA,MAAM,EAAE,WAAW,EAAE,GAAG,UAAsB,CAAC;AAC/C;IACA,SAAc,GAAG;AACjB,IAAI;AACJ,QAAQ,SAAS,CAAC,GAAG,EAAE,EAAE,SAAS,EAAE,EAAE;AACtC,YAAY,OAAO,SAAS,CAAC,aAAa,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC;AACnE,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,6BAA6B,CAAC;AAC9D,KAAK;AACL,CAAC",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"8c8af24fe547dd99d25564587afdab61e340ba07"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_286zi90wae=function(){return actualCoverage;};}return actualCoverage;}cov_286zi90wae();const{MODULE_NAME: MODULE_NAME$5}=(cov_286zi90wae().s[0]++,_const);var telephone=(cov_286zi90wae().s[1]++,[{validator(val,{validator}){cov_286zi90wae().f[0]++;cov_286zi90wae().s[2]++;return validator.isMobilePhone(val.replace(/\D/g,""));},message:`${MODULE_NAME$5}:telephone_value_is_not_valid`}]);var vTelephone = /*@__PURE__*/getDefaultExportFromCjs(telephone);

	function cov_g4s92mff7(){var path="/home/cypher/proj/not-lib/not-user/src/fields/validators/password.js";var hash="0eaef20cf9db4be2529c1329bd038736b89e44e1";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/fields/validators/password.js",statementMap:{"0":{start:{line:4,column:24},end:{line:4,column:34}},"1":{start:{line:6,column:15},end:{line:13,column:1}},"2":{start:{line:9,column:12},end:{line:9,column:65}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:8,column:19},end:{line:8,column:20}},loc:{start:{line:8,column:43},end:{line:10,column:9}},line:8}},branchMap:{},s:{"0":0,"1":0,"2":0},f:{"0":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/fields/validators/password.js"],sourcesContent:["const { MODULE_NAME } = require(\"../../const\");\n\nmodule.exports = [\n    {\n        validator: (val, { validator }) => {\n            return validator.isLength(val, { min: 6, max: 256 });\n        },\n        message: `${MODULE_NAME}:password_length_not_valid`,\n    },\n];\n"],names:[],mappings:";;;AAAA,MAAM,EAAE,WAAW,EAAE,GAAG,UAAsB,CAAC;AAC/C;IACA,QAAc,GAAG;AACjB,IAAI;AACJ,QAAQ,SAAS,EAAE,CAAC,GAAG,EAAE,EAAE,SAAS,EAAE,KAAK;AAC3C,YAAY,OAAO,SAAS,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;AACjE,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,0BAA0B,CAAC;AAC3D,KAAK;AACL,CAAC",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"0eaef20cf9db4be2529c1329bd038736b89e44e1"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_g4s92mff7=function(){return actualCoverage;};}return actualCoverage;}cov_g4s92mff7();const{MODULE_NAME: MODULE_NAME$4}=(cov_g4s92mff7().s[0]++,_const);var password=(cov_g4s92mff7().s[1]++,[{validator:(val,{validator})=>{cov_g4s92mff7().f[0]++;cov_g4s92mff7().s[2]++;return validator.isLength(val,{min:6,max:256});},message:`${MODULE_NAME$4}:password_length_not_valid`}]);var vPassword = /*@__PURE__*/getDefaultExportFromCjs(password);

	function cov_2nwtr3xzpu(){var path="/home/cypher/proj/not-lib/not-user/src/fields/validators/code.js";var hash="ba7f90d768839e915ae71c5773c1b0b02b82612d";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/fields/validators/code.js",statementMap:{"0":{start:{line:4,column:24},end:{line:4,column:34}},"1":{start:{line:6,column:11},end:{line:13,column:1}},"2":{start:{line:9,column:12},end:{line:9,column:44}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:8,column:19},end:{line:8,column:20}},loc:{start:{line:8,column:43},end:{line:10,column:9}},line:8}},branchMap:{},s:{"0":0,"1":0,"2":0},f:{"0":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/fields/validators/code.js"],sourcesContent:["const { MODULE_NAME } = require(\"../../const\");\n\nmodule.exports = [\n    {\n        validator: (val, { validator }) => {\n            return validator.isUUID(val, 4);\n        },\n        message: `${MODULE_NAME}:code_is_not_valid`,\n    },\n];\n"],names:[],mappings:";;;AAAA,MAAM,EAAE,WAAW,EAAE,GAAG,UAAsB,CAAC;AAC/C;IACA,IAAc,GAAG;AACjB,IAAI;AACJ,QAAQ,SAAS,EAAE,CAAC,GAAG,EAAE,EAAE,SAAS,EAAE,KAAK;AAC3C,YAAY,OAAO,SAAS,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AAC5C,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,kBAAkB,CAAC;AACnD,KAAK;AACL,CAAC",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"ba7f90d768839e915ae71c5773c1b0b02b82612d"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_2nwtr3xzpu=function(){return actualCoverage;};}return actualCoverage;}cov_2nwtr3xzpu();const{MODULE_NAME: MODULE_NAME$3}=(cov_2nwtr3xzpu().s[0]++,_const);var code=(cov_2nwtr3xzpu().s[1]++,[{validator:(val,{validator})=>{cov_2nwtr3xzpu().f[0]++;cov_2nwtr3xzpu().s[2]++;return validator.isUUID(val,4);},message:`${MODULE_NAME$3}:code_is_not_valid`}]);var vCode = /*@__PURE__*/getDefaultExportFromCjs(code);

	function cov_1nbs5w0i1(){var path="/home/cypher/proj/not-lib/not-user/src/fields/validators/role.js";var hash="d1640b3eae8006dfb43a1d86b41aa363cb435e9a";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/fields/validators/role.js",statementMap:{"0":{start:{line:8,column:4},end:{line:8,column:14}},"1":{start:{line:10,column:11},end:{line:64,column:1}},"2":{start:{line:13,column:12},end:{line:13,column:36}},"3":{start:{line:19,column:12},end:{line:19,column:34}},"4":{start:{line:25,column:34},end:{line:28,column:13}},"5":{start:{line:29,column:24},end:{line:29,column:25}},"6":{start:{line:30,column:12},end:{line:35,column:15}},"7":{start:{line:31,column:33},end:{line:31,column:74}},"8":{start:{line:32,column:16},end:{line:34,column:17}},"9":{start:{line:33,column:20},end:{line:33,column:28}},"10":{start:{line:36,column:12},end:{line:36,column:31}},"11":{start:{line:42,column:34},end:{line:45,column:13}},"12":{start:{line:46,column:36},end:{line:49,column:13}},"13":{start:{line:50,column:33},end:{line:50,column:38}},"14":{start:{line:51,column:12},end:{line:59,column:15}},"15":{start:{line:52,column:33},end:{line:52,column:74}},"16":{start:{line:53,column:16},end:{line:58,column:17}},"17":{start:{line:57,column:20},end:{line:57,column:42}},"18":{start:{line:60,column:12},end:{line:60,column:35}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:12,column:8},end:{line:12,column:9}},loc:{start:{line:12,column:23},end:{line:14,column:9}},line:12},"1":{name:"(anonymous_1)",decl:{start:{line:18,column:8},end:{line:18,column:9}},loc:{start:{line:18,column:23},end:{line:20,column:9}},line:18},"2":{name:"(anonymous_2)",decl:{start:{line:24,column:8},end:{line:24,column:9}},loc:{start:{line:24,column:35},end:{line:37,column:9}},line:24},"3":{name:"(anonymous_3)",decl:{start:{line:30,column:24},end:{line:30,column:25}},loc:{start:{line:30,column:34},end:{line:35,column:13}},line:30},"4":{name:"(anonymous_4)",decl:{start:{line:41,column:8},end:{line:41,column:9}},loc:{start:{line:41,column:35},end:{line:61,column:9}},line:41},"5":{name:"(anonymous_5)",decl:{start:{line:51,column:24},end:{line:51,column:25}},loc:{start:{line:51,column:34},end:{line:59,column:13}},line:51}},branchMap:{"0":{loc:{start:{line:31,column:33},end:{line:31,column:74}},type:"cond-expr",locations:[{start:{line:31,column:60},end:{line:31,column:64}},{start:{line:31,column:67},end:{line:31,column:74}}],line:31},"1":{loc:{start:{line:32,column:16},end:{line:34,column:17}},type:"if",locations:[{start:{line:32,column:16},end:{line:34,column:17}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:32},"2":{loc:{start:{line:52,column:33},end:{line:52,column:74}},type:"cond-expr",locations:[{start:{line:52,column:60},end:{line:52,column:64}},{start:{line:52,column:67},end:{line:52,column:74}}],line:52},"3":{loc:{start:{line:53,column:16},end:{line:58,column:17}},type:"if",locations:[{start:{line:53,column:16},end:{line:58,column:17}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:53},"4":{loc:{start:{line:54,column:20},end:{line:55,column:55}},type:"binary-expr",locations:[{start:{line:54,column:20},end:{line:54,column:53}},{start:{line:55,column:20},end:{line:55,column:55}}],line:54}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0},b:{"0":[0,0],"1":[0,0],"2":[0,0],"3":[0,0],"4":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/fields/validators/role.js"],sourcesContent:["const {\n    MODULE_NAME,\n    DEFAULT_ROLES_LIST,\n    EXTRA_ROLES_LIST,\n} = require(\"../../const\");\n\nmodule.exports = [\n    {\n        validator(val) {\n            return val.length !== 0;\n        },\n        message: `${MODULE_NAME}:user_role_should_be_declared`,\n    },\n    {\n        validator(val) {\n            return val.length < 7;\n        },\n        message: `${MODULE_NAME}:user_role_too_many`,\n    },\n    {\n        validator(val, { config }) {\n            const ROLES_PRIMARY = config.get(\n                \"roles.primary\",\n                DEFAULT_ROLES_LIST\n            );\n            let count = 0;\n            val.forEach((role) => {\n                const roleName = typeof role === \"string\" ? role : role.id;\n                if (ROLES_PRIMARY.includes(roleName)) {\n                    count++;\n                }\n            });\n            return count === 1;\n        },\n        message: `${MODULE_NAME}:user_role_should_have_one_primary`,\n    },\n    {\n        validator(val, { config }) {\n            const ROLES_PRIMARY = config.get(\n                \"roles.primary\",\n                DEFAULT_ROLES_LIST\n            );\n            const ROLES_SECONDARY = config.get(\n                \"roles.secondary\",\n                EXTRA_ROLES_LIST\n            );\n            let extraIsInvalid = false;\n            val.forEach((role) => {\n                const roleName = typeof role === \"string\" ? role : role.id;\n                if (\n                    !ROLES_PRIMARY.includes(roleName) &&\n                    !ROLES_SECONDARY.includes(roleName)\n                ) {\n                    extraIsInvalid = true;\n                }\n            });\n            return !extraIsInvalid;\n        },\n        message: `${MODULE_NAME}:user_role_secondary_is_not_exists`,\n    },\n];\n"],names:[],mappings:";;;AAAA,MAAM;AACN,IAAI,WAAW;AACf,IAAI,kBAAkB;AACtB,IAAI,gBAAgB;AACpB,CAAC,GAAG,UAAsB,CAAC;AAC3B;IACA,IAAc,GAAG;AACjB,IAAI;AACJ,QAAQ,SAAS,CAAC,GAAG,EAAE;AACvB,YAAY,OAAO,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC;AACpC,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,6BAA6B,CAAC;AAC9D,KAAK;AACL,IAAI;AACJ,QAAQ,SAAS,CAAC,GAAG,EAAE;AACvB,YAAY,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;AAClC,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,mBAAmB,CAAC;AACpD,KAAK;AACL,IAAI;AACJ,QAAQ,SAAS,CAAC,GAAG,EAAE,EAAE,MAAM,EAAE,EAAE;AACnC,YAAY,MAAM,aAAa,GAAG,MAAM,CAAC,GAAG;AAC5C,gBAAgB,eAAe;AAC/B,gBAAgB,kBAAkB;AAClC,aAAa,CAAC;AACd,YAAY,IAAI,KAAK,GAAG,CAAC,CAAC;AAC1B,YAAY,GAAG,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK;AAClC,gBAAgB,MAAM,QAAQ,GAAG,OAAO,IAAI,KAAK,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC;AAC3E,gBAAgB,IAAI,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;AACtD,oBAAoB,KAAK,EAAE,CAAC;AAC5B,iBAAiB;AACjB,aAAa,CAAC,CAAC;AACf,YAAY,OAAO,KAAK,KAAK,CAAC,CAAC;AAC/B,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,kCAAkC,CAAC;AACnE,KAAK;AACL,IAAI;AACJ,QAAQ,SAAS,CAAC,GAAG,EAAE,EAAE,MAAM,EAAE,EAAE;AACnC,YAAY,MAAM,aAAa,GAAG,MAAM,CAAC,GAAG;AAC5C,gBAAgB,eAAe;AAC/B,gBAAgB,kBAAkB;AAClC,aAAa,CAAC;AACd,YAAY,MAAM,eAAe,GAAG,MAAM,CAAC,GAAG;AAC9C,gBAAgB,iBAAiB;AACjC,gBAAgB,gBAAgB;AAChC,aAAa,CAAC;AACd,YAAY,IAAI,cAAc,GAAG,KAAK,CAAC;AACvC,YAAY,GAAG,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK;AAClC,gBAAgB,MAAM,QAAQ,GAAG,OAAO,IAAI,KAAK,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC;AAC3E,gBAAgB;AAChB,oBAAoB,CAAC,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC;AACrD,oBAAoB,CAAC,eAAe,CAAC,QAAQ,CAAC,QAAQ,CAAC;AACvD,kBAAkB;AAClB,oBAAoB,cAAc,GAAG,IAAI,CAAC;AAC1C,iBAAiB;AACjB,aAAa,CAAC,CAAC;AACf,YAAY,OAAO,CAAC,cAAc,CAAC;AACnC,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,kCAAkC,CAAC;AACnE,KAAK;AACL,CAAC",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"d1640b3eae8006dfb43a1d86b41aa363cb435e9a"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1nbs5w0i1=function(){return actualCoverage;};}return actualCoverage;}cov_1nbs5w0i1();const{MODULE_NAME: MODULE_NAME$2,DEFAULT_ROLES_LIST,EXTRA_ROLES_LIST}=(cov_1nbs5w0i1().s[0]++,_const);var role=(cov_1nbs5w0i1().s[1]++,[{validator(val){cov_1nbs5w0i1().f[0]++;cov_1nbs5w0i1().s[2]++;return val.length!==0;},message:`${MODULE_NAME$2}:user_role_should_be_declared`},{validator(val){cov_1nbs5w0i1().f[1]++;cov_1nbs5w0i1().s[3]++;return val.length<7;},message:`${MODULE_NAME$2}:user_role_too_many`},{validator(val,{config}){cov_1nbs5w0i1().f[2]++;const ROLES_PRIMARY=(cov_1nbs5w0i1().s[4]++,config.get("roles.primary",DEFAULT_ROLES_LIST));let count=(cov_1nbs5w0i1().s[5]++,0);cov_1nbs5w0i1().s[6]++;val.forEach(role=>{cov_1nbs5w0i1().f[3]++;const roleName=(cov_1nbs5w0i1().s[7]++,typeof role==="string"?(cov_1nbs5w0i1().b[0][0]++,role):(cov_1nbs5w0i1().b[0][1]++,role.id));cov_1nbs5w0i1().s[8]++;if(ROLES_PRIMARY.includes(roleName)){cov_1nbs5w0i1().b[1][0]++;cov_1nbs5w0i1().s[9]++;count++;}else {cov_1nbs5w0i1().b[1][1]++;}});cov_1nbs5w0i1().s[10]++;return count===1;},message:`${MODULE_NAME$2}:user_role_should_have_one_primary`},{validator(val,{config}){cov_1nbs5w0i1().f[4]++;const ROLES_PRIMARY=(cov_1nbs5w0i1().s[11]++,config.get("roles.primary",DEFAULT_ROLES_LIST));const ROLES_SECONDARY=(cov_1nbs5w0i1().s[12]++,config.get("roles.secondary",EXTRA_ROLES_LIST));let extraIsInvalid=(cov_1nbs5w0i1().s[13]++,false);cov_1nbs5w0i1().s[14]++;val.forEach(role=>{cov_1nbs5w0i1().f[5]++;const roleName=(cov_1nbs5w0i1().s[15]++,typeof role==="string"?(cov_1nbs5w0i1().b[2][0]++,role):(cov_1nbs5w0i1().b[2][1]++,role.id));cov_1nbs5w0i1().s[16]++;if((cov_1nbs5w0i1().b[4][0]++,!ROLES_PRIMARY.includes(roleName))&&(cov_1nbs5w0i1().b[4][1]++,!ROLES_SECONDARY.includes(roleName))){cov_1nbs5w0i1().b[3][0]++;cov_1nbs5w0i1().s[17]++;extraIsInvalid=true;}else {cov_1nbs5w0i1().b[3][1]++;}});cov_1nbs5w0i1().s[18]++;return !extraIsInvalid;},message:`${MODULE_NAME$2}:user_role_secondary_is_not_exists`}]);var vRole = /*@__PURE__*/getDefaultExportFromCjs(role);

	function cov_1xtzhi1rzq(){var path="/home/cypher/proj/not-lib/not-user/src/fields/validators/country.js";var hash="cde8fa15290d2f96aa13fa6a075aee87c17d5395";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/fields/validators/country.js",statementMap:{"0":{start:{line:4,column:24},end:{line:4,column:34}},"1":{start:{line:6,column:14},end:{line:13,column:1}},"2":{start:{line:9,column:12},end:{line:9,column:32}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:8,column:8},end:{line:8,column:9}},loc:{start:{line:8,column:23},end:{line:10,column:9}},line:8}},branchMap:{},s:{"0":0,"1":0,"2":0},f:{"0":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/fields/validators/country.js"],sourcesContent:["const { MODULE_NAME } = require(\"../../const\");\n\nmodule.exports = [\n    {\n        validator(val) {\n            return val === \"ru\";\n        },\n        message: `${MODULE_NAME}:selected_user_language_is_not_valid`,\n    },\n];\n"],names:[],mappings:";;;AAAA,MAAM,EAAE,WAAW,EAAE,GAAG,UAAsB,CAAC;AAC/C;IACA,OAAc,GAAG;AACjB,IAAI;AACJ,QAAQ,SAAS,CAAC,GAAG,EAAE;AACvB,YAAY,OAAO,GAAG,KAAK,IAAI,CAAC;AAChC,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,oCAAoC,CAAC;AACrE,KAAK;AACL,CAAC",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"cde8fa15290d2f96aa13fa6a075aee87c17d5395"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1xtzhi1rzq=function(){return actualCoverage;};}return actualCoverage;}cov_1xtzhi1rzq();const{MODULE_NAME: MODULE_NAME$1}=(cov_1xtzhi1rzq().s[0]++,_const);var country=(cov_1xtzhi1rzq().s[1]++,[{validator(val){cov_1xtzhi1rzq().f[0]++;cov_1xtzhi1rzq().s[2]++;return val==="ru";},message:`${MODULE_NAME$1}:selected_user_language_is_not_valid`}]);var vCountry = /*@__PURE__*/getDefaultExportFromCjs(country);

	function cov_1b9ryfjrbj(){var path="/home/cypher/proj/not-lib/not-user/src/fields/validators/active.js";var hash="337b6717629d2a77ed8375642b0876c8d82d1dca";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/fields/validators/active.js",statementMap:{"0":{start:{line:4,column:24},end:{line:4,column:34}},"1":{start:{line:6,column:13},end:{line:13,column:1}},"2":{start:{line:9,column:12},end:{line:9,column:44}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:8,column:8},end:{line:8,column:9}},loc:{start:{line:8,column:23},end:{line:10,column:9}},line:8}},branchMap:{},s:{"0":0,"1":0,"2":0},f:{"0":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/fields/validators/active.js"],sourcesContent:["const { MODULE_NAME } = require(\"../../const\");\n\nmodule.exports = [\n    {\n        validator(val) {\n            return typeof val === \"boolean\";\n        },\n        message: `${MODULE_NAME}:active_state_value_is_not_valid`,\n    },\n];\n"],names:[],mappings:";;;AAAA,MAAM,EAAE,WAAW,EAAE,GAAG,UAAsB,CAAC;AAC/C;IACA,MAAc,GAAG;AACjB,IAAI;AACJ,QAAQ,SAAS,CAAC,GAAG,EAAE;AACvB,YAAY,OAAO,OAAO,GAAG,KAAK,SAAS,CAAC;AAC5C,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC,EAAE,WAAW,CAAC,gCAAgC,CAAC;AACjE,KAAK;AACL,CAAC",file:null},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"337b6717629d2a77ed8375642b0876c8d82d1dca"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1b9ryfjrbj=function(){return actualCoverage;};}return actualCoverage;}cov_1b9ryfjrbj();const{MODULE_NAME}=(cov_1b9ryfjrbj().s[0]++,_const);var active=(cov_1b9ryfjrbj().s[1]++,[{validator(val){cov_1b9ryfjrbj().f[0]++;cov_1b9ryfjrbj().s[2]++;return typeof val==="boolean";},message:`${MODULE_NAME}:active_state_value_is_not_valid`}]);var vActive = /*@__PURE__*/getDefaultExportFromCjs(active);

	function cov_1g1dpvfeuu(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/common/validators.js";var hash="ae3ebfa05dd817159f2317aec6c11e8c57db402b";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/common/validators.js",statementMap:{"0":{start:{line:12,column:30},end:{line:12,column:54}},"1":{start:{line:14,column:4},end:{line:14,column:45}},"2":{start:{line:16,column:29},end:{line:25,column:1}},"3":{start:{line:17,column:4},end:{line:24,column:5}},"4":{start:{line:18,column:8},end:{line:23,column:11}},"5":{start:{line:27,column:19},end:{line:48,column:1}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:16,column:29},end:{line:16,column:30}},loc:{start:{line:16,column:45},end:{line:25,column:1}},line:16}},branchMap:{"0":{loc:{start:{line:17,column:4},end:{line:24,column:5}},type:"if",locations:[{start:{line:17,column:4},end:{line:24,column:5}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:17}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0},f:{"0":0},b:{"0":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/common/validators.js"],sourcesContent:["import notValidationError from \"not-error/src/validation.error.browser.mjs\";\n\nimport vUsername from \"../../fields/validators/username.js\";\nimport vEmail from \"../../fields/validators/email.js\";\nimport vTelephone from \"../../fields/validators/telephone.js\";\nimport vPassword from \"../../fields/validators/password.js\";\nimport vCode from \"../../fields/validators/code.js\";\nimport vRole from \"../../fields/validators/role.js\";\nimport vCountry from \"../../fields/validators/country.js\";\nimport vActive from \"../../fields/validators/active.js\";\n\nconst ERR_MSG_FORM_IS_DIRTY = \"not-user:form_is_dirty\";\nconst ERR_MSG_FORM_PASSWORDS_SHOULD_BE_EQUAL =\n    \"not-user:form_passwords_should_be_equal\";\n\nconst createUserValidation = async (data) => {\n    if (data.password !== data.passwordRepeat) {\n        throw new notValidationError(ERR_MSG_FORM_PASSWORDS_SHOULD_BE_EQUAL, {\n            form: [ERR_MSG_FORM_IS_DIRTY],\n            fields: {\n                passwordRepeat: [ERR_MSG_FORM_PASSWORDS_SHOULD_BE_EQUAL],\n            },\n        });\n    }\n};\n\nconst Validators = {\n    //val - value of field\n    //env - resources (constants, config reader, third party libs) needed for validation and provided from module level\n    //(val:any, env: Object)=>Promise<Boolean>\n    fields: {\n        username: vUsername,\n        password: vPassword,\n        telephone: vTelephone,\n        email: vEmail,\n        code: vCode,\n        role: vRole,\n        country: vCountry,\n        active: vActive,\n    },\n    //form - object with form values\n    //env - resources needed for validation and provided from module level\n    //(form:Object, env: Object)=>Promise<Boolean>\n    forms: {\n        create: [createUserValidation],\n        register: [createUserValidation],\n    },\n};\n\nexport default Validators;\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5E;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvH,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"ae3ebfa05dd817159f2317aec6c11e8c57db402b"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1g1dpvfeuu=function(){return actualCoverage;};}return actualCoverage;}cov_1g1dpvfeuu();const ERR_MSG_FORM_IS_DIRTY=(cov_1g1dpvfeuu().s[0]++,"not-user:form_is_dirty");const ERR_MSG_FORM_PASSWORDS_SHOULD_BE_EQUAL=(cov_1g1dpvfeuu().s[1]++,"not-user:form_passwords_should_be_equal");cov_1g1dpvfeuu().s[2]++;const createUserValidation=async data=>{cov_1g1dpvfeuu().f[0]++;cov_1g1dpvfeuu().s[3]++;if(data.password!==data.passwordRepeat){cov_1g1dpvfeuu().b[0][0]++;cov_1g1dpvfeuu().s[4]++;throw new notValidationError(ERR_MSG_FORM_PASSWORDS_SHOULD_BE_EQUAL,{form:[ERR_MSG_FORM_IS_DIRTY],fields:{passwordRepeat:[ERR_MSG_FORM_PASSWORDS_SHOULD_BE_EQUAL]}});}else {cov_1g1dpvfeuu().b[0][1]++;}};const Validators=(cov_1g1dpvfeuu().s[5]++,{//val - value of field
	//env - resources (constants, config reader, third party libs) needed for validation and provided from module level
	//(val:any, env: Object)=>Promise<Boolean>
	fields:{username:vUsername,password:vPassword,telephone:vTelephone,email:vEmail,code:vCode,role:vRole,country:vCountry,active:vActive},//form - object with form values
	//env - resources needed for validation and provided from module level
	//(form:Object, env: Object)=>Promise<Boolean>
	forms:{create:[createUserValidation],register:[createUserValidation]}});

	function cov_b6uz3zi97(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/login.js";var hash="adb876b27d478602f9458667a6b4c27a581b1410";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/login.js",statementMap:{"0":{start:{line:3,column:20},end:{line:3,column:25}},"1":{start:{line:9,column:8},end:{line:9,column:33}},"2":{start:{line:10,column:8},end:{line:10,column:31}},"3":{start:{line:11,column:8},end:{line:15,column:11}},"4":{start:{line:17,column:8},end:{line:17,column:51}},"5":{start:{line:17,column:33},end:{line:17,column:49}},"6":{start:{line:18,column:8},end:{line:20,column:11}},"7":{start:{line:19,column:12},end:{line:19,column:76}},"8":{start:{line:21,column:8},end:{line:25,column:11}},"9":{start:{line:22,column:12},end:{line:24,column:14}},"10":{start:{line:29,column:8},end:{line:32,column:46}},"11":{start:{line:36,column:8},end:{line:49,column:9}},"12":{start:{line:37,column:12},end:{line:37,column:30}},"13":{start:{line:38,column:27},end:{line:40,column:15}},"14":{start:{line:42,column:12},end:{line:42,column:39}},"15":{start:{line:45,column:12},end:{line:45,column:34}},"16":{start:{line:48,column:12},end:{line:48,column:32}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:8,column:4},end:{line:8,column:5}},loc:{start:{line:8,column:45},end:{line:26,column:5}},line:8},"1":{name:"(anonymous_1)",decl:{start:{line:17,column:26},end:{line:17,column:27}},loc:{start:{line:17,column:33},end:{line:17,column:49}},line:17},"2":{name:"(anonymous_2)",decl:{start:{line:18,column:26},end:{line:18,column:27}},loc:{start:{line:18,column:32},end:{line:20,column:9}},line:18},"3":{name:"(anonymous_3)",decl:{start:{line:21,column:27},end:{line:21,column:28}},loc:{start:{line:21,column:33},end:{line:25,column:9}},line:21},"4":{name:"(anonymous_4)",decl:{start:{line:28,column:4},end:{line:28,column:5}},loc:{start:{line:28,column:24},end:{line:33,column:5}},line:28},"5":{name:"(anonymous_5)",decl:{start:{line:35,column:4},end:{line:35,column:5}},loc:{start:{line:35,column:25},end:{line:50,column:5}},line:35}},branchMap:{"0":{loc:{start:{line:8,column:18},end:{line:8,column:27}},type:"default-arg",locations:[{start:{line:8,column:25},end:{line:8,column:27}}],line:8},"1":{loc:{start:{line:8,column:29},end:{line:8,column:41}},type:"default-arg",locations:[{start:{line:8,column:39},end:{line:8,column:41}}],line:8}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0},b:{"0":[0],"1":[0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/login.js"],sourcesContent:["import { Frame, notCommon } from \"not-bulma\";\nimport UserCommon from \"../../common/user\";\nconst { notForm } = Frame;\n\nimport ValidatorsLib from \"../../common/validators.js\";\n\nexport default class LoginForm extends notForm {\n    constructor({ data = {}, options = {} }) {\n        options.action = \"login\";\n        options.model = \"user\";\n        super({\n            name: \"Login\",\n            options,\n            data,\n        });\n        //events after user button actions\n        this.on(\"submit\", (e) => this.onSubmit(e));\n        this.on(\"reject\", () => {\n            location.assign(UserCommon.DEFAULT_USER_AFTER_LOGIN_FAILED_URL);\n        });\n        this.on(\"success\", () => {\n            location.assign(\n                UserCommon.getUserAfterLoginRedirectURL(notCommon.getApp())\n            );\n        });\n    }\n\n    getFormValidators() {\n        return notCommon\n            .getApp()\n            .getService(\"nsUser\")\n            .augmentValidators(ValidatorsLib);\n    }\n\n    async onSubmit(data) {\n        try {\n            this.setLoading();\n            const result = await this.getModel(\"user\", data)[\n                `$${this.getFormAction()}`\n            ]();\n            //maybe error or success\n            this.processResult(result);\n        } catch (e) {\n            //if exactly error\n            this.processResult(e);\n        } finally {\n            //should unlock UI anyway\n            this.resetLoading();\n        }\n    }\n}\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"adb876b27d478602f9458667a6b4c27a581b1410"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_b6uz3zi97=function(){return actualCoverage;};}return actualCoverage;}cov_b6uz3zi97();const{notForm: notForm$4}=(cov_b6uz3zi97().s[0]++,Frame);let LoginForm$1 = class LoginForm extends notForm$4{constructor({data=(cov_b6uz3zi97().b[0][0]++,{}),options=(cov_b6uz3zi97().b[1][0]++,{})}){cov_b6uz3zi97().f[0]++;cov_b6uz3zi97().s[1]++;options.action="login";cov_b6uz3zi97().s[2]++;options.model="user";cov_b6uz3zi97().s[3]++;super({name:"Login",options,data});//events after user button actions
	cov_b6uz3zi97().s[4]++;this.on("submit",e=>{cov_b6uz3zi97().f[1]++;cov_b6uz3zi97().s[5]++;return this.onSubmit(e);});cov_b6uz3zi97().s[6]++;this.on("reject",()=>{cov_b6uz3zi97().f[2]++;cov_b6uz3zi97().s[7]++;location.assign(UserCommon.DEFAULT_USER_AFTER_LOGIN_FAILED_URL);});cov_b6uz3zi97().s[8]++;this.on("success",()=>{cov_b6uz3zi97().f[3]++;cov_b6uz3zi97().s[9]++;location.assign(UserCommon.getUserAfterLoginRedirectURL(notCommon$1.getApp()));});}getFormValidators(){cov_b6uz3zi97().f[4]++;cov_b6uz3zi97().s[10]++;return notCommon$1.getApp().getService("nsUser").augmentValidators(Validators);}async onSubmit(data){cov_b6uz3zi97().f[5]++;cov_b6uz3zi97().s[11]++;try{cov_b6uz3zi97().s[12]++;this.setLoading();const result=(cov_b6uz3zi97().s[13]++,await this.getModel("user",data)[`$${this.getFormAction()}`]());//maybe error or success
	cov_b6uz3zi97().s[14]++;this.processResult(result);}catch(e){cov_b6uz3zi97().s[15]++;//if exactly error
	this.processResult(e);}finally{cov_b6uz3zi97().s[16]++;//should unlock UI anyway
	this.resetLoading();}}};

	function cov_5yvqxtl0a(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/loginByCode.js";var hash="ddcd54551a383fb8dc47cf8ea83fcca9e6e6594b";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/loginByCode.js",statementMap:{"0":{start:{line:2,column:20},end:{line:2,column:25}},"1":{start:{line:8,column:8},end:{line:8,column:39}},"2":{start:{line:9,column:8},end:{line:9,column:31}},"3":{start:{line:10,column:8},end:{line:14,column:11}},"4":{start:{line:16,column:8},end:{line:16,column:51}},"5":{start:{line:16,column:33},end:{line:16,column:49}},"6":{start:{line:17,column:8},end:{line:19,column:11}},"7":{start:{line:18,column:12},end:{line:18,column:75}},"8":{start:{line:20,column:8},end:{line:23,column:11}},"9":{start:{line:21,column:12},end:{line:21,column:41}},"10":{start:{line:22,column:12},end:{line:22,column:30}},"11":{start:{line:27,column:8},end:{line:30,column:46}},"12":{start:{line:34,column:8},end:{line:47,column:9}},"13":{start:{line:35,column:12},end:{line:35,column:30}},"14":{start:{line:36,column:27},end:{line:38,column:15}},"15":{start:{line:40,column:12},end:{line:40,column:39}},"16":{start:{line:43,column:12},end:{line:43,column:34}},"17":{start:{line:46,column:12},end:{line:46,column:32}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:7,column:4},end:{line:7,column:5}},loc:{start:{line:7,column:45},end:{line:24,column:5}},line:7},"1":{name:"(anonymous_1)",decl:{start:{line:16,column:26},end:{line:16,column:27}},loc:{start:{line:16,column:33},end:{line:16,column:49}},line:16},"2":{name:"(anonymous_2)",decl:{start:{line:17,column:26},end:{line:17,column:27}},loc:{start:{line:17,column:32},end:{line:19,column:9}},line:17},"3":{name:"(anonymous_3)",decl:{start:{line:20,column:27},end:{line:20,column:28}},loc:{start:{line:20,column:33},end:{line:23,column:9}},line:20},"4":{name:"(anonymous_4)",decl:{start:{line:26,column:4},end:{line:26,column:5}},loc:{start:{line:26,column:24},end:{line:31,column:5}},line:26},"5":{name:"(anonymous_5)",decl:{start:{line:33,column:4},end:{line:33,column:5}},loc:{start:{line:33,column:25},end:{line:48,column:5}},line:33}},branchMap:{"0":{loc:{start:{line:7,column:18},end:{line:7,column:27}},type:"default-arg",locations:[{start:{line:7,column:25},end:{line:7,column:27}}],line:7},"1":{loc:{start:{line:7,column:29},end:{line:7,column:41}},type:"default-arg",locations:[{start:{line:7,column:39},end:{line:7,column:41}}],line:7}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0},b:{"0":[0],"1":[0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/loginByCode.js"],sourcesContent:["import { Frame, notCommon } from \"not-bulma\";\nconst { notForm } = Frame;\n\nimport ValidatorsLib from \"../../common/validators.js\";\nimport UserCommon from \"../../common/user\";\nexport default class LoginForm extends notForm {\n    constructor({ data = {}, options = {} }) {\n        options.action = \"loginByCode\";\n        options.model = \"user\";\n        super({\n            name: \"LoginByCode\",\n            options,\n            data,\n        });\n        //events after user button actions\n        this.on(\"submit\", (e) => this.onSubmit(e));\n        this.on(\"reject\", () => {\n            location.href = UserCommon.DEFAULT_USER_AFTER_LOGIN_FAILED_URL;\n        });\n        this.on(\"success\", () => {\n            location.href = \"/dashboard\";\n            location.reload();\n        });\n    }\n\n    getFormValidators() {\n        return notCommon\n            .getApp()\n            .getService(\"nsUser\")\n            .augmentValidators(ValidatorsLib);\n    }\n\n    async onSubmit(data) {\n        try {\n            this.setLoading();\n            const result = await this.getModel(\"user\", data)[\n                `$${this.getFormAction()}`\n            ]();\n            //maybe error or success\n            this.processResult(result);\n        } catch (e) {\n            //if exactly error\n            this.processResult(e);\n        } finally {\n            //should unlock UI anyway\n            this.resetLoading();\n        }\n    }\n}\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"ddcd54551a383fb8dc47cf8ea83fcca9e6e6594b"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_5yvqxtl0a=function(){return actualCoverage;};}return actualCoverage;}cov_5yvqxtl0a();const{notForm: notForm$3}=(cov_5yvqxtl0a().s[0]++,Frame);class LoginForm extends notForm$3{constructor({data=(cov_5yvqxtl0a().b[0][0]++,{}),options=(cov_5yvqxtl0a().b[1][0]++,{})}){cov_5yvqxtl0a().f[0]++;cov_5yvqxtl0a().s[1]++;options.action="loginByCode";cov_5yvqxtl0a().s[2]++;options.model="user";cov_5yvqxtl0a().s[3]++;super({name:"LoginByCode",options,data});//events after user button actions
	cov_5yvqxtl0a().s[4]++;this.on("submit",e=>{cov_5yvqxtl0a().f[1]++;cov_5yvqxtl0a().s[5]++;return this.onSubmit(e);});cov_5yvqxtl0a().s[6]++;this.on("reject",()=>{cov_5yvqxtl0a().f[2]++;cov_5yvqxtl0a().s[7]++;location.href=UserCommon.DEFAULT_USER_AFTER_LOGIN_FAILED_URL;});cov_5yvqxtl0a().s[8]++;this.on("success",()=>{cov_5yvqxtl0a().f[3]++;cov_5yvqxtl0a().s[9]++;location.href="/dashboard";cov_5yvqxtl0a().s[10]++;location.reload();});}getFormValidators(){cov_5yvqxtl0a().f[4]++;cov_5yvqxtl0a().s[11]++;return notCommon$1.getApp().getService("nsUser").augmentValidators(Validators);}async onSubmit(data){cov_5yvqxtl0a().f[5]++;cov_5yvqxtl0a().s[12]++;try{cov_5yvqxtl0a().s[13]++;this.setLoading();const result=(cov_5yvqxtl0a().s[14]++,await this.getModel("user",data)[`$${this.getFormAction()}`]());//maybe error or success
	cov_5yvqxtl0a().s[15]++;this.processResult(result);}catch(e){cov_5yvqxtl0a().s[16]++;//if exactly error
	this.processResult(e);}finally{cov_5yvqxtl0a().s[17]++;//should unlock UI anyway
	this.resetLoading();}}}

	function cov_qt0d18gox(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/requestLoginCodeOnTelephone.js";var hash="2dd18b17568ec911d6af654646f283cb31eb5da5";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/requestLoginCodeOnTelephone.js",statementMap:{"0":{start:{line:2,column:20},end:{line:2,column:25}},"1":{start:{line:8,column:8},end:{line:8,column:55}},"2":{start:{line:9,column:8},end:{line:9,column:31}},"3":{start:{line:10,column:8},end:{line:14,column:11}},"4":{start:{line:16,column:8},end:{line:16,column:51}},"5":{start:{line:16,column:33},end:{line:16,column:49}},"6":{start:{line:17,column:8},end:{line:20,column:11}},"7":{start:{line:18,column:12},end:{line:18,column:32}},"8":{start:{line:19,column:12},end:{line:19,column:30}},"9":{start:{line:21,column:8},end:{line:27,column:11}},"10":{start:{line:22,column:12},end:{line:26,column:13}},"11":{start:{line:23,column:16},end:{line:25,column:25}},"12":{start:{line:24,column:20},end:{line:24,column:65}},"13":{start:{line:31,column:8},end:{line:34,column:46}},"14":{start:{line:38,column:8},end:{line:51,column:9}},"15":{start:{line:39,column:12},end:{line:39,column:30}},"16":{start:{line:40,column:27},end:{line:42,column:15}},"17":{start:{line:44,column:12},end:{line:44,column:39}},"18":{start:{line:47,column:12},end:{line:47,column:34}},"19":{start:{line:50,column:12},end:{line:50,column:32}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:7,column:4},end:{line:7,column:5}},loc:{start:{line:7,column:45},end:{line:28,column:5}},line:7},"1":{name:"(anonymous_1)",decl:{start:{line:16,column:26},end:{line:16,column:27}},loc:{start:{line:16,column:33},end:{line:16,column:49}},line:16},"2":{name:"(anonymous_2)",decl:{start:{line:17,column:26},end:{line:17,column:27}},loc:{start:{line:17,column:32},end:{line:20,column:9}},line:17},"3":{name:"(anonymous_3)",decl:{start:{line:21,column:27},end:{line:21,column:28}},loc:{start:{line:21,column:33},end:{line:27,column:9}},line:21},"4":{name:"(anonymous_4)",decl:{start:{line:23,column:27},end:{line:23,column:28}},loc:{start:{line:23,column:33},end:{line:25,column:17}},line:23},"5":{name:"(anonymous_5)",decl:{start:{line:30,column:4},end:{line:30,column:5}},loc:{start:{line:30,column:24},end:{line:35,column:5}},line:30},"6":{name:"(anonymous_6)",decl:{start:{line:37,column:4},end:{line:37,column:5}},loc:{start:{line:37,column:25},end:{line:52,column:5}},line:37}},branchMap:{"0":{loc:{start:{line:7,column:18},end:{line:7,column:27}},type:"default-arg",locations:[{start:{line:7,column:25},end:{line:7,column:27}}],line:7},"1":{loc:{start:{line:7,column:29},end:{line:7,column:41}},type:"default-arg",locations:[{start:{line:7,column:39},end:{line:7,column:41}}],line:7},"2":{loc:{start:{line:22,column:12},end:{line:26,column:13}},type:"if",locations:[{start:{line:22,column:12},end:{line:26,column:13}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:22}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0},b:{"0":[0],"1":[0],"2":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/requestLoginCodeOnTelephone.js"],sourcesContent:["import { Frame, notCommon } from \"not-bulma\";\nconst { notForm } = Frame;\n\nimport ValidatorsLib from \"../../common/validators.js\";\n\nexport default class RequestLoginCodeOnTelephone extends notForm {\n    constructor({ data = {}, options = {} }) {\n        options.action = \"requestLoginCodeOnTelephone\";\n        options.model = \"user\";\n        super({\n            name: \"RequestLoginCodeOnTelephone\",\n            options,\n            data,\n        });\n        //events after user button actions\n        this.on(\"submit\", (e) => this.onSubmit(e));\n        this.on(\"reject\", () => {\n            location.href = \"/\";\n            location.reload();\n        });\n        this.on(\"success\", () => {\n            if (this.getOptions(\"changeMode\")) {\n                setTimeout(() => {\n                    this.getOptions(\"changeMode\")(\"loginByCode\");\n                }, 1000);\n            }\n        });\n    }\n\n    getFormValidators() {\n        return notCommon\n            .getApp()\n            .getService(\"nsUser\")\n            .augmentValidators(ValidatorsLib);\n    }\n\n    async onSubmit(data) {\n        try {\n            this.setLoading();\n            const result = await this.getModel(\"user\", data)[\n                `$${this.getFormAction()}`\n            ]();\n            //maybe error or success\n            this.processResult(result);\n        } catch (e) {\n            //if exactly error\n            this.processResult(e);\n        } finally {\n            //should unlock UI anyway\n            this.resetLoading();\n        }\n    }\n}\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"2dd18b17568ec911d6af654646f283cb31eb5da5"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_qt0d18gox=function(){return actualCoverage;};}return actualCoverage;}cov_qt0d18gox();const{notForm: notForm$2}=(cov_qt0d18gox().s[0]++,Frame);class RequestLoginCodeOnTelephone extends notForm$2{constructor({data=(cov_qt0d18gox().b[0][0]++,{}),options=(cov_qt0d18gox().b[1][0]++,{})}){cov_qt0d18gox().f[0]++;cov_qt0d18gox().s[1]++;options.action="requestLoginCodeOnTelephone";cov_qt0d18gox().s[2]++;options.model="user";cov_qt0d18gox().s[3]++;super({name:"RequestLoginCodeOnTelephone",options,data});//events after user button actions
	cov_qt0d18gox().s[4]++;this.on("submit",e=>{cov_qt0d18gox().f[1]++;cov_qt0d18gox().s[5]++;return this.onSubmit(e);});cov_qt0d18gox().s[6]++;this.on("reject",()=>{cov_qt0d18gox().f[2]++;cov_qt0d18gox().s[7]++;location.href="/";cov_qt0d18gox().s[8]++;location.reload();});cov_qt0d18gox().s[9]++;this.on("success",()=>{cov_qt0d18gox().f[3]++;cov_qt0d18gox().s[10]++;if(this.getOptions("changeMode")){cov_qt0d18gox().b[2][0]++;cov_qt0d18gox().s[11]++;setTimeout(()=>{cov_qt0d18gox().f[4]++;cov_qt0d18gox().s[12]++;this.getOptions("changeMode")("loginByCode");},1000);}else {cov_qt0d18gox().b[2][1]++;}});}getFormValidators(){cov_qt0d18gox().f[5]++;cov_qt0d18gox().s[13]++;return notCommon$1.getApp().getService("nsUser").augmentValidators(Validators);}async onSubmit(data){cov_qt0d18gox().f[6]++;cov_qt0d18gox().s[14]++;try{cov_qt0d18gox().s[15]++;this.setLoading();const result=(cov_qt0d18gox().s[16]++,await this.getModel("user",data)[`$${this.getFormAction()}`]());//maybe error or success
	cov_qt0d18gox().s[17]++;this.processResult(result);}catch(e){cov_qt0d18gox().s[18]++;//if exactly error
	this.processResult(e);}finally{cov_qt0d18gox().s[19]++;//should unlock UI anyway
	this.resetLoading();}}}

	function cov_1fcox07t0t(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/requestLoginCodeOnEmail.js";var hash="69e95155298e6affcc1db8effd430ee0ef813051";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/requestLoginCodeOnEmail.js",statementMap:{"0":{start:{line:2,column:20},end:{line:2,column:25}},"1":{start:{line:8,column:8},end:{line:8,column:51}},"2":{start:{line:9,column:8},end:{line:9,column:31}},"3":{start:{line:10,column:8},end:{line:14,column:11}},"4":{start:{line:16,column:8},end:{line:16,column:51}},"5":{start:{line:16,column:33},end:{line:16,column:49}},"6":{start:{line:17,column:8},end:{line:20,column:11}},"7":{start:{line:18,column:12},end:{line:18,column:32}},"8":{start:{line:19,column:12},end:{line:19,column:30}},"9":{start:{line:21,column:8},end:{line:27,column:11}},"10":{start:{line:22,column:12},end:{line:26,column:13}},"11":{start:{line:23,column:16},end:{line:25,column:25}},"12":{start:{line:24,column:20},end:{line:24,column:65}},"13":{start:{line:31,column:8},end:{line:34,column:46}},"14":{start:{line:38,column:8},end:{line:51,column:9}},"15":{start:{line:39,column:12},end:{line:39,column:30}},"16":{start:{line:40,column:27},end:{line:42,column:15}},"17":{start:{line:44,column:12},end:{line:44,column:39}},"18":{start:{line:47,column:12},end:{line:47,column:34}},"19":{start:{line:50,column:12},end:{line:50,column:32}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:7,column:4},end:{line:7,column:5}},loc:{start:{line:7,column:45},end:{line:28,column:5}},line:7},"1":{name:"(anonymous_1)",decl:{start:{line:16,column:26},end:{line:16,column:27}},loc:{start:{line:16,column:33},end:{line:16,column:49}},line:16},"2":{name:"(anonymous_2)",decl:{start:{line:17,column:26},end:{line:17,column:27}},loc:{start:{line:17,column:32},end:{line:20,column:9}},line:17},"3":{name:"(anonymous_3)",decl:{start:{line:21,column:27},end:{line:21,column:28}},loc:{start:{line:21,column:33},end:{line:27,column:9}},line:21},"4":{name:"(anonymous_4)",decl:{start:{line:23,column:27},end:{line:23,column:28}},loc:{start:{line:23,column:33},end:{line:25,column:17}},line:23},"5":{name:"(anonymous_5)",decl:{start:{line:30,column:4},end:{line:30,column:5}},loc:{start:{line:30,column:24},end:{line:35,column:5}},line:30},"6":{name:"(anonymous_6)",decl:{start:{line:37,column:4},end:{line:37,column:5}},loc:{start:{line:37,column:25},end:{line:52,column:5}},line:37}},branchMap:{"0":{loc:{start:{line:7,column:18},end:{line:7,column:27}},type:"default-arg",locations:[{start:{line:7,column:25},end:{line:7,column:27}}],line:7},"1":{loc:{start:{line:7,column:29},end:{line:7,column:41}},type:"default-arg",locations:[{start:{line:7,column:39},end:{line:7,column:41}}],line:7},"2":{loc:{start:{line:22,column:12},end:{line:26,column:13}},type:"if",locations:[{start:{line:22,column:12},end:{line:26,column:13}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:22}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0},b:{"0":[0],"1":[0],"2":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/requestLoginCodeOnEmail.js"],sourcesContent:["import { Frame, notCommon } from \"not-bulma\";\nconst { notForm } = Frame;\n\nimport ValidatorsLib from \"../../common/validators.js\";\n\nexport default class RequestLoginCodeOnEmailForm extends notForm {\n    constructor({ data = {}, options = {} }) {\n        options.action = \"requestLoginCodeOnEmail\";\n        options.model = \"user\";\n        super({\n            name: \"RequestLoginCodeOnEmail\",\n            options,\n            data,\n        });\n        //events after user button actions\n        this.on(\"submit\", (e) => this.onSubmit(e));\n        this.on(\"reject\", () => {\n            location.href = \"/\";\n            location.reload();\n        });\n        this.on(\"success\", () => {\n            if (this.getOptions(\"changeMode\")) {\n                setTimeout(() => {\n                    this.getOptions(\"changeMode\")(\"loginByCode\");\n                }, 1000);\n            }\n        });\n    }\n\n    getFormValidators() {\n        return notCommon\n            .getApp()\n            .getService(\"nsUser\")\n            .augmentValidators(ValidatorsLib);\n    }\n\n    async onSubmit(data) {\n        try {\n            this.setLoading();\n            const result = await this.getModel(\"user\", data)[\n                `$${this.getFormAction()}`\n            ]();\n            //maybe error or success\n            this.processResult(result);\n        } catch (e) {\n            //if exactly error\n            this.processResult(e);\n        } finally {\n            //should unlock UI anyway\n            this.resetLoading();\n        }\n    }\n}\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"69e95155298e6affcc1db8effd430ee0ef813051"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1fcox07t0t=function(){return actualCoverage;};}return actualCoverage;}cov_1fcox07t0t();const{notForm: notForm$1}=(cov_1fcox07t0t().s[0]++,Frame);class RequestLoginCodeOnEmailForm extends notForm$1{constructor({data=(cov_1fcox07t0t().b[0][0]++,{}),options=(cov_1fcox07t0t().b[1][0]++,{})}){cov_1fcox07t0t().f[0]++;cov_1fcox07t0t().s[1]++;options.action="requestLoginCodeOnEmail";cov_1fcox07t0t().s[2]++;options.model="user";cov_1fcox07t0t().s[3]++;super({name:"RequestLoginCodeOnEmail",options,data});//events after user button actions
	cov_1fcox07t0t().s[4]++;this.on("submit",e=>{cov_1fcox07t0t().f[1]++;cov_1fcox07t0t().s[5]++;return this.onSubmit(e);});cov_1fcox07t0t().s[6]++;this.on("reject",()=>{cov_1fcox07t0t().f[2]++;cov_1fcox07t0t().s[7]++;location.href="/";cov_1fcox07t0t().s[8]++;location.reload();});cov_1fcox07t0t().s[9]++;this.on("success",()=>{cov_1fcox07t0t().f[3]++;cov_1fcox07t0t().s[10]++;if(this.getOptions("changeMode")){cov_1fcox07t0t().b[2][0]++;cov_1fcox07t0t().s[11]++;setTimeout(()=>{cov_1fcox07t0t().f[4]++;cov_1fcox07t0t().s[12]++;this.getOptions("changeMode")("loginByCode");},1000);}else {cov_1fcox07t0t().b[2][1]++;}});}getFormValidators(){cov_1fcox07t0t().f[5]++;cov_1fcox07t0t().s[13]++;return notCommon$1.getApp().getService("nsUser").augmentValidators(Validators);}async onSubmit(data){cov_1fcox07t0t().f[6]++;cov_1fcox07t0t().s[14]++;try{cov_1fcox07t0t().s[15]++;this.setLoading();const result=(cov_1fcox07t0t().s[16]++,await this.getModel("user",data)[`$${this.getFormAction()}`]());//maybe error or success
	cov_1fcox07t0t().s[17]++;this.processResult(result);}catch(e){cov_1fcox07t0t().s[18]++;//if exactly error
	this.processResult(e);}finally{cov_1fcox07t0t().s[19]++;//should unlock UI anyway
	this.resetLoading();}}}

	function cov_2lwsr40uqt(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/guest/ncLogin.js";var hash="35bee47210f8049777e462dfee3cf53820307b16";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/guest/ncLogin.js",statementMap:{"0":{start:{line:8,column:30},end:{line:13,column:1}},"1":{start:{line:15,column:14},end:{line:36,column:1}},"2":{start:{line:40,column:8},end:{line:44,column:11}},"3":{start:{line:48,column:8},end:{line:50,column:10}},"4":{start:{line:54,column:8},end:{line:54,column:24}},"5":{start:{line:58,column:32},end:{line:58,column:53}},"6":{start:{line:59,column:41},end:{line:61,column:30}},"7":{start:{line:62,column:8},end:{line:64,column:9}},"8":{start:{line:63,column:12},end:{line:63,column:57}},"9":{start:{line:65,column:8},end:{line:65,column:75}},"10":{start:{line:65,column:37},end:{line:65,column:73}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:39,column:4},end:{line:39,column:5}},loc:{start:{line:39,column:21},end:{line:45,column:5}},line:39},"1":{name:"(anonymous_1)",decl:{start:{line:47,column:4},end:{line:47,column:5}},loc:{start:{line:47,column:25},end:{line:51,column:5}},line:47},"2":{name:"(anonymous_2)",decl:{start:{line:53,column:4},end:{line:53,column:5}},loc:{start:{line:53,column:17},end:{line:55,column:5}},line:53},"3":{name:"(anonymous_3)",decl:{start:{line:57,column:4},end:{line:57,column:5}},loc:{start:{line:57,column:18},end:{line:66,column:5}},line:57},"4":{name:"(anonymous_4)",decl:{start:{line:65,column:28},end:{line:65,column:29}},loc:{start:{line:65,column:37},end:{line:65,column:73}},line:65}},branchMap:{"0":{loc:{start:{line:62,column:8},end:{line:64,column:9}},type:"if",locations:[{start:{line:62,column:8},end:{line:64,column:9}},{start:{line:undefined,column:undefined},end:{line:undefined,column:undefined}}],line:62}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0},b:{"0":[0,0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/guest/ncLogin.js"],sourcesContent:["import ncFormFrame from \"./ncFormFrame.js\";\n\nimport LoginForm from \"./forms/login.js\";\nimport LoginByCodeForm from \"./forms/loginByCode.js\";\nimport RequestLoginCodeOnTelephoneForm from \"./forms/requestLoginCodeOnTelephone.js\";\nimport RequestLoginCodeOnEmailForm from \"./forms/requestLoginCodeOnEmail.js\";\n\nconst DEFAULT_LOGIN_OPTIONS = [\n    \"login\",\n    \"requestLoginCodeOnEmail\",\n    \"requestLoginCodeOnTelephone\",\n    \"loginByCode\",\n];\n\nconst FORMS = [\n    {\n        mode: \"login\",\n        title: \"not-user:form_mode_login_label\",\n        form: LoginForm,\n    },\n    {\n        mode: \"requestLoginCodeOnEmail\",\n        title: \"not-user:form_mode_requestLoginCodeOnEmail_label\",\n        form: RequestLoginCodeOnEmailForm,\n    },\n    {\n        mode: \"requestLoginCodeOnTelephone\",\n        title: \"not-user:form_mode_requestLoginCodeOnTelephone_label\",\n        form: RequestLoginCodeOnTelephoneForm,\n    },\n    {\n        mode: \"loginByCode\",\n        title: \"not-user:form_mode_loginByCode_label\",\n        form: LoginByCodeForm,\n    },\n];\n\nclass ncLogin extends ncFormFrame {\n    constructor(app) {\n        super({\n            app,\n            name: \"Login\",\n            mode: \"login\",\n        });\n    }\n\n    getTargetContainer() {\n        return document.querySelector(\n            this.app.getOptions(\"modules.user.loginFormContainerSelector\")\n        );\n    }\n\n    getMainURL() {\n        return \"/login\";\n    }\n\n    getFormsSet() {\n        let enabledLoginModes = DEFAULT_LOGIN_OPTIONS;\n        const enabledLoginModesOptions = this.app\n            .getConfigReaderForModule(\"user\")\n            .get(\"loginModes\");\n        if (enabledLoginModesOptions) {\n            enabledLoginModes = enabledLoginModesOptions;\n        }\n        return FORMS.filter((itm) => enabledLoginModes.includes(itm.mode));\n    }\n}\n\nexport default ncLogin;\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7E;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3E,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;AACD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"35bee47210f8049777e462dfee3cf53820307b16"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_2lwsr40uqt=function(){return actualCoverage;};}return actualCoverage;}cov_2lwsr40uqt();const DEFAULT_LOGIN_OPTIONS=(cov_2lwsr40uqt().s[0]++,["login","requestLoginCodeOnEmail","requestLoginCodeOnTelephone","loginByCode"]);const FORMS$1=(cov_2lwsr40uqt().s[1]++,[{mode:"login",title:"not-user:form_mode_login_label",form:LoginForm$1},{mode:"requestLoginCodeOnEmail",title:"not-user:form_mode_requestLoginCodeOnEmail_label",form:RequestLoginCodeOnEmailForm},{mode:"requestLoginCodeOnTelephone",title:"not-user:form_mode_requestLoginCodeOnTelephone_label",form:RequestLoginCodeOnTelephone},{mode:"loginByCode",title:"not-user:form_mode_loginByCode_label",form:LoginForm}]);class ncLogin extends ncFormFrame{constructor(app){cov_2lwsr40uqt().f[0]++;cov_2lwsr40uqt().s[2]++;super({app,name:"Login",mode:"login"});}getTargetContainer(){cov_2lwsr40uqt().f[1]++;cov_2lwsr40uqt().s[3]++;return document.querySelector(this.app.getOptions("modules.user.loginFormContainerSelector"));}getMainURL(){cov_2lwsr40uqt().f[2]++;cov_2lwsr40uqt().s[4]++;return "/login";}getFormsSet(){cov_2lwsr40uqt().f[3]++;let enabledLoginModes=(cov_2lwsr40uqt().s[5]++,DEFAULT_LOGIN_OPTIONS);const enabledLoginModesOptions=(cov_2lwsr40uqt().s[6]++,this.app.getConfigReaderForModule("user").get("loginModes"));cov_2lwsr40uqt().s[7]++;if(enabledLoginModesOptions){cov_2lwsr40uqt().b[0][0]++;cov_2lwsr40uqt().s[8]++;enabledLoginModes=enabledLoginModesOptions;}else {cov_2lwsr40uqt().b[0][1]++;}cov_2lwsr40uqt().s[9]++;return FORMS$1.filter(itm=>{cov_2lwsr40uqt().f[4]++;cov_2lwsr40uqt().s[10]++;return enabledLoginModes.includes(itm.mode);});}}

	function cov_2koxxzhvfd(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/register.js";var hash="a8e1fd58721a073798279f50ba0be9d13b809269";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/register.js",statementMap:{"0":{start:{line:2,column:20},end:{line:2,column:25}},"1":{start:{line:8,column:8},end:{line:8,column:36}},"2":{start:{line:9,column:8},end:{line:9,column:31}},"3":{start:{line:10,column:8},end:{line:14,column:11}},"4":{start:{line:16,column:8},end:{line:16,column:51}},"5":{start:{line:16,column:33},end:{line:16,column:49}},"6":{start:{line:17,column:8},end:{line:19,column:11}},"7":{start:{line:18,column:12},end:{line:18,column:32}},"8":{start:{line:20,column:8},end:{line:23,column:11}},"9":{start:{line:21,column:12},end:{line:21,column:41}},"10":{start:{line:22,column:12},end:{line:22,column:30}},"11":{start:{line:27,column:8},end:{line:30,column:46}},"12":{start:{line:34,column:8},end:{line:47,column:9}},"13":{start:{line:35,column:12},end:{line:35,column:30}},"14":{start:{line:36,column:27},end:{line:38,column:15}},"15":{start:{line:40,column:12},end:{line:40,column:39}},"16":{start:{line:43,column:12},end:{line:43,column:34}},"17":{start:{line:46,column:12},end:{line:46,column:32}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:7,column:4},end:{line:7,column:5}},loc:{start:{line:7,column:45},end:{line:24,column:5}},line:7},"1":{name:"(anonymous_1)",decl:{start:{line:16,column:26},end:{line:16,column:27}},loc:{start:{line:16,column:33},end:{line:16,column:49}},line:16},"2":{name:"(anonymous_2)",decl:{start:{line:17,column:26},end:{line:17,column:27}},loc:{start:{line:17,column:32},end:{line:19,column:9}},line:17},"3":{name:"(anonymous_3)",decl:{start:{line:20,column:27},end:{line:20,column:28}},loc:{start:{line:20,column:33},end:{line:23,column:9}},line:20},"4":{name:"(anonymous_4)",decl:{start:{line:26,column:4},end:{line:26,column:5}},loc:{start:{line:26,column:24},end:{line:31,column:5}},line:26},"5":{name:"(anonymous_5)",decl:{start:{line:33,column:4},end:{line:33,column:5}},loc:{start:{line:33,column:25},end:{line:48,column:5}},line:33}},branchMap:{"0":{loc:{start:{line:7,column:18},end:{line:7,column:27}},type:"default-arg",locations:[{start:{line:7,column:25},end:{line:7,column:27}}],line:7},"1":{loc:{start:{line:7,column:29},end:{line:7,column:41}},type:"default-arg",locations:[{start:{line:7,column:39},end:{line:7,column:41}}],line:7}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0},b:{"0":[0],"1":[0]},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/guest/forms/register.js"],sourcesContent:["import { Frame, notCommon } from \"not-bulma\";\nconst { notForm } = Frame;\n\nimport ValidatorsLib from \"../../common/validators.js\";\n\nexport default class RegisterForm extends notForm {\n    constructor({ data = {}, options = {} }) {\n        options.action = \"register\";\n        options.model = \"user\";\n        super({\n            name: \"Register\",\n            options,\n            data,\n        });\n        //events after user button actions\n        this.on(\"submit\", (e) => this.onSubmit(e));\n        this.on(\"reject\", () => {\n            location.href = \"/\";\n        });\n        this.on(\"success\", () => {\n            location.href = \"/dashboard\";\n            location.reload();\n        });\n    }\n\n    getFormValidators() {\n        return notCommon\n            .getApp()\n            .getService(\"nsUser\")\n            .augmentValidators(ValidatorsLib);\n    }\n\n    async onSubmit(data) {\n        try {\n            this.setLoading();\n            const result = await this.getModel(\"user\", data)[\n                `$${this.getFormAction()}`\n            ]();\n            //maybe error or success\n            this.processResult(result);\n        } catch (e) {\n            //if exactly error\n            this.processResult(e);\n        } finally {\n            //should unlock UI anyway\n            this.resetLoading();\n        }\n    }\n}\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"a8e1fd58721a073798279f50ba0be9d13b809269"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_2koxxzhvfd=function(){return actualCoverage;};}return actualCoverage;}cov_2koxxzhvfd();const{notForm}=(cov_2koxxzhvfd().s[0]++,Frame);class RegisterForm extends notForm{constructor({data=(cov_2koxxzhvfd().b[0][0]++,{}),options=(cov_2koxxzhvfd().b[1][0]++,{})}){cov_2koxxzhvfd().f[0]++;cov_2koxxzhvfd().s[1]++;options.action="register";cov_2koxxzhvfd().s[2]++;options.model="user";cov_2koxxzhvfd().s[3]++;super({name:"Register",options,data});//events after user button actions
	cov_2koxxzhvfd().s[4]++;this.on("submit",e=>{cov_2koxxzhvfd().f[1]++;cov_2koxxzhvfd().s[5]++;return this.onSubmit(e);});cov_2koxxzhvfd().s[6]++;this.on("reject",()=>{cov_2koxxzhvfd().f[2]++;cov_2koxxzhvfd().s[7]++;location.href="/";});cov_2koxxzhvfd().s[8]++;this.on("success",()=>{cov_2koxxzhvfd().f[3]++;cov_2koxxzhvfd().s[9]++;location.href="/dashboard";cov_2koxxzhvfd().s[10]++;location.reload();});}getFormValidators(){cov_2koxxzhvfd().f[4]++;cov_2koxxzhvfd().s[11]++;return notCommon$1.getApp().getService("nsUser").augmentValidators(Validators);}async onSubmit(data){cov_2koxxzhvfd().f[5]++;cov_2koxxzhvfd().s[12]++;try{cov_2koxxzhvfd().s[13]++;this.setLoading();const result=(cov_2koxxzhvfd().s[14]++,await this.getModel("user",data)[`$${this.getFormAction()}`]());//maybe error or success
	cov_2koxxzhvfd().s[15]++;this.processResult(result);}catch(e){cov_2koxxzhvfd().s[16]++;//if exactly error
	this.processResult(e);}finally{cov_2koxxzhvfd().s[17]++;//should unlock UI anyway
	this.resetLoading();}}}

	function cov_1skrz98lwz(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/guest/ncRegister.js";var hash="e87271989c7e1cd224ffd32d66f0e66edf071cc8";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/guest/ncRegister.js",statementMap:{"0":{start:{line:5,column:14},end:{line:11,column:1}},"1":{start:{line:15,column:8},end:{line:15,column:59}},"2":{start:{line:19,column:8},end:{line:21,column:10}},"3":{start:{line:25,column:8},end:{line:25,column:27}},"4":{start:{line:29,column:8},end:{line:29,column:21}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:14,column:4},end:{line:14,column:5}},loc:{start:{line:14,column:21},end:{line:16,column:5}},line:14},"1":{name:"(anonymous_1)",decl:{start:{line:18,column:4},end:{line:18,column:5}},loc:{start:{line:18,column:25},end:{line:22,column:5}},line:18},"2":{name:"(anonymous_2)",decl:{start:{line:24,column:4},end:{line:24,column:5}},loc:{start:{line:24,column:17},end:{line:26,column:5}},line:24},"3":{name:"(anonymous_3)",decl:{start:{line:28,column:4},end:{line:28,column:5}},loc:{start:{line:28,column:18},end:{line:30,column:5}},line:28}},branchMap:{},s:{"0":0,"1":0,"2":0,"3":0,"4":0},f:{"0":0,"1":0,"2":0,"3":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/guest/ncRegister.js"],sourcesContent:["import ncFormFrame from \"./ncFormFrame.js\";\n\nimport RegisterForm from \"./forms/register.js\";\n\nconst FORMS = [\n    {\n        mode: \"register\",\n        title: \"not-user:form_mode_register_label\",\n        form: RegisterForm,\n    },\n];\n\nclass ncRegister extends ncFormFrame {\n    constructor(app) {\n        super({ app, name: \"Register\", mode: \"register\" });\n    }\n\n    getTargetContainer() {\n        return document.querySelector(\n            this.app.getOptions(\"modules.user.registerFormContainerSelector\")\n        );\n    }\n\n    getMainURL() {\n        return \"/register\";\n    }\n\n    getFormsSet() {\n        return FORMS;\n    }\n}\n\nexport default ncRegister;\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/C;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3D,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC;AACD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"e87271989c7e1cd224ffd32d66f0e66edf071cc8"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1skrz98lwz=function(){return actualCoverage;};}return actualCoverage;}cov_1skrz98lwz();const FORMS=(cov_1skrz98lwz().s[0]++,[{mode:"register",title:"not-user:form_mode_register_label",form:RegisterForm}]);class ncRegister extends ncFormFrame{constructor(app){cov_1skrz98lwz().f[0]++;cov_1skrz98lwz().s[1]++;super({app,name:"Register",mode:"register"});}getTargetContainer(){cov_1skrz98lwz().f[1]++;cov_1skrz98lwz().s[2]++;return document.querySelector(this.app.getOptions("modules.user.registerFormContainerSelector"));}getMainURL(){cov_1skrz98lwz().f[2]++;cov_1skrz98lwz().s[3]++;return "/register";}getFormsSet(){cov_1skrz98lwz().f[3]++;cov_1skrz98lwz().s[4]++;return FORMS;}}

	function cov_1asse6z0ir(){var path="/home/cypher/proj/not-lib/not-user/src/controllers/guest/index.js";var hash="77eb3ca8b2fc7620b7c907d0f1a75ce96ebaae06";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/src/controllers/guest/index.js",statementMap:{"0":{start:{line:4,column:15},end:{line:17,column:1}}},fnMap:{},branchMap:{},s:{"0":0},f:{},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/src/controllers/guest/index.js"],sourcesContent:["import ncLogin from \"./ncLogin.js\";\nimport ncRegister from \"./ncRegister.js\";\n\nlet manifest = {\n    router: {\n        manifest: [\n            {\n                paths: [\"login\"],\n                controller: ncLogin,\n            },\n            {\n                paths: [\"register\"],\n                controller: ncRegister,\n            },\n        ],\n    },\n};\n\nexport { ncLogin, ncRegister, manifest };\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"77eb3ca8b2fc7620b7c907d0f1a75ce96ebaae06"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_1asse6z0ir=function(){return actualCoverage;};}return actualCoverage;}cov_1asse6z0ir();let manifest$1=(cov_1asse6z0ir().s[0]++,{router:{manifest:[{paths:["login"],controller:ncLogin},{paths:["register"],controller:ncRegister}]}});

	var notUserGuest = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$1,
		ncLogin: ncLogin,
		ncRegister: ncRegister
	});

	function cov_2f7ih0z481(){var path="/home/cypher/proj/not-lib/not-user/test/testapp/front/src/guest/main/index.js";var hash="1a062bfbc3332273e027004282714ddbe42cf235";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/test/testapp/front/src/guest/main/index.js",statementMap:{"0":{start:{line:4,column:15},end:{line:4,column:17}},"1":{start:{line:5,column:10},end:{line:5,column:12}},"2":{start:{line:6,column:10},end:{line:6,column:12}},"3":{start:{line:7,column:13},end:{line:7,column:15}},"4":{start:{line:12,column:15},end:{line:52,column:1}},"5":{start:{line:54,column:0},end:{line:61,column:3}},"6":{start:{line:63,column:0},end:{line:70,column:3}}},fnMap:{},branchMap:{},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0},f:{},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/test/testapp/front/src/guest/main/index.js"],sourcesContent:["import ncInit from \"../../common/ncInit\";\nimport { notCommon } from \"not-bulma\";\n\nlet services = {},\n    uis = {},\n    wsc = {},\n    fields = {};\n\nimport * as notUserCommon from \"../../../../../../src/controllers/common/index\";\nimport * as notUserGuest from \"../../../../../../src/controllers/guest/index\";\n\nlet manifest = {\n    environment: \"guest\",\n    router: {\n        manifest: [],\n    },\n    crud: {\n        containerSelector: \".main-container\",\n    },\n    modules: {\n        user: {\n            loginFormContainerSelector: \".main-container\",\n            registerFormContainerSelector: \".main-container\",\n        },\n    },\n    initController: ncInit,\n    menu: {\n        top: {\n            toggleSelector: \".navbar-burger\",\n            sections: [],\n            items: [\n                {\n                    title: \"\u0412\u0445\u043E\u0434\",\n                    url: \"/login\",\n                    priority: 10,\n                    showOnTouch: true,\n                    type: \"button\",\n                    place: \"start\",\n                },\n                {\n                    id: \"register\",\n                    title: \"\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044F\",\n                    url: \"/register\",\n                    type: \"button\",\n                    priority: 11,\n                    showOnTouch: true,\n                    place: \"start\",\n                },\n            ],\n        },\n    },\n};\n\nmanifest = notCommon.absorbModule({\n    defaultConf: manifest,\n    mod: notUserCommon,\n    services,\n    uis,\n    wsc,\n    fields,\n});\n\nmanifest = notCommon.absorbModule({\n    defaultConf: manifest,\n    mod: notUserGuest,\n    services,\n    uis,\n    wsc,\n    fields,\n});\n\nexport { ncInit, manifest, services, uis, wsc, fields };\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9E;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"1a062bfbc3332273e027004282714ddbe42cf235"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_2f7ih0z481=function(){return actualCoverage;};}return actualCoverage;}cov_2f7ih0z481();let services$1=(cov_2f7ih0z481().s[0]++,{}),uis$1=(cov_2f7ih0z481().s[1]++,{}),wsc$1=(cov_2f7ih0z481().s[2]++,{}),fields$1=(cov_2f7ih0z481().s[3]++,{});let manifest=(cov_2f7ih0z481().s[4]++,{environment:"guest",router:{manifest:[]},crud:{containerSelector:".main-container"},modules:{user:{loginFormContainerSelector:".main-container",registerFormContainerSelector:".main-container"}},initController:ncInit,menu:{top:{toggleSelector:".navbar-burger",sections:[],items:[{title:"Вход",url:"/login",priority:10,showOnTouch:true,type:"button",place:"start"},{id:"register",title:"Регистрация",url:"/register",type:"button",priority:11,showOnTouch:true,place:"start"}]}}});cov_2f7ih0z481().s[5]++;manifest=notCommon$1.absorbModule({defaultConf:manifest,mod:notUserCommon,services: services$1,uis: uis$1,wsc: wsc$1,fields: fields$1});cov_2f7ih0z481().s[6]++;manifest=notCommon$1.absorbModule({defaultConf:manifest,mod:notUserGuest,services: services$1,uis: uis$1,wsc: wsc$1,fields: fields$1});

	var mod_8 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		fields: fields$1,
		get manifest () { return manifest; },
		ncInit: ncInit,
		services: services$1,
		uis: uis$1,
		wsc: wsc$1
	});

	function cov_2bb3n6h2bq(){var path="/home/cypher/proj/not-lib/not-user/test/testapp/front/tmpl/index.guest.mjs";var hash="2884a3d8bb43fe5e3b7a80974653b4f5cafd630b";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/home/cypher/proj/not-lib/not-user/test/testapp/front/tmpl/index.guest.mjs",statementMap:{"0":{start:{line:5,column:0},end:{line:5,column:55}},"1":{start:{line:7,column:40},end:{line:7,column:45}},"2":{start:{line:9,column:0},end:{line:9,column:36}},"3":{start:{line:11,column:0},end:{line:11,column:59}},"4":{start:{line:15,column:0},end:{line:17,column:9}},"5":{start:{line:16,column:2},end:{line:16,column:35}},"6":{start:{line:21,column:24},end:{line:61,column:1}},"7":{start:{line:63,column:15},end:{line:63,column:17}},"8":{start:{line:63,column:25},end:{line:63,column:27}},"9":{start:{line:63,column:35},end:{line:63,column:37}},"10":{start:{line:63,column:48},end:{line:63,column:50}},"11":{start:{line:68,column:0},end:{line:72,column:3}},"12":{start:{line:76,column:0},end:{line:80,column:3}},"13":{start:{line:84,column:0},end:{line:88,column:3}},"14":{start:{line:92,column:0},end:{line:96,column:3}},"15":{start:{line:100,column:0},end:{line:104,column:3}},"16":{start:{line:108,column:0},end:{line:112,column:3}},"17":{start:{line:116,column:0},end:{line:120,column:3}},"18":{start:{line:124,column:0},end:{line:128,column:3}},"19":{start:{line:132,column:0},end:{line:136,column:3}},"20":{start:{line:139,column:0},end:{line:139,column:23}},"21":{start:{line:145,column:0},end:{line:145,column:38}},"22":{start:{line:146,column:0},end:{line:146,column:28}},"23":{start:{line:148,column:0},end:{line:148,column:56}},"24":{start:{line:148,column:25},end:{line:148,column:54}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:15,column:33},end:{line:15,column:34}},loc:{start:{line:15,column:40},end:{line:17,column:1}},line:15},"1":{name:"(anonymous_1)",decl:{start:{line:148,column:19},end:{line:148,column:20}},loc:{start:{line:148,column:25},end:{line:148,column:54}},line:148}},branchMap:{},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0},f:{"0":0,"1":0},b:{},inputSourceMap:{version:3,sources:["/home/cypher/proj/not-lib/not-user/test/testapp/front/tmpl/index.guest.mjs"],sourcesContent:["import {\n  Frame\n} from 'not-bulma';\n\nwindow.NOT_NODE_ERROR_URL_BROWSER = '/api/key/collect';\n\nconst {notCommon, notApp, COMPONENTS} = Frame;\n\nnotCommon.register('backlog', true);\n\nwindow.dumpBacklog = notCommon.dumpBacklog.bind(notCommon);\n\nimport notErrorReporter from 'not-error/src/reporter.browser.mjs';\n\nwindow.addEventListener('error', (e) => {\n  new notErrorReporter().report(e);\n}, true);\n\n\n//\u0411\u0430\u0437\u043E\u0432\u044B\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438\nlet appDefaultOptions = {\n  //url from which will take interfaceManifest json file\n  manifestURL: '/api/manifest',\n  //routes for client-side\n  router: {\n    root: '/',\n    manifest: [],\n    index: ''\n  },\n  language: 'ru',\n  crud: {\n    navigateBackAfter: ['create', 'update', 'delete']\n  },\n  modules: {\n    user: {\n      redirectTimout: 1000,\n      afterLoginURL: '/dashboard',\n      loginModes: [\n          'login',\n          'requestLoginCodeOnEmail',\n          'loginByCode'\n      ],\n      colorsOfRoles: {\n        //style_color_name:[string]\n        primary:{\n          danger: ['guest'],\n          warning: ['user'],\n          link: ['client'],        \n          success: ['admin'],\n          primary: ['root'],\n        },\n        secondary: {\n          info: ['confirmed', 'manager', 'hr', 'logist'],          \n        }        \n      },\n      loginFormContainerSelector: '.main-container',\n      restoreFormContainerSelector: '.main-container',\n      registerFormContainerSelector: '.main-container'\n    }\n  }\n};\n\nlet services = {}, uis = {}, wsc = {}, fields = {};\n\n\nimport * as mod_0\nfrom '/home/cypher/proj/not-lib/not-user/node_modules/not-options/src/controllers/common';\nappDefaultOptions = notCommon.absorbModule({\n  defaultConf: appDefaultOptions,\n  mod: mod_0,\n  services, uis, wsc, fields\n});\n\nimport * as mod_1\nfrom '/home/cypher/proj/not-lib/not-user/node_modules/not-filter/src/controllers/common';\nappDefaultOptions = notCommon.absorbModule({\n  defaultConf: appDefaultOptions,\n  mod: mod_1,\n  services, uis, wsc, fields\n});\n\nimport * as mod_2\nfrom '/home/cypher/proj/not-lib/not-user/node_modules/not-notification/src/controllers/guest';\nappDefaultOptions = notCommon.absorbModule({\n  defaultConf: appDefaultOptions,\n  mod: mod_2,\n  services, uis, wsc, fields\n});\n\nimport * as mod_3\nfrom '/home/cypher/proj/not-lib/not-user/node_modules/not-locale/src/controllers/common';\nappDefaultOptions = notCommon.absorbModule({\n  defaultConf: appDefaultOptions,\n  mod: mod_3,\n  services, uis, wsc, fields\n});\n\nimport * as mod_4\nfrom '/home/cypher/proj/not-lib/not-user/node_modules/not-key/src/controllers/common';\nappDefaultOptions = notCommon.absorbModule({\n  defaultConf: appDefaultOptions,\n  mod: mod_4,\n  services, uis, wsc, fields\n});\n\nimport * as mod_5\nfrom '/home/cypher/proj/not-lib/not-user/node_modules/not-error/src/controllers/common';\nappDefaultOptions = notCommon.absorbModule({\n  defaultConf: appDefaultOptions,\n  mod: mod_5,\n  services, uis, wsc, fields\n});\n\nimport * as mod_6\nfrom '/home/cypher/proj/not-lib/not-user/node_modules/not-ws/src/controllers/common';\nappDefaultOptions = notCommon.absorbModule({\n  defaultConf: appDefaultOptions,\n  mod: mod_6,\n  services, uis, wsc, fields\n});\n\nimport * as mod_7\nfrom '/home/cypher/proj/not-lib/not-user/test/testapp/front/src/common';\nappDefaultOptions = notCommon.absorbModule({\n  defaultConf: appDefaultOptions,\n  mod: mod_7,\n  services, uis, wsc, fields\n});\n\nimport * as mod_8\nfrom '/home/cypher/proj/not-lib/not-user/test/testapp/front/src/guest/main';\nappDefaultOptions = notCommon.absorbModule({\n  defaultConf: appDefaultOptions,\n  mod: mod_8,\n  services, uis, wsc, fields\n});\n\n\nCOMPONENTS.import(uis);\n\nimport 'bulma';\n\n\n\nappDefaultOptions.services = services;\nappDefaultOptions.wsc = wsc;\n\nnotCommon.startApp(() => new notApp(appDefaultOptions));\n"],names:[],mappings:"AAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACP,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3D;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClE;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT;AACA;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC;AACJ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrD,CAAC,CAAC,CAAC,CAAC;AACJ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC,CAAC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AACH,CAAC,CAAC;AACF;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD;AACA;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1F,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9F,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AACH;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AACH;AACA;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACf;AACA;AACA;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;",file:undefined},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"2884a3d8bb43fe5e3b7a80974653b4f5cafd630b"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
	cov_2bb3n6h2bq=function(){return actualCoverage;};}return actualCoverage;}cov_2bb3n6h2bq();cov_2bb3n6h2bq().s[0]++;window.NOT_NODE_ERROR_URL_BROWSER='/api/key/collect';const{notCommon,notApp,COMPONENTS}=(cov_2bb3n6h2bq().s[1]++,Frame);cov_2bb3n6h2bq().s[2]++;notCommon.register('backlog',true);cov_2bb3n6h2bq().s[3]++;window.dumpBacklog=notCommon.dumpBacklog.bind(notCommon);cov_2bb3n6h2bq().s[4]++;window.addEventListener('error',e=>{cov_2bb3n6h2bq().f[0]++;cov_2bb3n6h2bq().s[5]++;new notErrorReporter().report(e);},true);//Базовые настройки
	let appDefaultOptions=(cov_2bb3n6h2bq().s[6]++,{//url from which will take interfaceManifest json file
	manifestURL:'/api/manifest',//routes for client-side
	router:{root:'/',manifest:[],index:''},language:'ru',crud:{navigateBackAfter:['create','update','delete']},modules:{user:{redirectTimout:1000,afterLoginURL:'/dashboard',loginModes:['login','requestLoginCodeOnEmail','loginByCode'],colorsOfRoles:{//style_color_name:[string]
	primary:{danger:['guest'],warning:['user'],link:['client'],success:['admin'],primary:['root']},secondary:{info:['confirmed','manager','hr','logist']}},loginFormContainerSelector:'.main-container',restoreFormContainerSelector:'.main-container',registerFormContainerSelector:'.main-container'}}});let services=(cov_2bb3n6h2bq().s[7]++,{}),uis=(cov_2bb3n6h2bq().s[8]++,{}),wsc=(cov_2bb3n6h2bq().s[9]++,{}),fields=(cov_2bb3n6h2bq().s[10]++,{});cov_2bb3n6h2bq().s[11]++;appDefaultOptions=notCommon.absorbModule({defaultConf:appDefaultOptions,mod:mod_0,services,uis,wsc,fields});cov_2bb3n6h2bq().s[12]++;appDefaultOptions=notCommon.absorbModule({defaultConf:appDefaultOptions,mod:mod_1,services,uis,wsc,fields});cov_2bb3n6h2bq().s[13]++;appDefaultOptions=notCommon.absorbModule({defaultConf:appDefaultOptions,mod:mod_2,services,uis,wsc,fields});cov_2bb3n6h2bq().s[14]++;appDefaultOptions=notCommon.absorbModule({defaultConf:appDefaultOptions,mod:mod_3,services,uis,wsc,fields});cov_2bb3n6h2bq().s[15]++;appDefaultOptions=notCommon.absorbModule({defaultConf:appDefaultOptions,mod:mod_4,services,uis,wsc,fields});cov_2bb3n6h2bq().s[16]++;appDefaultOptions=notCommon.absorbModule({defaultConf:appDefaultOptions,mod:mod_5,services,uis,wsc,fields});cov_2bb3n6h2bq().s[17]++;appDefaultOptions=notCommon.absorbModule({defaultConf:appDefaultOptions,mod:mod_6,services,uis,wsc,fields});cov_2bb3n6h2bq().s[18]++;appDefaultOptions=notCommon.absorbModule({defaultConf:appDefaultOptions,mod:mod_7,services,uis,wsc,fields});cov_2bb3n6h2bq().s[19]++;appDefaultOptions=notCommon.absorbModule({defaultConf:appDefaultOptions,mod:mod_8,services,uis,wsc,fields});cov_2bb3n6h2bq().s[20]++;COMPONENTS.import(uis);cov_2bb3n6h2bq().s[21]++;appDefaultOptions.services=services;cov_2bb3n6h2bq().s[22]++;appDefaultOptions.wsc=wsc;cov_2bb3n6h2bq().s[23]++;notCommon.startApp(()=>{cov_2bb3n6h2bq().f[1]++;cov_2bb3n6h2bq().s[24]++;return new notApp(appDefaultOptions);});

})();
