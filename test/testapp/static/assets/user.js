(function () {
	'use strict';

	/** @returns {void} */
	function noop$1() {}

	const identity = (x) => x;

	/**
	 * @template T
	 * @template S
	 * @param {T} tar
	 * @param {S} src
	 * @returns {T & S}
	 */
	function assign(tar, src) {
		// @ts-ignore
		for (const k in src) tar[k] = src[k];
		return /** @type {T & S} */ (tar);
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function run_all(fns) {
		fns.forEach(run);
	}

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	/** @returns {boolean} */
	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
	}

	let src_url_equal_anchor;

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
		if (element_src === url) return true;
		if (!src_url_equal_anchor) {
			src_url_equal_anchor = document.createElement('a');
		}
		// This is actually faster than doing URL(..).href
		src_url_equal_anchor.href = url;
		return element_src === src_url_equal_anchor.href;
	}

	/** @returns {boolean} */
	function is_empty(obj) {
		return Object.keys(obj).length === 0;
	}

	function subscribe(store, ...callbacks) {
		if (store == null) {
			for (const callback of callbacks) {
				callback(undefined);
			}
			return noop$1;
		}
		const unsub = store.subscribe(...callbacks);
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @returns {void} */
	function component_subscribe(component, store, callback) {
		component.$$.on_destroy.push(subscribe(store, callback));
	}

	function create_slot(definition, ctx, $$scope, fn) {
		if (definition) {
			const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
			return definition[0](slot_ctx);
		}
	}

	function get_slot_context(definition, ctx, $$scope, fn) {
		return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
	}

	function get_slot_changes(definition, $$scope, dirty, fn) {
		if (definition[2] && fn) {
			const lets = definition[2](fn(dirty));
			if ($$scope.dirty === undefined) {
				return lets;
			}
			if (typeof lets === 'object') {
				const merged = [];
				const len = Math.max($$scope.dirty.length, lets.length);
				for (let i = 0; i < len; i += 1) {
					merged[i] = $$scope.dirty[i] | lets[i];
				}
				return merged;
			}
			return $$scope.dirty | lets;
		}
		return $$scope.dirty;
	}

	/** @returns {void} */
	function update_slot_base(
		slot,
		slot_definition,
		ctx,
		$$scope,
		slot_changes,
		get_slot_context_fn
	) {
		if (slot_changes) {
			const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
			slot.p(slot_context, slot_changes);
		}
	}

	/** @returns {any[] | -1} */
	function get_all_dirty_from_scope($$scope) {
		if ($$scope.ctx.length > 32) {
			const dirty = [];
			const length = $$scope.ctx.length / 32;
			for (let i = 0; i < length; i++) {
				dirty[i] = -1;
			}
			return dirty;
		}
		return -1;
	}

	/** @returns {{}} */
	function exclude_internal_props(props) {
		const result = {};
		for (const k in props) if (k[0] !== '$') result[k] = props[k];
		return result;
	}

	/** @returns {{}} */
	function compute_rest_props(props, keys) {
		const rest = {};
		keys = new Set(keys);
		for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
		return rest;
	}

	function null_to_empty(value) {
		return value == null ? '' : value;
	}

	const is_client = typeof window !== 'undefined';

	/** @type {() => number} */
	let now = is_client ? () => window.performance.now() : () => Date.now();

	let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop$1;

	const tasks = new Set();

	/**
	 * @param {number} now
	 * @returns {void}
	 */
	function run_tasks(now) {
		tasks.forEach((task) => {
			if (!task.c(now)) {
				tasks.delete(task);
				task.f();
			}
		});
		if (tasks.size !== 0) raf(run_tasks);
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {import('./private.js').TaskCallback} callback
	 * @returns {import('./private.js').Task}
	 */
	function loop(callback) {
		/** @type {import('./private.js').TaskEntry} */
		let task;
		if (tasks.size === 0) raf(run_tasks);
		return {
			promise: new Promise((fulfill) => {
				tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				tasks.delete(task);
			}
		};
	}

	/** @type {typeof globalThis} */
	const globals =
		typeof window !== 'undefined'
			? window
			: typeof globalThis !== 'undefined'
			? globalThis
			: // @ts-ignore Node typings have this
			  global;

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append(target, node) {
		target.appendChild(node);
	}

	/**
	 * @param {Node} node
	 * @returns {ShadowRoot | Document}
	 */
	function get_root_for_style(node) {
		if (!node) return document;
		const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
		if (root && /** @type {ShadowRoot} */ (root).host) {
			return /** @type {ShadowRoot} */ (root);
		}
		return node.ownerDocument;
	}

	/**
	 * @param {Node} node
	 * @returns {CSSStyleSheet}
	 */
	function append_empty_stylesheet(node) {
		const style_element = element('style');
		// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,
		// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.
		// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.
		// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.
		// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.
		style_element.textContent = '/* empty */';
		append_stylesheet(get_root_for_style(node), style_element);
		return style_element.sheet;
	}

	/**
	 * @param {ShadowRoot | Document} node
	 * @param {HTMLStyleElement} style
	 * @returns {CSSStyleSheet}
	 */
	function append_stylesheet(node, style) {
		append(/** @type {Document} */ (node).head || node, style);
		return style.sheet;
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert(target, node, anchor) {
		target.insertBefore(node, anchor || null);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach(node) {
		if (node.parentNode) {
			node.parentNode.removeChild(node);
		}
	}

	/**
	 * @returns {void} */
	function destroy_each(iterations, detaching) {
		for (let i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detaching);
		}
	}

	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */
	function element(name) {
		return document.createElement(name);
	}

	/**
	 * @template {keyof SVGElementTagNameMap} K
	 * @param {K} name
	 * @returns {SVGElement}
	 */
	function svg_element(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	function text(data) {
		return document.createTextNode(data);
	}

	/**
	 * @returns {Text} */
	function space() {
		return text(' ');
	}

	/**
	 * @returns {Text} */
	function empty() {
		return text('');
	}

	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */
	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	/**
	 * @returns {(event: any) => any} */
	function prevent_default(fn) {
		return function (event) {
			event.preventDefault();
			// @ts-ignore
			return fn.call(this, event);
		};
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}
	/**
	 * List of attributes that should always be set through the attr method,
	 * because updating them through the property setter doesn't work reliably.
	 * In the example of `width`/`height`, the problem is that the setter only
	 * accepts numeric values, but the attribute can also be set to a string like `50%`.
	 * If this list becomes too big, rethink this approach.
	 */
	const always_set_through_set_attribute = ['width', 'height'];

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {{ [x: string]: string }} attributes
	 * @returns {void}
	 */
	function set_attributes(node, attributes) {
		// @ts-ignore
		const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
		for (const key in attributes) {
			if (attributes[key] == null) {
				node.removeAttribute(key);
			} else if (key === 'style') {
				node.style.cssText = attributes[key];
			} else if (key === '__value') {
				/** @type {any} */ (node).value = node[key] = attributes[key];
			} else if (
				descriptors[key] &&
				descriptors[key].set &&
				always_set_through_set_attribute.indexOf(key) === -1
			) {
				node[key] = attributes[key];
			} else {
				attr(node, key, attributes[key]);
			}
		}
	}

	/** @returns {number} */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */
	function children(element) {
		return Array.from(element.childNodes);
	}

	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */
	function set_data(text, data) {
		data = '' + data;
		if (text.data === data) return;
		text.data = /** @type {string} */ (data);
	}

	/**
	 * @returns {void} */
	function set_input_value(input, value) {
		input.value = value == null ? '' : value;
	}

	/**
	 * @returns {void} */
	function set_style(node, key, value, important) {
		if (value == null) {
			node.style.removeProperty(key);
		} else {
			node.style.setProperty(key, value, '');
		}
	}

	/**
	 * @returns {void} */
	function toggle_class(element, name, toggle) {
		// The `!!` is required because an `undefined` flag means flipping the current state.
		element.classList.toggle(name, !!toggle);
	}

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */
	function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}
	/** */
	class HtmlTag {
		/**
		 * @private
		 * @default false
		 */
		is_svg = false;
		/** parent for creating node */
		e = undefined;
		/** html tag nodes */
		n = undefined;
		/** target */
		t = undefined;
		/** anchor */
		a = undefined;
		constructor(is_svg = false) {
			this.is_svg = is_svg;
			this.e = this.n = null;
		}

		/**
		 * @param {string} html
		 * @returns {void}
		 */
		c(html) {
			this.h(html);
		}

		/**
		 * @param {string} html
		 * @param {HTMLElement | SVGElement} target
		 * @param {HTMLElement | SVGElement} anchor
		 * @returns {void}
		 */
		m(html, target, anchor = null) {
			if (!this.e) {
				if (this.is_svg)
					this.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));
				/** #7364  target for <template> may be provided as #document-fragment(11) */ else
					this.e = element(
						/** @type {keyof HTMLElementTagNameMap} */ (
							target.nodeType === 11 ? 'TEMPLATE' : target.nodeName
						)
					);
				this.t =
					target.tagName !== 'TEMPLATE'
						? target
						: /** @type {HTMLTemplateElement} */ (target).content;
				this.c(html);
			}
			this.i(anchor);
		}

		/**
		 * @param {string} html
		 * @returns {void}
		 */
		h(html) {
			this.e.innerHTML = html;
			this.n = Array.from(
				this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes
			);
		}

		/**
		 * @returns {void} */
		i(anchor) {
			for (let i = 0; i < this.n.length; i += 1) {
				insert(this.t, this.n[i], anchor);
			}
		}

		/**
		 * @param {string} html
		 * @returns {void}
		 */
		p(html) {
			this.d();
			this.h(html);
			this.i(this.a);
		}

		/**
		 * @returns {void} */
		d() {
			this.n.forEach(detach);
		}
	}

	function construct_svelte_component(component, props) {
		return new component(props);
	}

	/**
	 * @typedef {Node & {
	 * 	claim_order?: number;
	 * 	hydrate_init?: true;
	 * 	actual_end_child?: NodeEx;
	 * 	childNodes: NodeListOf<NodeEx>;
	 * }} NodeEx
	 */

	/** @typedef {ChildNode & NodeEx} ChildNodeEx */

	/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

	/**
	 * @typedef {ChildNodeEx[] & {
	 * 	claim_info?: {
	 * 		last_index: number;
	 * 		total_claimed: number;
	 * 	};
	 * }} ChildNodeArray
	 */

	// we need to store the information for multiple documents because a Svelte application could also contain iframes
	// https://github.com/sveltejs/svelte/issues/3624
	/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */
	const managed_styles = new Map();

	let active = 0;

	// https://github.com/darkskyapp/string-hash/blob/master/index.js
	/**
	 * @param {string} str
	 * @returns {number}
	 */
	function hash$1(str) {
		let hash = 5381;
		let i = str.length;
		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return hash >>> 0;
	}

	/**
	 * @param {Document | ShadowRoot} doc
	 * @param {Element & ElementCSSInlineStyle} node
	 * @returns {{ stylesheet: any; rules: {}; }}
	 */
	function create_style_information(doc, node) {
		const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
		managed_styles.set(doc, info);
		return info;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {number} a
	 * @param {number} b
	 * @param {number} duration
	 * @param {number} delay
	 * @param {(t: number) => number} ease
	 * @param {(t: number, u: number) => string} fn
	 * @param {number} uid
	 * @returns {string}
	 */
	function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
		const step = 16.666 / duration;
		let keyframes = '{\n';
		for (let p = 0; p <= 1; p += step) {
			const t = a + (b - a) * ease(p);
			keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
		}
		const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
		const name = `__svelte_${hash$1(rule)}_${uid}`;
		const doc = get_root_for_style(node);
		const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
		if (!rules[name]) {
			rules[name] = true;
			stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
		}
		const animation = node.style.animation || '';
		node.style.animation = `${
		animation ? `${animation}, ` : ''
	}${name} ${duration}ms linear ${delay}ms 1 both`;
		active += 1;
		return name;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {string} [name]
	 * @returns {void}
	 */
	function delete_rule(node, name) {
		const previous = (node.style.animation || '').split(', ');
		const next = previous.filter(
			name
				? (anim) => anim.indexOf(name) < 0 // remove specific animation
				: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations
		);
		const deleted = previous.length - next.length;
		if (deleted) {
			node.style.animation = next.join(', ');
			active -= deleted;
			if (!active) clear_rules();
		}
	}

	/** @returns {void} */
	function clear_rules() {
		raf(() => {
			if (active) return;
			managed_styles.forEach((info) => {
				const { ownerNode } = info.stylesheet;
				// there is no ownerNode if it runs on jsdom.
				if (ownerNode) detach(ownerNode);
			});
			managed_styles.clear();
		});
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {import('./private.js').PositionRect} from
	 * @param {import('./private.js').AnimationFn} fn
	 */
	function create_animation(node, from, fn, params) {
		if (!from) return noop$1;
		const to = node.getBoundingClientRect();
		if (
			from.left === to.left &&
			from.right === to.right &&
			from.top === to.top &&
			from.bottom === to.bottom
		)
			return noop$1;
		const {
			delay = 0,
			duration = 300,
			easing = identity,
			// @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
			start: start_time = now() + delay,
			// @ts-ignore todo:
			end = start_time + duration,
			tick = noop$1,
			css
		} = fn(node, { from, to }, params);
		let running = true;
		let started = false;
		let name;
		/** @returns {void} */
		function start() {
			if (css) {
				name = create_rule(node, 0, 1, duration, delay, easing, css);
			}
			if (!delay) {
				started = true;
			}
		}
		/** @returns {void} */
		function stop() {
			if (css) delete_rule(node, name);
			running = false;
		}
		loop((now) => {
			if (!started && now >= start_time) {
				started = true;
			}
			if (started && now >= end) {
				tick(1, 0);
				stop();
			}
			if (!running) {
				return false;
			}
			if (started) {
				const p = now - start_time;
				const t = 0 + 1 * easing(p / duration);
				tick(t, 1 - t);
			}
			return true;
		});
		start();
		tick(0, 1);
		return stop;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @returns {void}
	 */
	function fix_position(node) {
		const style = getComputedStyle(node);
		if (style.position !== 'absolute' && style.position !== 'fixed') {
			const { width, height } = style;
			const a = node.getBoundingClientRect();
			node.style.position = 'absolute';
			node.style.width = width;
			node.style.height = height;
			add_transform(node, a);
		}
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {import('./private.js').PositionRect} a
	 * @returns {void}
	 */
	function add_transform(node, a) {
		const b = node.getBoundingClientRect();
		if (a.left !== b.left || a.top !== b.top) {
			const style = getComputedStyle(node);
			const transform = style.transform === 'none' ? '' : style.transform;
			node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
		}
	}

	let current_component;

	/** @returns {void} */
	function set_current_component(component) {
		current_component = component;
	}

	function get_current_component() {
		if (!current_component) throw new Error('Function called outside component initialization');
		return current_component;
	}

	/**
	 * Schedules a callback to run immediately before the component is updated after any state change.
	 *
	 * The first time the callback runs will be before the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#beforeupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function beforeUpdate(fn) {
		get_current_component().$$.before_update.push(fn);
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#afterupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		get_current_component().$$.after_update.push(fn);
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * https://svelte.dev/docs/svelte#ondestroy
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		get_current_component().$$.on_destroy.push(fn);
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * https://svelte.dev/docs/svelte#createeventdispatcher
	 * @template {Record<string, any>} [EventMap=any]
	 * @returns {import('./public.js').EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const component = get_current_component();
		return (type, detail, { cancelable = false } = {}) => {
			const callbacks = component.$$.callbacks[type];
			if (callbacks) {
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = custom_event(/** @type {string} */ (type), detail, { cancelable });
				callbacks.slice().forEach((fn) => {
					fn.call(component, event);
				});
				return !event.defaultPrevented;
			}
			return true;
		};
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	/**
	 * @param component
	 * @param event
	 * @returns {void}
	 */
	function bubble(component, event) {
		const callbacks = component.$$.callbacks[event.type];
		if (callbacks) {
			// @ts-ignore
			callbacks.slice().forEach((fn) => fn.call(this, event));
		}
	}

	const dirty_components = [];
	const binding_callbacks = [];

	let render_callbacks = [];

	const flush_callbacks = [];

	const resolved_promise = /* @__PURE__ */ Promise.resolve();

	let update_scheduled = false;

	/** @returns {void} */
	function schedule_update() {
		if (!update_scheduled) {
			update_scheduled = true;
			resolved_promise.then(flush);
		}
	}

	/** @returns {void} */
	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	/** @returns {void} */
	function add_flush_callback(fn) {
		flush_callbacks.push(fn);
	}

	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();

	let flushidx = 0; // Do *not* move this inside the flush() function

	/** @returns {void} */
	function flush() {
		// Do not reenter flush while dirty components are updated, as this can
		// result in an infinite loop. Instead, let the inner flush handle it.
		// Reentrancy is ok afterwards for bindings etc.
		if (flushidx !== 0) {
			return;
		}
		const saved_component = current_component;
		do {
			// first, call beforeUpdate functions
			// and update components
			try {
				while (flushidx < dirty_components.length) {
					const component = dirty_components[flushidx];
					flushidx++;
					set_current_component(component);
					update(component.$$);
				}
			} catch (e) {
				// reset dirty state to not end up in a deadlocked state and then rethrow
				dirty_components.length = 0;
				flushidx = 0;
				throw e;
			}
			set_current_component(null);
			dirty_components.length = 0;
			flushidx = 0;
			while (binding_callbacks.length) binding_callbacks.pop()();
			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			for (let i = 0; i < render_callbacks.length; i += 1) {
				const callback = render_callbacks[i];
				if (!seen_callbacks.has(callback)) {
					// ...so guard against infinite loops
					seen_callbacks.add(callback);
					callback();
				}
			}
			render_callbacks.length = 0;
		} while (dirty_components.length);
		while (flush_callbacks.length) {
			flush_callbacks.pop()();
		}
		update_scheduled = false;
		seen_callbacks.clear();
		set_current_component(saved_component);
	}

	/** @returns {void} */
	function update($$) {
		if ($$.fragment !== null) {
			$$.update();
			run_all($$.before_update);
			const dirty = $$.dirty;
			$$.dirty = [-1];
			$$.fragment && $$.fragment.p($$.ctx, dirty);
			$$.after_update.forEach(add_render_callback);
		}
	}

	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function flush_render_callbacks(fns) {
		const filtered = [];
		const targets = [];
		render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
		targets.forEach((c) => c());
		render_callbacks = filtered;
	}

	/**
	 * @type {Promise<void> | null}
	 */
	let promise;

	/**
	 * @returns {Promise<void>}
	 */
	function wait() {
		if (!promise) {
			promise = Promise.resolve();
			promise.then(() => {
				promise = null;
			});
		}
		return promise;
	}

	/**
	 * @param {Element} node
	 * @param {INTRO | OUTRO | boolean} direction
	 * @param {'start' | 'end'} kind
	 * @returns {void}
	 */
	function dispatch(node, direction, kind) {
		node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	const outroing = new Set();

	/**
	 * @type {Outro}
	 */
	let outros;

	/**
	 * @returns {void} */
	function group_outros() {
		outros = {
			r: 0,
			c: [],
			p: outros // parent group
		};
	}

	/**
	 * @returns {void} */
	function check_outros() {
		if (!outros.r) {
			run_all(outros.c);
		}
		outros = outros.p;
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */
	function transition_in(block, local) {
		if (block && block.i) {
			outroing.delete(block);
			block.i(local);
		}
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */
	function transition_out(block, local, detach, callback) {
		if (block && block.o) {
			if (outroing.has(block)) return;
			outroing.add(block);
			outros.c.push(() => {
				outroing.delete(block);
				if (callback) {
					if (detach) block.d(1);
					callback();
				}
			});
			block.o(local);
		} else if (callback) {
			callback();
		}
	}

	/**
	 * @type {import('../transition/public.js').TransitionConfig}
	 */
	const null_transition = { duration: 0 };

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {TransitionFn} fn
	 * @param {any} params
	 * @param {boolean} intro
	 * @returns {{ run(b: 0 | 1): void; end(): void; }}
	 */
	function create_bidirectional_transition(node, fn, params, intro) {
		/**
		 * @type {TransitionOptions} */
		const options = { direction: 'both' };
		let config = fn(node, params, options);
		let t = intro ? 0 : 1;

		/**
		 * @type {Program | null} */
		let running_program = null;

		/**
		 * @type {PendingProgram | null} */
		let pending_program = null;
		let animation_name = null;

		/** @type {boolean} */
		let original_inert_value;

		/**
		 * @returns {void} */
		function clear_animation() {
			if (animation_name) delete_rule(node, animation_name);
		}

		/**
		 * @param {PendingProgram} program
		 * @param {number} duration
		 * @returns {Program}
		 */
		function init(program, duration) {
			const d = /** @type {Program['d']} */ (program.b - t);
			duration *= Math.abs(d);
			return {
				a: t,
				b: program.b,
				d,
				duration,
				start: program.start,
				end: program.start + duration,
				group: program.group
			};
		}

		/**
		 * @param {INTRO | OUTRO} b
		 * @returns {void}
		 */
		function go(b) {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick = noop$1,
				css
			} = config || null_transition;

			/**
			 * @type {PendingProgram} */
			const program = {
				start: now() + delay,
				b
			};

			if (!b) {
				// @ts-ignore todo: improve typings
				program.group = outros;
				outros.r += 1;
			}

			if ('inert' in node) {
				if (b) {
					if (original_inert_value !== undefined) {
						// aborted/reversed outro — restore previous inert value
						node.inert = original_inert_value;
					}
				} else {
					original_inert_value = /** @type {HTMLElement} */ (node).inert;
					node.inert = true;
				}
			}

			if (running_program || pending_program) {
				pending_program = program;
			} else {
				// if this is an intro, and there's a delay, we need to do
				// an initial tick and/or apply CSS animation immediately
				if (css) {
					clear_animation();
					animation_name = create_rule(node, t, b, duration, delay, easing, css);
				}
				if (b) tick(0, 1);
				running_program = init(program, duration);
				add_render_callback(() => dispatch(node, b, 'start'));
				loop((now) => {
					if (pending_program && now > pending_program.start) {
						running_program = init(pending_program, duration);
						pending_program = null;
						dispatch(node, running_program.b, 'start');
						if (css) {
							clear_animation();
							animation_name = create_rule(
								node,
								t,
								running_program.b,
								running_program.duration,
								0,
								easing,
								config.css
							);
						}
					}
					if (running_program) {
						if (now >= running_program.end) {
							tick((t = running_program.b), 1 - t);
							dispatch(node, running_program.b, 'end');
							if (!pending_program) {
								// we're done
								if (running_program.b) {
									// intro — we can tidy up immediately
									clear_animation();
								} else {
									// outro — needs to be coordinated
									if (!--running_program.group.r) run_all(running_program.group.c);
								}
							}
							running_program = null;
						} else if (now >= running_program.start) {
							const p = now - running_program.start;
							t = running_program.a + running_program.d * easing(p / running_program.duration);
							tick(t, 1 - t);
						}
					}
					return !!(running_program || pending_program);
				});
			}
		}
		return {
			run(b) {
				if (is_function(config)) {
					wait().then(() => {
						const opts = { direction: b ? 'in' : 'out' };
						// @ts-ignore
						config = config(opts);
						go(b);
					});
				} else {
					go(b);
				}
			},
			end() {
				clear_animation();
				running_program = pending_program = null;
			}
		};
	}

	/** @typedef {1} INTRO */
	/** @typedef {0} OUTRO */
	/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
	/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

	/**
	 * @typedef {Object} Outro
	 * @property {number} r
	 * @property {Function[]} c
	 * @property {Object} p
	 */

	/**
	 * @typedef {Object} PendingProgram
	 * @property {number} start
	 * @property {INTRO|OUTRO} b
	 * @property {Outro} [group]
	 */

	/**
	 * @typedef {Object} Program
	 * @property {number} a
	 * @property {INTRO|OUTRO} b
	 * @property {1|-1} d
	 * @property {number} duration
	 * @property {number} start
	 * @property {number} end
	 * @property {Outro} [group]
	 */

	// general each functions:

	function ensure_array_like(array_like_or_iterator) {
		return array_like_or_iterator?.length !== undefined
			? array_like_or_iterator
			: Array.from(array_like_or_iterator);
	}

	// keyed each functions:

	/** @returns {void} */
	function destroy_block(block, lookup) {
		block.d(1);
		lookup.delete(block.key);
	}

	/** @returns {void} */
	function outro_and_destroy_block(block, lookup) {
		transition_out(block, 1, 1, () => {
			lookup.delete(block.key);
		});
	}

	/** @returns {void} */
	function fix_and_outro_and_destroy_block(block, lookup) {
		block.f();
		outro_and_destroy_block(block, lookup);
	}

	/** @returns {any[]} */
	function update_keyed_each(
		old_blocks,
		dirty,
		get_key,
		dynamic,
		ctx,
		list,
		lookup,
		node,
		destroy,
		create_each_block,
		next,
		get_context
	) {
		let o = old_blocks.length;
		let n = list.length;
		let i = o;
		const old_indexes = {};
		while (i--) old_indexes[old_blocks[i].key] = i;
		const new_blocks = [];
		const new_lookup = new Map();
		const deltas = new Map();
		const updates = [];
		i = n;
		while (i--) {
			const child_ctx = get_context(ctx, list, i);
			const key = get_key(child_ctx);
			let block = lookup.get(key);
			if (!block) {
				block = create_each_block(key, child_ctx);
				block.c();
			} else {
				// defer updates until all the DOM shuffling is done
				updates.push(() => block.p(child_ctx, dirty));
			}
			new_lookup.set(key, (new_blocks[i] = block));
			if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
		}
		const will_move = new Set();
		const did_move = new Set();
		/** @returns {void} */
		function insert(block) {
			transition_in(block, 1);
			block.m(node, next);
			lookup.set(block.key, block);
			next = block.first;
			n--;
		}
		while (o && n) {
			const new_block = new_blocks[n - 1];
			const old_block = old_blocks[o - 1];
			const new_key = new_block.key;
			const old_key = old_block.key;
			if (new_block === old_block) {
				// do nothing
				next = new_block.first;
				o--;
				n--;
			} else if (!new_lookup.has(old_key)) {
				// remove old block
				destroy(old_block, lookup);
				o--;
			} else if (!lookup.has(new_key) || will_move.has(new_key)) {
				insert(new_block);
			} else if (did_move.has(old_key)) {
				o--;
			} else if (deltas.get(new_key) > deltas.get(old_key)) {
				did_move.add(new_key);
				insert(new_block);
			} else {
				will_move.add(old_key);
				o--;
			}
		}
		while (o--) {
			const old_block = old_blocks[o];
			if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
		}
		while (n) insert(new_blocks[n - 1]);
		run_all(updates);
		return new_blocks;
	}

	/** @returns {{}} */
	function get_spread_update(levels, updates) {
		const update = {};
		const to_null_out = {};
		const accounted_for = { $$scope: 1 };
		let i = levels.length;
		while (i--) {
			const o = levels[i];
			const n = updates[i];
			if (n) {
				for (const key in o) {
					if (!(key in n)) to_null_out[key] = 1;
				}
				for (const key in n) {
					if (!accounted_for[key]) {
						update[key] = n[key];
						accounted_for[key] = 1;
					}
				}
				levels[i] = n;
			} else {
				for (const key in o) {
					accounted_for[key] = 1;
				}
			}
		}
		for (const key in to_null_out) {
			if (!(key in update)) update[key] = undefined;
		}
		return update;
	}

	function get_spread_object(spread_props) {
		return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
	}

	/** @returns {void} */
	function bind(component, name, callback) {
		const index = component.$$.props[name];
		if (index !== undefined) {
			component.$$.bound[index] = callback;
			callback(component.$$.ctx[index]);
		}
	}

	/** @returns {void} */
	function create_component(block) {
		block && block.c();
	}

	/** @returns {void} */
	function mount_component(component, target, anchor) {
		const { fragment, after_update } = component.$$;
		fragment && fragment.m(target, anchor);
		// onMount happens before the initial afterUpdate
		add_render_callback(() => {
			const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
			// if the component was destroyed immediately
			// it will update the `$$.on_destroy` reference to `null`.
			// the destructured on_destroy may still reference to the old array
			if (component.$$.on_destroy) {
				component.$$.on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});
		after_update.forEach(add_render_callback);
	}

	/** @returns {void} */
	function destroy_component(component, detaching) {
		const $$ = component.$$;
		if ($$.fragment !== null) {
			flush_render_callbacks($$.after_update);
			run_all($$.on_destroy);
			$$.fragment && $$.fragment.d(detaching);
			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			$$.on_destroy = $$.fragment = null;
			$$.ctx = [];
		}
	}

	/** @returns {void} */
	function make_dirty(component, i) {
		if (component.$$.dirty[0] === -1) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty.fill(0);
		}
		component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
	}

	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */
	function init(
		component,
		options,
		instance,
		create_fragment,
		not_equal,
		props,
		append_styles = null,
		dirty = [-1]
	) {
		const parent_component = current_component;
		set_current_component(component);
		/** @type {import('./private.js').T$$} */
		const $$ = (component.$$ = {
			fragment: null,
			ctx: [],
			// state
			props,
			update: noop$1,
			not_equal,
			bound: blank_object(),
			// lifecycle
			on_mount: [],
			on_destroy: [],
			on_disconnect: [],
			before_update: [],
			after_update: [],
			context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
			// everything else
			callbacks: blank_object(),
			dirty,
			skip_bound: false,
			root: options.target || parent_component.$$.root
		});
		append_styles && append_styles($$.root);
		let ready = false;
		$$.ctx = instance
			? instance(component, options.props || {}, (i, ret, ...rest) => {
					const value = rest.length ? rest[0] : ret;
					if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
						if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
						if (ready) make_dirty(component, i);
					}
					return ret;
			  })
			: [];
		$$.update();
		ready = true;
		run_all($$.before_update);
		// `false` as a special case of no DOM component
		$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
		if (options.target) {
			if (options.hydrate) {
				// TODO: what is the correct type here?
				// @ts-expect-error
				const nodes = children(options.target);
				$$.fragment && $$.fragment.l(nodes);
				nodes.forEach(detach);
			} else {
				// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
				$$.fragment && $$.fragment.c();
			}
			if (options.intro) transition_in(component.$$.fragment);
			mount_component(component, options.target, options.anchor);
			flush();
		}
		set_current_component(parent_component);
	}

	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */
	class SvelteComponent {
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$ = undefined;
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$set = undefined;

		/** @returns {void} */
		$destroy() {
			destroy_component(this, 1);
			this.$destroy = noop$1;
		}

		/**
		 * @template {Extract<keyof Events, string>} K
		 * @param {K} type
		 * @param {((e: Events[K]) => void) | null | undefined} callback
		 * @returns {() => void}
		 */
		$on(type, callback) {
			if (!is_function(callback)) {
				return noop$1;
			}
			const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
			callbacks.push(callback);
			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		/**
		 * @param {Partial<Props>} props
		 * @returns {void}
		 */
		$set(props) {
			if (this.$$set && !is_empty(props)) {
				this.$$.skip_bound = true;
				this.$$set(props);
				this.$$.skip_bound = false;
			}
		}
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	// generated during release, do not modify

	const PUBLIC_VERSION = '4';

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

	/* node_modules/not-bulma/src/elements/block/ui.block.svelte generated by Svelte v4.2.19 */

	function create_fragment$1F(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "id", /*id*/ ctx[0]);
				attr(div, "class", div_class_value = "block " + /*classes*/ ctx[1]);
				attr(div, "role", "button");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[5]),
						listen(div, "keyup", /*keyup_handler*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && div_class_value !== (div_class_value = "block " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$1E($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		const dispatch = createEventDispatcher();
		let { id = "" } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler = () => dispatch("click");

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		return [id, classes, dispatch, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_block extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1E, create_fragment$1F, safe_not_equal, { id: 0, classes: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/block/ui.block.inner.vertical.svelte generated by Svelte v4.2.19 */

	function create_default_slot$6(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

		return {
			c() {
				if (default_slot) default_slot.c();
			},
			m(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[6],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
							null
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function create_fragment$1E(ctx) {
		let uiblock;
		let updating_id;
		let updating_classes;
		let current;

		function uiblock_id_binding(value) {
			/*uiblock_id_binding*/ ctx[4](value);
		}

		function uiblock_classes_binding(value) {
			/*uiblock_classes_binding*/ ctx[5](value);
		}

		let uiblock_props = {
			$$slots: { default: [create_default_slot$6] },
			$$scope: { ctx }
		};

		if (/*id*/ ctx[0] !== void 0) {
			uiblock_props.id = /*id*/ ctx[0];
		}

		if (/*classesInner*/ ctx[1] !== void 0) {
			uiblock_props.classes = /*classesInner*/ ctx[1];
		}

		uiblock = new Ui_block({ props: uiblock_props });
		binding_callbacks.push(() => bind(uiblock, 'id', uiblock_id_binding));
		binding_callbacks.push(() => bind(uiblock, 'classes', uiblock_classes_binding));

		return {
			c() {
				create_component(uiblock.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiblock, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uiblock_changes = {};

				if (dirty & /*$$scope*/ 64) {
					uiblock_changes.$$scope = { dirty, ctx };
				}

				if (!updating_id && dirty & /*id*/ 1) {
					updating_id = true;
					uiblock_changes.id = /*id*/ ctx[0];
					add_flush_callback(() => updating_id = false);
				}

				if (!updating_classes && dirty & /*classesInner*/ 2) {
					updating_classes = true;
					uiblock_changes.classes = /*classesInner*/ ctx[1];
					add_flush_callback(() => updating_classes = false);
				}

				uiblock.$set(uiblock_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiblock.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiblock.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiblock, detaching);
			}
		};
	}

	function instance$1D($$self, $$props, $$invalidate) {
		let classesInner;
		let { $$slots: slots = {}, $$scope } = $$props;
		let { id = "" } = $$props;
		let { classes = "" } = $$props;

		function uiblock_id_binding(value) {
			id = value;
			$$invalidate(0, id);
		}

		function uiblock_classes_binding(value) {
			classesInner = value;
			($$invalidate(1, classesInner), $$invalidate(2, classes));
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*classes*/ 4) {
				$$invalidate(1, classesInner = `block-inner-vertical ${classes}`);
			}
		};

		return [
			id,
			classesInner,
			classes,
			slots,
			uiblock_id_binding,
			uiblock_classes_binding,
			$$scope
		];
	}

	class Ui_block_inner_vertical extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1D, create_fragment$1E, safe_not_equal, { id: 0, classes: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/block/ui.box.svelte generated by Svelte v4.2.19 */

	function create_fragment$1D(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "id", /*id*/ ctx[0]);
				attr(div, "class", div_class_value = "box " + /*classes*/ ctx[1] + "");
				attr(div, "role", "button");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[5]),
						listen(div, "keyup", /*keyup_handler*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && div_class_value !== (div_class_value = "box " + /*classes*/ ctx[1] + "")) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$1C($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		const dispatch = createEventDispatcher();
		let { id = "" } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler = () => dispatch("click");

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		return [id, classes, dispatch, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_box extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1C, create_fragment$1D, safe_not_equal, { id: 0, classes: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/block/ui.content.svelte generated by Svelte v4.2.19 */

	function create_fragment$1C(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				attr(div, "id", /*id*/ ctx[0]);
				attr(div, "class", div_class_value = "content " + /*classes*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[5]),
						listen(div, "keyup", /*keyup_handler*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && div_class_value !== (div_class_value = "content " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$1B($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		const dispatch = createEventDispatcher();
		let { id = "" } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler = () => dispatch("click");

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		return [id, classes, dispatch, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_content extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1B, create_fragment$1C, safe_not_equal, { id: 0, classes: 1 });
		}
	}

	var index$b = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBlock: Ui_block,
		UIBlockInnerVertical: Ui_block_inner_vertical,
		UIBox: Ui_box,
		UIContent: Ui_content
	});

	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#writable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Writable<T>}
	 */
	function writable(value, start = noop$1) {
		/** @type {import('./public.js').Unsubscriber} */
		let stop;
		/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();
		/** @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {import('./public.js').Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(value));
		}

		/**
		 * @param {import('./public.js').Subscriber<T>} run
		 * @param {import('./private.js').Invalidator<T>} [invalidate]
		 * @returns {import('./public.js').Unsubscriber}
		 */
		function subscribe(run, invalidate = noop$1) {
			/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop$1;
			}
			run(value);
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	function initDict(target = {}) {
	    const handler = {
	        get: function (target, prop) {
	            if (!Object.hasOwn(target, prop)) {
	                return prop;
	            }
	            return Reflect.get(...arguments);
	        },
	    };
	    return new Proxy(target, handler);
	}

	function createLocale() {
	    const { subscribe, set, update } = writable(initDict());
	    return {
	        subscribe,
	        update,
	        set: (val) => {
	            set(initDict(val));
	        },
	        reset: () => set(initDict()),
	    };
	}

	const LOCALE = createLocale();

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var EventEmitter$1 = {exports: {}};

	/*!
	 * EventEmitter v5.2.9 - git.io/ee
	 * Unlicense - http://unlicense.org/
	 * Oliver Caldwell - https://oli.me.uk/
	 * @preserve
	 */

	(function (module) {
	(function (exports) {

		    /**
		     * Class for managing events.
		     * Can be extended to provide event functionality in other classes.
		     *
		     * @class EventEmitter Manages event registering and emitting.
		     */
		    function EventEmitter() {}

		    // Shortcuts to improve speed and size
		    var proto = EventEmitter.prototype;
		    var originalGlobalValue = exports.EventEmitter;

		    /**
		     * Finds the index of the listener for the event in its storage array.
		     *
		     * @param {Function[]} listeners Array of listeners to search through.
		     * @param {Function} listener Method to look for.
		     * @return {Number} Index of the specified listener, -1 if not found
		     * @api private
		     */
		    function indexOfListener(listeners, listener) {
		        var i = listeners.length;
		        while (i--) {
		            if (listeners[i].listener === listener) {
		                return i;
		            }
		        }

		        return -1;
		    }

		    /**
		     * Alias a method while keeping the context correct, to allow for overwriting of target method.
		     *
		     * @param {String} name The name of the target method.
		     * @return {Function} The aliased method
		     * @api private
		     */
		    function alias(name) {
		        return function aliasClosure() {
		            return this[name].apply(this, arguments);
		        };
		    }

		    /**
		     * Returns the listener array for the specified event.
		     * Will initialise the event object and listener arrays if required.
		     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
		     * Each property in the object response is an array of listener functions.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Function[]|Object} All listener functions for the event.
		     */
		    proto.getListeners = function getListeners(evt) {
		        var events = this._getEvents();
		        var response;
		        var key;

		        // Return a concatenated array of all matching events if
		        // the selector is a regular expression.
		        if (evt instanceof RegExp) {
		            response = {};
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    response[key] = events[key];
		                }
		            }
		        }
		        else {
		            response = events[evt] || (events[evt] = []);
		        }

		        return response;
		    };

		    /**
		     * Takes a list of listener objects and flattens it into a list of listener functions.
		     *
		     * @param {Object[]} listeners Raw listener objects.
		     * @return {Function[]} Just the listener functions.
		     */
		    proto.flattenListeners = function flattenListeners(listeners) {
		        var flatListeners = [];
		        var i;

		        for (i = 0; i < listeners.length; i += 1) {
		            flatListeners.push(listeners[i].listener);
		        }

		        return flatListeners;
		    };

		    /**
		     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Object} All listener functions for an event in an object.
		     */
		    proto.getListenersAsObject = function getListenersAsObject(evt) {
		        var listeners = this.getListeners(evt);
		        var response;

		        if (listeners instanceof Array) {
		            response = {};
		            response[evt] = listeners;
		        }

		        return response || listeners;
		    };

		    function isValidListener (listener) {
		        if (typeof listener === 'function' || listener instanceof RegExp) {
		            return true
		        } else if (listener && typeof listener === 'object') {
		            return isValidListener(listener.listener)
		        } else {
		            return false
		        }
		    }

		    /**
		     * Adds a listener function to the specified event.
		     * The listener will not be added if it is a duplicate.
		     * If the listener returns true then it will be removed after it is called.
		     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListener = function addListener(evt, listener) {
		        if (!isValidListener(listener)) {
		            throw new TypeError('listener must be a function');
		        }

		        var listeners = this.getListenersAsObject(evt);
		        var listenerIsWrapped = typeof listener === 'object';
		        var key;

		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
		                listeners[key].push(listenerIsWrapped ? listener : {
		                    listener: listener,
		                    once: false
		                });
		            }
		        }

		        return this;
		    };

		    /**
		     * Alias of addListener
		     */
		    proto.on = alias('addListener');

		    /**
		     * Semi-alias of addListener. It will add a listener that will be
		     * automatically removed after its first execution.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addOnceListener = function addOnceListener(evt, listener) {
		        return this.addListener(evt, {
		            listener: listener,
		            once: true
		        });
		    };

		    /**
		     * Alias of addOnceListener.
		     */
		    proto.once = alias('addOnceListener');

		    /**
		     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
		     * You need to tell it what event names should be matched by a regex.
		     *
		     * @param {String} evt Name of the event to create.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvent = function defineEvent(evt) {
		        this.getListeners(evt);
		        return this;
		    };

		    /**
		     * Uses defineEvent to define multiple events.
		     *
		     * @param {String[]} evts An array of event names to define.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvents = function defineEvents(evts) {
		        for (var i = 0; i < evts.length; i += 1) {
		            this.defineEvent(evts[i]);
		        }
		        return this;
		    };

		    /**
		     * Removes a listener function from the specified event.
		     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to remove the listener from.
		     * @param {Function} listener Method to remove from the event.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListener = function removeListener(evt, listener) {
		        var listeners = this.getListenersAsObject(evt);
		        var index;
		        var key;

		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key)) {
		                index = indexOfListener(listeners[key], listener);

		                if (index !== -1) {
		                    listeners[key].splice(index, 1);
		                }
		            }
		        }

		        return this;
		    };

		    /**
		     * Alias of removeListener
		     */
		    proto.off = alias('removeListener');

		    /**
		     * Adds listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
		     * You can also pass it a regular expression to add the array of listeners to all events that match it.
		     * Yeah, this function does quite a bit. That's probably a bad thing.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListeners = function addListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(false, evt, listeners);
		    };

		    /**
		     * Removes listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be removed.
		     * You can also pass it a regular expression to remove the listeners from all events that match it.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListeners = function removeListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(true, evt, listeners);
		    };

		    /**
		     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
		     * The first argument will determine if the listeners are removed (true) or added (false).
		     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be added/removed.
		     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
		     *
		     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		        var i;
		        var value;
		        var single = remove ? this.removeListener : this.addListener;
		        var multiple = remove ? this.removeListeners : this.addListeners;

		        // If evt is an object then pass each of its properties to this method
		        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
		            for (i in evt) {
		                if (evt.hasOwnProperty(i) && (value = evt[i])) {
		                    // Pass the single listener straight through to the singular method
		                    if (typeof value === 'function') {
		                        single.call(this, i, value);
		                    }
		                    else {
		                        // Otherwise pass back to the multiple function
		                        multiple.call(this, i, value);
		                    }
		                }
		            }
		        }
		        else {
		            // So evt must be a string
		            // And listeners must be an array of listeners
		            // Loop over it and pass each one to the multiple method
		            i = listeners.length;
		            while (i--) {
		                single.call(this, evt, listeners[i]);
		            }
		        }

		        return this;
		    };

		    /**
		     * Removes all listeners from a specified event.
		     * If you do not specify an event then all listeners will be removed.
		     * That means every event will be emptied.
		     * You can also pass a regex to remove all events that match it.
		     *
		     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeEvent = function removeEvent(evt) {
		        var type = typeof evt;
		        var events = this._getEvents();
		        var key;

		        // Remove different things depending on the state of evt
		        if (type === 'string') {
		            // Remove all listeners for the specified event
		            delete events[evt];
		        }
		        else if (evt instanceof RegExp) {
		            // Remove all events matching the regex.
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    delete events[key];
		                }
		            }
		        }
		        else {
		            // Remove all listeners in all events
		            delete this._events;
		        }

		        return this;
		    };

		    /**
		     * Alias of removeEvent.
		     *
		     * Added to mirror the node API.
		     */
		    proto.removeAllListeners = alias('removeEvent');

		    /**
		     * Emits an event of your choice.
		     * When emitted, every listener attached to that event will be executed.
		     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
		     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
		     * So they will not arrive within the array on the other side, they will be separate.
		     * You can also pass a regular expression to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {Array} [args] Optional array of arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emitEvent = function emitEvent(evt, args) {
		        var listenersMap = this.getListenersAsObject(evt);
		        var listeners;
		        var listener;
		        var i;
		        var key;
		        var response;

		        for (key in listenersMap) {
		            if (listenersMap.hasOwnProperty(key)) {
		                listeners = listenersMap[key].slice(0);

		                for (i = 0; i < listeners.length; i++) {
		                    // If the listener returns true then it shall be removed from the event
		                    // The function is executed either with a basic call or an apply if there is an args array
		                    listener = listeners[i];

		                    if (listener.once === true) {
		                        this.removeListener(evt, listener.listener);
		                    }

		                    response = listener.listener.apply(this, args || []);

		                    if (response === this._getOnceReturnValue()) {
		                        this.removeListener(evt, listener.listener);
		                    }
		                }
		            }
		        }

		        return this;
		    };

		    /**
		     * Alias of emitEvent
		     */
		    proto.trigger = alias('emitEvent');

		    /**
		     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
		     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {...*} Optional additional arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emit = function emit(evt) {
		        var args = Array.prototype.slice.call(arguments, 1);
		        return this.emitEvent(evt, args);
		    };

		    /**
		     * Sets the current value to check against when executing listeners. If a
		     * listeners return value matches the one set here then it will be removed
		     * after execution. This value defaults to true.
		     *
		     * @param {*} value The new value to check for when executing listeners.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.setOnceReturnValue = function setOnceReturnValue(value) {
		        this._onceReturnValue = value;
		        return this;
		    };

		    /**
		     * Fetches the current value to check against when executing listeners. If
		     * the listeners return value matches this one then it should be removed
		     * automatically. It will return true by default.
		     *
		     * @return {*|Boolean} The current value to check for or the default, true.
		     * @api private
		     */
		    proto._getOnceReturnValue = function _getOnceReturnValue() {
		        if (this.hasOwnProperty('_onceReturnValue')) {
		            return this._onceReturnValue;
		        }
		        else {
		            return true;
		        }
		    };

		    /**
		     * Fetches the events object and creates one if required.
		     *
		     * @return {Object} The events storage object.
		     * @api private
		     */
		    proto._getEvents = function _getEvents() {
		        return this._events || (this._events = {});
		    };

		    /**
		     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
		     *
		     * @return {Function} Non conflicting EventEmitter class.
		     */
		    EventEmitter.noConflict = function noConflict() {
		        exports.EventEmitter = originalGlobalValue;
		        return EventEmitter;
		    };

		    // Expose the class either via AMD, CommonJS or the global object
		    if (module.exports){
		        module.exports = EventEmitter;
		    }
		    else {
		        exports.EventEmitter = EventEmitter;
		    }
		}(typeof window !== 'undefined' ? window : commonjsGlobal || {})); 
	} (EventEmitter$1));

	var EventEmitterExports = EventEmitter$1.exports;
	var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(EventEmitterExports);

	/*
		:property.sub1.func().funcProp
		 = return funcProp of function result of sub1 property of property of object
		:{::helperVal}.sub
		 = return sub property of object property with name retrieved from helperVal property of helpers object
		:{::helperFunc()}.sub
		= return sub property of object property with name retrieved from helperVal function result of helpers object.
		if helpersFunx return 'car' then source path becomes :car.sub

	*/

	const SUB_PATH_START = "{",
	    SUB_PATH_END = "}",
	    PATH_SPLIT = ".",
	    PATH_START_OBJECT = ":",
	    PATH_START_HELPERS = "::",
	    FUNCTION_MARKER = "()",
	    MAX_DEEP = 10;

	/**
	 * Set of tools to use notPath property access notation
	 * : is for item
	 * :: is for helpers
	 * {} subpath
	 * . path splitter
	 * () function and should be executed with params (item, helper | undefined)
	 * sub-paths will be parsed and replaced by results in source path
	 */
	let notPath$2 = class notPath {
	    static get SUB_PATH_START() {
	        return SUB_PATH_START;
	    }
	    static get SUB_PATH_END() {
	        return SUB_PATH_END;
	    }
	    static get PATH_SPLIT() {
	        return PATH_SPLIT;
	    }
	    static get PATH_START_OBJECT() {
	        return PATH_START_OBJECT;
	    }
	    static get PATH_START_HELPERS() {
	        return PATH_START_HELPERS;
	    }
	    static get FUNCTION_MARKER() {
	        return FUNCTION_MARKER;
	    }
	    static get MAX_DEEP() {
	        return MAX_DEEP;
	    }

	    /*
			input ':{::helperVal}.sub'
			return ::helperVal
		*/

	    /**
	     * Returns first subpath in path
	     * if subpath not closed will return it anyway
	     * @param {string} path path in string notation
	     * @return {string|null} subpath or null if no sub path were found
	     */
	    static findNextSubPath(path) {
	        let subPath = "",
	            find = false;
	        for (let i = 0; i < path.length; i++) {
	            if (path[i] === SUB_PATH_START) {
	                find = true;
	                subPath = "";
	            } else {
	                if (path[i] === SUB_PATH_END && find) {
	                    return subPath;
	                } else {
	                    subPath += path[i];
	                }
	            }
	        }
	        return find ? subPath : null;
	    }

	    /**
	     * Replace sub-path in parent path by parsed version
	     * @param {string} path path to process
	     * @param {string} sub sub path to replace
	     * @param {string} parsed parsed sub path
	     * @return {string} parsed path
	     */

	    static replaceSubPath(path, sub, parsed) {
	        let subf = SUB_PATH_START + sub + SUB_PATH_END,
	            i = 0;
	        while (path.indexOf(subf) > -1 && i < MAX_DEEP) {
	            path = path.replace(subf, parsed);
	            i++;
	        }
	        return path;
	    }

	    /**
	     * Parses path while there any sub-paths
	     * @param {string} path raw unparsed path
	     * @param {object} item data
	     * @param {object} helpers helpers
	     * @return {string} parsed path
	     */
	    static parseSubs(path, item, helpers) {
	        let subPath = this.findNextSubPath(path),
	            subPathParsed,
	            i = 0;
	        while (subPath) {
	            subPathParsed = this.getValueByPath(
	                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
	                subPath,
	                item,
	                helpers
	            );
	            path = this.replaceSubPath(path, subPath, subPathParsed);
	            i++;
	            if (i > MAX_DEEP) {
	                break;
	            }
	            subPath = this.findNextSubPath(path);
	        }
	        return path;
	    }

	    /**
	     * Get property value
	     * @param {string} path path to property
	     * @param {object} item item object
	     * @param {object} [helpers] helpers object
	     */

	    static get(path, item, helpers = undefined) {
	        switch (path) {
	            case PATH_START_OBJECT:
	                return item;
	            case PATH_START_HELPERS:
	                return helpers;
	        }
	        path = this.parseSubs(path, item, helpers);
	        return this.getValueByPath(
	            path.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
	            path,
	            item,
	            helpers
	        );
	    }

	    /**
	     * Set property value
	     * @param {string}  path path to property
	     * @param {object}  item item object
	     * @param {object}  helpers         helpers object if 4 arguments or attrValue if only 3 provided
	     * @param {any}     [attrValue]     value we want to assign
	     */

	    static set(path, item, helpers, attrValue = undefined) {
	        if (arguments.length === 3) {
	            attrValue = helpers;
	            helpers = undefined;
	        }
	        let subPath = this.findNextSubPath(path),
	            subPathParsed,
	            i = 0;
	        while (subPath) {
	            subPathParsed = this.getValueByPath(
	                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
	                subPath,
	                item,
	                helpers
	            );
	            path = this.replaceSubPath(path, subPath, subPathParsed);
	            if (i > MAX_DEEP) {
	                break;
	            }
	            subPath = this.findNextSubPath(path);
	            i++;
	        }
	        this.setValueByPath(item, path, attrValue);
	        if (
	            item.isRecord &&
	            this.normilizePath(path).length > 1 &&
	            item.__isActive
	        ) {
	            item.trigger("change", item, path, attrValue);
	        }
	    }

	    /**
	     * Set target property to null
	     * @param {string} path path to property
	     * @param {object} item item object
	     * @param {object} helpers helpers object
	     */

	    static unset(path, item, helpers) {
	        this.set(path, item, helpers, null);
	    }

	    /**
	     * Parses step key, transforms it to end-form
	     * @param {string} step not parsed step key
	     * @param {object} item item object
	     * @param {object} helper helpers object
	     * @return {string|number} parsed step key
	     */

	    static parsePathStep(step, item, helper) {
	        let rStep = null;
	        if (step.indexOf(PATH_START_HELPERS) === 0 && helper) {
	            rStep = step.replace(PATH_START_HELPERS, "");
	            if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
	                rStep = rStep.replace(FUNCTION_MARKER, "");
	                if (Object.prototype.hasOwnProperty.call(helper, rStep)) {
	                    return helper[rStep](item, undefined);
	                }
	            } else {
	                return helper[rStep];
	            }
	        } else {
	            if (step.indexOf(PATH_START_OBJECT) === 0 && item) {
	                rStep = step.replace(PATH_START_OBJECT, "");
	                if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
	                    rStep = rStep.replace(FUNCTION_MARKER, "");
	                    if (Object.prototype.hasOwnProperty.call(item, rStep)) {
	                        return item[rStep](item, undefined);
	                    }
	                } else {
	                    return item[rStep];
	                }
	            }
	        }
	        return step;
	    }

	    //::fieldName.result
	    //{}
	    //{fieldName: 'targetRecordField'}
	    ////['targetRecordField', 'result']
	    /**
	     * Transforms path with sub paths to path without
	     * @param {string|array} path path to target property
	     * @param {object} item item object
	     * @param {object} helper helper object
	     * @return {array} parsed path
	     **/
	    static parsePath(path, item, helper) {
	        if (!Array.isArray(path)) {
	            path = path.split(PATH_SPLIT);
	        }
	        for (var i = 0; i < path.length; i++) {
	            path[i] = this.parsePathStep(path[i], item, helper);
	        }
	        return path;
	    }

	    /**
	     * Transforms path from string notation to array of keys
	     * @param {string|array} path  input path, if array does nothing
	     * @return {array} path in array notation
	     */

	    static normilizePath(path) {
	        if (Array.isArray(path)) {
	            return path;
	        } else {
	            while (path.indexOf(PATH_START_OBJECT) > -1) {
	                path = path.replace(PATH_START_OBJECT, "");
	            }
	            return path.split(PATH_SPLIT);
	        }
	    }

	    /*
			small = ["todo"],
			big = ["todo", "length"]
			return true;

		*/

	    /**
	     * Identifies if first path includes second, compared from start,
	     * no floating start position inside ['join', 'me'], ['me']
	     * will result in false
	     * @param {array} big where we will search
	     * @param {array} small what we will search
	     * @return {boolean} if we succeed
	     */

	    static ifFullSubPath(big, small) {
	        if (big.length < small.length) {
	            return false;
	        }
	        for (let t = 0; t < small.length; t++) {
	            if (small[t] !== big[t]) {
	                return false;
	            }
	        }
	        return true;
	    }

	    /**
	     * Getter through third object
	     * Path is parsed, no event triggering for notRecord
	     * @param {object} object object to be used as getter
	     * @param {string|array} attrPath path to property
	     * @param {object} item supporting data
	     * @param {helpers} object  supporting helpers
	     */

	    static getValueByPath(object, attrPath, item, helpers) {
	        attrPath = this.normilizePath(attrPath);
	        let attrName = attrPath.shift(),
	            isFunction = attrName.indexOf(FUNCTION_MARKER) > -1;
	        if (isFunction) {
	            attrName = attrName.replace(FUNCTION_MARKER, "");
	        }
	        if (
	            (typeof object === "object" || typeof object === "function") &&
	            typeof object !== "undefined" &&
	            object !== null &&
	            typeof object[attrName] !== "undefined" &&
	            object[attrName] !== null
	        ) {
	            let newObj = isFunction
	                ? object[attrName]({
	                      item,
	                      helpers,
	                  })
	                : object[attrName];
	            if (attrPath.length > 0) {
	                return this.getValueByPath(newObj, attrPath, item, helpers);
	            } else {
	                return newObj;
	            }
	        } else {
	            return undefined;
	        }
	    }

	    /**
	     * Setter through third object
	     * Path is parsed, no event triggering for notRecord
	     * @param {object} object object to be modified
	     * @param {string|array} attrPath path to property
	     * @param {any} attrValue  value to assign
	     */

	    static setValueByPath(object, attrPath, attrValue) {
	        attrPath = this.normilizePath(attrPath);
	        let attrName = attrPath.shift();
	        if (attrPath.length > 0) {
	            if (!Object.prototype.hasOwnProperty.call(object, attrName)) {
	                object[attrName] = {};
	            }
	            this.setValueByPath(object[attrName], attrPath, attrValue);
	        } else {
	            object[attrName] = attrValue;
	        }
	    }

	    /**
	     * Joins passed in strings with PATH_SPLIT
	     * @param {string} arguments path to be glued
	     * @return {string} composite path
	     */

	    static join() {
	        let args = Array.prototype.slice.call(arguments);
	        return args.join(PATH_SPLIT);
	    }
	};

	var src$1 = notPath$2;

	var notPath = src$1;

	var notPath$1 = /*@__PURE__*/getDefaultExportFromCjs(notPath);

	/*
	https://github.com/TehShrike/is-mergeable-object

	Included for convinience only. All rights belongs to their authors and etc.
	start of my code marked.

	*/

	let isMergeableObject = function isMergeableObject(value) {
	    return isNonNullObject(value) && !isSpecial(value);
	};

	function isNonNullObject(value) {
	    return !!value && typeof value === "object";
	}

	function isSpecial(value) {
	    var stringValue = Object.prototype.toString.call(value);

	    return (
	        stringValue === "[object RegExp]" ||
	        stringValue === "[object Date]" ||
	        isReactElement(value)
	    );
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === "function" && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 0xeac7;

	function isReactElement(value) {
	    return value.$$typeof === REACT_ELEMENT_TYPE;
	}

	/*
	https://github.com/KyleAMathews/deepmerge

	The MIT License (MIT)

	Copyright (c) 2012 Nicholas Fisher

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/

	function emptyTarget(val) {
	    return Array.isArray(val) ? [] : {};
	}

	function cloneUnlessOtherwiseSpecified(value, optionsArgument) {
	    var clone = !optionsArgument || optionsArgument.clone !== false;

	    return clone && isMergeableObject(value)
	        ? deepmerge(emptyTarget(value), value, optionsArgument)
	        : value;
	}

	function defaultArrayMerge(target, source, optionsArgument) {
	    return target.concat(source).map(function (element) {
	        return cloneUnlessOtherwiseSpecified(element, optionsArgument);
	    });
	}

	function mergeObject(target, source, optionsArgument) {
	    var destination = {};
	    if (isMergeableObject(target)) {
	        Object.keys(target).forEach(function (key) {
	            destination[key] = cloneUnlessOtherwiseSpecified(
	                target[key],
	                optionsArgument
	            );
	        });
	    }
	    Object.keys(source).forEach(function (key) {
	        if (!isMergeableObject(source[key]) || !target[key]) {
	            destination[key] = cloneUnlessOtherwiseSpecified(
	                source[key],
	                optionsArgument
	            );
	        } else {
	            destination[key] = deepmerge(
	                target[key],
	                source[key],
	                optionsArgument
	            );
	        }
	    });
	    return destination;
	}

	function deepmerge(target, source, optionsArgument) {
	    var sourceIsArray = Array.isArray(source);
	    var targetIsArray = Array.isArray(target);
	    var options = optionsArgument || {
	        arrayMerge: defaultArrayMerge,
	    };
	    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	    if (!sourceAndTargetTypesMatch) {
	        return cloneUnlessOtherwiseSpecified(source, optionsArgument);
	    } else if (sourceIsArray) {
	        var arrayMerge = options.arrayMerge || defaultArrayMerge;
	        return arrayMerge(target, source, optionsArgument);
	    } else {
	        return mergeObject(target, source, optionsArgument);
	    }
	}

	deepmerge.all = function deepmergeAll(array, optionsArgument) {
	    if (!Array.isArray(array)) {
	        throw new Error("first argument should be an array");
	    }

	    return array.reduce(function (prev, next) {
	        return deepmerge(prev, next, optionsArgument);
	    }, {});
	};

	/**
	 *  Collection of common functions
	 *  @class
	 */
	let notCommon$3 = class notCommon {
	    /**
	     *  @static {Object} [MANAGER=null]  application manager, in some cases used to control initialization routine
	     */
	    static MANAGER = null;
	    /**
	     *  @static {string} [LOG="console"]  logger, window[LOG]
	     */
	    static LOG = "console";
	    /**
	     *  @static {function} deepMerge  function to perform deep merges of objects
	     */
	    static deepMerge = deepmerge;

	    /**
	     *  @static {function} isError  function to perform object test, if it's an error object or not
	     * @param   {object}    e   object to test
	     */
	    static isError(e) {
	        return (
	            e instanceof Error ||
	            (Object.hasOwn(e, "status") && e.status === "error")
	        );
	    }

	    static TZ_OFFSET = (new Date().getTimezoneOffset() / 60) * -1;
	    static DEV_ENV = "production";
	    // @ts-ignore
	    static ENV_TYPE = window.NOT_ENV_TYPE
	        ? // @ts-ignore
	          window.NOT_ENV_TYPE
	        : notCommon.DEV_ENV;
	    static NOOP = () => {};

	    static mute() {
	        notCommon.ENV_TYPE = "production";
	    }

	    static pad(n) {
	        return n < 10 ? "0" + n : n;
	    }
	    /**
	     *  Returns today Date object without hours, minutes, seconds
	     *  @return {number}  current date with 00:00:00 in ms of unix time
	     */
	    static getTodayDate() {
	        let t = new Date();
	        return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();
	    }

	    /**
	     *  Returns true if object has field of name
	     *   @param   {object}    obj    some object
	     *  @param  {string}    name  field name
	     *  @return {boolean}          if object contains field with name
	     **/
	    static objHas(obj, name) {
	        return Object.hasOwn(obj, name);
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	    static copyObj(obj) {
	        return JSON.parse(JSON.stringify(obj));
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	    static partCopyObj(obj, list) {
	        let partObj = Object.keys(obj).reduce((prev, curr) => {
	            if (list.includes(curr)) {
	                prev[curr] = obj[curr];
	            }
	            return prev;
	        }, {});
	        return JSON.parse(JSON.stringify(partObj));
	    }

	    static compareTwoArrays(a, b) {
	        return (
	            a.length === b.length &&
	            a.every((element, index) => element === b[index])
	        );
	    }

	    /**
	     * Test argument type to be 'function'
	     * @param {any}  func    possible function
	     * @return {boolean}     if this is a function
	     **/
	    static isFunc(func) {
	        return typeof func === "function";
	    }

	    /**
	     * Returns true if argument is Async function
	     * @param {function} func  to test
	     * @return {boolean}       if this function is constructed as AsyncFunction
	     **/
	    static isAsync(func) {
	        return func.constructor.name === "AsyncFunction";
	    }

	    /**
	     *  Executes method of object in appropriate way inside Promise
	     * @param {object}   obj     original object
	     * @param {string}   name    method name to execute
	     * @param {Array}     params  array of params
	     * @return {Promise}          results of method execution
	     **/
	    static async executeObjectFunction(obj, name, params) {
	        if (obj) {
	            const proc = notPath$1.get(":" + name, obj);
	            if (notCommon.isFunc(proc)) {
	                if (notCommon.isAsync(proc)) {
	                    return await proc(...params);
	                } else {
	                    return proc(...params);
	                }
	            }
	        }
	    }

	    /**
	     *  Executes method of object in apropriate way inside Promise
	     * @param {Object}   from     original object
	     * @param {Object}   to    method name to execute
	     * @param {Array}     list  array of params
	     * @return {undefined}          results of method execution
	     **/
	    static mapBind(from, to, list) {
	        list.forEach((item) => {
	            if (typeof from[item] === "function") {
	                to[item] = from[item].bind(from);
	            }
	        });
	    }

	    static isClass(fn) {
	        return /^\s*class/.test(fn.toString());
	    }

	    static detectType(testie) {
	        if (typeof testie !== "function") {
	            return typeof testie;
	        } else {
	            if (notCommon.isClass(testie)) {
	                return "class";
	            } else {
	                return "function";
	            }
	        }
	    }

	    //Проверка является ли переменная массивом
	    static isArray(data) {
	        return typeof data == "object" && data instanceof Array;
	    }

	    static localIsoDate(date) {
	        date = date || new Date();
	        let localIsoString =
	            date.getFullYear() +
	            "-" +
	            notCommon.pad(date.getMonth() + 1) +
	            "-" +
	            notCommon.pad(date.getDate()) +
	            "T" +
	            notCommon.pad(date.getHours()) +
	            ":" +
	            notCommon.pad(date.getMinutes()) +
	            ":" +
	            notCommon.pad(date.getSeconds());
	        return localIsoString;
	    }

	    static getToday() {
	        let today = new Date();
	        let date =
	            today.getFullYear() +
	            "-" +
	            notCommon.pad(today.getMonth() + 1) +
	            "-" +
	            notCommon.pad(today.getDate());
	        return date;
	    }

	    static backlog = [];

	    static backlogAdd(msg, type = "log") {
	        if (notCommon.get("backlog") === true) {
	            notCommon.backlog.push({ msg, type });
	        }
	    }

	    static dumpBacklog() {
	        while (notCommon.backlog.length) {
	            let row = notCommon.backlog.shift();
	            window[notCommon.LOG][row.type](...row.msg);
	        }
	    }

	    static logMsg() {
	        let now = notCommon.localIsoDate();
	        // eslint-disable-next-line no-console
	        window[notCommon.LOG].log(`[${now}]: `, ...arguments);
	        notCommon.backlogAdd([`[${now}]: `, ...arguments], "log");
	    }

	    static log() {
	        notCommon.logMsg(...arguments);
	    }

	    static createLogger(prefix) {
	        return {
	            log: notCommon.genLogMsg(prefix),
	            error: notCommon.genLogError(prefix),
	            debug: notCommon.genLogDebug(prefix),
	            report: notCommon.report,
	        };
	    }

	    //Генерация метода вывода сообщений в консоль с указанием префикса.
	    static genLogMsg(prefix) {
	        return function () {
	            //not arrow bc of arguments special var is not available in arrow functions
	            let now = notCommon.localIsoDate();
	            // eslint-disable-next-line no-console
	            window[notCommon.LOG].log(`[${now}]: ${prefix}::`, ...arguments);
	            notCommon.backlogAdd(
	                [`[${now}]: ${prefix}::`, ...arguments],
	                "log"
	            );
	        };
	    }

	    /**
	     * Определяет является ли окружение окружением разработки
	     * @returns  {boolean} true если это запущено в окружении разработки
	     **/
	    static isDev() {
	        return notCommon.ENV_TYPE === notCommon.DEV_ENV;
	    }

	    static debug() {
	        if (notCommon.isDev()) {
	            return notCommon.logMsg(...arguments);
	        } else {
	            return notCommon.NOOP;
	        }
	    }

	    static genLogDebug(prefix) {
	        if (notCommon.isDev()) {
	            return notCommon.genLogMsg(prefix);
	        } else {
	            return notCommon.NOOP;
	        }
	    }

	    static error() {
	        notCommon.logError(...arguments);
	    }

	    //Функция вывода сообщения об ошибке
	    static logError() {
	        let now = notCommon.localIsoDate();
	        // eslint-disable-next-line no-console
	        window[notCommon.LOG].error(`[${now}]: `, ...arguments);
	        notCommon.backlogAdd([`[${now}]: `, ...arguments], "error");
	    }

	    static genLogError(prefix) {
	        return function () {
	            //do not change to arrow function, bc of arguments
	            let now = notCommon.localIsoDate();
	            // eslint-disable-next-line no-console
	            window[notCommon.LOG].error(`[${now}]: ${prefix}::`, ...arguments);
	            notCommon.backlogAdd(
	                [`[${now}]: ${prefix}::`, ...arguments],
	                "error"
	            );
	        };
	    }

	    static report(e) {
	        if (notCommon.getApp()) {
	            let reporter = notCommon.getApp().getService("nsErrorReporter");
	            if (reporter) {
	                reporter.report(e).catch(notCommon.error);
	            }
	        } else {
	            if (!notCommon.get("production")) {
	                notCommon.error(...arguments);
	            }
	        }
	    }

	    static trace() {
	        if (!notCommon.get("production")) {
	            notCommon.trace(...arguments);
	        }
	    }

	    static trimBackslash(str) {
	        if (str.indexOf("/") === 0) {
	            str = str.substring(1);
	        }
	        if (str[str.length - 1] === "/") {
	            str = str.substring(0, str.length - 1);
	        }
	        return str;
	    }

	    /**
	     *  Builds URL with structure like prefix/module/model/id/action
	     * If some part absent or set to false it will be excluded from result
	     *  @param {object} urlParts
	     *  @param {string} [urlParts.prefix='']
	     *  @param {string} [urlParts.module='']
	     *  @param {string} [urlParts.model='']
	     *  @param {string} [urlParts.id='']
	     *  @param {string} [urlParts.action='']
	     *  @return {string}  url path
	     */
	    static buildURL(
	        { prefix, module, model, id, action } = {
	            prefix: "",
	            module: "",
	            model: "",
	            id: "",
	            action: "",
	        }
	    ) {
	        let url = ["/"];
	        if (prefix) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(prefix)));
	        }
	        if (module) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(module)));
	        }
	        if (model) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(model)));
	        }
	        if (id) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(id)));
	        }
	        if (action) {
	            url.push(encodeURIComponent(notCommon.trimBackslash(action)));
	        }
	        url = url.filter((el) => el !== "");
	        return url.join("/").replace(/\/\//g, "/");
	    }

	    static capitalizeFirstLetter(name) {
	        return name.charAt(0).toUpperCase() + name.slice(1);
	    }

	    static lowerFirstLetter(string) {
	        return string.charAt(0).toLowerCase() + string.slice(1);
	    }

	    static strLengthCap(str, MAX_TITLE_LENGTH = 50, POST_FIX = "...") {
	        if (typeof str === "string" && str.length > MAX_TITLE_LENGTH) {
	            return str.substr(0, MAX_TITLE_LENGTH) + POST_FIX;
	        } else {
	            return str;
	        }
	    }

	    static escapeHtml(unsafe) {
	        return unsafe
	            .replace(/&/g, "&amp;")
	            .replace(/</g, "&lt;")
	            .replace(/>/g, "&gt;")
	            .replace(/"/g, "&quot;")
	            .replace(/'/g, "&#039;");
	    }

	    static startApp(starter) {
	        document.addEventListener("DOMContentLoaded", starter);
	    }

	    static getApp() {
	        return notCommon.get("app");
	    }

	    static extendAppConfig(conf, conf2) {
	        return notCommon.deepMerge(conf, conf2);
	    }

	    static absorbModule() {
	        let defaultConf, //app options
	            mod, //module options
	            targets = {}; //various collections
	        if (arguments.length == 1) {
	            targets = { ...arguments[0] };
	            if (Object.hasOwnProperty.call(arguments[0], "defaultConf")) {
	                defaultConf = arguments[0].defaultConf;
	                delete targets.defaultConf;
	            }
	            if (Object.hasOwnProperty.call(arguments[0], "mod")) {
	                mod = arguments[0].mod;
	                delete targets.mod;
	            }
	        } else {
	            notCommon.log(
	                "WARNING: absorbModule format obsoleted, use object {defaultConf, mod, services, uis, wsc, etc}"
	            );
	            defaultConf = arguments[0];
	            mod = arguments[1];
	            if (arguments.length > 2) {
	                targets.services = arguments[2];
	            }
	            if (arguments.length > 3) {
	                targets.uis = arguments[3];
	            }
	            if (arguments.length > 4) {
	                targets.wcs = arguments[4];
	            }
	        }
	        for (let prop in mod) {
	            //add manifest to other
	            if (prop === "manifest") {
	                defaultConf = notCommon.extendAppConfig(
	                    defaultConf,
	                    mod.manifest
	                );
	                continue;
	            }
	            if (typeof notCommon.get(`absorb.${prop}`) === "function") {
	                if (!Object.hasOwn(targets, prop)) {
	                    targets[prop] = {};
	                    notCommon.log(
	                        `WARNING: no accamulator object provided for '${prop}' collection`
	                    );
	                }
	                notCommon.get(`absorb.${prop}`)(targets[prop], mod[prop]);
	            } else if (prop.indexOf("nc") === 0) {
	                if (!Object.hasOwn(defaultConf, "controllers")) {
	                    defaultConf.controllers = {};
	                }
	                defaultConf.controllers[prop] = mod[prop];
	            } else {
	                //in case of some other stuff presented, isolating it in special var
	                if (!Object.hasOwn(window, "notEnv")) {
	                    // @ts-ignore
	                    window.notEnv = {};
	                }
	                // @ts-ignore
	                window.notEnv[prop] = mod[prop];
	            }
	        }
	        return defaultConf;
	    }

	    static defineIfNotExists(obj, key, defaultValue) {
	        if (!Object.hasOwn(obj, key)) {
	            obj[key] = defaultValue;
	        }
	    }

	    static registry = {};

	    static register(key, val) {
	        notCommon.registry[key] = val;
	    }

	    static get(key) {
	        return Object.hasOwn(notCommon.registry, key)
	            ? notCommon.registry[key]
	            : null;
	    }

	    static moveItem(array, old_index, new_index) {
	        const inRange = (num) => num < array.length && num > -1;
	        if (inRange(new_index) && inRange(old_index)) {
	            array.splice(new_index, 0, array.splice(old_index, 1)[0]);
	        }
	    }

	    static stripProxy(obj) {
	        if (typeof obj !== "undefined" && obj !== null) {
	            if (obj.isProxy) {
	                if (Array.isArray(obj)) {
	                    obj = Array.from(obj);
	                } else {
	                    obj = Object.assign({}, obj);
	                }
	                for (let t in obj) {
	                    if (Object.hasOwn(obj, t)) {
	                        obj[t] = notCommon.stripProxy(obj[t]);
	                    }
	                }
	            }
	        }
	        return obj;
	    }

	    static pipe(data /* feed data */, funcs /* functions array */) {
	        let result;
	        for (let func of funcs) {
	            result = func(result || data);
	        }
	        return result;
	    }

	    static getAPI(type) {
	        return notCommon.getManager()
	            ? // @ts-ignore
	              notCommon.getManager()?.getAPI(type)
	            : null;
	    }

	    static setManager(v) {
	        notCommon.MANAGER = v;
	    }

	    static getManager() {
	        return notCommon.MANAGER;
	    }

	    static getJSON(url) {
	        return fetch(url).then((response) => response.json());
	    }

	    static wait(sec) {
	        return new Promise((res) => {
	            setTimeout(res, sec * 1000);
	        });
	    }

	    static registerWidgetEvents(events) {
	        if (notCommon.getApp()) {
	            Object.keys(events).forEach((eventName) => {
	                notCommon.getApp().on(eventName, events[eventName]);
	            });
	        }
	    }

	    static navigate(url) {
	        notCommon.getApp() &&
	            notCommon.getApp().getWorking("router").navigate(url);
	    }

	    static select(variantsSet, value, def) {
	        if (
	            variantsSet &&
	            typeof variantsSet == "object" &&
	            notCommon.objHas(variantsSet, value) &&
	            typeof variantsSet[value] !== "undefined" &&
	            variantsSet[value] !== null
	        ) {
	            return variantsSet[value];
	        } else {
	            return def;
	        }
	    }
	};

	function absorbServices(target, src) {
	    if (target) {
	        for (let serv in src) {
	            if (Object.hasOwn(target, serv)) {
	                notCommon$3.logError(`services property duplication ${serv}`);
	            }
	            target[serv] = src[serv];
	        }
	    }
	}

	function extendWSClient(wcs, wscName, wscOptions) {
	    if (!Object.hasOwn(wcs, wscName)) {
	        wcs[wscName] = {
	            connection: {},
	            router: {
	                routes: {},
	            },
	            messenger: {},
	        };
	    }
	    let target = wcs[wscName];
	    if (Object.hasOwn(wscOptions, "router")) {
	        if (Object.hasOwn(wscOptions.router, "routes")) {
	            for (let routeType in wscOptions.router.routes) {
	                if (!Object.hasOwn(target.router.routes, routeType)) {
	                    target.router.routes[routeType] = {};
	                }
	                Object.assign(target.router.routes[routeType], {
	                    ...wscOptions.router.routes[routeType],
	                });
	            }
	        }
	    }
	    if (Object.hasOwn(wscOptions, "messenger")) {
	        Object.assign(target.messenger, { ...wscOptions.messenger });
	    }
	    if (Object.hasOwn(wscOptions, "connection")) {
	        Object.assign(target.connection, { ...wscOptions.connection });
	    }
	    for (let t of ["name", "getToken", "logger", "identity", "credentials"]) {
	        if (Object.hasOwn(wscOptions, t)) {
	            target[t] = wscOptions[t];
	        }
	    }
	}

	function absorbWSC(target, src) {
	    if (target) {
	        for (let wsClientName in src) {
	            extendWSClient(target, wsClientName, src[wsClientName]);
	        }
	    }
	}

	function absorbUIs(target, src) {
	    if (target) {
	        for (let ui in src) {
	            if (Object.hasOwn(target, ui)) {
	                notCommon$3.logError(`uis property duplication ${ui}`);
	            }
	            target[ui] = src[ui];
	        }
	    }
	}

	function absorbFields(target, src) {
	    if (target) {
	        for (let ui in src) {
	            if (Object.hasOwn(target, ui)) {
	                notCommon$3.logError(`fields property duplication ${ui}`);
	            }
	            target[ui] = src[ui];
	        }
	    }
	}

	notCommon$3.register("absorb.wsc", absorbWSC);
	notCommon$3.register("absorb.services", absorbServices);
	notCommon$3.register("absorb.uis", absorbUIs);
	notCommon$3.register("absorb.uis", absorbFields);

	/**
	 * Purpose of this Locale object is that it will hold library of localization
	 * templates and provide basic localization service to other modules
	 **/


	/**
	 * strings localization and formating model
	 * @class
	 */
	class notLocale extends EventEmitter {
	    constructor() {
	        super();
	        this.dict = {}; //dictionary of phrases
	        this.helpers = {}; //additional helper functions and constants
	        let dict = this.restoreFromStorage();
	        if (dict) {
	            this.set(dict);
	        }
	    }

	    /**
	     * String format should comply notPath standart.
	     * {path_to_access} - is
	     * : - is used to access to params
	     * :: - is used to access to helpers
	     * Welcome, {:where}! - will replace {:where} with content of params.where
	     * Welcome, {::where}! - will replace {:where} with content of this.helpers.where
	     * () - after path is to invoke function of target object
	     * Welcome, {::where()}! - will try to exec this.helpers.where(params, undefined)
	     * @param    {string}  str         localized string template with mark to include data
	     * @param    {object}  params      params to use in string
	     * @returns  {string}              localized version of string with
	     */
	    format(str, params) {
	        return notPath$1.parseSubs(str, params, this.helpers);
	    }

	    /**
	     * Return localized version of string with injected data from provided object
	     * may also use Locale.helpers as source of data
	     * @param {string}   phrase    name of string to localize
	     * @param {object}   params    object with data to inject in phrase template
	     * @return {string}            localized string with injected data
	     */
	    say(phrase, params = false) {
	        try {
	            if (notCommon$3.objHas(this.dict, phrase)) {
	                let tmpl = this.dict[phrase],
	                    result = "";
	                if (params) {
	                    result = this.format(tmpl, params);
	                } else {
	                    result = tmpl;
	                }
	                return result;
	            } else {
	                throw new Error(`Unknown locale phrase: ${phrase}`);
	            }
	        } catch (e) {
	            notCommon$3.debug(e);
	            return phrase;
	        }
	    }

	    /**
	     * Setting new dictionary. triggers event 'change'
	     * @param {object}     dict      vocabulary of phrases and templates
	     **/
	    set(dict) {
	        LOCALE.set(dict);
	        this.saveToStorage(dict);
	        this.dict = Object.assign({}, { ...dict });
	        this.emit("change");
	    }

	    saveToStorage(dict) {
	        if (window.localStorage) {
	            try {
	                return window.localStorage.setItem(
	                    "dictionary",
	                    JSON.stringify(dict)
	                );
	            } catch (e) {
	                notCommon$3.debug(e);
	                return false;
	            }
	        }
	        return false;
	    }

	    restoreFromStorage() {
	        if (window.localStorage) {
	            try {
	                let str = window.localStorage.getItem("dictionary");
	                if (str) {
	                    let dict = JSON.parse(str);
	                    return dict;
	                } else {
	                    return false;
	                }
	            } catch (e) {
	                notCommon$3.debug(e);
	                return false;
	            }
	        }
	        return false;
	    }

	    /**
	     * Returns writable store of phrases
	     * @return {object}  writable store
	     */
	    vocabulary() {
	        return LOCALE;
	    }
	}

	var notLocale$1 = new notLocale();

	const say = notLocale$1.say.bind(notLocale$1);

	/* node_modules/not-bulma/src/elements/various/ui.tag.svelte generated by Svelte v4.2.19 */

	function create_if_block$X(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[13][/*title*/ ctx[0]] + "";
		let t;
		let span_id_value;
		let span_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "id", span_id_value = "tag-" + /*id*/ ctx[1]);

				attr(span, "class", span_class_value = "tag " + (/*bold*/ ctx[5] ? 'has-text-weight-bold' : '') + " " + (/*padding*/ ctx[4] !== 'normal'
				? `is-padded-${/*padding*/ ctx[4]}`
				: '') + " is-" + /*size*/ ctx[3] + " is-" + /*color*/ ctx[2] + " " + (/*sided*/ ctx[12] ? 'is-sided' : '') + " " + (/*right*/ ctx[6] ? 'is-sided-right' : '') + " " + (/*left*/ ctx[7] ? 'is-sided-left' : '') + " " + (/*top*/ ctx[8] ? 'is-sided-top' : '') + " " + (/*bottom*/ ctx[9] ? 'is-sided-bottom' : '') + " " + /*classes*/ ctx[10]);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);

				if (!mounted) {
					dispose = listen(span, "click", function () {
						if (is_function(/*action*/ ctx[11] ? /*action*/ ctx[11] : undefined)) (/*action*/ ctx[11] ? /*action*/ ctx[11] : undefined).apply(this, arguments);
					});

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty & /*$LOCALE, title*/ 8193 && t_value !== (t_value = /*$LOCALE*/ ctx[13][/*title*/ ctx[0]] + "")) set_data(t, t_value);

				if (dirty & /*id*/ 2 && span_id_value !== (span_id_value = "tag-" + /*id*/ ctx[1])) {
					attr(span, "id", span_id_value);
				}

				if (dirty & /*bold, padding, size, color, sided, right, left, top, bottom, classes*/ 6140 && span_class_value !== (span_class_value = "tag " + (/*bold*/ ctx[5] ? 'has-text-weight-bold' : '') + " " + (/*padding*/ ctx[4] !== 'normal'
				? `is-padded-${/*padding*/ ctx[4]}`
				: '') + " is-" + /*size*/ ctx[3] + " is-" + /*color*/ ctx[2] + " " + (/*sided*/ ctx[12] ? 'is-sided' : '') + " " + (/*right*/ ctx[6] ? 'is-sided-right' : '') + " " + (/*left*/ ctx[7] ? 'is-sided-left' : '') + " " + (/*top*/ ctx[8] ? 'is-sided-top' : '') + " " + (/*bottom*/ ctx[9] ? 'is-sided-bottom' : '') + " " + /*classes*/ ctx[10])) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$1B(ctx) {
		let if_block_anchor;
		let if_block = /*title*/ ctx[0] && create_if_block$X(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*title*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$X(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$1A($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let { id = "tagId" } = $$props;
		let { title = "tag" } = $$props;
		let { color = "info" } = $$props;
		let { size = "normal" } = $$props;
		let { padding = "normal" } = $$props;
		let { bold = false } = $$props;
		let { right = false } = $$props;
		let { left = false } = $$props;
		let { top = false } = $$props;
		let { bottom = false } = $$props;
		let { classes = "" } = $$props;
		let sided = false;
		let { events = {} } = $$props;
		let { register = notCommon$3.registerWidgetEvents.bind(notCommon$3) } = $$props;

		let { onUpdate = data => {
			if (Object.hasOwn(data, "title")) {
				$$invalidate(0, title = data.title);
			}
		} } = $$props;

		let { action = () => {
			return true;
		} } = $$props;

		function getStandartUpdateEventName() {
			return `tag-${id}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events, getStandartUpdateEventName())) {
				$$invalidate(14, events[getStandartUpdateEventName()] = onUpdate, events);
			}

			register(events);
		});

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(1, id = $$props.id);
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('color' in $$props) $$invalidate(2, color = $$props.color);
			if ('size' in $$props) $$invalidate(3, size = $$props.size);
			if ('padding' in $$props) $$invalidate(4, padding = $$props.padding);
			if ('bold' in $$props) $$invalidate(5, bold = $$props.bold);
			if ('right' in $$props) $$invalidate(6, right = $$props.right);
			if ('left' in $$props) $$invalidate(7, left = $$props.left);
			if ('top' in $$props) $$invalidate(8, top = $$props.top);
			if ('bottom' in $$props) $$invalidate(9, bottom = $$props.bottom);
			if ('classes' in $$props) $$invalidate(10, classes = $$props.classes);
			if ('events' in $$props) $$invalidate(14, events = $$props.events);
			if ('register' in $$props) $$invalidate(15, register = $$props.register);
			if ('onUpdate' in $$props) $$invalidate(16, onUpdate = $$props.onUpdate);
			if ('action' in $$props) $$invalidate(11, action = $$props.action);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*right, left, top, bottom*/ 960) {
				$$invalidate(12, sided = right || left || top || bottom);
			}
		};

		return [
			title,
			id,
			color,
			size,
			padding,
			bold,
			right,
			left,
			top,
			bottom,
			classes,
			action,
			sided,
			$LOCALE,
			events,
			register,
			onUpdate
		];
	}

	class Ui_tag extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1A, create_fragment$1B, safe_not_equal, {
				id: 1,
				title: 0,
				color: 2,
				size: 3,
				padding: 4,
				bold: 5,
				right: 6,
				left: 7,
				top: 8,
				bottom: 9,
				classes: 10,
				events: 14,
				register: 15,
				onUpdate: 16,
				action: 11
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.boolean.svelte generated by Svelte v4.2.19 */

	function create_fragment$1A(ctx) {
		let uitag;
		let current;
		const uitag_spread_levels = [/*tagValue*/ ctx[0]];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uitag_changes = (dirty & /*tagValue*/ 1)
				? get_spread_update(uitag_spread_levels, [get_spread_object(/*tagValue*/ ctx[0])])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	function instance$1z($$self, $$props, $$invalidate) {
		let tagValue;
		let { LC_TRUE = "not-node:booleans_true" } = $$props;
		let { LC_FALSE = "not-node:booleans_false" } = $$props;
		let { value } = $$props;
		let { inverted = false } = $$props;

		const FALSE_VALUE = {
			title: LC_FALSE,
			color: inverted ? "success" : "danger"
		};

		const TRUE_VALUE = {
			title: LC_TRUE,
			color: inverted ? "danger" : "success"
		};

		$$self.$$set = $$props => {
			if ('LC_TRUE' in $$props) $$invalidate(1, LC_TRUE = $$props.LC_TRUE);
			if ('LC_FALSE' in $$props) $$invalidate(2, LC_FALSE = $$props.LC_FALSE);
			if ('value' in $$props) $$invalidate(3, value = $$props.value);
			if ('inverted' in $$props) $$invalidate(4, inverted = $$props.inverted);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value*/ 8) {
				//if inverted === true, inverts value
				$$invalidate(0, tagValue = value ? TRUE_VALUE : FALSE_VALUE);
			}
		};

		return [tagValue, LC_TRUE, LC_FALSE, value, inverted];
	}

	class Ui_boolean extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1z, create_fragment$1A, safe_not_equal, {
				LC_TRUE: 1,
				LC_FALSE: 2,
				value: 3,
				inverted: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.boolean.labeled.svelte generated by Svelte v4.2.19 */

	function create_fragment$1z(ctx) {
		let span;
		let t0_value = /*$LOCALE*/ ctx[3][/*label*/ ctx[1]] + "";
		let t0;
		let t1;
		let uiboolean;
		let current;

		uiboolean = new Ui_boolean({
				props: {
					value: /*value*/ ctx[0],
					inverted: /*inverted*/ ctx[2]
				}
			});

		return {
			c() {
				span = element("span");
				t0 = text(t0_value);
				t1 = text(": ");
				create_component(uiboolean.$$.fragment);
				attr(span, "class", "label");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t0);
				append(span, t1);
				mount_component(uiboolean, span, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if ((!current || dirty & /*$LOCALE, label*/ 10) && t0_value !== (t0_value = /*$LOCALE*/ ctx[3][/*label*/ ctx[1]] + "")) set_data(t0, t0_value);
				const uiboolean_changes = {};
				if (dirty & /*value*/ 1) uiboolean_changes.value = /*value*/ ctx[0];
				if (dirty & /*inverted*/ 4) uiboolean_changes.inverted = /*inverted*/ ctx[2];
				uiboolean.$set(uiboolean_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiboolean.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiboolean.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				destroy_component(uiboolean);
			}
		};
	}

	function instance$1y($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { value } = $$props;
		let { label } = $$props;
		let { inverted = false } = $$props;

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
			if ('inverted' in $$props) $$invalidate(2, inverted = $$props.inverted);
		};

		return [value, label, inverted, $LOCALE];
	}

	class Ui_boolean_labeled extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1y, create_fragment$1z, safe_not_equal, { value: 0, label: 1, inverted: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.booleans.svelte generated by Svelte v4.2.19 */

	function get_each_context$o(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[3] = list[i];
		return child_ctx;
	}

	// (9:0) {#each values as item}
	function create_each_block$o(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*item*/ ctx[3],
			{
				inverted: /*inverted*/ ctx[1] || /*item*/ ctx[3].inverted
			}
		];

		var switch_value = /*componentConstructor*/ ctx[2];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*values, inverted*/ 3) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[3]),
					{
						inverted: /*inverted*/ ctx[1] || /*item*/ ctx[3].inverted
					}
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*componentConstructor*/ 4 && switch_value !== (switch_value = /*componentConstructor*/ ctx[2])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*values, inverted*/ 3)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[3]),
							{
								inverted: /*inverted*/ ctx[1] || /*item*/ ctx[3].inverted
							}
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1y(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$o(get_each_context$o(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*componentConstructor, values, inverted*/ 7) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$o(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$o(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$1x($$self, $$props, $$invalidate) {
		let { values = [] } = $$props;
		let { inverted = false } = $$props;
		let { componentConstructor = Ui_boolean } = $$props;

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
			if ('inverted' in $$props) $$invalidate(1, inverted = $$props.inverted);
			if ('componentConstructor' in $$props) $$invalidate(2, componentConstructor = $$props.componentConstructor);
		};

		return [values, inverted, componentConstructor];
	}

	class Ui_booleans extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1x, create_fragment$1y, safe_not_equal, {
				values: 0,
				inverted: 1,
				componentConstructor: 2
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.censored.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$K(ctx) {
		let span;
		let i;
		let i_class_value;
		let span_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*copyIcon*/ ctx[3]);

				attr(span, "class", span_class_value = "icon is-small is-right is-clickable " + (/*tooltipActive*/ ctx[10]
				? ` ${/*tooltipClass*/ ctx[8]} `
				: "") + " is-vertical-middle");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
				/*span_binding*/ ctx[18](span);

				if (!mounted) {
					dispose = listen(span, "click", /*copyContent*/ ctx[13]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*copyIcon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*copyIcon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}

				if (dirty & /*tooltipActive, tooltipClass*/ 1280 && span_class_value !== (span_class_value = "icon is-small is-right is-clickable " + (/*tooltipActive*/ ctx[10]
				? ` ${/*tooltipClass*/ ctx[8]} `
				: "") + " is-vertical-middle")) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				/*span_binding*/ ctx[18](null);
				mounted = false;
				dispose();
			}
		};
	}

	// (61:0) {#if showable}
	function create_if_block$W(ctx) {
		let span;
		let i;
		let i_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				i = element("i");

				attr(i, "class", i_class_value = "fas fa-" + (/*hidden*/ ctx[0]
				? /*showIcon*/ ctx[4]
				: /*hideIcon*/ ctx[5]));

				attr(span, "class", "icon is-small is-right is-clickable is-vertical-middle");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);

				if (!mounted) {
					dispose = listen(span, "click", /*toggleView*/ ctx[12]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*hidden, showIcon, hideIcon*/ 49 && i_class_value !== (i_class_value = "fas fa-" + (/*hidden*/ ctx[0]
				? /*showIcon*/ ctx[4]
				: /*hideIcon*/ ctx[5]))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$1x(ctx) {
		let span;
		let t0_value = (/*hidden*/ ctx[0] ? "" : /*value*/ ctx[9]) + "";
		let t0;
		let span_class_value;
		let span_style_value;
		let t1;
		let t2;
		let if_block1_anchor;
		let if_block0 = /*copiable*/ ctx[2] && create_if_block_1$K(ctx);
		let if_block1 = /*showable*/ ctx[1] && create_if_block$W(ctx);

		return {
			c() {
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();

				attr(span, "class", span_class_value = (/*hidden*/ ctx[0]
				? "is-censored " + /*shadowClass*/ ctx[7]
				: "") + " is-vertical-middle ");

				attr(span, "style", span_style_value = `display:inline-block; width: ${/*maxLength*/ ctx[6]}rem; height: var(--bulma-size-medium); overflow-x:hidden;`);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t0);
				insert(target, t1, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t2, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (dirty & /*hidden, value*/ 513 && t0_value !== (t0_value = (/*hidden*/ ctx[0] ? "" : /*value*/ ctx[9]) + "")) set_data(t0, t0_value);

				if (dirty & /*hidden, shadowClass*/ 129 && span_class_value !== (span_class_value = (/*hidden*/ ctx[0]
				? "is-censored " + /*shadowClass*/ ctx[7]
				: "") + " is-vertical-middle ")) {
					attr(span, "class", span_class_value);
				}

				if (dirty & /*maxLength*/ 64 && span_style_value !== (span_style_value = `display:inline-block; width: ${/*maxLength*/ ctx[6]}rem; height: var(--bulma-size-medium); overflow-x:hidden;`)) {
					attr(span, "style", span_style_value);
				}

				if (/*copiable*/ ctx[2]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$K(ctx);
						if_block0.c();
						if_block0.m(t2.parentNode, t2);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*showable*/ ctx[1]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$W(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
					detach(t1);
					detach(t2);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	function instance$1w($$self, $$props, $$invalidate) {
		let { hidden = true } = $$props;
		let { showable = true } = $$props;
		let { copiable = true } = $$props;
		let { copyIcon = "copy" } = $$props;
		let { showIcon = "eye" } = $$props;
		let { hideIcon = "eye-slash" } = $$props;
		let { maxLength = 20 } = $$props;
		let { shadowClass = "has-background-primary-90" } = $$props;
		let { tooltip = true } = $$props;
		let { tooltipTTL = 2000 } = $$props;
		let { tooltipText = "Скопировано в буфер" } = $$props;
		let { tooltipClass = "has-tooltip-info" } = $$props;
		let { value = "" } = $$props;

		function toggleView() {
			$$invalidate(0, hidden = !hidden);
		}

		let contentCopied = false, tooltipActive, tooltipTarget;

		async function copyContent() {
			try {
				await navigator.clipboard.writeText(value);

				if (tooltip) {
					$$invalidate(17, contentCopied = true);
					$$invalidate(11, tooltipTarget.dataset.tooltip = tooltipText, tooltipTarget);

					setTimeout(
						() => {
							$$invalidate(17, contentCopied = false);
							tooltipTarget.removeAttribute("data-tooltip");
						},
						tooltipTTL
					);
				}
			} catch(err) {
				console.error("Failed to copy: ", err);
			}
		}

		function span_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				tooltipTarget = $$value;
				$$invalidate(11, tooltipTarget);
			});
		}

		$$self.$$set = $$props => {
			if ('hidden' in $$props) $$invalidate(0, hidden = $$props.hidden);
			if ('showable' in $$props) $$invalidate(1, showable = $$props.showable);
			if ('copiable' in $$props) $$invalidate(2, copiable = $$props.copiable);
			if ('copyIcon' in $$props) $$invalidate(3, copyIcon = $$props.copyIcon);
			if ('showIcon' in $$props) $$invalidate(4, showIcon = $$props.showIcon);
			if ('hideIcon' in $$props) $$invalidate(5, hideIcon = $$props.hideIcon);
			if ('maxLength' in $$props) $$invalidate(6, maxLength = $$props.maxLength);
			if ('shadowClass' in $$props) $$invalidate(7, shadowClass = $$props.shadowClass);
			if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
			if ('tooltipTTL' in $$props) $$invalidate(15, tooltipTTL = $$props.tooltipTTL);
			if ('tooltipText' in $$props) $$invalidate(16, tooltipText = $$props.tooltipText);
			if ('tooltipClass' in $$props) $$invalidate(8, tooltipClass = $$props.tooltipClass);
			if ('value' in $$props) $$invalidate(9, value = $$props.value);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*tooltip, contentCopied*/ 147456) {
				$$invalidate(10, tooltipActive = tooltip && contentCopied);
			}
		};

		return [
			hidden,
			showable,
			copiable,
			copyIcon,
			showIcon,
			hideIcon,
			maxLength,
			shadowClass,
			tooltipClass,
			value,
			tooltipActive,
			tooltipTarget,
			toggleView,
			copyContent,
			tooltip,
			tooltipTTL,
			tooltipText,
			contentCopied,
			span_binding
		];
	}

	class Ui_censored extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1w, create_fragment$1x, safe_not_equal, {
				hidden: 0,
				showable: 1,
				copiable: 2,
				copyIcon: 3,
				showIcon: 4,
				hideIcon: 5,
				maxLength: 6,
				shadowClass: 7,
				tooltip: 14,
				tooltipTTL: 15,
				tooltipText: 16,
				tooltipClass: 8,
				value: 9
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.indicator.svelte generated by Svelte v4.2.19 */

	function create_fragment$1w(ctx) {
		let span;
		let t_value = /*labels*/ ctx[2][/*state*/ ctx[0]] + "";
		let t;
		let span_class_value;

		return {
			c() {
				span = element("span");
				t = text(t_value);

				attr(span, "class", span_class_value = "tag is-" + /*size*/ ctx[1] + " " + (/*bold*/ ctx[5] ? 'has-text-weight-bold' : '') + " " + (/*padding*/ ctx[4] !== 'normal'
				? `is-padded-${/*padding*/ ctx[4]}`
				: '') + " " + (/*sided*/ ctx[10] ? 'is-sided' : '') + " " + (/*right*/ ctx[6] ? 'is-sided-right' : '') + " " + (/*left*/ ctx[7] ? 'is-sided-left' : '') + " " + (/*top*/ ctx[8] ? 'is-sided-top' : '') + " " + (/*bottom*/ ctx[9] ? 'is-sided-bottom' : '') + " is-" + /*state*/ ctx[0] + " " + /*classes*/ ctx[3] + "");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, [dirty]) {
				if (dirty & /*labels, state*/ 5 && t_value !== (t_value = /*labels*/ ctx[2][/*state*/ ctx[0]] + "")) set_data(t, t_value);

				if (dirty & /*size, bold, padding, sided, right, left, top, bottom, state, classes*/ 2043 && span_class_value !== (span_class_value = "tag is-" + /*size*/ ctx[1] + " " + (/*bold*/ ctx[5] ? 'has-text-weight-bold' : '') + " " + (/*padding*/ ctx[4] !== 'normal'
				? `is-padded-${/*padding*/ ctx[4]}`
				: '') + " " + (/*sided*/ ctx[10] ? 'is-sided' : '') + " " + (/*right*/ ctx[6] ? 'is-sided-right' : '') + " " + (/*left*/ ctx[7] ? 'is-sided-left' : '') + " " + (/*top*/ ctx[8] ? 'is-sided-top' : '') + " " + (/*bottom*/ ctx[9] ? 'is-sided-bottom' : '') + " is-" + /*state*/ ctx[0] + " " + /*classes*/ ctx[3] + "")) {
					attr(span, "class", span_class_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function instance$1v($$self, $$props, $$invalidate) {
		let { id = "tagId" } = $$props;
		let { state = "light" } = $$props;
		let { size = "normal" } = $$props;

		let { labels = {
			black: "black",
			dark: "dark",
			light: "light",
			white: "white",
			primary: "primary",
			link: "link",
			info: "info",
			success: "success",
			warning: "warning",
			danger: "danger"
		} } = $$props;

		let { classes = "mx-1" } = $$props;
		let { padding = "normal" } = $$props;
		let { bold = false } = $$props;
		let { right = false } = $$props;
		let { left = false } = $$props;
		let { top = false } = $$props;
		let { bottom = false } = $$props;
		let sided = false;
		let { events = {} } = $$props;
		let { register = notCommon$3.registerWidgetEvents.bind(notCommon$3) } = $$props;

		let { onUpdate = data => {
			if (Object.hasOwn(data, "state")) {
				$$invalidate(0, state = data.state);
			}
		} } = $$props;

		function getStandartUpdateEventName() {
			return `indicator-${id}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events, getStandartUpdateEventName())) {
				$$invalidate(11, events[getStandartUpdateEventName()] = onUpdate, events);
			}

			register(events);
		});

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(12, id = $$props.id);
			if ('state' in $$props) $$invalidate(0, state = $$props.state);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
			if ('labels' in $$props) $$invalidate(2, labels = $$props.labels);
			if ('classes' in $$props) $$invalidate(3, classes = $$props.classes);
			if ('padding' in $$props) $$invalidate(4, padding = $$props.padding);
			if ('bold' in $$props) $$invalidate(5, bold = $$props.bold);
			if ('right' in $$props) $$invalidate(6, right = $$props.right);
			if ('left' in $$props) $$invalidate(7, left = $$props.left);
			if ('top' in $$props) $$invalidate(8, top = $$props.top);
			if ('bottom' in $$props) $$invalidate(9, bottom = $$props.bottom);
			if ('events' in $$props) $$invalidate(11, events = $$props.events);
			if ('register' in $$props) $$invalidate(13, register = $$props.register);
			if ('onUpdate' in $$props) $$invalidate(14, onUpdate = $$props.onUpdate);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*right, left, top, bottom*/ 960) {
				$$invalidate(10, sided = right || left || top || bottom);
			}
		};

		return [
			state,
			size,
			labels,
			classes,
			padding,
			bold,
			right,
			left,
			top,
			bottom,
			sided,
			events,
			id,
			register,
			onUpdate
		];
	}

	class Ui_indicator extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1v, create_fragment$1w, safe_not_equal, {
				id: 12,
				state: 0,
				size: 1,
				labels: 2,
				classes: 3,
				padding: 4,
				bold: 5,
				right: 6,
				left: 7,
				top: 8,
				bottom: 9,
				events: 11,
				register: 13,
				onUpdate: 14
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.loader.svelte generated by Svelte v4.2.19 */

	function create_if_block$V(ctx) {
		let div;
		let span;
		let t_value = /*$LOCALE*/ ctx[3][/*title*/ ctx[2]] + "";
		let t;
		let div_class_value;

		return {
			c() {
				div = element("div");
				span = element("span");
				t = text(t_value);
				attr(span, "class", "title");

				attr(div, "class", div_class_value = "" + ((/*size*/ ctx[1] === 'page'
				? 'pageloader'
				: 'containerloader') + " " + (/*loading*/ ctx[0] ? 'is-active' : '')));
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, title*/ 12 && t_value !== (t_value = /*$LOCALE*/ ctx[3][/*title*/ ctx[2]] + "")) set_data(t, t_value);

				if (dirty & /*size, loading*/ 3 && div_class_value !== (div_class_value = "" + ((/*size*/ ctx[1] === 'page'
				? 'pageloader'
				: 'containerloader') + " " + (/*loading*/ ctx[0] ? 'is-active' : '')))) {
					attr(div, "class", div_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$1v(ctx) {
		let if_block_anchor;
		let if_block = /*size*/ ctx[1] !== "hidden" && create_if_block$V(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*size*/ ctx[1] !== "hidden") {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$V(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$1u($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { loading = false } = $$props;
		let { size = "container" } = $$props;
		let { title = "Waiting..." } = $$props;

		$$self.$$set = $$props => {
			if ('loading' in $$props) $$invalidate(0, loading = $$props.loading);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
			if ('title' in $$props) $$invalidate(2, title = $$props.title);
		};

		return [loading, size, title, $LOCALE];
	}

	class Ui_loader extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1u, create_fragment$1v, safe_not_equal, { loading: 0, size: 1, title: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.select.option.svelte generated by Svelte v4.2.19 */

	function create_fragment$1u(ctx) {
		let option;
		let t_value = /*$LOCALE*/ ctx[3][/*title*/ ctx[1]] + "";
		let t;

		return {
			c() {
				option = element("option");
				t = text(t_value);
				option.__value = /*value*/ ctx[0];
				set_input_value(option, option.__value);
				option.selected = /*selected*/ ctx[2];
			},
			m(target, anchor) {
				insert(target, option, anchor);
				append(option, t);
			},
			p(ctx, [dirty]) {
				if (dirty & /*$LOCALE, title*/ 10 && t_value !== (t_value = /*$LOCALE*/ ctx[3][/*title*/ ctx[1]] + "")) set_data(t, t_value);

				if (dirty & /*value*/ 1) {
					option.__value = /*value*/ ctx[0];
					set_input_value(option, option.__value);
				}

				if (dirty & /*selected*/ 4) {
					option.selected = /*selected*/ ctx[2];
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	function instance$1t($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { value } = $$props;
		let { title } = $$props;
		let { selected } = $$props;

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('selected' in $$props) $$invalidate(2, selected = $$props.selected);
		};

		return [value, title, selected, $LOCALE];
	}

	class Ui_select_option extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1t, create_fragment$1u, safe_not_equal, { value: 0, title: 1, selected: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.errors.list.svelte generated by Svelte v4.2.19 */

	function get_each_context$n(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	// (9:0) {#if Array.isArray(errors) && errors.length}
	function create_if_block$U(ctx) {
		let p;
		let p_class_value;

		function select_block_type(ctx, dirty) {
			if (/*show*/ ctx[1]) return create_if_block_1$J;
			return create_else_block$B;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				p = element("p");
				if_block.c();
				attr(p, "class", p_class_value = "help " + /*classes*/ ctx[2]);
				attr(p, "id", /*id*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				if_block.m(p, null);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(p, null);
					}
				}

				if (dirty & /*classes*/ 4 && p_class_value !== (p_class_value = "help " + /*classes*/ ctx[2])) {
					attr(p, "class", p_class_value);
				}

				if (dirty & /*id*/ 8) {
					attr(p, "id", /*id*/ ctx[3]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}

				if_block.d();
			}
		};
	}

	// (15:8) {:else}
	function create_else_block$B(ctx) {
		let t;

		return {
			c() {
				t = text(" ");
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (11:8) {#if show}
	function create_if_block_1$J(ctx) {
		let each_1_anchor;
		let each_value = ensure_array_like(/*errors*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$n(get_each_context$n(ctx, each_value, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, errors*/ 17) {
					each_value = ensure_array_like(/*errors*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$n(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$n(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (12:12) {#each errors as error}
	function create_each_block$n(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[4][/*error*/ ctx[5]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, errors*/ 17 && t_value !== (t_value = /*$LOCALE*/ ctx[4][/*error*/ ctx[5]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$1t(ctx) {
		let show_if = Array.isArray(/*errors*/ ctx[0]) && /*errors*/ ctx[0].length;
		let if_block_anchor;
		let if_block = show_if && create_if_block$U(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (dirty & /*errors*/ 1) show_if = Array.isArray(/*errors*/ ctx[0]) && /*errors*/ ctx[0].length;

				if (show_if) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$U(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$1s($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(4, $LOCALE = $$value));
		let { errors = [] } = $$props;
		let { show = false } = $$props;
		let { classes = "" } = $$props;
		let { id = "errors-list" } = $$props;

		$$self.$$set = $$props => {
			if ('errors' in $$props) $$invalidate(0, errors = $$props.errors);
			if ('show' in $$props) $$invalidate(1, show = $$props.show);
			if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
			if ('id' in $$props) $$invalidate(3, id = $$props.id);
		};

		return [errors, show, classes, id, $LOCALE];
	}

	class Ui_errors_list extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1s, create_fragment$1t, safe_not_equal, { errors: 0, show: 1, classes: 2, id: 3 });
		}
	}

	let UICommon$1 = class UICommon {
	    static CLEAR_MACRO = "__CLEAR__";
	    static ERROR_DEFAULT = "Что пошло не так.";
	    static DEFAULT_REDIRECT_TIMEOUT = 3000;
	    static CLASS_OK = "is-success";
	    static CLASS_ERR = "is-danger";
	    static FILLER = "_";

	    static SCROLL_OPTIONS = {
	        top: 0,
	        behavior: "smooth",
	    };

	    /**
	     *  Reformats input from any string to strict phone format
	     *  @param {string}    val    free style phone number
	     *  @param {string}    [filler=UICommon.FILLER]    free style phone number
	     *  @returns {string}          phone number
	     **/
	    static formatPhone(val, filler = this.FILLER) {
	        //starting from 11 digits in phone number
	        const slots = [1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5];
	        let digits = val.replace(/\D/g, "");
	        //if there are more, move them to country code slot
	        if (digits.length > 11) {
	            let d = digits.length - 11;
	            while (d > 0) {
	                d--;
	                slots.unshift(1);
	            }
	        }
	        let stack = ["", "", "", "", ""];
	        Array.from(digits).forEach((digit, index) => {
	            let slot = slots[index];
	            stack[slot - 1] = stack[slot - 1] + digit;
	        });
	        //creating map of parts lengths
	        const lens = slots.reduce((acc, curr) => {
	            if (typeof acc[curr] === "undefined") {
	                acc[curr] = 1;
	            } else {
	                acc[curr] += 1;
	            }
	            return acc;
	        }, {});
	        //fill empty positions with filler (_)
	        for (let t in stack) {
	            let dif = lens[parseInt(t) + 1] - stack[t].length;
	            while (dif > 0) {
	                stack[t] = stack[t] + filler;
	                dif--;
	            }
	        }
	        return `+${stack[0]} (${stack[1]}) ${stack[2]}-${stack[3]}-${stack[4]}`;
	    }

	    static MONEY_SIGN = "&#8381;";

	    static setMoneySign(val) {
	        this.MONEY_SIGN = val;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {number} price
	     * @return {string}
	     * @memberof UICommon
	     */
	    static formatPrice(price) {
	        let major = Math.floor(price / 100),
	            minor = price % 100;
	        return `${this.MONEY_SIGN}${major.toString()}.${minor.toString()}`;
	    }

	    static formatLocaleDatetime(dt, opts = { date: true, time: true }) {
	        const date = dt.toLocaleDateString(window.navigator.language);
	        const time = dt.toLocaleTimeString(window.navigator.language);
	        if (opts.date && opts.time) {
	            return `${date} ${time}`;
	        } else if (opts.date && !opts.time) {
	            return date;
	        } else {
	            return time;
	        }
	    }

	    static tryFormatLocaleDateTime(value, opts = { date: true, time: true }) {
	        if (typeof value == "string" || typeof value == "number") {
	            const dt = new Date(value);
	            return UICommon.formatLocaleDatetime(dt, opts);
	        } else if (typeof value == "object") {
	            return UICommon.formatLocaleDatetime(value, opts);
	        } else {
	            return "";
	        }
	    }

	    static formatTimestamp(timestamp, offset = 0) {
	        let offsetLocal = new Date().getTimezoneOffset();
	        let deltaOffset = (offsetLocal - offset) * 60 * 1000;
	        let localDateTime = new Date(parseInt(timestamp) - deltaOffset);
	        return localDateTime.toLocaleString(window.navigator.language);
	    }

	    static TIME = {
	        SECONDS: ["секунду", "секунды", "секунд"],
	        MINUTES: ["минуту", "минуты", "минут"],
	        HOURS: ["час", "часа", "часов"],
	    };

	    static declOfNum(n, text_forms) {
	        n = Math.abs(n) % 100;
	        let n1 = n % 10;
	        if (n > 10 && n < 20) {
	            return text_forms[2];
	        }
	        if (n1 > 1 && n1 < 5) {
	            return text_forms[1];
	        }
	        if (n1 == 1) {
	            return text_forms[0];
	        }
	        return text_forms[2];
	    }

	    static humanizedTimeDiff(date /* unix time */) {
	        let currentTime = new Date().getTime();
	        let sec = Math.round((currentTime - date) / 1000);
	        let unit;
	        if (sec < 60) {
	            unit = this.declOfNum(sec, this.TIME.SECONDS);
	            return `${sec} ${unit} назад`;
	        } else if (sec < 3600) {
	            let min = Math.floor(sec / 60);
	            unit = this.declOfNum(min, this.TIME.MINUTES);
	            return `${min} ${unit} назад`;
	        } else {
	            let hours = Math.floor(sec / (60 * 60));
	            unit = this.declOfNum(hours, this.TIME.HOURS);
	            return `${hours} ${unit} назад`;
	        }
	    }
	};

	/* node_modules/not-bulma/src/elements/form/ui.select.svelte generated by Svelte v4.2.19 */

	function get_each_context_1$7(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[35] = list[i];
		return child_ctx;
	}

	function get_each_context$m(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[32] = list[i];
		return child_ctx;
	}

	// (128:4) {:else}
	function create_else_block_1$7(ctx) {
		let div;
		let select;
		let if_block0_anchor;
		let select_id_value;
		let select_size_value;
		let div_class_value;
		let t0;
		let t1;
		let if_block2_anchor;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*placeholder*/ ctx[2].length > 0 && create_if_block_7$5(ctx);
		let each_value_1 = ensure_array_like(/*variants*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block1 = /*icon*/ ctx[5] && create_if_block_5$8(ctx);
		let if_block2 = /*validated*/ ctx[11] === true && create_if_block_2$u(ctx);

		return {
			c() {
				div = element("div");
				select = element("select");
				if (if_block0) if_block0.c();
				if_block0_anchor = empty();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
				attr(select, "id", select_id_value = "form-field-select-" + /*fieldname*/ ctx[4]);
				attr(select, "name", /*fieldname*/ ctx[4]);
				attr(select, "readonly", /*readonly*/ ctx[7]);
				select.required = /*required*/ ctx[6];
				select.multiple = /*multiple*/ ctx[8];
				attr(select, "size", select_size_value = /*multiple*/ ctx[8] ? /*size*/ ctx[9] : false);
				attr(div, "class", div_class_value = "select " + /*validationClasses*/ ctx[14] + " " + /*multipleClass*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, select);
				if (if_block0) if_block0.m(select, null);
				append(select, if_block0_anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(select, null);
					}
				}

				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
				current = true;

				if (!mounted) {
					dispose = [
						listen(select, "blur", /*onBlur*/ ctx[19]),
						listen(select, "input", /*onInput*/ ctx[20])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (/*placeholder*/ ctx[2].length > 0) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*placeholder*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_7$5(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(select, if_block0_anchor);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (dirty[0] & /*variants, value, multiple*/ 259) {
					each_value_1 = ensure_array_like(/*variants*/ ctx[1]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$7(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$7(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(select, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty[0] & /*fieldname*/ 16 && select_id_value !== (select_id_value = "form-field-select-" + /*fieldname*/ ctx[4])) {
					attr(select, "id", select_id_value);
				}

				if (!current || dirty[0] & /*fieldname*/ 16) {
					attr(select, "name", /*fieldname*/ ctx[4]);
				}

				if (!current || dirty[0] & /*readonly*/ 128) {
					attr(select, "readonly", /*readonly*/ ctx[7]);
				}

				if (!current || dirty[0] & /*required*/ 64) {
					select.required = /*required*/ ctx[6];
				}

				if (!current || dirty[0] & /*multiple*/ 256) {
					select.multiple = /*multiple*/ ctx[8];
				}

				if (!current || dirty[0] & /*multiple, size*/ 768 && select_size_value !== (select_size_value = /*multiple*/ ctx[8] ? /*size*/ ctx[9] : false)) {
					attr(select, "size", select_size_value);
				}

				if (!current || dirty[0] & /*validationClasses, multipleClass*/ 24576 && div_class_value !== (div_class_value = "select " + /*validationClasses*/ ctx[14] + " " + /*multipleClass*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				if (/*icon*/ ctx[5]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_5$8(ctx);
						if_block1.c();
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*validated*/ ctx[11] === true) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_2$u(ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(if_block0);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t0);
					detach(t1);
					detach(if_block2_anchor);
				}

				if (if_block0) if_block0.d();
				destroy_each(each_blocks, detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (120:4) {#if readonly}
	function create_if_block$T(ctx) {
		let if_block_anchor;

		function select_block_type_1(ctx, dirty) {
			if (/*value*/ ctx[0]) return create_if_block_1$I;
			return create_else_block$A;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	// (140:16) {#if placeholder.length > 0}
	function create_if_block_7$5(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_8$3, create_else_block_3$1];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*value*/ ctx[0]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (146:20) {:else}
	function create_else_block_3$1(ctx) {
		let uiselectoption;
		let current;

		uiselectoption = new Ui_select_option({
				props: {
					value: UICommon$1.CLEAR_MACRO,
					selected: "selected",
					title: /*placeholder*/ ctx[2]
				}
			});

		return {
			c() {
				create_component(uiselectoption.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselectoption, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiselectoption_changes = {};
				if (dirty[0] & /*placeholder*/ 4) uiselectoption_changes.title = /*placeholder*/ ctx[2];
				uiselectoption.$set(uiselectoption_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselectoption.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselectoption.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselectoption, detaching);
			}
		};
	}

	// (141:20) {#if value}
	function create_if_block_8$3(ctx) {
		let uiselectoption;
		let current;

		uiselectoption = new Ui_select_option({
				props: {
					value: UICommon$1.CLEAR_MACRO,
					title: /*placeholder*/ ctx[2]
				}
			});

		return {
			c() {
				create_component(uiselectoption.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselectoption, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiselectoption_changes = {};
				if (dirty[0] & /*placeholder*/ 4) uiselectoption_changes.title = /*placeholder*/ ctx[2];
				uiselectoption.$set(uiselectoption_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselectoption.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselectoption.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselectoption, detaching);
			}
		};
	}

	// (161:20) {:else}
	function create_else_block_2$5(ctx) {
		let uiselectoption;
		let current;

		uiselectoption = new Ui_select_option({
				props: {
					value: /*variant*/ ctx[35].id,
					selected: /*value*/ ctx[0] == /*variant*/ ctx[35].id,
					title: /*variant*/ ctx[35].title
				}
			});

		return {
			c() {
				create_component(uiselectoption.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselectoption, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiselectoption_changes = {};
				if (dirty[0] & /*variants*/ 2) uiselectoption_changes.value = /*variant*/ ctx[35].id;
				if (dirty[0] & /*value, variants*/ 3) uiselectoption_changes.selected = /*value*/ ctx[0] == /*variant*/ ctx[35].id;
				if (dirty[0] & /*variants*/ 2) uiselectoption_changes.title = /*variant*/ ctx[35].title;
				uiselectoption.$set(uiselectoption_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselectoption.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselectoption.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselectoption, detaching);
			}
		};
	}

	// (155:20) {#if multiple}
	function create_if_block_6$5(ctx) {
		let uiselectoption;
		let current;

		uiselectoption = new Ui_select_option({
				props: {
					value: /*variant*/ ctx[35].id,
					selected: /*value*/ ctx[0] && /*value*/ ctx[0].indexOf(/*variant*/ ctx[35].id) > -1,
					title: /*variant*/ ctx[35].title
				}
			});

		return {
			c() {
				create_component(uiselectoption.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselectoption, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiselectoption_changes = {};
				if (dirty[0] & /*variants*/ 2) uiselectoption_changes.value = /*variant*/ ctx[35].id;
				if (dirty[0] & /*value, variants*/ 3) uiselectoption_changes.selected = /*value*/ ctx[0] && /*value*/ ctx[0].indexOf(/*variant*/ ctx[35].id) > -1;
				if (dirty[0] & /*variants*/ 2) uiselectoption_changes.title = /*variant*/ ctx[35].title;
				uiselectoption.$set(uiselectoption_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselectoption.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselectoption.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselectoption, detaching);
			}
		};
	}

	// (154:16) {#each variants as variant}
	function create_each_block_1$7(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_6$5, create_else_block_2$5];
		const if_blocks = [];

		function select_block_type_3(ctx, dirty) {
			if (/*multiple*/ ctx[8]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_3(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_3(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (171:8) {#if icon}
	function create_if_block_5$8(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[5]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*icon*/ 32 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[5])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (176:8) {#if validated === true}
	function create_if_block_2$u(ctx) {
		let span;

		function select_block_type_4(ctx, dirty) {
			if (/*valid*/ ctx[10] === true) return create_if_block_3$p;
			if (/*valid*/ ctx[10] === false) return create_if_block_4$h;
		}

		let current_block_type = select_block_type_4(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_4(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (180:42) 
	function create_if_block_4$h(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (178:16) {#if valid === true}
	function create_if_block_3$p(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (125:8) {:else}
	function create_else_block$A(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[18][/*emptyValueTitle*/ ctx[3]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "class", "mr-2");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, emptyValueTitle*/ 262152 && t_value !== (t_value = /*$LOCALE*/ ctx[18][/*emptyValueTitle*/ ctx[3]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (121:8) {#if value}
	function create_if_block_1$I(ctx) {
		let each_1_anchor;
		let each_value = ensure_array_like(/*selectedVariants*/ ctx[12]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, selectedVariants*/ 266240) {
					each_value = ensure_array_like(/*selectedVariants*/ ctx[12]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$m(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$m(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (122:12) {#each selectedVariants as selectedVariant}
	function create_each_block$m(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[18][/*selectedVariant*/ ctx[32].title] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "class", "mr-2");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, selectedVariants*/ 266240 && t_value !== (t_value = /*$LOCALE*/ ctx[18][/*selectedVariant*/ ctx[32].title] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$1s(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		const if_block_creators = [create_if_block$T, create_else_block_1$7];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[7]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[25](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[26](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[27](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[4]
		};

		if (/*allErrors*/ ctx[16] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[16];
		}

		if (/*showErrors*/ ctx[15] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[15];
		}

		if (/*validationClasses*/ ctx[14] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[14];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[17]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}

				if (!current || dirty[0] & /*iconClasses*/ 131072 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[17])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 16) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[4];

				if (!updating_errors && dirty[0] & /*allErrors*/ 65536) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[16];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 32768) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[15];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 16384) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[14];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$1r($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let validationClasses;
		let multipleClass;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(18, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { variants = [] } = $$props;
		let { placeholder = "" } = $$props;
		let { emptyValueTitle = "" } = $$props;
		let { fieldname = "select" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { multiple = false } = $$props;
		let { size = 8 } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let selectedVariants = [];

		function filterSelectedVariants(variant) {
			if (Array.isArray(value) && multiple) {
				return value.indexOf(variant.id) > -1;
			} else if (value) {
				return value == variant.id;
			} else {
				return false;
			}
		}

		let lastChange;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			if (lastChange === data.value) {
				return true;
			} else {
				if (Array.isArray(data.value) && notCommon$3.compareTwoArrays(lastChange, data.value)) {
					return true;
				}
			}

			if (multiple) {
				$$invalidate(0, value = Array.from(ev.target.selectedOptions).map(el => el.value));

				if (value.indexOf(UICommon$1.CLEAR_MACRO) > -1) {
					$$invalidate(0, value = []);
				}

				data.value = value;
			} else {
				if (data.value === UICommon$1.CLEAR_MACRO) {
					$$invalidate(0, value = "");
				} else {
					$$invalidate(0, value = data.value);
				}
			}

			$$invalidate(21, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			if (multiple) {
				$$invalidate(0, value = Array.from(ev.target.selectedOptions).map(el => el.value));

				if (value.indexOf(UICommon$1.CLEAR_MACRO) > -1) {
					$$invalidate(0, value = []);
				}

				data.value = value;
			} else {
				if (data.value === UICommon$1.CLEAR_MACRO) {
					$$invalidate(0, value = "");
				} else {
					$$invalidate(0, value = data.value);
				}
			}

			$$invalidate(21, inputStarted = true);
			lastChange = data.value;
			dispatch("change", data);
			return true;
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(16, allErrors), $$invalidate(22, errors)), $$invalidate(23, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(15, showErrors), $$invalidate(11, validated)), $$invalidate(10, valid)), $$invalidate(21, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(14, validationClasses), $$invalidate(10, valid)), $$invalidate(21, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(21, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('variants' in $$props) $$invalidate(1, variants = $$props.variants);
			if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
			if ('emptyValueTitle' in $$props) $$invalidate(3, emptyValueTitle = $$props.emptyValueTitle);
			if ('fieldname' in $$props) $$invalidate(4, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(5, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(6, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(7, readonly = $$props.readonly);
			if ('multiple' in $$props) $$invalidate(8, multiple = $$props.multiple);
			if ('size' in $$props) $$invalidate(9, size = $$props.size);
			if ('valid' in $$props) $$invalidate(10, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(11, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(22, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(23, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(24, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 32) {
				$$invalidate(17, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 12582912) {
				$$invalidate(16, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 2100224) {
				$$invalidate(15, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 16778240) ;

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 2098176) {
				$$invalidate(14, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}

			if ($$self.$$.dirty[0] & /*multiple*/ 256) {
				$$invalidate(13, multipleClass = multiple ? " is-multiple " : "");
			}

			if ($$self.$$.dirty[0] & /*value, variants*/ 3) {
				{

					$$invalidate(12, selectedVariants = Array.isArray(variants)
					? variants.filter(filterSelectedVariants)
					: []);
				}
			}
		};

		return [
			value,
			variants,
			placeholder,
			emptyValueTitle,
			fieldname,
			icon,
			required,
			readonly,
			multiple,
			size,
			valid,
			validated,
			selectedVariants,
			multipleClass,
			validationClasses,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_select extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$1r,
				create_fragment$1s,
				safe_not_equal,
				{
					inputStarted: 21,
					value: 0,
					variants: 1,
					placeholder: 2,
					emptyValueTitle: 3,
					fieldname: 4,
					icon: 5,
					required: 6,
					readonly: 7,
					multiple: 8,
					size: 9,
					valid: 10,
					validated: 11,
					errors: 22,
					formErrors: 23,
					formLevelError: 24
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.button.svelte generated by Svelte v4.2.19 */

	function create_else_block$z(ctx) {
		let t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[0]] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, title*/ 32769 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[0]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (54:8) {#if icon}
	function create_if_block$S(ctx) {
		let t0;
		let t1;
		let if_block2_anchor;
		let if_block0 = /*iconSide*/ ctx[14] === "left" && create_if_block_3$o(ctx);
		let if_block1 = /*title*/ ctx[0] && create_if_block_2$t(ctx);
		let if_block2 = /*iconSide*/ ctx[14] === "right" && create_if_block_1$H(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*iconSide*/ ctx[14] === "left") {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$o(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*title*/ ctx[0]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$t(ctx);
						if_block1.c();
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*iconSide*/ ctx[14] === "right") {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_1$H(ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(if_block2_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
			}
		};
	}

	// (55:12) {#if iconSide === "left"}
	function create_if_block_3$o(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[13] + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : ''));
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon, size*/ 10240 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[13] + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : ''))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (62:12) {#if title}
	function create_if_block_2$t(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[0]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, title*/ 32769 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[0]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (65:12) {#if iconSide === "right"}
	function create_if_block_1$H(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[13] + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : ''));
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon, size*/ 10240 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[13] + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : ''))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (53:10)          
	function fallback_block$1(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*icon*/ ctx[13]) return create_if_block$S;
			return create_else_block$z;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function create_fragment$1r(ctx) {
		let button;
		let button_type_value;
		let button_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[20].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
		const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

		return {
			c() {
				button = element("button");
				if (default_slot_or_fallback) default_slot_or_fallback.c();
				button.disabled = /*disabled*/ ctx[7];
				attr(button, "type", button_type_value = /*type*/ ctx[9] ? /*type*/ ctx[9] : "");
				attr(button, "class", button_class_value = "button " + /*classes*/ ctx[12] + " " + (/*state*/ ctx[8] ? `is-${/*state*/ ctx[8]}` : '') + " " + (/*inverted*/ ctx[5] ? `is-inverted` : '') + " " + (/*outlined*/ ctx[4] ? `is-outlined` : '') + " " + (/*raised*/ ctx[3] ? `is-raised` : '') + " " + (/*rounded*/ ctx[6] ? `is-rounded` : '') + " " + (/*light*/ ctx[1] ? `is-light` : '') + " " + (/*loading*/ ctx[2] ? `is-loading` : '') + " " + (/*color*/ ctx[10] ? `is-${/*color*/ ctx[10]}` : '') + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : '') + "");
			},
			m(target, anchor) {
				insert(target, button, anchor);

				if (default_slot_or_fallback) {
					default_slot_or_fallback.m(button, null);
				}

				current = true;

				if (!mounted) {
					dispose = listen(button, "click", /*onClick*/ ctx[16]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[19],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
							null
						);
					}
				} else {
					if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*icon, size, iconSide, $LOCALE, title*/ 59393)) {
						default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
					}
				}

				if (!current || dirty & /*disabled*/ 128) {
					button.disabled = /*disabled*/ ctx[7];
				}

				if (!current || dirty & /*type*/ 512 && button_type_value !== (button_type_value = /*type*/ ctx[9] ? /*type*/ ctx[9] : "")) {
					attr(button, "type", button_type_value);
				}

				if (!current || dirty & /*classes, state, inverted, outlined, raised, rounded, light, loading, color, size*/ 7550 && button_class_value !== (button_class_value = "button " + /*classes*/ ctx[12] + " " + (/*state*/ ctx[8] ? `is-${/*state*/ ctx[8]}` : '') + " " + (/*inverted*/ ctx[5] ? `is-inverted` : '') + " " + (/*outlined*/ ctx[4] ? `is-outlined` : '') + " " + (/*raised*/ ctx[3] ? `is-raised` : '') + " " + (/*rounded*/ ctx[6] ? `is-rounded` : '') + " " + (/*light*/ ctx[1] ? `is-light` : '') + " " + (/*loading*/ ctx[2] ? `is-loading` : '') + " " + (/*color*/ ctx[10] ? `is-${/*color*/ ctx[10]}` : '') + " " + (/*size*/ ctx[11] ? `is-${/*size*/ ctx[11]}` : '') + "")) {
					attr(button, "class", button_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
				mounted = false;
				dispose();
			}
		};
	}

	function instance$1q($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(15, $LOCALE = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		const dispatch = createEventDispatcher();
		let { title = "" } = $$props;
		let { light = false } = $$props;
		let { loading = false } = $$props;
		let { raised = false } = $$props;
		let { outlined = false } = $$props;
		let { inverted = false } = $$props;
		let { rounded = false } = $$props;
		let { disabled = false } = $$props;
		let { state = "" } = $$props;
		let { type = "" } = $$props;
		let { color = "" } = $$props;
		let { size = "" } = $$props;
		let { classes = "" } = $$props;
		let { icon = false } = $$props;
		let { iconSide = "right" } = $$props;

		let { action = () => {
			return true;
		} } = $$props;

		let { value } = $$props;

		function onClick(event) {
			event.stopPropagation();
			dispatch("click", { event, value });
			return action(event, value);
		}

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('light' in $$props) $$invalidate(1, light = $$props.light);
			if ('loading' in $$props) $$invalidate(2, loading = $$props.loading);
			if ('raised' in $$props) $$invalidate(3, raised = $$props.raised);
			if ('outlined' in $$props) $$invalidate(4, outlined = $$props.outlined);
			if ('inverted' in $$props) $$invalidate(5, inverted = $$props.inverted);
			if ('rounded' in $$props) $$invalidate(6, rounded = $$props.rounded);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('state' in $$props) $$invalidate(8, state = $$props.state);
			if ('type' in $$props) $$invalidate(9, type = $$props.type);
			if ('color' in $$props) $$invalidate(10, color = $$props.color);
			if ('size' in $$props) $$invalidate(11, size = $$props.size);
			if ('classes' in $$props) $$invalidate(12, classes = $$props.classes);
			if ('icon' in $$props) $$invalidate(13, icon = $$props.icon);
			if ('iconSide' in $$props) $$invalidate(14, iconSide = $$props.iconSide);
			if ('action' in $$props) $$invalidate(17, action = $$props.action);
			if ('value' in $$props) $$invalidate(18, value = $$props.value);
			if ('$$scope' in $$props) $$invalidate(19, $$scope = $$props.$$scope);
		};

		return [
			title,
			light,
			loading,
			raised,
			outlined,
			inverted,
			rounded,
			disabled,
			state,
			type,
			color,
			size,
			classes,
			icon,
			iconSide,
			$LOCALE,
			onClick,
			action,
			value,
			$$scope,
			slots
		];
	}

	class Ui_button extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1q, create_fragment$1r, safe_not_equal, {
				title: 0,
				light: 1,
				loading: 2,
				raised: 3,
				outlined: 4,
				inverted: 5,
				rounded: 6,
				disabled: 7,
				state: 8,
				type: 9,
				color: 10,
				size: 11,
				classes: 12,
				icon: 13,
				iconSide: 14,
				action: 17,
				value: 18
			});
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.buttons.svelte generated by Svelte v4.2.19 */

	function get_each_context$l(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[9] = list[i];
		child_ctx[10] = list;
		child_ctx[11] = i;
		return child_ctx;
	}

	// (22:4) {#each values as item (item.id)}
	function create_each_block$l(key_1, ctx) {
		let first;
		let switch_instance;
		let updating_value;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*item*/ ctx[9],
			{
				action: /*item*/ ctx[9].action
				? /*item*/ ctx[9].action
				: /*action*/ ctx[5]
			}
		];

		function switch_instance_value_binding(value) {
			/*switch_instance_value_binding*/ ctx[6](value, /*item*/ ctx[9]);
		}

		var switch_value = /*buttonComponent*/ ctx[4];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*values, action*/ 33) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[9]),
					{
						action: /*item*/ ctx[9].action
						? /*item*/ ctx[9].action
						: /*action*/ ctx[5]
					}
				]));
			}

			if (/*item*/ ctx[9].value !== void 0) {
				switch_instance_props.value = /*item*/ ctx[9].value;
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
			switch_instance.$on("click", /*click_handler*/ ctx[7]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*buttonComponent*/ 16 && switch_value !== (switch_value = /*buttonComponent*/ ctx[4])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
						switch_instance.$on("click", /*click_handler*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*values, action*/ 33)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[9]),
							{
								action: /*item*/ ctx[9].action
								? /*item*/ ctx[9].action
								: /*action*/ ctx[5]
							}
						])
					: {};

					if (!updating_value && dirty & /*values*/ 1) {
						updating_value = true;
						switch_instance_changes.value = /*item*/ ctx[9].value;
						add_flush_callback(() => updating_value = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1q(ctx) {
		let div;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div_class_value;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[9].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$l(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$l(key, child_ctx));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", div_class_value = "buttons has-addons " + (/*centered*/ ctx[1] ? 'is-centered' : '') + " " + (/*right*/ ctx[2] ? 'is-right' : '') + " " + /*classes*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*buttonComponent, values, action*/ 49) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$l, null, get_each_context$l);
					check_outros();
				}

				if (!current || dirty & /*centered, right, classes*/ 14 && div_class_value !== (div_class_value = "buttons has-addons " + (/*centered*/ ctx[1] ? 'is-centered' : '') + " " + (/*right*/ ctx[2] ? 'is-right' : '') + " " + /*classes*/ ctx[3])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	function instance$1p($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { values = [] } = $$props;
		let { centered = false } = $$props;
		let { right = false } = $$props;
		let { classes = "" } = $$props;
		let { buttonComponent = Ui_button } = $$props;

		let { action = e => {
			dispatch("click", e);
		} } = $$props;

		function switch_instance_value_binding(value, item) {
			if ($$self.$$.not_equal(item.value, value)) {
				item.value = value;
				$$invalidate(0, values);
			}
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
			if ('centered' in $$props) $$invalidate(1, centered = $$props.centered);
			if ('right' in $$props) $$invalidate(2, right = $$props.right);
			if ('classes' in $$props) $$invalidate(3, classes = $$props.classes);
			if ('buttonComponent' in $$props) $$invalidate(4, buttonComponent = $$props.buttonComponent);
			if ('action' in $$props) $$invalidate(5, action = $$props.action);
		};

		return [
			values,
			centered,
			right,
			classes,
			buttonComponent,
			action,
			switch_instance_value_binding,
			click_handler
		];
	}

	class Ui_buttons extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1p, create_fragment$1q, safe_not_equal, {
				values: 0,
				centered: 1,
				right: 2,
				classes: 3,
				buttonComponent: 4,
				action: 5
			});
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.buttons.row.svelte generated by Svelte v4.2.19 */

	function create_fragment$1p(ctx) {
		let div3;
		let div0;
		let uibuttons0;
		let t0;
		let div1;
		let uibuttons1;
		let t1;
		let div2;
		let uibuttons2;
		let div3_class_value;
		let current;
		uibuttons0 = new Ui_buttons({ props: { values: /*left*/ ctx[1] } });

		uibuttons1 = new Ui_buttons({
				props: {
					values: /*center*/ ctx[2],
					centered: true
				}
			});

		uibuttons2 = new Ui_buttons({
				props: { values: /*right*/ ctx[3], right: true }
			});

		return {
			c() {
				div3 = element("div");
				div0 = element("div");
				create_component(uibuttons0.$$.fragment);
				t0 = space();
				div1 = element("div");
				create_component(uibuttons1.$$.fragment);
				t1 = space();
				div2 = element("div");
				create_component(uibuttons2.$$.fragment);
				attr(div0, "class", "column");
				attr(div1, "class", "column");
				attr(div2, "class", "column");
				attr(div3, "class", div3_class_value = "columns " + /*classes*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, div3, anchor);
				append(div3, div0);
				mount_component(uibuttons0, div0, null);
				append(div3, t0);
				append(div3, div1);
				mount_component(uibuttons1, div1, null);
				append(div3, t1);
				append(div3, div2);
				mount_component(uibuttons2, div2, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibuttons0_changes = {};
				if (dirty & /*left*/ 2) uibuttons0_changes.values = /*left*/ ctx[1];
				uibuttons0.$set(uibuttons0_changes);
				const uibuttons1_changes = {};
				if (dirty & /*center*/ 4) uibuttons1_changes.values = /*center*/ ctx[2];
				uibuttons1.$set(uibuttons1_changes);
				const uibuttons2_changes = {};
				if (dirty & /*right*/ 8) uibuttons2_changes.values = /*right*/ ctx[3];
				uibuttons2.$set(uibuttons2_changes);

				if (!current || dirty & /*classes*/ 1 && div3_class_value !== (div3_class_value = "columns " + /*classes*/ ctx[0])) {
					attr(div3, "class", div3_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons0.$$.fragment, local);
				transition_in(uibuttons1.$$.fragment, local);
				transition_in(uibuttons2.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons0.$$.fragment, local);
				transition_out(uibuttons1.$$.fragment, local);
				transition_out(uibuttons2.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div3);
				}

				destroy_component(uibuttons0);
				destroy_component(uibuttons1);
				destroy_component(uibuttons2);
			}
		};
	}

	function instance$1o($$self, $$props, $$invalidate) {
		let { classes = "" } = $$props;
		let { left = [] } = $$props;
		let { center = [] } = $$props;
		let { right = [] } = $$props;

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('left' in $$props) $$invalidate(1, left = $$props.left);
			if ('center' in $$props) $$invalidate(2, center = $$props.center);
			if ('right' in $$props) $$invalidate(3, right = $$props.right);
		};

		return [classes, left, center, right];
	}

	class Ui_buttons_row extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1o, create_fragment$1p, safe_not_equal, { classes: 0, left: 1, center: 2, right: 3 });
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.button.switch.svelte generated by Svelte v4.2.19 */

	function create_fragment$1o(ctx) {
		let uibutton;
		let current;

		let uibutton_props = {
			title: /*title*/ ctx[0],
			light: /*light*/ ctx[1],
			loading: /*loading*/ ctx[2],
			raised: /*raised*/ ctx[3],
			outlined: /*outlined*/ ctx[4],
			inverted: /*inverted*/ ctx[5],
			rounded: /*rounded*/ ctx[6],
			disabled: /*disabled*/ ctx[7],
			state: /*state*/ ctx[8],
			type: /*type*/ ctx[9],
			color: /*color*/ ctx[10],
			size: /*size*/ ctx[11],
			classes: /*classes*/ ctx[12],
			icon: /*icon*/ ctx[13],
			iconSide: /*iconSide*/ ctx[14],
			value: /*value*/ ctx[15]
		};

		uibutton = new Ui_button({ props: uibutton_props });
		/*uibutton_binding*/ ctx[22](uibutton);
		uibutton.$on("click", /*onClick*/ ctx[17]);

		return {
			c() {
				create_component(uibutton.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibutton_changes = {};
				if (dirty & /*title*/ 1) uibutton_changes.title = /*title*/ ctx[0];
				if (dirty & /*light*/ 2) uibutton_changes.light = /*light*/ ctx[1];
				if (dirty & /*loading*/ 4) uibutton_changes.loading = /*loading*/ ctx[2];
				if (dirty & /*raised*/ 8) uibutton_changes.raised = /*raised*/ ctx[3];
				if (dirty & /*outlined*/ 16) uibutton_changes.outlined = /*outlined*/ ctx[4];
				if (dirty & /*inverted*/ 32) uibutton_changes.inverted = /*inverted*/ ctx[5];
				if (dirty & /*rounded*/ 64) uibutton_changes.rounded = /*rounded*/ ctx[6];
				if (dirty & /*disabled*/ 128) uibutton_changes.disabled = /*disabled*/ ctx[7];
				if (dirty & /*state*/ 256) uibutton_changes.state = /*state*/ ctx[8];
				if (dirty & /*type*/ 512) uibutton_changes.type = /*type*/ ctx[9];
				if (dirty & /*color*/ 1024) uibutton_changes.color = /*color*/ ctx[10];
				if (dirty & /*size*/ 2048) uibutton_changes.size = /*size*/ ctx[11];
				if (dirty & /*classes*/ 4096) uibutton_changes.classes = /*classes*/ ctx[12];
				if (dirty & /*icon*/ 8192) uibutton_changes.icon = /*icon*/ ctx[13];
				if (dirty & /*iconSide*/ 16384) uibutton_changes.iconSide = /*iconSide*/ ctx[14];
				if (dirty & /*value*/ 32768) uibutton_changes.value = /*value*/ ctx[15];
				uibutton.$set(uibutton_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				/*uibutton_binding*/ ctx[22](null);
				destroy_component(uibutton, detaching);
			}
		};
	}

	function instance$1n($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { title = "" } = $$props;
		let { light = false } = $$props;
		let { loading = false } = $$props;
		let { raised = false } = $$props;
		let { outlined = false } = $$props;
		let { inverted = false } = $$props;
		let { rounded = false } = $$props;
		let { disabled = false } = $$props;
		let { state = "" } = $$props;
		let { type = "" } = $$props;
		let { color = "" } = $$props;
		let { size = "" } = $$props;
		let { classes = "" } = $$props;
		let { icon = false } = $$props;
		let { iconSide = "right" } = $$props;

		let { uiOff = () => {
			return { color: "" };
		} } = $$props;

		let { uiOn = () => {
			return { color: "success" };
		} } = $$props;

		let { action = () => {
			return !selected;
		} } = $$props;

		let { value } = $$props;
		let { selected = false } = $$props;

		function onClick(event) {
			$$invalidate(18, selected = action(event, value, selected));
			dispatch("click", { value, selected });
			onChange();
		}

		function onChange() {
			dispatch("change", { value, selected });
		}

		let uiElement;

		function uibutton_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				uiElement = $$value;
				$$invalidate(16, uiElement);
			});
		}

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('light' in $$props) $$invalidate(1, light = $$props.light);
			if ('loading' in $$props) $$invalidate(2, loading = $$props.loading);
			if ('raised' in $$props) $$invalidate(3, raised = $$props.raised);
			if ('outlined' in $$props) $$invalidate(4, outlined = $$props.outlined);
			if ('inverted' in $$props) $$invalidate(5, inverted = $$props.inverted);
			if ('rounded' in $$props) $$invalidate(6, rounded = $$props.rounded);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('state' in $$props) $$invalidate(8, state = $$props.state);
			if ('type' in $$props) $$invalidate(9, type = $$props.type);
			if ('color' in $$props) $$invalidate(10, color = $$props.color);
			if ('size' in $$props) $$invalidate(11, size = $$props.size);
			if ('classes' in $$props) $$invalidate(12, classes = $$props.classes);
			if ('icon' in $$props) $$invalidate(13, icon = $$props.icon);
			if ('iconSide' in $$props) $$invalidate(14, iconSide = $$props.iconSide);
			if ('uiOff' in $$props) $$invalidate(19, uiOff = $$props.uiOff);
			if ('uiOn' in $$props) $$invalidate(20, uiOn = $$props.uiOn);
			if ('action' in $$props) $$invalidate(21, action = $$props.action);
			if ('value' in $$props) $$invalidate(15, value = $$props.value);
			if ('selected' in $$props) $$invalidate(18, selected = $$props.selected);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*uiElement, selected, uiOn, uiOff*/ 1900544) {
				{
					if (uiElement) {
						selected
						? uiElement.$set(uiOn())
						: uiElement.$set(uiOff());
					}
				}
			}
		};

		return [
			title,
			light,
			loading,
			raised,
			outlined,
			inverted,
			rounded,
			disabled,
			state,
			type,
			color,
			size,
			classes,
			icon,
			iconSide,
			value,
			uiElement,
			onClick,
			selected,
			uiOff,
			uiOn,
			action,
			uibutton_binding
		];
	}

	class Ui_button_switch extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1n, create_fragment$1o, safe_not_equal, {
				title: 0,
				light: 1,
				loading: 2,
				raised: 3,
				outlined: 4,
				inverted: 5,
				rounded: 6,
				disabled: 7,
				state: 8,
				type: 9,
				color: 10,
				size: 11,
				classes: 12,
				icon: 13,
				iconSide: 14,
				uiOff: 19,
				uiOn: 20,
				action: 21,
				value: 15,
				selected: 18
			});
		}
	}

	/* node_modules/not-bulma/src/elements/button/ui.buttons.switchers.svelte generated by Svelte v4.2.19 */

	function get_each_context$k(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[21] = list[i];
		child_ctx[22] = list;
		child_ctx[23] = i;
		return child_ctx;
	}

	// (124:4) {#each values as item (item.id)}
	function create_each_block$k(key_1, ctx) {
		let first;
		let switch_instance;
		let updating_value;
		let updating_selected;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*item*/ ctx[21],
			{
				action: /*item*/ ctx[21].action
				? /*item*/ ctx[21].action
				: /*action*/ ctx[5]
			}
		];

		function switch_instance_value_binding(value) {
			/*switch_instance_value_binding*/ ctx[10](value, /*item*/ ctx[21]);
		}

		function switch_instance_selected_binding(value) {
			/*switch_instance_selected_binding*/ ctx[11](value, /*item*/ ctx[21]);
		}

		var switch_value = /*buttonComponent*/ ctx[4];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*values, action*/ 33) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[21]),
					{
						action: /*item*/ ctx[21].action
						? /*item*/ ctx[21].action
						: /*action*/ ctx[5]
					}
				]));
			}

			if (/*item*/ ctx[21].value !== void 0) {
				switch_instance_props.value = /*item*/ ctx[21].value;
			}

			if (/*item*/ ctx[21].selected !== void 0) {
				switch_instance_props.selected = /*item*/ ctx[21].selected;
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
			binding_callbacks.push(() => bind(switch_instance, 'selected', switch_instance_selected_binding));
			switch_instance.$on("click", /*click_handler*/ ctx[12]);
			switch_instance.$on("change", /*change_handler*/ ctx[13]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*buttonComponent*/ 16 && switch_value !== (switch_value = /*buttonComponent*/ ctx[4])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
						binding_callbacks.push(() => bind(switch_instance, 'selected', switch_instance_selected_binding));
						switch_instance.$on("click", /*click_handler*/ ctx[12]);
						switch_instance.$on("change", /*change_handler*/ ctx[13]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*values, action*/ 33)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*values*/ 1 && get_spread_object(/*item*/ ctx[21]),
							{
								action: /*item*/ ctx[21].action
								? /*item*/ ctx[21].action
								: /*action*/ ctx[5]
							}
						])
					: {};

					if (!updating_value && dirty & /*values*/ 1) {
						updating_value = true;
						switch_instance_changes.value = /*item*/ ctx[21].value;
						add_flush_callback(() => updating_value = false);
					}

					if (!updating_selected && dirty & /*values*/ 1) {
						updating_selected = true;
						switch_instance_changes.selected = /*item*/ ctx[21].selected;
						add_flush_callback(() => updating_selected = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1n(ctx) {
		let div;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div_class_value;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[21].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$k(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$k(key, child_ctx));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", div_class_value = "buttons has-addons " + (/*centered*/ ctx[1] ? 'is-centered' : '') + " " + (/*right*/ ctx[2] ? 'is-right' : '') + " " + /*classes*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*buttonComponent, values, action*/ 49) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$k, null, get_each_context$k);
					check_outros();
				}

				if (!current || dirty & /*centered, right, classes*/ 14 && div_class_value !== (div_class_value = "buttons has-addons " + (/*centered*/ ctx[1] ? 'is-centered' : '') + " " + (/*right*/ ctx[2] ? 'is-right' : '') + " " + /*classes*/ ctx[3])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	function instance$1m($$self, $$props, $$invalidate) {
		createEventDispatcher();
		let { values = [] } = $$props;
		let { centered = false } = $$props;
		let { right = false } = $$props;
		let { classes = "" } = $$props;
		let { buttonComponent = Ui_button_switch } = $$props;

		function selectAll() {
			values.forEach(itm => {
				itm.selected = true;
			});

			$$invalidate(0, values);
		}

		function deselectAll() {
			values.forEach(itm => {
				itm.selected = false;
			});

			$$invalidate(0, values);
		}

		onMount(() => {
			if (min) {
				selectUpToMin(0, -1);
			}
		});

		function countSelected() {
			return values.filter(btn => btn.selected).length;
		}

		function selectUpToMin(cnt, indexOfCurrent) {
			let delta = min - cnt;

			if (!delta) {
				return;
			}

			for (let t in values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (!values[t].selected) {
					$$invalidate(0, values[t].selected = true, values);
					delta--;

					if (!delta) {
						break;
					}
				}
			}
		}

		function deselectDownToMin(cnt, indexOfCurrent) {
			let delta = cnt - max;

			if (!delta) {
				return;
			}

			for (let t in values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (values[t].selected) {
					$$invalidate(0, values[t].selected = false, values);
					delta--;

					if (!delta) {
						break;
					}
				}
			}
		}

		let { action = (ev, value, selected) => {
			let newSelected = !selected;
			const indexOfCurrent = values.indexOf(itm => itm.value === value);
			const cnt = countSelected() + (newSelected ? 1 : -1);

			if (min) {
				if (cnt < min) {
					selectUpToMin(cnt, indexOfCurrent);
					$$invalidate(0, values);
				}
			}

			if (max) {
				if (max < cnt) {
					deselectDownToMin(cnt, indexOfCurrent);
					$$invalidate(0, values);
				}
			}

			return newSelected;
		} } = $$props;

		let { min = 0 } = $$props;
		let { max = 100 } = $$props;

		function switch_instance_value_binding(value, item) {
			if ($$self.$$.not_equal(item.value, value)) {
				item.value = value;
				$$invalidate(0, values);
			}
		}

		function switch_instance_selected_binding(value, item) {
			if ($$self.$$.not_equal(item.selected, value)) {
				item.selected = value;
				$$invalidate(0, values);
			}
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function change_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
			if ('centered' in $$props) $$invalidate(1, centered = $$props.centered);
			if ('right' in $$props) $$invalidate(2, right = $$props.right);
			if ('classes' in $$props) $$invalidate(3, classes = $$props.classes);
			if ('buttonComponent' in $$props) $$invalidate(4, buttonComponent = $$props.buttonComponent);
			if ('action' in $$props) $$invalidate(5, action = $$props.action);
			if ('min' in $$props) $$invalidate(8, min = $$props.min);
			if ('max' in $$props) $$invalidate(9, max = $$props.max);
		};

		return [
			values,
			centered,
			right,
			classes,
			buttonComponent,
			action,
			selectAll,
			deselectAll,
			min,
			max,
			switch_instance_value_binding,
			switch_instance_selected_binding,
			click_handler,
			change_handler
		];
	}

	class Ui_buttons_switchers extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1m, create_fragment$1n, safe_not_equal, {
				values: 0,
				centered: 1,
				right: 2,
				classes: 3,
				buttonComponent: 4,
				selectAll: 6,
				deselectAll: 7,
				action: 5,
				min: 8,
				max: 9
			});
		}

		get selectAll() {
			return this.$$.ctx[6];
		}

		get deselectAll() {
			return this.$$.ctx[7];
		}
	}

	var index$a = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIButton: Ui_button,
		UIButtonSwitch: Ui_button_switch,
		UIButtons: Ui_buttons,
		UIButtonsRow: Ui_buttons_row,
		UIButtonsSwitchers: Ui_buttons_switchers
	});

	const DEFAULT_STATUS_SUCCESS = "ok";

	const NAVIGATION_DELAY_SHORT = 500;
	const NAVIGATION_DELAY_NORMAL = 1500;
	const NAVIGATION_DELAY_LONG = 5000;

	const NAVIGATION_DELAYS = {
	    SHORT: NAVIGATION_DELAY_SHORT,
	    NORMAL: NAVIGATION_DELAY_NORMAL,
	    LONG: NAVIGATION_DELAY_LONG,
	};

	const NAVIGATION_DELAY_DEFAULT = NAVIGATION_DELAY_NORMAL;

	/* node_modules/not-bulma/src/elements/various/ui.select.from.model.on.demand.inline.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$G(ctx) {
		let div0;
		let uiselect;
		let t;
		let div1;
		let uibuttons;
		let current;

		uiselect = new Ui_select({
				props: {
					inputStarted: /*inputStarted*/ ctx[2],
					value: /*value*/ ctx[3],
					variants: /*variants*/ ctx[0],
					placeholder: /*placeholder*/ ctx[4],
					fieldname: /*fieldname*/ ctx[5],
					icon: /*icon*/ ctx[6],
					required: /*required*/ ctx[7],
					readonly: /*readonly*/ ctx[8],
					disabled: /*disabled*/ ctx[16],
					multiple: /*multiple*/ ctx[9],
					size: /*size*/ ctx[10],
					valid: /*valid*/ ctx[11],
					validated: /*validated*/ ctx[12],
					errors: /*errors*/ ctx[1],
					formErrors: /*formErrors*/ ctx[13],
					formLevelError: /*formLevelError*/ ctx[14]
				}
			});

		uiselect.$on("change", /*onModelChanged*/ ctx[17]);

		uibuttons = new Ui_buttons({
				props: {
					values: [/*ACTIONS*/ ctx[18].resolve, /*ACTIONS*/ ctx[18].reject]
				}
			});

		return {
			c() {
				div0 = element("div");
				create_component(uiselect.$$.fragment);
				t = space();
				div1 = element("div");
				create_component(uibuttons.$$.fragment);
				attr(div0, "class", "field has-addons");
				attr(div1, "class", "control");
			},
			m(target, anchor) {
				insert(target, div0, anchor);
				mount_component(uiselect, div0, null);
				insert(target, t, anchor);
				insert(target, div1, anchor);
				mount_component(uibuttons, div1, null);
				current = true;
			},
			p(ctx, dirty) {
				const uiselect_changes = {};
				if (dirty & /*inputStarted*/ 4) uiselect_changes.inputStarted = /*inputStarted*/ ctx[2];
				if (dirty & /*value*/ 8) uiselect_changes.value = /*value*/ ctx[3];
				if (dirty & /*variants*/ 1) uiselect_changes.variants = /*variants*/ ctx[0];
				if (dirty & /*placeholder*/ 16) uiselect_changes.placeholder = /*placeholder*/ ctx[4];
				if (dirty & /*fieldname*/ 32) uiselect_changes.fieldname = /*fieldname*/ ctx[5];
				if (dirty & /*icon*/ 64) uiselect_changes.icon = /*icon*/ ctx[6];
				if (dirty & /*required*/ 128) uiselect_changes.required = /*required*/ ctx[7];
				if (dirty & /*readonly*/ 256) uiselect_changes.readonly = /*readonly*/ ctx[8];
				if (dirty & /*disabled*/ 65536) uiselect_changes.disabled = /*disabled*/ ctx[16];
				if (dirty & /*multiple*/ 512) uiselect_changes.multiple = /*multiple*/ ctx[9];
				if (dirty & /*size*/ 1024) uiselect_changes.size = /*size*/ ctx[10];
				if (dirty & /*valid*/ 2048) uiselect_changes.valid = /*valid*/ ctx[11];
				if (dirty & /*validated*/ 4096) uiselect_changes.validated = /*validated*/ ctx[12];
				if (dirty & /*errors*/ 2) uiselect_changes.errors = /*errors*/ ctx[1];
				if (dirty & /*formErrors*/ 8192) uiselect_changes.formErrors = /*formErrors*/ ctx[13];
				if (dirty & /*formLevelError*/ 16384) uiselect_changes.formLevelError = /*formLevelError*/ ctx[14];
				uiselect.$set(uiselect_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselect.$$.fragment, local);
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselect.$$.fragment, local);
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div0);
					detach(t);
					detach(div1);
				}

				destroy_component(uiselect);
				destroy_component(uibuttons);
			}
		};
	}

	// (104:0) {#if state === "hidden"}
	function create_if_block$R(ctx) {
		let uibutton;
		let current;
		const uibutton_spread_levels = [/*ACTIONS*/ ctx[18].add];
		let uibutton_props = {};

		for (let i = 0; i < uibutton_spread_levels.length; i += 1) {
			uibutton_props = assign(uibutton_props, uibutton_spread_levels[i]);
		}

		uibutton = new Ui_button({ props: uibutton_props });

		return {
			c() {
				create_component(uibutton.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibutton_changes = (dirty & /*ACTIONS*/ 262144)
				? get_spread_update(uibutton_spread_levels, [get_spread_object(/*ACTIONS*/ ctx[18].add)])
				: {};

				uibutton.$set(uibutton_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibutton, detaching);
			}
		};
	}

	function create_fragment$1m(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$R, create_if_block_1$G];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*state*/ ctx[15] === "hidden") return 0;
			if (/*state*/ ctx[15] == "show") return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						} else {
							if_block.p(ctx, dirty);
						}

						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}
			}
		};
	}

	let loaded$1 = false;

	function instance$1l($$self, $$props, $$invalidate) {
		let disabled;
		const dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value } = $$props;
		let { variants = [] } = $$props;
		let { placeholder = "empty select item" } = $$props;
		let { fieldname = "selectFromModel" } = $$props;
		let { modelName = "" } = $$props;
		let { actionName = "" } = $$props;
		let { actionFilter = {} } = $$props;
		let { actionSorter = {} } = $$props;
		let { actionPager = {} } = $$props;
		let { actionSearch = undefined } = $$props;
		let { optionId = ":_id" } = $$props;
		let { optionTitle = ":title" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { multiple = false } = $$props;
		let { size = 8 } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function argumentsSetProvided() {
			return modelName && actionName && actionFilter;
		}

		let state = "hidden";
		let resultsList = [];

		onMount(async () => {
			if (argumentsSetProvided()) {
				const notApp = notCommon$3.getApp();
				const Model = notApp.getModel(modelName).setFilter(actionFilter).setSorter(actionSorter).setPager(actionPager).setSearch(actionSearch);
				const response = await Model[`$` + actionName]();

				if (response.status === DEFAULT_STATUS_SUCCESS) {
					resultsList = response.result;

					$$invalidate(0, variants = resultsList.map(item => {
						return {
							id: notPath$1.get(optionId, item),
							title: notPath$1.get(optionTitle, item)
						};
					}));
				} else {
					$$invalidate(1, errors = result.errors || [result.message]);
				}
			}
		});

		let resolvedValue;

		function onModelChanged({ detail }) {
			resolvedValue = resultsList.find(item => notPath$1.get(optionId, item) === detail.value);
		}

		const ACTIONS = {
			add: {
				color: "primary",
				icon: "plus",
				action() {
					$$invalidate(15, state = "show");
				}
			},
			resolve: {
				icon: "check",
				color: "primary",
				action() {
					$$invalidate(15, state = "hidden");
					dispatch("resolve", resolvedValue);
				}
			},
			reject: {
				icon: "close",
				color: "danger",
				action() {
					$$invalidate(15, state = "hidden");
					dispatch("reject");
				}
			}
		};

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(2, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(3, value = $$props.value);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(5, fieldname = $$props.fieldname);
			if ('modelName' in $$props) $$invalidate(19, modelName = $$props.modelName);
			if ('actionName' in $$props) $$invalidate(20, actionName = $$props.actionName);
			if ('actionFilter' in $$props) $$invalidate(21, actionFilter = $$props.actionFilter);
			if ('actionSorter' in $$props) $$invalidate(22, actionSorter = $$props.actionSorter);
			if ('actionPager' in $$props) $$invalidate(23, actionPager = $$props.actionPager);
			if ('actionSearch' in $$props) $$invalidate(24, actionSearch = $$props.actionSearch);
			if ('optionId' in $$props) $$invalidate(25, optionId = $$props.optionId);
			if ('optionTitle' in $$props) $$invalidate(26, optionTitle = $$props.optionTitle);
			if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(7, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(8, readonly = $$props.readonly);
			if ('multiple' in $$props) $$invalidate(9, multiple = $$props.multiple);
			if ('size' in $$props) $$invalidate(10, size = $$props.size);
			if ('valid' in $$props) $$invalidate(11, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(12, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(1, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(13, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(14, formLevelError = $$props.formLevelError);
		};

		$$invalidate(16, disabled = !loaded$1);

		return [
			variants,
			errors,
			inputStarted,
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			multiple,
			size,
			valid,
			validated,
			formErrors,
			formLevelError,
			state,
			disabled,
			onModelChanged,
			ACTIONS,
			modelName,
			actionName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch,
			optionId,
			optionTitle
		];
	}

	class Ui_select_from_model_on_demand_inline extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1l, create_fragment$1m, safe_not_equal, {
				inputStarted: 2,
				value: 3,
				variants: 0,
				placeholder: 4,
				fieldname: 5,
				modelName: 19,
				actionName: 20,
				actionFilter: 21,
				actionSorter: 22,
				actionPager: 23,
				actionSearch: 24,
				optionId: 25,
				optionTitle: 26,
				icon: 6,
				required: 7,
				readonly: 8,
				multiple: 9,
				size: 10,
				valid: 11,
				validated: 12,
				errors: 1,
				formErrors: 13,
				formLevelError: 14
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.select.from.model.with.search.modal.svelte generated by Svelte v4.2.19 */

	function create_fragment$1l(ctx) {
		let div;
		let uibuttons;
		let current;

		uibuttons = new Ui_buttons({
				props: {
					values: /*VISIBLE_BUTTONS*/ ctx[0],
					classes: "is-no-flex-wrap"
				}
			});

		return {
			c() {
				div = element("div");
				create_component(uibuttons.$$.fragment);
				attr(div, "class", "control");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uibuttons, div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibuttons_changes = {};
				if (dirty & /*VISIBLE_BUTTONS*/ 1) uibuttons_changes.values = /*VISIBLE_BUTTONS*/ ctx[0];
				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uibuttons);
			}
		};
	}

	function instance$1k($$self, $$props, $$invalidate) {
		let dispatch = createEventDispatcher();
		let { value } = $$props;
		let { inputStarted = false } = $$props;
		let { icon = false } = $$props;
		let { fieldname = "" } = $$props;
		let { readonly = false } = $$props;
		let { serviceName = "" } = $$props;
		let { serviceOpenSelectorMethod = "openSelector" } = $$props;
		let { serviceLoadDataMethod = "loadData" } = $$props;
		let { modelData = null } = $$props;
		let { loading = false } = $$props;
		let { selectedModelTitleFormatter = data => `${data._id}` } = $$props;
		let { loadingLabel = "not-node:loading_label" } = $$props;
		let { isEmptyLabel = "not-node:field_value_is_empty_placeholder" } = $$props;

		function getService() {
			if (!serviceName) throw new Error("serviceName is not set");
			return notCommon$3.getApp().getService(serviceName);
		}

		function openModelSearchAndSelect() {
			if (!serviceOpenSelectorMethod) {
				throw new Error("serviceOpenSelectorMethod is not set");
			}

			getService()[serviceOpenSelectorMethod]().then(results => {
				$$invalidate(1, value = results._id);
				$$invalidate(3, modelData = results);
				return value;
			}).then(value => {
				$$invalidate(2, inputStarted = true);
				dispatch("change", { field: fieldname, value });
			}).catch(e => {
				notCommon$3.report(e);
			});
		}

		function resetSelectedModel() {
			$$invalidate(1, value = undefined);
			$$invalidate(3, modelData = null);
			dispatch("change", { field: fieldname, value });
		}

		async function loadModelData() {
			try {
				if (value) {
					$$invalidate(4, loading = true);
					$$invalidate(3, modelData = await getService()[serviceLoadDataMethod](value));
				}
			} catch(e) {
				notCommon$3.report(e);
			} finally {
				$$invalidate(4, loading = false);
			}
		}

		onMount(() => {
			loadModelData();
		});

		const AVAILABLE_BUTTONS = [
			{
				id: 1,
				action: openModelSearchAndSelect,
				icon,
				color: "warning"
			},
			{
				id: 2,
				action: resetSelectedModel,
				icon: "times",
				color: "danger"
			}
		];

		function getModelButton() {
			if (loading) {
				return {
					disabled: true,
					loading,
					title: loadingLabel
				};
			} else {
				if (modelData) {
					return {
						disabled: readonly,
						action: openModelSearchAndSelect,
						title: selectedModelTitleFormatter(modelData)
					};
				} else {
					return { disabled: true, title: isEmptyLabel };
				}
			}
		}

		let VISIBLE_BUTTONS = [];

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(1, value = $$props.value);
			if ('inputStarted' in $$props) $$invalidate(2, inputStarted = $$props.inputStarted);
			if ('icon' in $$props) $$invalidate(5, icon = $$props.icon);
			if ('fieldname' in $$props) $$invalidate(6, fieldname = $$props.fieldname);
			if ('readonly' in $$props) $$invalidate(7, readonly = $$props.readonly);
			if ('serviceName' in $$props) $$invalidate(8, serviceName = $$props.serviceName);
			if ('serviceOpenSelectorMethod' in $$props) $$invalidate(9, serviceOpenSelectorMethod = $$props.serviceOpenSelectorMethod);
			if ('serviceLoadDataMethod' in $$props) $$invalidate(10, serviceLoadDataMethod = $$props.serviceLoadDataMethod);
			if ('modelData' in $$props) $$invalidate(3, modelData = $$props.modelData);
			if ('loading' in $$props) $$invalidate(4, loading = $$props.loading);
			if ('selectedModelTitleFormatter' in $$props) $$invalidate(11, selectedModelTitleFormatter = $$props.selectedModelTitleFormatter);
			if ('loadingLabel' in $$props) $$invalidate(12, loadingLabel = $$props.loadingLabel);
			if ('isEmptyLabel' in $$props) $$invalidate(13, isEmptyLabel = $$props.isEmptyLabel);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value, readonly*/ 130) {
				{
					if (value) {
						$$invalidate(0, VISIBLE_BUTTONS = [getModelButton(), ...readonly ? [] : AVAILABLE_BUTTONS]);
					} else {
						$$invalidate(0, VISIBLE_BUTTONS = [getModelButton(), ...readonly ? [] : [AVAILABLE_BUTTONS[0]]]);
					}
				}
			}
		};

		return [
			VISIBLE_BUTTONS,
			value,
			inputStarted,
			modelData,
			loading,
			icon,
			fieldname,
			readonly,
			serviceName,
			serviceOpenSelectorMethod,
			serviceLoadDataMethod,
			selectedModelTitleFormatter,
			loadingLabel,
			isEmptyLabel
		];
	}

	class Ui_select_from_model_with_search_modal extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1k, create_fragment$1l, safe_not_equal, {
				value: 1,
				inputStarted: 2,
				icon: 5,
				fieldname: 6,
				readonly: 7,
				serviceName: 8,
				serviceOpenSelectorMethod: 9,
				serviceLoadDataMethod: 10,
				modelData: 3,
				loading: 4,
				selectedModelTitleFormatter: 11,
				loadingLabel: 12,
				isEmptyLabel: 13
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.progress.svelte generated by Svelte v4.2.19 */

	function create_fragment$1k(ctx) {
		let progress;
		let t0;
		let t1;
		let progress_class_value;

		return {
			c() {
				progress = element("progress");
				t0 = text(/*value*/ ctx[0]);
				t1 = text("%");
				attr(progress, "class", progress_class_value = "progress " + /*classes*/ ctx[4] + " " + (/*color*/ ctx[2] ? `is-${/*color*/ ctx[2]}` : '') + " " + (/*size*/ ctx[3] ? `is-${/*size*/ ctx[3]}` : ''));
				progress.value = /*value*/ ctx[0];
				attr(progress, "max", /*max*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, progress, anchor);
				append(progress, t0);
				append(progress, t1);
			},
			p(ctx, [dirty]) {
				if (dirty & /*value*/ 1) set_data(t0, /*value*/ ctx[0]);

				if (dirty & /*classes, color, size*/ 28 && progress_class_value !== (progress_class_value = "progress " + /*classes*/ ctx[4] + " " + (/*color*/ ctx[2] ? `is-${/*color*/ ctx[2]}` : '') + " " + (/*size*/ ctx[3] ? `is-${/*size*/ ctx[3]}` : ''))) {
					attr(progress, "class", progress_class_value);
				}

				if (dirty & /*value*/ 1) {
					progress.value = /*value*/ ctx[0];
				}

				if (dirty & /*max*/ 2) {
					attr(progress, "max", /*max*/ ctx[1]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(progress);
				}
			}
		};
	}

	function instance$1j($$self, $$props, $$invalidate) {
		let { value } = $$props;
		let { max = 100 } = $$props;
		let { color = "" } = $$props;
		let { size = "" } = $$props;
		let { classes = "" } = $$props;

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('max' in $$props) $$invalidate(1, max = $$props.max);
			if ('color' in $$props) $$invalidate(2, color = $$props.color);
			if ('size' in $$props) $$invalidate(3, size = $$props.size);
			if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
		};

		return [value, max, color, size, classes];
	}

	class Ui_progress extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1j, create_fragment$1k, safe_not_equal, {
				value: 0,
				max: 1,
				color: 2,
				size: 3,
				classes: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.show.one.from.list.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$F(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		var switch_value = /*UIPlaceholder*/ ctx[2];

		function switch_props(ctx, dirty) {
			return {};
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props());
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*UIPlaceholder*/ 4 && switch_value !== (switch_value = /*UIPlaceholder*/ ctx[2])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props());
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (17:0) {#if active}
	function create_if_block$Q(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*active*/ ctx[0]];
		var switch_value = /*UIComponent*/ ctx[1];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*active*/ 1) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*active*/ ctx[0])]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*UIComponent*/ 2 && switch_value !== (switch_value = /*UIComponent*/ ctx[1])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*active*/ 1)
					? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*active*/ ctx[0])])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1j(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$Q, create_if_block_1$F];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*active*/ ctx[0]) return 0;
			if (/*UIPlaceholder*/ ctx[2]) return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						} else {
							if_block.p(ctx, dirty);
						}

						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}
			}
		};
	}

	function instance$1i($$self, $$props, $$invalidate) {
		const defaultFilter = value => value[idFieldName] === id;
		let { values = [] } = $$props;
		let { id } = $$props;
		let { UIComponent } = $$props;
		let { UIPlaceholder } = $$props;
		let { active } = $$props;
		let { idFieldName = "_id" } = $$props;
		let { filter = defaultFilter } = $$props;

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(3, values = $$props.values);
			if ('id' in $$props) $$invalidate(4, id = $$props.id);
			if ('UIComponent' in $$props) $$invalidate(1, UIComponent = $$props.UIComponent);
			if ('UIPlaceholder' in $$props) $$invalidate(2, UIPlaceholder = $$props.UIPlaceholder);
			if ('active' in $$props) $$invalidate(0, active = $$props.active);
			if ('idFieldName' in $$props) $$invalidate(5, idFieldName = $$props.idFieldName);
			if ('filter' in $$props) $$invalidate(6, filter = $$props.filter);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*values, id, filter*/ 88) {
				$$invalidate(0, active = Array.isArray(values) && values.length && typeof id !== "undefined"
				? values.find(filter || defaultFilter)
				: undefined);
			}
		};

		return [active, UIComponent, UIPlaceholder, values, id, idFieldName, filter];
	}

	class Ui_show_one_from_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1i, create_fragment$1j, safe_not_equal, {
				values: 3,
				id: 4,
				UIComponent: 1,
				UIPlaceholder: 2,
				active: 0,
				idFieldName: 5,
				filter: 6
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.tag.value.svelte generated by Svelte v4.2.19 */

	function create_if_block_2$s(ctx) {
		let uitag;
		let current;
		const uitag_spread_levels = [/*title*/ ctx[1]];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitag_changes = (dirty & /*title*/ 2)
				? get_spread_update(uitag_spread_levels, [get_spread_object(/*title*/ ctx[1])])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	// (18:4) {#if value}
	function create_if_block_1$E(ctx) {
		let uitag;
		let current;
		const uitag_spread_levels = [/*value*/ ctx[2]];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitag_changes = (dirty & /*value*/ 4)
				? get_spread_update(uitag_spread_levels, [get_spread_object(/*value*/ ctx[2])])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	// (19:4) {#if !readonly && actions && actions.length}
	function create_if_block$P(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ values: /*actions*/ ctx[3] }, /*actionsGroupProps*/ ctx[6]];
		var switch_value = /*actionsGroupContructor*/ ctx[5];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*actions, actionsGroupProps*/ 72) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*actions*/ 8 && { values: /*actions*/ ctx[3] },
					dirty & /*actionsGroupProps*/ 64 && get_spread_object(/*actionsGroupProps*/ ctx[6])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*actionsGroupContructor*/ 32 && switch_value !== (switch_value = /*actionsGroupContructor*/ ctx[5])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*actions, actionsGroupProps*/ 72)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*actions*/ 8 && { values: /*actions*/ ctx[3] },
							dirty & /*actionsGroupProps*/ 64 && get_spread_object(/*actionsGroupProps*/ ctx[6])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$1i(ctx) {
		let div;
		let t0;
		let t1;
		let div_class_value;
		let current;
		let if_block0 = /*title*/ ctx[1] && create_if_block_2$s(ctx);
		let if_block1 = /*value*/ ctx[2] && create_if_block_1$E(ctx);
		let if_block2 = !/*readonly*/ ctx[7] && /*actions*/ ctx[3] && /*actions*/ ctx[3].length && create_if_block$P(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(div, "class", div_class_value = "tags has-addons " + /*classes*/ ctx[4]);
				attr(div, "id", /*id*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				if (if_block1) if_block1.m(div, null);
				append(div, t1);
				if (if_block2) if_block2.m(div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*title*/ ctx[1]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*title*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$s(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*value*/ ctx[2]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*value*/ 4) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$E(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!/*readonly*/ ctx[7] && /*actions*/ ctx[3] && /*actions*/ ctx[3].length) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*readonly, actions*/ 136) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block$P(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*classes*/ 16 && div_class_value !== (div_class_value = "tags has-addons " + /*classes*/ ctx[4])) {
					attr(div, "class", div_class_value);
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	function instance$1h($$self, $$props, $$invalidate) {
		let { id = "taggedValueId" } = $$props;
		let { title } = $$props;
		let { value } = $$props;
		let { actions = [] } = $$props;
		let { classes = "" } = $$props;
		let { actionsGroupContructor = Ui_buttons } = $$props;
		let { actionsGroupProps = {} } = $$props;
		let { readonly = false } = $$props;

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('value' in $$props) $$invalidate(2, value = $$props.value);
			if ('actions' in $$props) $$invalidate(3, actions = $$props.actions);
			if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
			if ('actionsGroupContructor' in $$props) $$invalidate(5, actionsGroupContructor = $$props.actionsGroupContructor);
			if ('actionsGroupProps' in $$props) $$invalidate(6, actionsGroupProps = $$props.actionsGroupProps);
			if ('readonly' in $$props) $$invalidate(7, readonly = $$props.readonly);
		};

		return [
			id,
			title,
			value,
			actions,
			classes,
			actionsGroupContructor,
			actionsGroupProps,
			readonly
		];
	}

	class Ui_tag_value extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1h, create_fragment$1i, safe_not_equal, {
				id: 0,
				title: 1,
				value: 2,
				actions: 3,
				classes: 4,
				actionsGroupContructor: 5,
				actionsGroupProps: 6,
				readonly: 7
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.title.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$D(ctx) {
		let html_tag;
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(/*resultTitle*/ ctx[3], target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*resultTitle*/ 8) html_tag.p(/*resultTitle*/ ctx[3]);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	// (35:0) {#if subtitle}
	function create_if_block$O(ctx) {
		let html_tag;
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(/*resultSubtitle*/ ctx[2], target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*resultSubtitle*/ 4) html_tag.p(/*resultSubtitle*/ ctx[2]);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	function create_fragment$1h(ctx) {
		let t;
		let if_block1_anchor;
		let if_block0 = /*title*/ ctx[0] && create_if_block_1$D(ctx);
		let if_block1 = /*subtitle*/ ctx[1] && create_if_block$O(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*title*/ ctx[0]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$D(ctx);
						if_block0.c();
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*subtitle*/ ctx[1]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$O(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	function instance$1g($$self, $$props, $$invalidate) {
		let spacedStyle;
		let resultTitle;
		let resultSubtitle;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(12, $LOCALE = $$value));
		let { id = `title-${Math.random()}` } = $$props;
		let { title = "" } = $$props;
		let { subtitle } = $$props;
		let { size = 1 } = $$props;
		let { subsize } = $$props;
		let { spaced = false } = $$props;
		let { align = "left" } = $$props;

		const scrollToTop = (options = UICommon$1.SCROLL_OPTIONS) => {
			setTimeout(
				() => {
					document.getElementById(id).scrollIntoView(options);
				},
				100
			);
		};

		let size2;

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(4, id = $$props.id);
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('subtitle' in $$props) $$invalidate(1, subtitle = $$props.subtitle);
			if ('size' in $$props) $$invalidate(5, size = $$props.size);
			if ('subsize' in $$props) $$invalidate(6, subsize = $$props.subsize);
			if ('spaced' in $$props) $$invalidate(7, spaced = $$props.spaced);
			if ('align' in $$props) $$invalidate(8, align = $$props.align);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*subsize, size*/ 96) {
				$$invalidate(10, size2 = subsize
				? subsize
				: parseInt(size) < 6 ? parseInt(size) + 1 : size);
			}

			if ($$self.$$.dirty & /*spaced*/ 128) {
				$$invalidate(11, spacedStyle = spaced ? "is-spaced" : "");
			}

			if ($$self.$$.dirty & /*size, id, align, spacedStyle, $LOCALE, title*/ 6449) {
				$$invalidate(3, resultTitle = `<h${size} id="${id}" style="text-align: ${align};" class="title ${spacedStyle} is-${size}">${$LOCALE[title]}</h${size}>`);
			}

			if ($$self.$$.dirty & /*size2, id, align, $LOCALE, subtitle*/ 5394) {
				$$invalidate(2, resultSubtitle = `<h${size2} id="${id}" style="text-align: ${align};" class="subtitle is-${size2}">${$LOCALE[subtitle]}</h${size2}>`);
			}
		};

		return [
			title,
			subtitle,
			resultSubtitle,
			resultTitle,
			id,
			size,
			subsize,
			spaced,
			align,
			scrollToTop,
			size2,
			spacedStyle,
			$LOCALE
		];
	}

	class Ui_title extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1g, create_fragment$1h, safe_not_equal, {
				id: 4,
				title: 0,
				subtitle: 1,
				size: 5,
				subsize: 6,
				spaced: 7,
				align: 8,
				scrollToTop: 9
			});
		}

		get scrollToTop() {
			return this.$$.ctx[9];
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.user.card.svelte generated by Svelte v4.2.19 */

	function create_fragment$1g(ctx) {
		let article;
		let figure;
		let p0;
		let img;
		let img_src_value;
		let t0;
		let div1;
		let div0;
		let p1;
		let strong0;
		let t1;
		let t2;
		let small;
		let t4;
		let strong1;
		let t5;

		return {
			c() {
				article = element("article");
				figure = element("figure");
				p0 = element("p");
				img = element("img");
				t0 = space();
				div1 = element("div");
				div0 = element("div");
				p1 = element("p");
				strong0 = element("strong");
				t1 = text(/*username*/ ctx[0]);
				t2 = space();
				small = element("small");
				small.textContent = "@";
				t4 = space();
				strong1 = element("strong");
				t5 = text(/*role*/ ctx[1]);
				if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[2])) attr(img, "src", img_src_value);
				attr(img, "alt", /*username*/ ctx[0]);
				attr(p0, "class", "image is-32x32");
				attr(figure, "class", "media-left");
				attr(div0, "class", "content");
				attr(div1, "class", "media-content");
				attr(article, "id", /*getCompId*/ ctx[3]());
				attr(article, "class", "media");
			},
			m(target, anchor) {
				insert(target, article, anchor);
				append(article, figure);
				append(figure, p0);
				append(p0, img);
				append(article, t0);
				append(article, div1);
				append(div1, div0);
				append(div0, p1);
				append(p1, strong0);
				append(strong0, t1);
				append(p1, t2);
				append(p1, small);
				append(p1, t4);
				append(p1, strong1);
				append(strong1, t5);
			},
			p(ctx, [dirty]) {
				if (dirty & /*image*/ 4 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[2])) {
					attr(img, "src", img_src_value);
				}

				if (dirty & /*username*/ 1) {
					attr(img, "alt", /*username*/ ctx[0]);
				}

				if (dirty & /*username*/ 1) set_data(t1, /*username*/ ctx[0]);
				if (dirty & /*role*/ 2) set_data(t5, /*role*/ ctx[1]);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(article);
				}
			}
		};
	}

	function instance$1f($$self, $$props, $$invalidate) {
		let { id = "userCard" } = $$props;
		let { image = "https://bulma.io/images/placeholders/32x32.png" } = $$props;
		let { username = "John Doe" } = $$props;
		let { role = "admin" } = $$props;
		let { events = {} } = $$props;
		let { register = notCommon$3.registerWidgetEvents } = $$props;

		let { onUpdate = data => {
			if (Object.hasOwn(data, "username")) {
				$$invalidate(0, username = data.username);
			}

			if (Object.hasOwn(data, "role")) {
				$$invalidate(1, role = data.role);
			}
		} } = $$props;

		function getCompId() {
			return `usercard-${id}`;
		}

		function getStandartUpdateEventName() {
			let compId = getCompId();
			return `${compId}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events, getStandartUpdateEventName())) {
				$$invalidate(4, events[getStandartUpdateEventName()] = onUpdate, events);
			}

			register(events);
		});

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(5, id = $$props.id);
			if ('image' in $$props) $$invalidate(2, image = $$props.image);
			if ('username' in $$props) $$invalidate(0, username = $$props.username);
			if ('role' in $$props) $$invalidate(1, role = $$props.role);
			if ('events' in $$props) $$invalidate(4, events = $$props.events);
			if ('register' in $$props) $$invalidate(6, register = $$props.register);
			if ('onUpdate' in $$props) $$invalidate(7, onUpdate = $$props.onUpdate);
		};

		return [username, role, image, getCompId, events, id, register, onUpdate];
	}

	class Ui_user_card extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1f, create_fragment$1g, safe_not_equal, {
				id: 5,
				image: 2,
				username: 0,
				role: 1,
				events: 4,
				register: 6,
				onUpdate: 7
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.textfield.svelte generated by Svelte v4.2.19 */

	function create_else_block$y(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4$g(ctx);
		let if_block1 = /*validated*/ ctx[8] === true && create_if_block_1$C(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-textfield-" + /*fieldname*/ ctx[2]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[9]);
				attr(input, "type", "text");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[10]);
				input.disabled = /*disabled*/ ctx[5];
				input.required = /*required*/ ctx[4];
				input.readOnly = /*readonly*/ ctx[6];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[21]),
						listen(input, "change", /*onBlur*/ ctx[15]),
						listen(input, "input", /*onInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-textfield-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty & /*disabled*/ 32) {
					input.disabled = /*disabled*/ ctx[5];
				}

				if (dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (dirty & /*readonly*/ 64) {
					input.readOnly = /*readonly*/ ctx[6];
				}

				if (dirty & /*$LOCALE, placeholder*/ 16386 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$g(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[8] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$C(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (56:4) {#if readonly}
	function create_if_block$N(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (76:8) {#if icon}
	function create_if_block_4$g(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (81:8) {#if validated === true}
	function create_if_block_1$C(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[7] === true) return create_if_block_2$r;
			if (/*valid*/ ctx[7] === false) return create_if_block_3$n;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (85:42) 
	function create_if_block_3$n(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (83:16) {#if valid === true}
	function create_if_block_2$r(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$1f(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return create_if_block$N;
			return create_else_block$y;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$1e($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(14, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "input some text here, please" } = $$props;
		let { fieldname = "textfield" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur() /*ev*/ {
			let data = { field: fieldname, value };
			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(8, validated)), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(7, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(8, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 786432) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131456) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 1048704) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131200) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_textfield extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1e, create_fragment$1f, safe_not_equal, {
				inputStarted: 17,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				disabled: 5,
				readonly: 6,
				valid: 7,
				validated: 8,
				errors: 18,
				formErrors: 19,
				formLevelError: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/various/ui.simple.search.input.svelte generated by Svelte v4.2.19 */

	function create_fragment$1e(ctx) {
		let div2;
		let div1;
		let div0;
		let uitextfield;
		let updating_value;
		let current;

		function uitextfield_value_binding(value) {
			/*uitextfield_value_binding*/ ctx[3](value);
		}

		let uitextfield_props = {
			placeholder: /*placeholder*/ ctx[1],
			fieldname: "searchTermInput",
			icon: "magnifying-glass"
		};

		if (/*term*/ ctx[0] !== void 0) {
			uitextfield_props.value = /*term*/ ctx[0];
		}

		uitextfield = new Ui_textfield({ props: uitextfield_props });
		binding_callbacks.push(() => bind(uitextfield, 'value', uitextfield_value_binding));
		uitextfield.$on("change", /*onChange*/ ctx[2]);

		return {
			c() {
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				create_component(uitextfield.$$.fragment);
				attr(div0, "class", "field");
				attr(div1, "class", "column");
				attr(div2, "class", "columns");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				append(div1, div0);
				mount_component(uitextfield, div0, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uitextfield_changes = {};
				if (dirty & /*placeholder*/ 2) uitextfield_changes.placeholder = /*placeholder*/ ctx[1];

				if (!updating_value && dirty & /*term*/ 1) {
					updating_value = true;
					uitextfield_changes.value = /*term*/ ctx[0];
					add_flush_callback(() => updating_value = false);
				}

				uitextfield.$set(uitextfield_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitextfield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitextfield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				destroy_component(uitextfield);
			}
		};
	}

	function instance$1d($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(4, $LOCALE = $$value));
		const dispatch = createEventDispatcher();
		let { placeholder = $LOCALE['not-node:field_search_placeholder'] } = $$props;
		let { term = '' } = $$props;

		function onChange({ detail }) {
			dispatch('termChange', detail);
		}

		function uitextfield_value_binding(value) {
			term = value;
			$$invalidate(0, term);
		}

		$$self.$$set = $$props => {
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('term' in $$props) $$invalidate(0, term = $$props.term);
		};

		return [term, placeholder, onChange, uitextfield_value_binding];
	}

	class Ui_simple_search_input extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1d, create_fragment$1e, safe_not_equal, { placeholder: 1, term: 0 });
		}
	}

	var index$9 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBoolean: Ui_boolean,
		UIBooleanLabeled: Ui_boolean_labeled,
		UIBooleans: Ui_booleans,
		UICensored: Ui_censored,
		UIErrorsList: Ui_errors_list,
		UIIndicator: Ui_indicator,
		UILoader: Ui_loader,
		UIProgress: Ui_progress,
		UISelectFromModelOnDemandInline: Ui_select_from_model_on_demand_inline,
		UISelectFromModelWithSearchModal: Ui_select_from_model_with_search_modal,
		UIShowOneFromList: Ui_show_one_from_list,
		UISimpleSearchInput: Ui_simple_search_input,
		UITag: Ui_tag,
		UITagValue: Ui_tag_value,
		UITitle: Ui_title,
		UIUserCard: Ui_user_card
	});

	/*
	Adapted from https://github.com/mattdesl
	Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
	*/

	/**
	 * https://svelte.dev/docs/svelte-easing
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicOut(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	/**
	 * The flip function calculates the start and end position of an element and animates between them, translating the x and y values.
	 * `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/).
	 *
	 * https://svelte.dev/docs/svelte-animate#flip
	 * @param {Element} node
	 * @param {{ from: DOMRect; to: DOMRect }} fromTo
	 * @param {import('./public.js').FlipParams} params
	 * @returns {import('./public.js').AnimationConfig}
	 */
	function flip(node, { from, to }, params = {}) {
		const style = getComputedStyle(node);
		const transform = style.transform === 'none' ? '' : style.transform;
		const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
		const dx = from.left + (from.width * ox) / to.width - (to.left + ox);
		const dy = from.top + (from.height * oy) / to.height - (to.top + oy);
		const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
		return {
			delay,
			duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
			easing,
			css: (t, u) => {
				const x = u * dx;
				const y = u * dy;
				const sx = t + (u * from.width) / to.width;
				const sy = t + (u * from.height) / to.height;
				return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
			}
		};
	}

	/**
	 * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.
	 *
	 * https://svelte.dev/docs/svelte-transition#fade
	 * @param {Element} node
	 * @param {import('./public').FadeParams} [params]
	 * @returns {import('./public').TransitionConfig}
	 */
	function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
		const o = +getComputedStyle(node).opacity;
		return {
			delay,
			duration,
			easing,
			css: (t) => `opacity: ${t * o}`
		};
	}

	/* node_modules/simple-svelte-autocomplete/src/SimpleAutocomplete.svelte generated by Svelte v4.2.19 */

	const { window: window_1 } = globals;

	const get_no_results_slot_changes = dirty => ({
		noResultsText: dirty[0] & /*noResultsText*/ 1024
	});

	const get_no_results_slot_context = ctx => ({ noResultsText: /*noResultsText*/ ctx[10] });

	const get_create_slot_changes = dirty => ({
		createText: dirty[0] & /*createText*/ 8192
	});

	const get_create_slot_context = ctx => ({ createText: /*createText*/ ctx[13] });

	const get_loading_slot_changes = dirty => ({
		loadingText: dirty[0] & /*loadingText*/ 2048
	});

	const get_loading_slot_context = ctx => ({ loadingText: /*loadingText*/ ctx[11] });

	const get_dropdown_footer_slot_changes = dirty => ({
		nbItems: dirty[1] & /*filteredListItems*/ 1,
		maxItemsToShowInList: dirty[0] & /*maxItemsToShowInList*/ 16
	});

	const get_dropdown_footer_slot_context = ctx => ({
		nbItems: /*filteredListItems*/ ctx[31].length,
		maxItemsToShowInList: /*maxItemsToShowInList*/ ctx[4]
	});

	function get_each_context$j(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[144] = list[i];
		child_ctx[146] = i;
		return child_ctx;
	}

	const get_item_slot_changes = dirty => ({
		item: dirty[1] & /*filteredListItems*/ 1,
		label: dirty[1] & /*filteredListItems*/ 1
	});

	const get_item_slot_context = ctx => ({
		item: /*listItem*/ ctx[144].item,
		label: /*listItem*/ ctx[144].highlighted
		? /*listItem*/ ctx[144].highlighted
		: /*listItem*/ ctx[144].label
	});

	const get_dropdown_header_slot_changes = dirty => ({
		nbItems: dirty[1] & /*filteredListItems*/ 1,
		maxItemsToShowInList: dirty[0] & /*maxItemsToShowInList*/ 16
	});

	const get_dropdown_header_slot_context = ctx => ({
		nbItems: /*filteredListItems*/ ctx[31].length,
		maxItemsToShowInList: /*maxItemsToShowInList*/ ctx[4]
	});

	function get_each_context_1$6(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[147] = list[i];
		child_ctx[146] = i;
		return child_ctx;
	}

	const get_tag_slot_changes = dirty => ({
		label: dirty[0] & /*selectedItem*/ 2,
		item: dirty[0] & /*selectedItem*/ 2
	});

	const get_tag_slot_context = ctx => ({
		label: /*safeLabelFunction*/ ctx[43](/*tagItem*/ ctx[147]),
		item: /*tagItem*/ ctx[147],
		unselectItem: /*unselectItem*/ ctx[50]
	});

	function get_each_context_2$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[146] = list[i];
		return child_ctx;
	}

	// (1125:39) 
	function create_if_block_11$2(ctx) {
		let each_1_anchor;
		let each_value_2 = ensure_array_like(/*selectedItem*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*valueFunction, selectedItem*/ 10 | dirty[1] & /*safeLabelFunction*/ 4096) {
					each_value_2 = ensure_array_like(/*selectedItem*/ ctx[1]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block_2$4(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value_2.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (1121:4) {#if !multiple && hasSelection}
	function create_if_block_10$2(ctx) {
		let option;
		let t_value = /*safeLabelFunction*/ ctx[43](/*selectedItem*/ ctx[1]) + "";
		let t;
		let option_value_value;

		return {
			c() {
				option = element("option");
				t = text(t_value);
				option.__value = option_value_value = /*valueFunction*/ ctx[3](/*selectedItem*/ ctx[1], true);
				set_input_value(option, option.__value);
				option.selected = true;
				attr(option, "class", "svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, option, anchor);
				append(option, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectedItem*/ 2 && t_value !== (t_value = /*safeLabelFunction*/ ctx[43](/*selectedItem*/ ctx[1]) + "")) set_data(t, t_value);

				if (dirty[0] & /*valueFunction, selectedItem*/ 10 && option_value_value !== (option_value_value = /*valueFunction*/ ctx[3](/*selectedItem*/ ctx[1], true))) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	// (1126:6) {#each selectedItem as i}
	function create_each_block_2$4(ctx) {
		let option;
		let t0_value = /*safeLabelFunction*/ ctx[43](/*i*/ ctx[146]) + "";
		let t0;
		let t1;
		let option_value_value;

		return {
			c() {
				option = element("option");
				t0 = text(t0_value);
				t1 = space();
				option.__value = option_value_value = /*valueFunction*/ ctx[3](/*i*/ ctx[146], true);
				set_input_value(option, option.__value);
				option.selected = true;
				attr(option, "class", "svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, option, anchor);
				append(option, t0);
				append(option, t1);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectedItem*/ 2 && t0_value !== (t0_value = /*safeLabelFunction*/ ctx[43](/*i*/ ctx[146]) + "")) set_data(t0, t0_value);

				if (dirty[0] & /*valueFunction, selectedItem*/ 10 && option_value_value !== (option_value_value = /*valueFunction*/ ctx[3](/*i*/ ctx[146], true))) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	// (1134:4) {#if multiple && hasSelection}
	function create_if_block_9$2(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let current;
		let each_value_1 = ensure_array_like(/*selectedItem*/ ctx[1]);
		const get_key = ctx => /*valueFunction*/ ctx[3](/*tagItem*/ ctx[147], true);

		for (let i = 0; i < each_value_1.length; i += 1) {
			let child_ctx = get_each_context_1$6(ctx, each_value_1, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block_1$6(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectedItem, valueFunction*/ 10 | dirty[1] & /*draggingOver, dragstart, dragover, dragleave, drop, unselectItem, safeLabelFunction*/ 503844992 | dirty[3] & /*$$scope*/ 8) {
					each_value_1 = ensure_array_like(/*selectedItem*/ ctx[1]);
					group_outros();
					for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block_1$6, each_1_anchor, get_each_context_1$6);
					for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	// (1146:92)              
	function fallback_block_5(ctx) {
		let div;
		let span0;
		let t0_value = /*safeLabelFunction*/ ctx[43](/*tagItem*/ ctx[147]) + "";
		let t0;
		let t1;
		let span1;
		let mounted;
		let dispose;

		function keypress_handler(...args) {
			return /*keypress_handler*/ ctx[99](/*tagItem*/ ctx[147], ...args);
		}

		return {
			c() {
				div = element("div");
				span0 = element("span");
				t0 = text(t0_value);
				t1 = space();
				span1 = element("span");
				attr(span0, "class", "tag svelte-75ckfb");
				attr(span1, "class", "tag is-delete svelte-75ckfb");
				attr(div, "class", "tags has-addons svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span0);
				append(span0, t0);
				append(div, t1);
				append(div, span1);

				if (!mounted) {
					dispose = [
						listen(span1, "click", prevent_default(function () {
							if (is_function(/*unselectItem*/ ctx[50](/*tagItem*/ ctx[147]))) /*unselectItem*/ ctx[50](/*tagItem*/ ctx[147]).apply(this, arguments);
						})),
						listen(span1, "keypress", prevent_default(keypress_handler))
					];

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty[0] & /*selectedItem*/ 2 && t0_value !== (t0_value = /*safeLabelFunction*/ ctx[43](/*tagItem*/ ctx[147]) + "")) set_data(t0, t0_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1135:6) {#each selectedItem as tagItem, i (valueFunction(tagItem, true))}
	function create_each_block_1$6(key_1, ctx) {
		let div;
		let t;
		let div_transition;
		let rect;
		let stop_animation = noop$1;
		let current;
		let mounted;
		let dispose;
		const tag_slot_template = /*#slots*/ ctx[97].tag;
		const tag_slot = create_slot(tag_slot_template, ctx, /*$$scope*/ ctx[96], get_tag_slot_context);
		const tag_slot_or_fallback = tag_slot || fallback_block_5(ctx);

		function dragstart_handler(...args) {
			return /*dragstart_handler*/ ctx[100](/*i*/ ctx[146], ...args);
		}

		function dragover_handler(...args) {
			return /*dragover_handler*/ ctx[101](/*i*/ ctx[146], ...args);
		}

		function dragleave_handler(...args) {
			return /*dragleave_handler*/ ctx[102](/*i*/ ctx[146], ...args);
		}

		function drop_handler(...args) {
			return /*drop_handler*/ ctx[103](/*i*/ ctx[146], ...args);
		}

		return {
			key: key_1,
			first: null,
			c() {
				div = element("div");
				if (tag_slot_or_fallback) tag_slot_or_fallback.c();
				t = space();
				attr(div, "draggable", true);
				attr(div, "class", "svelte-75ckfb");
				toggle_class(div, "is-active", /*draggingOver*/ ctx[38] === /*i*/ ctx[146]);
				this.first = div;
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (tag_slot_or_fallback) {
					tag_slot_or_fallback.m(div, null);
				}

				append(div, t);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "dragstart", dragstart_handler),
						listen(div, "dragover", dragover_handler),
						listen(div, "dragleave", dragleave_handler),
						listen(div, "drop", drop_handler)
					];

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (tag_slot) {
					if (tag_slot.p && (!current || dirty[0] & /*selectedItem*/ 2 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							tag_slot,
							tag_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(tag_slot_template, /*$$scope*/ ctx[96], dirty, get_tag_slot_changes),
							get_tag_slot_context
						);
					}
				} else {
					if (tag_slot_or_fallback && tag_slot_or_fallback.p && (!current || dirty[0] & /*selectedItem*/ 2)) {
						tag_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}

				if (!current || dirty[0] & /*selectedItem*/ 2 | dirty[1] & /*draggingOver*/ 128) {
					toggle_class(div, "is-active", /*draggingOver*/ ctx[38] === /*i*/ ctx[146]);
				}
			},
			r() {
				rect = div.getBoundingClientRect();
			},
			f() {
				fix_position(div);
				stop_animation();
				add_transform(div, rect);
			},
			a() {
				stop_animation();
				stop_animation = create_animation(div, rect, flip, { duration: 200 });
			},
			i(local) {
				if (current) return;
				transition_in(tag_slot_or_fallback, local);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 200 }, true);
						div_transition.run(1);
					});
				}

				current = true;
			},
			o(local) {
				transition_out(tag_slot_or_fallback, local);

				if (local) {
					if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 200 }, false);
					div_transition.run(0);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (tag_slot_or_fallback) tag_slot_or_fallback.d(detaching);
				if (detaching && div_transition) div_transition.end();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1185:4) {#if clearable}
	function create_if_block_8$2(ctx) {
		let span;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				attr(span, "class", "autocomplete-clear-button svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				span.innerHTML = /*clearText*/ ctx[8];

				if (!mounted) {
					dispose = [
						listen(span, "click", /*clear*/ ctx[54]),
						listen(span, "keypress", /*keypress_handler_1*/ ctx[108])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*clearText*/ 256) span.innerHTML = /*clearText*/ ctx[8];		},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1250:28) 
	function create_if_block_7$4(ctx) {
		let div;
		let current;
		const no_results_slot_template = /*#slots*/ ctx[97]["no-results"];
		const no_results_slot = create_slot(no_results_slot_template, ctx, /*$$scope*/ ctx[96], get_no_results_slot_context);
		const no_results_slot_or_fallback = no_results_slot || fallback_block_4(ctx);

		return {
			c() {
				div = element("div");
				if (no_results_slot_or_fallback) no_results_slot_or_fallback.c();
				attr(div, "class", "autocomplete-list-item-no-results svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (no_results_slot_or_fallback) {
					no_results_slot_or_fallback.m(div, null);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (no_results_slot) {
					if (no_results_slot.p && (!current || dirty[0] & /*noResultsText*/ 1024 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							no_results_slot,
							no_results_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(no_results_slot_template, /*$$scope*/ ctx[96], dirty, get_no_results_slot_changes),
							get_no_results_slot_context
						);
					}
				} else {
					if (no_results_slot_or_fallback && no_results_slot_or_fallback.p && (!current || dirty[0] & /*noResultsText*/ 1024)) {
						no_results_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(no_results_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(no_results_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (no_results_slot_or_fallback) no_results_slot_or_fallback.d(detaching);
			}
		};
	}

	// (1242:21) 
	function create_if_block_6$4(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const create_slot_template = /*#slots*/ ctx[97].create;
		const create_slot_1 = create_slot(create_slot_template, ctx, /*$$scope*/ ctx[96], get_create_slot_context);
		const create_slot_or_fallback = create_slot_1 || fallback_block_3(ctx);

		return {
			c() {
				div = element("div");
				if (create_slot_or_fallback) create_slot_or_fallback.c();
				attr(div, "class", "autocomplete-list-item-create svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (create_slot_or_fallback) {
					create_slot_or_fallback.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*selectItem*/ ctx[44]),
						listen(div, "keypress", /*keypress_handler_3*/ ctx[113])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (create_slot_1) {
					if (create_slot_1.p && (!current || dirty[0] & /*createText*/ 8192 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							create_slot_1,
							create_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(create_slot_template, /*$$scope*/ ctx[96], dirty, get_create_slot_changes),
							get_create_slot_context
						);
					}
				} else {
					if (create_slot_or_fallback && create_slot_or_fallback.p && (!current || dirty[0] & /*createText*/ 8192)) {
						create_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(create_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(create_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (create_slot_or_fallback) create_slot_or_fallback.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1238:37) 
	function create_if_block_5$7(ctx) {
		let div;
		let current;
		const loading_slot_template = /*#slots*/ ctx[97].loading;
		const loading_slot = create_slot(loading_slot_template, ctx, /*$$scope*/ ctx[96], get_loading_slot_context);
		const loading_slot_or_fallback = loading_slot || fallback_block_2(ctx);

		return {
			c() {
				div = element("div");
				if (loading_slot_or_fallback) loading_slot_or_fallback.c();
				attr(div, "class", "autocomplete-list-item-loading svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (loading_slot_or_fallback) {
					loading_slot_or_fallback.m(div, null);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (loading_slot) {
					if (loading_slot.p && (!current || dirty[0] & /*loadingText*/ 2048 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							loading_slot,
							loading_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(loading_slot_template, /*$$scope*/ ctx[96], dirty, get_loading_slot_changes),
							get_loading_slot_context
						);
					}
				} else {
					if (loading_slot_or_fallback && loading_slot_or_fallback.p && (!current || dirty[0] & /*loadingText*/ 2048)) {
						loading_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(loading_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(loading_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (loading_slot_or_fallback) loading_slot_or_fallback.d(detaching);
			}
		};
	}

	// (1198:4) {#if filteredListItems && filteredListItems.length > 0}
	function create_if_block$M(ctx) {
		let t0;
		let t1;
		let current;
		const dropdown_header_slot_template = /*#slots*/ ctx[97]["dropdown-header"];
		const dropdown_header_slot = create_slot(dropdown_header_slot_template, ctx, /*$$scope*/ ctx[96], get_dropdown_header_slot_context);
		let each_value = ensure_array_like(/*filteredListItems*/ ctx[31]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const dropdown_footer_slot_template = /*#slots*/ ctx[97]["dropdown-footer"];
		const dropdown_footer_slot = create_slot(dropdown_footer_slot_template, ctx, /*$$scope*/ ctx[96], get_dropdown_footer_slot_context);
		const dropdown_footer_slot_or_fallback = dropdown_footer_slot || fallback_block(ctx);

		return {
			c() {
				if (dropdown_header_slot) dropdown_header_slot.c();
				t0 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t1 = space();
				if (dropdown_footer_slot_or_fallback) dropdown_footer_slot_or_fallback.c();
			},
			m(target, anchor) {
				if (dropdown_header_slot) {
					dropdown_header_slot.m(target, anchor);
				}

				insert(target, t0, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, t1, anchor);

				if (dropdown_footer_slot_or_fallback) {
					dropdown_footer_slot_or_fallback.m(target, anchor);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dropdown_header_slot) {
					if (dropdown_header_slot.p && (!current || dirty[0] & /*maxItemsToShowInList*/ 16 | dirty[1] & /*filteredListItems*/ 1 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							dropdown_header_slot,
							dropdown_header_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(dropdown_header_slot_template, /*$$scope*/ ctx[96], dirty, get_dropdown_header_slot_changes),
							get_dropdown_header_slot_context
						);
					}
				}

				if (dirty[0] & /*highlightIndex, maxItemsToShowInList*/ 1073741840 | dirty[1] & /*isConfirmed, filteredListItems, onListItemClick*/ 16793601 | dirty[3] & /*$$scope*/ 8) {
					each_value = ensure_array_like(/*filteredListItems*/ ctx[31]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$j(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$j(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(t1.parentNode, t1);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (dropdown_footer_slot) {
					if (dropdown_footer_slot.p && (!current || dirty[0] & /*maxItemsToShowInList*/ 16 | dirty[1] & /*filteredListItems*/ 1 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							dropdown_footer_slot,
							dropdown_footer_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(dropdown_footer_slot_template, /*$$scope*/ ctx[96], dirty, get_dropdown_footer_slot_changes),
							get_dropdown_footer_slot_context
						);
					}
				} else {
					if (dropdown_footer_slot_or_fallback && dropdown_footer_slot_or_fallback.p && (!current || dirty[0] & /*moreItemsText, maxItemsToShowInList*/ 4112 | dirty[1] & /*filteredListItems*/ 1)) {
						dropdown_footer_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(dropdown_header_slot, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(dropdown_footer_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(dropdown_header_slot, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(dropdown_footer_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
				}

				if (dropdown_header_slot) dropdown_header_slot.d(detaching);
				destroy_each(each_blocks, detaching);
				if (dropdown_footer_slot_or_fallback) dropdown_footer_slot_or_fallback.d(detaching);
			}
		};
	}

	// (1252:48) {noResultsText}
	function fallback_block_4(ctx) {
		let t;

		return {
			c() {
				t = text(/*noResultsText*/ ctx[10]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*noResultsText*/ 1024) set_data(t, /*noResultsText*/ ctx[10]);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (1248:41) {createText}
	function fallback_block_3(ctx) {
		let t;

		return {
			c() {
				t = text(/*createText*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*createText*/ 8192) set_data(t, /*createText*/ ctx[13]);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (1240:43) {loadingText}
	function fallback_block_2(ctx) {
		let t;

		return {
			c() {
				t = text(/*loadingText*/ ctx[11]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*loadingText*/ 2048) set_data(t, /*loadingText*/ ctx[11]);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (1202:8) {#if listItem && (maxItemsToShowInList <= 0 || i < maxItemsToShowInList)}
	function create_if_block_3$m(ctx) {
		let div;
		let current;
		let mounted;
		let dispose;
		const item_slot_template = /*#slots*/ ctx[97].item;
		const item_slot = create_slot(item_slot_template, ctx, /*$$scope*/ ctx[96], get_item_slot_context);
		const item_slot_or_fallback = item_slot || fallback_block_1(ctx);

		function click_handler() {
			return /*click_handler*/ ctx[110](/*listItem*/ ctx[144]);
		}

		function keypress_handler_2(...args) {
			return /*keypress_handler_2*/ ctx[111](/*listItem*/ ctx[144], ...args);
		}

		function pointerenter_handler() {
			return /*pointerenter_handler*/ ctx[112](/*i*/ ctx[146]);
		}

		return {
			c() {
				div = element("div");
				if (item_slot_or_fallback) item_slot_or_fallback.c();
				attr(div, "class", "autocomplete-list-item svelte-75ckfb");
				toggle_class(div, "selected", /*i*/ ctx[146] === /*highlightIndex*/ ctx[30]);
				toggle_class(div, "confirmed", /*isConfirmed*/ ctx[55](/*listItem*/ ctx[144].item));
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (item_slot_or_fallback) {
					item_slot_or_fallback.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", click_handler),
						listen(div, "keypress", keypress_handler_2),
						listen(div, "pointerenter", pointerenter_handler)
					];

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (item_slot) {
					if (item_slot.p && (!current || dirty[1] & /*filteredListItems*/ 1 | dirty[3] & /*$$scope*/ 8)) {
						update_slot_base(
							item_slot,
							item_slot_template,
							ctx,
							/*$$scope*/ ctx[96],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[96])
							: get_slot_changes(item_slot_template, /*$$scope*/ ctx[96], dirty, get_item_slot_changes),
							get_item_slot_context
						);
					}
				} else {
					if (item_slot_or_fallback && item_slot_or_fallback.p && (!current || dirty[1] & /*filteredListItems*/ 1)) {
						item_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
					}
				}

				if (!current || dirty[0] & /*highlightIndex*/ 1073741824) {
					toggle_class(div, "selected", /*i*/ ctx[146] === /*highlightIndex*/ ctx[30]);
				}

				if (!current || dirty[1] & /*isConfirmed, filteredListItems*/ 16777217) {
					toggle_class(div, "confirmed", /*isConfirmed*/ ctx[55](/*listItem*/ ctx[144].item));
				}
			},
			i(local) {
				if (current) return;
				transition_in(item_slot_or_fallback, local);
				current = true;
			},
			o(local) {
				transition_out(item_slot_or_fallback, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (1220:14) {:else}
	function create_else_block$x(ctx) {
		let html_tag;
		let raw_value = /*listItem*/ ctx[144].label + "";
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(raw_value, target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[1] & /*filteredListItems*/ 1 && raw_value !== (raw_value = /*listItem*/ ctx[144].label + "")) html_tag.p(raw_value);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	// (1218:14) {#if listItem.highlighted}
	function create_if_block_4$f(ctx) {
		let html_tag;
		let raw_value = /*listItem*/ ctx[144].highlighted + "";
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(raw_value, target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[1] & /*filteredListItems*/ 1 && raw_value !== (raw_value = /*listItem*/ ctx[144].highlighted + "")) html_tag.p(raw_value);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	// (1217:13)                
	function fallback_block_1(ctx) {
		let if_block_anchor;

		function select_block_type_2(ctx, dirty) {
			if (/*listItem*/ ctx[144].highlighted) return create_if_block_4$f;
			return create_else_block$x;
		}

		let current_block_type = select_block_type_2(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	// (1201:6) {#each filteredListItems as listItem, i}
	function create_each_block$j(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*listItem*/ ctx[144] && (/*maxItemsToShowInList*/ ctx[4] <= 0 || /*i*/ ctx[146] < /*maxItemsToShowInList*/ ctx[4]) && create_if_block_3$m(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*listItem*/ ctx[144] && (/*maxItemsToShowInList*/ ctx[4] <= 0 || /*i*/ ctx[146] < /*maxItemsToShowInList*/ ctx[4])) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*maxItemsToShowInList*/ 16 | dirty[1] & /*filteredListItems*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$m(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (1229:8) {#if maxItemsToShowInList > 0 && filteredListItems.length > maxItemsToShowInList}
	function create_if_block_1$B(ctx) {
		let if_block_anchor;
		let if_block = /*moreItemsText*/ ctx[12] && create_if_block_2$q(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*moreItemsText*/ ctx[12]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_2$q(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (1230:10) {#if moreItemsText}
	function create_if_block_2$q(ctx) {
		let div;
		let t0;
		let t1_value = /*filteredListItems*/ ctx[31].length - /*maxItemsToShowInList*/ ctx[4] + "";
		let t1;
		let t2;
		let t3;

		return {
			c() {
				div = element("div");
				t0 = text("...");
				t1 = text(t1_value);
				t2 = space();
				t3 = text(/*moreItemsText*/ ctx[12]);
				attr(div, "class", "autocomplete-list-item-no-results svelte-75ckfb");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, t2);
				append(div, t3);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*maxItemsToShowInList*/ 16 | dirty[1] & /*filteredListItems*/ 1 && t1_value !== (t1_value = /*filteredListItems*/ ctx[31].length - /*maxItemsToShowInList*/ ctx[4] + "")) set_data(t1, t1_value);
				if (dirty[0] & /*moreItemsText*/ 4096) set_data(t3, /*moreItemsText*/ ctx[12]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (1228:93)          
	function fallback_block(ctx) {
		let if_block_anchor;
		let if_block = /*maxItemsToShowInList*/ ctx[4] > 0 && /*filteredListItems*/ ctx[31].length > /*maxItemsToShowInList*/ ctx[4] && create_if_block_1$B(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*maxItemsToShowInList*/ ctx[4] > 0 && /*filteredListItems*/ ctx[31].length > /*maxItemsToShowInList*/ ctx[4]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$B(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function create_fragment$1d(ctx) {
		let div2;
		let select;
		let t0;
		let div0;
		let t1;
		let input_1;
		let input_1_class_value;
		let input_1_id_value;
		let input_1_autocomplete_value;
		let input_1_readonly_value;
		let t2;
		let t3;
		let div1;
		let current_block_type_index;
		let if_block3;
		let div1_class_value;
		let div2_class_value;
		let current;
		let mounted;
		let dispose;

		function select_block_type(ctx, dirty) {
			if (!/*multiple*/ ctx[5] && /*hasSelection*/ ctx[32]) return create_if_block_10$2;
			if (/*multiple*/ ctx[5] && /*hasSelection*/ ctx[32]) return create_if_block_11$2;
		}

		let current_block_type = select_block_type(ctx);
		let if_block0 = current_block_type && current_block_type(ctx);
		let if_block1 = /*multiple*/ ctx[5] && /*hasSelection*/ ctx[32] && create_if_block_9$2(ctx);

		let input_1_levels = [
			{ type: "text" },
			{
				class: input_1_class_value = "" + ((/*inputClassName*/ ctx[16]
				? /*inputClassName*/ ctx[16]
				: '') + " " + (/*noInputStyles*/ ctx[27]
				? ''
				: 'input autocomplete-input'))
			},
			{
				id: input_1_id_value = /*inputId*/ ctx[17] ? /*inputId*/ ctx[17] : ""
			},
			{
				autocomplete: input_1_autocomplete_value = /*html5autocomplete*/ ctx[22]
				? "on"
				: /*autocompleteOffValue*/ ctx[23]
			},
			{ placeholder: /*placeholder*/ ctx[14] },
			{ name: /*name*/ ctx[18] },
			{ disabled: /*disabled*/ ctx[26] },
			{ required: /*required*/ ctx[28] },
			{ title: /*title*/ ctx[21] },
			{
				readOnly: input_1_readonly_value = /*readonly*/ ctx[24] || /*locked*/ ctx[39]
			},
			{ tabindex: /*tabindex*/ ctx[29] },
			/*$$restProps*/ ctx[60]
		];

		let input_data = {};

		for (let i = 0; i < input_1_levels.length; i += 1) {
			input_data = assign(input_data, input_1_levels[i]);
		}

		let if_block2 = /*clearable*/ ctx[40] && create_if_block_8$2(ctx);
		const if_block_creators = [create_if_block$M, create_if_block_5$7, create_if_block_6$4, create_if_block_7$4];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*filteredListItems*/ ctx[31] && /*filteredListItems*/ ctx[31].length > 0) return 0;
			if (/*loading*/ ctx[36] && /*loadingText*/ ctx[11]) return 1;
			if (/*create*/ ctx[6]) return 2;
			if (/*noResultsText*/ ctx[10]) return 3;
			return -1;
		}

		if (~(current_block_type_index = select_block_type_1(ctx))) {
			if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				div2 = element("div");
				select = element("select");
				if (if_block0) if_block0.c();
				t0 = space();
				div0 = element("div");
				if (if_block1) if_block1.c();
				t1 = space();
				input_1 = element("input");
				t2 = space();
				if (if_block2) if_block2.c();
				t3 = space();
				div1 = element("div");
				if (if_block3) if_block3.c();
				attr(select, "name", /*selectName*/ ctx[19]);
				attr(select, "id", /*selectId*/ ctx[20]);
				select.multiple = /*multiple*/ ctx[5];
				attr(select, "class", "svelte-75ckfb");
				set_attributes(input_1, input_data);
				toggle_class(input_1, "svelte-75ckfb", true);
				attr(div0, "class", "input-container svelte-75ckfb");

				attr(div1, "class", div1_class_value = "" + ((/*dropdownClassName*/ ctx[25]
				? /*dropdownClassName*/ ctx[25]
				: '') + " autocomplete-list " + (/*showList*/ ctx[41] ? '' : 'hidden') + " is-fullwidth" + " svelte-75ckfb"));

				attr(div2, "class", div2_class_value = "" + ((/*className*/ ctx[15] ? /*className*/ ctx[15] : '') + " autocomplete select is-fullwidth " + /*uniqueId*/ ctx[42] + " svelte-75ckfb"));
				toggle_class(div2, "hide-arrow", /*hideArrow*/ ctx[7] || !/*items*/ ctx[0].length);
				toggle_class(div2, "is-multiple", /*multiple*/ ctx[5]);
				toggle_class(div2, "show-clear", /*clearable*/ ctx[40]);
				toggle_class(div2, "is-loading", /*showLoadingIndicator*/ ctx[9] && /*loading*/ ctx[36]);
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, select);
				if (if_block0) if_block0.m(select, null);
				append(div2, t0);
				append(div2, div0);
				if (if_block1) if_block1.m(div0, null);
				append(div0, t1);
				append(div0, input_1);
				if (input_1.autofocus) input_1.focus();
				/*input_1_binding*/ ctx[104](input_1);
				set_input_value(input_1, /*text*/ ctx[2]);
				append(div0, t2);
				if (if_block2) if_block2.m(div0, null);
				/*div0_binding*/ ctx[109](div0);
				append(div2, t3);
				append(div2, div1);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(div1, null);
				}

				/*div1_binding*/ ctx[114](div1);
				current = true;

				if (!mounted) {
					dispose = [
						listen(window_1, "click", /*onDocumentClick*/ ctx[46]),
						listen(window_1, "scroll", /*scroll_handler*/ ctx[98]),
						listen(input_1, "input", /*input_1_input_handler*/ ctx[105]),
						listen(input_1, "input", /*onInput*/ ctx[49]),
						listen(input_1, "focus", /*onFocusInternal*/ ctx[52]),
						listen(input_1, "blur", /*onBlurInternal*/ ctx[53]),
						listen(input_1, "keydown", /*onKeyDown*/ ctx[47]),
						listen(input_1, "click", /*onInputClick*/ ctx[51]),
						listen(input_1, "keypress", /*onKeyPress*/ ctx[48]),
						listen(input_1, "dragover", /*dragover_handler_1*/ ctx[106]),
						listen(input_1, "drop", /*drop_handler_1*/ ctx[107])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if (if_block0) if_block0.d(1);
					if_block0 = current_block_type && current_block_type(ctx);

					if (if_block0) {
						if_block0.c();
						if_block0.m(select, null);
					}
				}

				if (!current || dirty[0] & /*selectName*/ 524288) {
					attr(select, "name", /*selectName*/ ctx[19]);
				}

				if (!current || dirty[0] & /*selectId*/ 1048576) {
					attr(select, "id", /*selectId*/ ctx[20]);
				}

				if (!current || dirty[0] & /*multiple*/ 32) {
					select.multiple = /*multiple*/ ctx[5];
				}

				if (/*multiple*/ ctx[5] && /*hasSelection*/ ctx[32]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*multiple*/ 32 | dirty[1] & /*hasSelection*/ 2) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_9$2(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div0, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
					{ type: "text" },
					(!current || dirty[0] & /*inputClassName, noInputStyles*/ 134283264 && input_1_class_value !== (input_1_class_value = "" + ((/*inputClassName*/ ctx[16]
					? /*inputClassName*/ ctx[16]
					: '') + " " + (/*noInputStyles*/ ctx[27]
					? ''
					: 'input autocomplete-input')))) && { class: input_1_class_value },
					(!current || dirty[0] & /*inputId*/ 131072 && input_1_id_value !== (input_1_id_value = /*inputId*/ ctx[17] ? /*inputId*/ ctx[17] : "")) && { id: input_1_id_value },
					(!current || dirty[0] & /*html5autocomplete, autocompleteOffValue*/ 12582912 && input_1_autocomplete_value !== (input_1_autocomplete_value = /*html5autocomplete*/ ctx[22]
					? "on"
					: /*autocompleteOffValue*/ ctx[23])) && { autocomplete: input_1_autocomplete_value },
					(!current || dirty[0] & /*placeholder*/ 16384) && { placeholder: /*placeholder*/ ctx[14] },
					(!current || dirty[0] & /*name*/ 262144) && { name: /*name*/ ctx[18] },
					(!current || dirty[0] & /*disabled*/ 67108864) && { disabled: /*disabled*/ ctx[26] },
					(!current || dirty[0] & /*required*/ 268435456) && { required: /*required*/ ctx[28] },
					(!current || dirty[0] & /*title*/ 2097152) && { title: /*title*/ ctx[21] },
					(!current || dirty[0] & /*readonly*/ 16777216 | dirty[1] & /*locked*/ 256 && input_1_readonly_value !== (input_1_readonly_value = /*readonly*/ ctx[24] || /*locked*/ ctx[39])) && { readOnly: input_1_readonly_value },
					(!current || dirty[0] & /*tabindex*/ 536870912) && { tabindex: /*tabindex*/ ctx[29] },
					dirty[1] & /*$$restProps*/ 536870912 && /*$$restProps*/ ctx[60]
				]));

				if (dirty[0] & /*text*/ 4 && input_1.value !== /*text*/ ctx[2]) {
					set_input_value(input_1, /*text*/ ctx[2]);
				}

				toggle_class(input_1, "svelte-75ckfb", true);

				if (/*clearable*/ ctx[40]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_8$2(ctx);
						if_block2.c();
						if_block2.m(div0, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block3) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block3 = if_blocks[current_block_type_index];

						if (!if_block3) {
							if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block3.c();
						} else {
							if_block3.p(ctx, dirty);
						}

						transition_in(if_block3, 1);
						if_block3.m(div1, null);
					} else {
						if_block3 = null;
					}
				}

				if (!current || dirty[0] & /*dropdownClassName*/ 33554432 | dirty[1] & /*showList*/ 1024 && div1_class_value !== (div1_class_value = "" + ((/*dropdownClassName*/ ctx[25]
				? /*dropdownClassName*/ ctx[25]
				: '') + " autocomplete-list " + (/*showList*/ ctx[41] ? '' : 'hidden') + " is-fullwidth" + " svelte-75ckfb"))) {
					attr(div1, "class", div1_class_value);
				}

				if (!current || dirty[0] & /*className*/ 32768 && div2_class_value !== (div2_class_value = "" + ((/*className*/ ctx[15] ? /*className*/ ctx[15] : '') + " autocomplete select is-fullwidth " + /*uniqueId*/ ctx[42] + " svelte-75ckfb"))) {
					attr(div2, "class", div2_class_value);
				}

				if (!current || dirty[0] & /*className, hideArrow, items*/ 32897) {
					toggle_class(div2, "hide-arrow", /*hideArrow*/ ctx[7] || !/*items*/ ctx[0].length);
				}

				if (!current || dirty[0] & /*className, multiple*/ 32800) {
					toggle_class(div2, "is-multiple", /*multiple*/ ctx[5]);
				}

				if (!current || dirty[0] & /*className*/ 32768 | dirty[1] & /*clearable*/ 512) {
					toggle_class(div2, "show-clear", /*clearable*/ ctx[40]);
				}

				if (!current || dirty[0] & /*className, showLoadingIndicator*/ 33280 | dirty[1] & /*loading*/ 32) {
					toggle_class(div2, "is-loading", /*showLoadingIndicator*/ ctx[9] && /*loading*/ ctx[36]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				transition_in(if_block3);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				transition_out(if_block3);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				if (if_block0) {
					if_block0.d();
				}

				if (if_block1) if_block1.d();
				/*input_1_binding*/ ctx[104](null);
				if (if_block2) if_block2.d();
				/*div0_binding*/ ctx[109](null);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d();
				}

				/*div1_binding*/ ctx[114](null);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function safeFunction(theFunction, argument) {
		if (typeof theFunction !== "function") {
			console.error("Not a function: " + theFunction + ", argument: " + argument);
			return undefined;
		}

		let result;

		try {
			result = theFunction(argument);
		} catch(error) {
			console.warn("Error executing Autocomplete function on value: " + argument + " function: " + theFunction);
		}

		return result;
	}

	function safeStringFunction(theFunction, argument) {
		let result = safeFunction(theFunction, argument);

		if (result === undefined || result === null) {
			result = "";
		}

		if (typeof result !== "string") {
			result = result.toString();
		}

		return result;
	}

	function numberOfMatches(listItem, searchWords) {
		if (!listItem) {
			return 0;
		}

		const itemKeywords = listItem.keywords;
		let matches = 0;

		searchWords.forEach(searchWord => {
			if (itemKeywords.includes(searchWord)) {
				matches++;
			}
		});

		return matches;
	}

	function defaultItemSortFunction(obj1, obj2, searchWords) {
		return numberOfMatches(obj2, searchWords) - numberOfMatches(obj1, searchWords);
	}

	function removeAccents(str) {
		return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
	}

	function instance$1c($$self, $$props, $$invalidate) {
		let showList;
		let hasSelection;
		let clearable;
		let locked;

		const omit_props_names = [
			"items","searchFunction","labelFieldName","keywordsFieldName","valueFieldName","labelFunction","keywordsFunction","valueFunction","keywordsCleanFunction","textCleanFunction","beforeChange","onChange","onFocus","onBlur","onCreate","selectFirstIfEmpty","minCharactersToSearch","maxItemsToShowInList","multiple","create","ignoreAccents","matchAllKeywords","sortByMatchedKeywords","itemFilterFunction","itemSortFunction","lock","delay","localFiltering","localSorting","cleanUserText","lowercaseKeywords","closeOnBlur","orderableSelection","hideArrow","showClear","clearText","showLoadingIndicator","noResultsText","loadingText","moreItemsText","createText","placeholder","className","inputClassName","inputId","name","selectName","selectId","title","html5autocomplete","autocompleteOffValue","readonly","dropdownClassName","disabled","noInputStyles","required","debug","tabindex","selectedItem","value","highlightedItem","text","highlightFilter"
		];

		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		let { items = [] } = $$props;
		let { searchFunction = false } = $$props;
		let { labelFieldName = undefined } = $$props;
		let { keywordsFieldName = labelFieldName } = $$props;
		let { valueFieldName = undefined } = $$props;

		let { labelFunction = function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return labelFieldName ? item[labelFieldName] : item;
		} } = $$props;

		let { keywordsFunction = function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return keywordsFieldName
			? item[keywordsFieldName]
			: labelFunction(item);
		} } = $$props;

		let { valueFunction = function (item, forceSingle = false) {
			if (item === undefined || item === null) {
				return item;
			}

			if (!multiple || forceSingle) {
				return valueFieldName ? item[valueFieldName] : item;
			} else {
				return item.map(i => valueFieldName ? i[valueFieldName] : i);
			}
		} } = $$props;

		let { keywordsCleanFunction = function (keywords) {
			return keywords;
		} } = $$props;

		let { textCleanFunction = function (userEnteredText) {
			return userEnteredText;
		} } = $$props;

		let { beforeChange = function (oldSelectedItem, newSelectedItem) {
			return true;
		} } = $$props;

		let { onChange = function (newSelectedItem) {
			
		} } = $$props;

		let { onFocus = function () {
			
		} } = $$props;

		let { onBlur = function () {
			
		} } = $$props;

		let { onCreate = function (text) {
			if (debug) {
				console.log("onCreate: " + text);
			}
		} } = $$props;

		let { selectFirstIfEmpty = false } = $$props;
		let { minCharactersToSearch = 1 } = $$props;
		let { maxItemsToShowInList = 0 } = $$props;
		let { multiple = false } = $$props;
		let { create = false } = $$props;
		let { ignoreAccents = true } = $$props;
		let { matchAllKeywords = true } = $$props;
		let { sortByMatchedKeywords = false } = $$props;
		let { itemFilterFunction = undefined } = $$props;
		let { itemSortFunction = undefined } = $$props;
		let { lock = false } = $$props;
		let { delay = 0 } = $$props;
		let { localFiltering = true } = $$props;
		let { localSorting = true } = $$props;
		let { cleanUserText = true } = $$props;
		let { lowercaseKeywords = true } = $$props;
		let { closeOnBlur = false } = $$props;
		let { orderableSelection = false } = $$props;
		let { hideArrow = false } = $$props;
		let { showClear = false } = $$props;
		let { clearText = "&#10006;" } = $$props;
		let { showLoadingIndicator = false } = $$props;
		let { noResultsText = "No results found" } = $$props;
		let { loadingText = "Loading results..." } = $$props;
		let { moreItemsText = "items not shown" } = $$props;
		let { createText = "Not found, add anyway?" } = $$props;
		let { placeholder = undefined } = $$props;
		let { className = undefined } = $$props;
		let { inputClassName = undefined } = $$props;
		let { inputId = undefined } = $$props;
		let { name = undefined } = $$props;
		let { selectName = undefined } = $$props;
		let { selectId = undefined } = $$props;
		let { title = undefined } = $$props;
		let { html5autocomplete = undefined } = $$props;
		let { autocompleteOffValue = "off" } = $$props;
		let { readonly = undefined } = $$props;
		let { dropdownClassName = undefined } = $$props;
		let { disabled = false } = $$props;
		let { noInputStyles = false } = $$props;
		let { required = null } = $$props;
		let { debug = false } = $$props;
		let { tabindex = 0 } = $$props;
		let { selectedItem = multiple ? [] : undefined } = $$props;
		let { value = undefined } = $$props;
		let { highlightedItem = undefined } = $$props;

		// --- Internal State ----
		const uniqueId = "sautocomplete-" + Math.floor(Math.random() * 1000);

		// HTML elements
		let input;

		let list;
		let inputContainer;

		// UI state
		let opened = false;

		let loading = false;
		let highlightIndex = -1;
		let { text = undefined } = $$props;
		let filteredTextLength = 0;

		// view model
		let filteredListItems;

		let listItems = [];

		// requests/responses counters
		let lastRequestId = 0;

		let lastResponseId = 0;

		// other state
		let inputDelayTimeout;

		let setPositionOnNextUpdate = false;

		// --- Lifecycle events ---
		afterUpdate(() => {
			if (setPositionOnNextUpdate) {
				setScrollAwareListPosition();
			}

			$$invalidate(37, setPositionOnNextUpdate = false);
		});

		function safeLabelFunction(item) {
			// console.log("labelFunction: " + labelFunction);
			// console.log("safeLabelFunction, item: " + item);
			return safeStringFunction(labelFunction, item);
		}

		function safeKeywordsFunction(item) {
			// console.log("safeKeywordsFunction");
			const keywords = safeStringFunction(keywordsFunction, item);

			let result = safeStringFunction(keywordsCleanFunction, keywords);
			result = lowercaseKeywords ? result.toLowerCase().trim() : result;

			if (ignoreAccents) {
				result = removeAccents(result);
			}

			if (debug) {
				console.log("Extracted keywords: '" + result + "' from item: " + JSON.stringify(item));
			}

			return result;
		}

		function prepareListItems() {
			let timerId;

			if (debug) {
				timerId = `Autocomplete prepare list ${inputId ? `(id: ${inputId})` : ""}`;
				console.time(timerId);
				console.log("Prepare items to search");
				console.log("items: " + JSON.stringify(items));
			}

			if (!Array.isArray(items)) {
				console.warn("Autocomplete items / search function did not return array but", items);
				$$invalidate(0, items = []);
			}

			const length = items ? items.length : 0;
			listItems = new Array(length);

			if (length > 0) {
				items.forEach((item, i) => {
					const listItem = getListItem(item);

					if (listItem === undefined) {
						console.log("Undefined item for: ", item);
					}

					listItems[i] = listItem;
				});
			}

			$$invalidate(31, filteredListItems = listItems);

			if (debug) {
				console.log(listItems.length + " items to search");
				console.timeEnd(timerId);
			}
		}

		function getListItem(item) {
			return {
				// keywords representation of the item
				keywords: localFiltering ? safeKeywordsFunction(item) : [],
				// item label
				label: safeLabelFunction(item),
				// store reference to the origial item
				item
			};
		}

		function onSelectedItemChanged() {
			$$invalidate(61, value = valueFunction(selectedItem));

			if (selectedItem && !multiple) {
				$$invalidate(2, text = safeLabelFunction(selectedItem));
			}

			$$invalidate(31, filteredListItems = listItems);
			onChange(selectedItem);
		}

		function prepareUserEnteredText(userEnteredText) {
			if (userEnteredText === undefined || userEnteredText === null) {
				return "";
			}

			if (!cleanUserText) {
				return userEnteredText;
			}

			const textFiltered = userEnteredText.replace(/[&/\\#,+()$~%.'":*?<>{}]/g, " ").trim();
			const cleanUserEnteredText = safeStringFunction(textCleanFunction, textFiltered);

			const textTrimmed = lowercaseKeywords
			? cleanUserEnteredText.toLowerCase().trim()
			: cleanUserEnteredText.trim();

			return textTrimmed;
		}

		async function search() {
			let timerId;

			if (debug) {
				timerId = `Autocomplete search ${inputId ? `(id: ${inputId})` : ""}`;
				console.time(timerId);
				console.log("Searching user entered text: '" + text + "'");
			}

			let textFiltered = prepareUserEnteredText(text);

			if (minCharactersToSearch > 1 && textFiltered.length < minCharactersToSearch) {
				textFiltered = "";
			}

			$$invalidate(95, filteredTextLength = textFiltered.length);

			if (debug) {
				console.log("Changed user entered text '" + text + "' into '" + textFiltered + "'");
			}

			// if no search text load all items
			if (textFiltered === "") {
				if (searchFunction) {
					// we will need to rerun the search
					$$invalidate(0, items = []);

					if (debug) {
						console.log("User entered text is empty clear list of items");
					}
				} else {
					$$invalidate(31, filteredListItems = listItems);

					if (debug) {
						console.log("User entered text is empty set the list of items to all items");
					}
				}

				if (closeIfMinCharsToSearchReached()) {
					if (debug) {
						console.timeEnd(timerId);
					}

					return;
				}
			}

			if (!searchFunction) {
				// internal search
				processListItems(textFiltered);
			} else {
				// external search which provides items
				lastRequestId = lastRequestId + 1;

				const currentRequestId = lastRequestId;
				$$invalidate(36, loading = true);

				// searchFunction is a generator
				if (searchFunction.constructor.name === "AsyncGeneratorFunction") {
					for await (const chunk of searchFunction(textFiltered, maxItemsToShowInList)) {
						// a chunk of an old response: throw it away
						if (currentRequestId < lastResponseId) {
							return false;
						}

						// a chunk for a new response: reset the item list
						if (currentRequestId > lastResponseId) {
							$$invalidate(0, items = []);
						}

						lastResponseId = currentRequestId;
						$$invalidate(0, items = [...items, ...chunk]);
						processListItems(textFiltered);
					}

					// there was nothing in the chunk
					if (lastResponseId < currentRequestId) {
						lastResponseId = currentRequestId;
						$$invalidate(0, items = []);
						processListItems(textFiltered);
					}
				} else // searchFunction is a regular function
				{
					let result = await searchFunction(textFiltered, maxItemsToShowInList);

					// If a response to a newer request has been received
					// while responses to this request were being loaded,
					// then we can just throw away this outdated results.
					if (currentRequestId < lastResponseId) {
						return false;
					}

					lastResponseId = currentRequestId;
					$$invalidate(0, items = result);
					processListItems(textFiltered);
				}

				$$invalidate(36, loading = false);
			}

			if (debug) {
				console.timeEnd(timerId);
				console.log("Search found " + filteredListItems.length + " items");
			}
		}

		function defaultItemFilterFunction(listItem, searchWords) {
			const matches = numberOfMatches(listItem, searchWords);

			if (matchAllKeywords) {
				return matches >= searchWords.length;
			} else {
				return matches > 0;
			}
		}

		function processListItems(textFiltered) {
			// cleans, filters, orders, and highlights the list items
			prepareListItems();

			const textFilteredWithoutAccents = ignoreAccents
			? removeAccents(textFiltered)
			: textFiltered;

			const searchWords = textFilteredWithoutAccents.split(/\s+/g).filter(word => word !== "");

			// local search
			let tempfilteredListItems;

			if (localFiltering) {
				if (itemFilterFunction) {
					tempfilteredListItems = listItems.filter(item => itemFilterFunction(item.item, searchWords));
				} else {
					tempfilteredListItems = listItems.filter(item => defaultItemFilterFunction(item, searchWords));
				}

				if (localSorting) {
					if (itemSortFunction) {
						tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => itemSortFunction(item1.item, item2.item, searchWords));
					} else {
						if (sortByMatchedKeywords) {
							tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => defaultItemSortFunction(item1, item2, searchWords));
						}
					}
				}
			} else {
				tempfilteredListItems = listItems;
			}

			const hlfilter = highlightFilter(searchWords, "label");
			$$invalidate(31, filteredListItems = tempfilteredListItems.map(hlfilter));
			closeIfMinCharsToSearchReached();
			return true;
		}

		// $: text, search();
		function afterCreate(createdItem) {
			let listItem;

			if (debug) {
				console.log("createdItem", createdItem);
			}

			if ("undefined" !== typeof createdItem) {
				prepareListItems();
				$$invalidate(31, filteredListItems = listItems);
				let index = findItemIndex(createdItem, filteredListItems);

				// if the items array was not updated, add the created item manually
				if (index <= 0) {
					$$invalidate(0, items = [createdItem]);
					prepareListItems();
					$$invalidate(31, filteredListItems = listItems);
					index = 0;
				}

				if (index >= 0) {
					$$invalidate(30, highlightIndex = index);
					listItem = filteredListItems[highlightIndex];
				}
			}

			return listItem;
		}

		function selectListItem(listItem) {
			if (debug) {
				console.log("selectListItem", listItem);
			}

			if ("undefined" === typeof listItem && create) {
				// allow undefined items if create is enabled
				const createdItem = onCreate(text);

				if ("undefined" !== typeof createdItem) {
					if (typeof createdItem.then === "function") {
						createdItem.then(newItem => {
							if ("undefined" !== typeof newItem) {
								const newListItem = afterCreate(newItem);

								if ("undefined" !== typeof newListItem) {
									selectListItem(newListItem);
								}
							}
						});

						return true;
					} else {
						listItem = afterCreate(createdItem);
					}
				}
			}

			if ("undefined" === typeof listItem) {
				if (debug) {
					console.log(`listItem is undefined. Can not select.`);
				}

				return false;
			}

			if (locked) {
				return true;
			}

			const newSelectedItem = listItem.item;

			if (beforeChange(selectedItem, newSelectedItem)) {
				// simple selection
				if (!multiple) {
					$$invalidate(1, selectedItem = undefined); // triggers change even if the the same item is selected
					$$invalidate(1, selectedItem = newSelectedItem);
				} else // first selection of multiple ones
				if (!selectedItem) {
					$$invalidate(1, selectedItem = [newSelectedItem]);
				} else // selecting something already selected => unselect it
				if (selectedItem.includes(newSelectedItem)) {
					$$invalidate(1, selectedItem = selectedItem.filter(i => i !== newSelectedItem));
				} else // adds the element to the selection
				{
					$$invalidate(1, selectedItem = [...selectedItem, newSelectedItem]);
				}
			}

			return true;
		}

		function selectItem() {
			if (debug) {
				console.log("selectItem", highlightIndex);
			}

			const listItem = filteredListItems[highlightIndex];

			if (selectListItem(listItem)) {
				if (debug) {
					console.log("selectListItem true, closing");
				}

				close();

				if (multiple) {
					$$invalidate(2, text = "");
					input.focus();
				}
			} else {
				if (debug) {
					console.log("selectListItem false, not closing");
				}
			}
		}

		function up() {
			if (debug) {
				console.log("up");
			}

			open();

			if (highlightIndex > 0) {
				$$invalidate(30, highlightIndex--, highlightIndex);
			}

			highlight();
		}

		function down() {
			if (debug) {
				console.log("down");
			}

			open();

			if (highlightIndex < filteredListItems.length - 1) {
				$$invalidate(30, highlightIndex++, highlightIndex);
			}

			highlight();
		}

		function highlight() {
			if (debug) {
				console.log("highlight");
			}

			const query = ".selected";

			if (debug) {
				console.log("Seaching DOM element: " + query + " in " + list);
			}

			/**
	 * @param {Element} el
	 */
			const el = list && list.querySelector(query);

			if (el) {
				if (typeof el.scrollIntoViewIfNeeded === "function") {
					if (debug) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoViewIfNeeded();
				} else if (el.scrollIntoView === "function") {
					if (debug) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoView();
				} else {
					if (debug) {
						console.warn("Could not scroll selected item into view, scrollIntoViewIfNeeded not supported");
					}
				}
			} else {
				if (debug) {
					console.warn("Selected item not found to scroll into view");
				}
			}
		}

		function onListItemClick(listItem) {
			if (debug) {
				console.log("onListItemClick");
			}

			if (selectListItem(listItem)) {
				close();

				if (multiple) {
					$$invalidate(2, text = "");
					input.focus();
				}
			}
		}

		function onDocumentClick(e) {
			if (debug) {
				console.log("onDocumentClick");
			}

			if (e.composedPath().some(path => path.classList && path.classList.contains(uniqueId))) {
				if (debug) {
					console.log("onDocumentClick inside");
				}

				// resetListToAllItemsAndOpen();
				highlight();
			} else {
				if (debug) {
					console.log("onDocumentClick outside");
				}

				close();
			}
		}

		function onKeyDown(e) {
			if (debug) {
				console.log("onKeyDown");
			}

			let key = e.key;
			if (key === "Tab" && e.shiftKey) key = "ShiftTab";

			const fnmap = {
				Tab: opened ? close : null,
				ShiftTab: opened ? close : null,
				ArrowDown: down.bind(this),
				ArrowUp: up.bind(this),
				Escape: onEsc.bind(this),
				Backspace: multiple && hasSelection && !text
				? onBackspace.bind(this)
				: null
			};

			const fn = fnmap[key];

			if (typeof fn === "function") {
				fn(e);
			}
		}

		function onKeyPress(e) {
			if (debug) {
				console.log("onKeyPress");
			}

			if (e.key === "Enter") {
				onEnter(e);
			}
		}

		function onEnter(e) {
			if (opened) {
				e.preventDefault();
				selectItem();
			}
		}

		function onInput(e) {
			if (debug) {
				console.log("onInput");
			}

			$$invalidate(2, text = e.target.value);

			if (inputDelayTimeout) {
				clearTimeout(inputDelayTimeout);
			}

			if (delay) {
				inputDelayTimeout = setTimeout(processInput, delay);
			} else {
				processInput();
			}
		}

		function unselectItem(tag) {
			if (debug) {
				console.log("unselectItem", tag);
			}

			$$invalidate(1, selectedItem = selectedItem.filter(i => i !== tag));
			input.focus();
		}

		function processInput() {
			if (search()) {
				$$invalidate(30, highlightIndex = 0);
				open();
			}
		}

		function onInputClick() {
			if (debug) {
				console.log("onInputClick");
			}

			resetListToAllItemsAndOpen();
		}

		function onEsc(e) {
			if (debug) {
				console.log("onEsc");
			}

			//if (text) return clear();
			e.stopPropagation();

			if (opened) {
				input.focus();
				close();
			}
		}

		function onBackspace(e) {
			if (debug) {
				console.log("onBackspace");
			}

			unselectItem(selectedItem[selectedItem.length - 1]);
		}

		function onFocusInternal() {
			if (debug) {
				console.log("onFocus");
			}

			onFocus();
			resetListToAllItemsAndOpen();
		}

		function onBlurInternal() {
			if (debug) {
				console.log("onBlur");
			}

			if (closeOnBlur) {
				close();
			}

			onBlur();
		}

		function resetListToAllItemsAndOpen() {
			if (debug) {
				console.log("resetListToAllItemsAndOpen");
			}

			if (searchFunction && !listItems.length) {
				search();
			} else if (!text) {
				$$invalidate(31, filteredListItems = listItems);
			}

			open();

			// find selected item
			if (selectedItem) {
				if (debug) {
					console.log("Searching currently selected item: " + JSON.stringify(selectedItem));
				}

				const index = findItemIndex(selectedItem, filteredListItems);

				if (index >= 0) {
					$$invalidate(30, highlightIndex = index);
					highlight();
				}
			}
		}

		function findItemIndex(item, items) {
			if (debug) {
				console.log("Finding index for item", item);
			}

			let index = -1;

			for (let i = 0; i < items.length; i++) {
				const listItem = items[i];

				if ("undefined" === typeof listItem) {
					if (debug) {
						console.log(`listItem ${i} is undefined. Skipping.`);
					}

					continue;
				}

				if (debug) {
					console.log("Item " + i + ": " + JSON.stringify(listItem));
				}

				if (item === listItem.item) {
					index = i;
					break;
				}
			}

			if (debug) {
				if (index >= 0) {
					console.log("Found index for item: " + index);
				} else {
					console.warn("Not found index for item: " + item);
				}
			}

			return index;
		}

		function open() {
			if (debug) {
				console.log("open");
			}

			// check if the search text has more than the min chars required
			if (locked || notEnoughSearchText()) {
				return;
			}

			$$invalidate(37, setPositionOnNextUpdate = true);
			$$invalidate(94, opened = true);
		}

		function close() {
			if (debug) {
				console.log("close");
			}

			$$invalidate(94, opened = false);
			$$invalidate(36, loading = false);

			if (!text && selectFirstIfEmpty) {
				$$invalidate(30, highlightIndex = 0);
				selectItem();
			}
		}

		function notEnoughSearchText() {
			return minCharactersToSearch > 0 && filteredTextLength < minCharactersToSearch && (// When no searchFunction is defined, the menu should always open when the input is focused
			searchFunction || filteredTextLength > 0);
		}

		function closeIfMinCharsToSearchReached() {
			if (notEnoughSearchText()) {
				close();
				return true;
			}

			return false;
		}

		function clear() {
			if (debug) {
				console.log("clear");
			}

			$$invalidate(2, text = "");
			$$invalidate(1, selectedItem = multiple ? [] : undefined);

			setTimeout(() => {
				input.focus();
			});
		}

		function highlightFilter(keywords, field) {
			return item => {
				let label = item[field];
				const newItem = Object.assign({ highlighted: undefined }, item);
				newItem.highlighted = label;
				const labelLowercase = label.toLowerCase();

				const labelLowercaseNoAc = ignoreAccents
				? removeAccents(labelLowercase)
				: labelLowercase;

				if (keywords && keywords.length) {
					const positions = [];

					for (let i = 0; i < keywords.length; i++) {
						let keyword = keywords[i];

						if (ignoreAccents) {
							keyword = removeAccents(keyword);
						}

						const keywordLen = keyword.length;
						let pos1 = 0;

						do {
							pos1 = labelLowercaseNoAc.indexOf(keyword, pos1);

							if (pos1 >= 0) {
								let pos2 = pos1 + keywordLen;
								positions.push([pos1, pos2]);
								pos1 = pos2;
							}
						} while (pos1 !== -1);
					}

					if (positions.length > 0) {
						const keywordPatterns = new Set();

						for (let i = 0; i < positions.length; i++) {
							const pair = positions[i];
							const pos1 = pair[0];
							const pos2 = pair[1];
							const keywordPattern = labelLowercase.substring(pos1, pos2);
							keywordPatterns.add(keywordPattern);
						}

						for (let keywordPattern of keywordPatterns) {
							// FIXME pst: workarond for wrong replacement <b> tags
							if (keywordPattern === "b") {
								continue;
							}

							const reg = new RegExp("(" + keywordPattern + ")", "ig");
							const newHighlighted = newItem.highlighted.replace(reg, "<b>$1</b>");
							newItem.highlighted = newHighlighted;
						}
					}
				}

				return newItem;
			};
		}

		function isConfirmed(listItem) {
			if (!selectedItem) {
				return false;
			}

			if (multiple) {
				return selectedItem.includes(listItem);
			} else {
				return listItem === selectedItem;
			}
		}

		let draggingOver = false;

		function dragstart(event, index) {
			if (orderableSelection) {
				event.dataTransfer.setData("source", index);
			}
		}

		function dragover(event, index) {
			if (orderableSelection) {
				event.preventDefault();
				$$invalidate(38, draggingOver = index);
			}
		}

		function dragleave(event, index) {
			if (orderableSelection) {
				$$invalidate(38, draggingOver = false);
			}
		}

		function drop(event, index) {
			if (orderableSelection) {
				event.preventDefault();
				$$invalidate(38, draggingOver = false);
				let from = parseInt(event.dataTransfer.getData("source"));
				let to = index;

				if (from != to) {
					moveSelectedItem(from, to);
				}
			}
		}

		function moveSelectedItem(from, to) {
			let newSelection = [...selectedItem];

			if (from < to) {
				newSelection.splice(to + 1, 0, newSelection[from]);
				newSelection.splice(from, 1);
			} else {
				newSelection.splice(to, 0, newSelection[from]);
				newSelection.splice(from + 1, 1);
			}

			$$invalidate(1, selectedItem = newSelection);
		}

		function setScrollAwareListPosition() {
			const { height: viewPortHeight } = window.visualViewport;
			const { bottom: inputButtom, height: inputHeight } = inputContainer.getBoundingClientRect();
			const { height: listHeight } = list.getBoundingClientRect();

			if (inputButtom + listHeight > viewPortHeight) {
				$$invalidate(34, list.style.top = `-${inputHeight + listHeight}px`, list);
			} else {
				$$invalidate(34, list.style.top = "0px", list);
			}
		}

		const scroll_handler = () => $$invalidate(37, setPositionOnNextUpdate = true);

		const keypress_handler = (tagItem, e) => {
			e.key == "Enter" && unselectItem(tagItem);
		};

		const dragstart_handler = (i, event) => dragstart(event, i);
		const dragover_handler = (i, event) => dragover(event, i);
		const dragleave_handler = (i, event) => dragleave();
		const drop_handler = (i, event) => drop(event, i);

		function input_1_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				input = $$value;
				$$invalidate(33, input);
			});
		}

		function input_1_input_handler() {
			text = this.value;
			$$invalidate(2, text);
		}

		const dragover_handler_1 = event => dragover(event, selectedItem.length - 1);
		const drop_handler_1 = event => drop(event, selectedItem.length - 1);

		const keypress_handler_1 = e => {
			e.key == "Enter" && clear();
		};

		function div0_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				inputContainer = $$value;
				$$invalidate(35, inputContainer);
			});
		}

		const click_handler = listItem => onListItemClick(listItem);

		const keypress_handler_2 = (listItem, e) => {
			e.key == "Enter" && onListItemClick(listItem);
		};

		const pointerenter_handler = i => {
			$$invalidate(30, highlightIndex = i);
		};

		const keypress_handler_3 = e => {
			e.key == "Enter" && selectItem();
		};

		function div1_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				list = $$value;
				$$invalidate(34, list);
			});
		}

		$$self.$$set = $$new_props => {
			$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
			$$invalidate(60, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('items' in $$new_props) $$invalidate(0, items = $$new_props.items);
			if ('searchFunction' in $$new_props) $$invalidate(63, searchFunction = $$new_props.searchFunction);
			if ('labelFieldName' in $$new_props) $$invalidate(64, labelFieldName = $$new_props.labelFieldName);
			if ('keywordsFieldName' in $$new_props) $$invalidate(65, keywordsFieldName = $$new_props.keywordsFieldName);
			if ('valueFieldName' in $$new_props) $$invalidate(66, valueFieldName = $$new_props.valueFieldName);
			if ('labelFunction' in $$new_props) $$invalidate(67, labelFunction = $$new_props.labelFunction);
			if ('keywordsFunction' in $$new_props) $$invalidate(68, keywordsFunction = $$new_props.keywordsFunction);
			if ('valueFunction' in $$new_props) $$invalidate(3, valueFunction = $$new_props.valueFunction);
			if ('keywordsCleanFunction' in $$new_props) $$invalidate(69, keywordsCleanFunction = $$new_props.keywordsCleanFunction);
			if ('textCleanFunction' in $$new_props) $$invalidate(70, textCleanFunction = $$new_props.textCleanFunction);
			if ('beforeChange' in $$new_props) $$invalidate(71, beforeChange = $$new_props.beforeChange);
			if ('onChange' in $$new_props) $$invalidate(72, onChange = $$new_props.onChange);
			if ('onFocus' in $$new_props) $$invalidate(73, onFocus = $$new_props.onFocus);
			if ('onBlur' in $$new_props) $$invalidate(74, onBlur = $$new_props.onBlur);
			if ('onCreate' in $$new_props) $$invalidate(75, onCreate = $$new_props.onCreate);
			if ('selectFirstIfEmpty' in $$new_props) $$invalidate(76, selectFirstIfEmpty = $$new_props.selectFirstIfEmpty);
			if ('minCharactersToSearch' in $$new_props) $$invalidate(77, minCharactersToSearch = $$new_props.minCharactersToSearch);
			if ('maxItemsToShowInList' in $$new_props) $$invalidate(4, maxItemsToShowInList = $$new_props.maxItemsToShowInList);
			if ('multiple' in $$new_props) $$invalidate(5, multiple = $$new_props.multiple);
			if ('create' in $$new_props) $$invalidate(6, create = $$new_props.create);
			if ('ignoreAccents' in $$new_props) $$invalidate(78, ignoreAccents = $$new_props.ignoreAccents);
			if ('matchAllKeywords' in $$new_props) $$invalidate(79, matchAllKeywords = $$new_props.matchAllKeywords);
			if ('sortByMatchedKeywords' in $$new_props) $$invalidate(80, sortByMatchedKeywords = $$new_props.sortByMatchedKeywords);
			if ('itemFilterFunction' in $$new_props) $$invalidate(81, itemFilterFunction = $$new_props.itemFilterFunction);
			if ('itemSortFunction' in $$new_props) $$invalidate(82, itemSortFunction = $$new_props.itemSortFunction);
			if ('lock' in $$new_props) $$invalidate(83, lock = $$new_props.lock);
			if ('delay' in $$new_props) $$invalidate(84, delay = $$new_props.delay);
			if ('localFiltering' in $$new_props) $$invalidate(85, localFiltering = $$new_props.localFiltering);
			if ('localSorting' in $$new_props) $$invalidate(86, localSorting = $$new_props.localSorting);
			if ('cleanUserText' in $$new_props) $$invalidate(87, cleanUserText = $$new_props.cleanUserText);
			if ('lowercaseKeywords' in $$new_props) $$invalidate(88, lowercaseKeywords = $$new_props.lowercaseKeywords);
			if ('closeOnBlur' in $$new_props) $$invalidate(89, closeOnBlur = $$new_props.closeOnBlur);
			if ('orderableSelection' in $$new_props) $$invalidate(90, orderableSelection = $$new_props.orderableSelection);
			if ('hideArrow' in $$new_props) $$invalidate(7, hideArrow = $$new_props.hideArrow);
			if ('showClear' in $$new_props) $$invalidate(91, showClear = $$new_props.showClear);
			if ('clearText' in $$new_props) $$invalidate(8, clearText = $$new_props.clearText);
			if ('showLoadingIndicator' in $$new_props) $$invalidate(9, showLoadingIndicator = $$new_props.showLoadingIndicator);
			if ('noResultsText' in $$new_props) $$invalidate(10, noResultsText = $$new_props.noResultsText);
			if ('loadingText' in $$new_props) $$invalidate(11, loadingText = $$new_props.loadingText);
			if ('moreItemsText' in $$new_props) $$invalidate(12, moreItemsText = $$new_props.moreItemsText);
			if ('createText' in $$new_props) $$invalidate(13, createText = $$new_props.createText);
			if ('placeholder' in $$new_props) $$invalidate(14, placeholder = $$new_props.placeholder);
			if ('className' in $$new_props) $$invalidate(15, className = $$new_props.className);
			if ('inputClassName' in $$new_props) $$invalidate(16, inputClassName = $$new_props.inputClassName);
			if ('inputId' in $$new_props) $$invalidate(17, inputId = $$new_props.inputId);
			if ('name' in $$new_props) $$invalidate(18, name = $$new_props.name);
			if ('selectName' in $$new_props) $$invalidate(19, selectName = $$new_props.selectName);
			if ('selectId' in $$new_props) $$invalidate(20, selectId = $$new_props.selectId);
			if ('title' in $$new_props) $$invalidate(21, title = $$new_props.title);
			if ('html5autocomplete' in $$new_props) $$invalidate(22, html5autocomplete = $$new_props.html5autocomplete);
			if ('autocompleteOffValue' in $$new_props) $$invalidate(23, autocompleteOffValue = $$new_props.autocompleteOffValue);
			if ('readonly' in $$new_props) $$invalidate(24, readonly = $$new_props.readonly);
			if ('dropdownClassName' in $$new_props) $$invalidate(25, dropdownClassName = $$new_props.dropdownClassName);
			if ('disabled' in $$new_props) $$invalidate(26, disabled = $$new_props.disabled);
			if ('noInputStyles' in $$new_props) $$invalidate(27, noInputStyles = $$new_props.noInputStyles);
			if ('required' in $$new_props) $$invalidate(28, required = $$new_props.required);
			if ('debug' in $$new_props) $$invalidate(92, debug = $$new_props.debug);
			if ('tabindex' in $$new_props) $$invalidate(29, tabindex = $$new_props.tabindex);
			if ('selectedItem' in $$new_props) $$invalidate(1, selectedItem = $$new_props.selectedItem);
			if ('value' in $$new_props) $$invalidate(61, value = $$new_props.value);
			if ('highlightedItem' in $$new_props) $$invalidate(62, highlightedItem = $$new_props.highlightedItem);
			if ('text' in $$new_props) $$invalidate(2, text = $$new_props.text);
			if ('$$scope' in $$new_props) $$invalidate(96, $$scope = $$new_props.$$scope);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*items*/ 1 | $$self.$$.dirty[2] & /*searchFunction*/ 2) {
				// -- Reactivity --
				(searchFunction || prepareListItems());
			}

			if ($$self.$$.dirty[0] & /*selectedItem*/ 2) {
				(onSelectedItemChanged());
			}

			if ($$self.$$.dirty[0] & /*highlightIndex*/ 1073741824 | $$self.$$.dirty[1] & /*filteredListItems*/ 1) {
				$$invalidate(62, highlightedItem = filteredListItems && highlightIndex && highlightIndex >= 0 && highlightIndex < filteredListItems.length
				? filteredListItems[highlightIndex].item
				: null);
			}

			if ($$self.$$.dirty[0] & /*items*/ 1 | $$self.$$.dirty[3] & /*opened, filteredTextLength*/ 6) {
				$$invalidate(41, showList = opened && (items && items.length > 0 || filteredTextLength > 0));
			}

			if ($$self.$$.dirty[0] & /*multiple, selectedItem*/ 34) {
				$$invalidate(32, hasSelection = multiple && selectedItem && selectedItem.length > 0 || !multiple && selectedItem);
			}

			if ($$self.$$.dirty[0] & /*multiple*/ 32 | $$self.$$.dirty[1] & /*hasSelection*/ 2 | $$self.$$.dirty[2] & /*showClear, lock*/ 538968064) {
				$$invalidate(40, clearable = showClear || (lock || multiple) && hasSelection);
			}

			if ($$self.$$.dirty[1] & /*hasSelection*/ 2 | $$self.$$.dirty[2] & /*lock*/ 2097152) {
				$$invalidate(39, locked = lock && hasSelection);
			}
		};

		return [
			items,
			selectedItem,
			text,
			valueFunction,
			maxItemsToShowInList,
			multiple,
			create,
			hideArrow,
			clearText,
			showLoadingIndicator,
			noResultsText,
			loadingText,
			moreItemsText,
			createText,
			placeholder,
			className,
			inputClassName,
			inputId,
			name,
			selectName,
			selectId,
			title,
			html5autocomplete,
			autocompleteOffValue,
			readonly,
			dropdownClassName,
			disabled,
			noInputStyles,
			required,
			tabindex,
			highlightIndex,
			filteredListItems,
			hasSelection,
			input,
			list,
			inputContainer,
			loading,
			setPositionOnNextUpdate,
			draggingOver,
			locked,
			clearable,
			showList,
			uniqueId,
			safeLabelFunction,
			selectItem,
			onListItemClick,
			onDocumentClick,
			onKeyDown,
			onKeyPress,
			onInput,
			unselectItem,
			onInputClick,
			onFocusInternal,
			onBlurInternal,
			clear,
			isConfirmed,
			dragstart,
			dragover,
			dragleave,
			drop,
			$$restProps,
			value,
			highlightedItem,
			searchFunction,
			labelFieldName,
			keywordsFieldName,
			valueFieldName,
			labelFunction,
			keywordsFunction,
			keywordsCleanFunction,
			textCleanFunction,
			beforeChange,
			onChange,
			onFocus,
			onBlur,
			onCreate,
			selectFirstIfEmpty,
			minCharactersToSearch,
			ignoreAccents,
			matchAllKeywords,
			sortByMatchedKeywords,
			itemFilterFunction,
			itemSortFunction,
			lock,
			delay,
			localFiltering,
			localSorting,
			cleanUserText,
			lowercaseKeywords,
			closeOnBlur,
			orderableSelection,
			showClear,
			debug,
			highlightFilter,
			opened,
			filteredTextLength,
			$$scope,
			slots,
			scroll_handler,
			keypress_handler,
			dragstart_handler,
			dragover_handler,
			dragleave_handler,
			drop_handler,
			input_1_binding,
			input_1_input_handler,
			dragover_handler_1,
			drop_handler_1,
			keypress_handler_1,
			div0_binding,
			click_handler,
			keypress_handler_2,
			pointerenter_handler,
			keypress_handler_3,
			div1_binding
		];
	}

	class SimpleAutocomplete extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$1c,
				create_fragment$1d,
				safe_not_equal,
				{
					items: 0,
					searchFunction: 63,
					labelFieldName: 64,
					keywordsFieldName: 65,
					valueFieldName: 66,
					labelFunction: 67,
					keywordsFunction: 68,
					valueFunction: 3,
					keywordsCleanFunction: 69,
					textCleanFunction: 70,
					beforeChange: 71,
					onChange: 72,
					onFocus: 73,
					onBlur: 74,
					onCreate: 75,
					selectFirstIfEmpty: 76,
					minCharactersToSearch: 77,
					maxItemsToShowInList: 4,
					multiple: 5,
					create: 6,
					ignoreAccents: 78,
					matchAllKeywords: 79,
					sortByMatchedKeywords: 80,
					itemFilterFunction: 81,
					itemSortFunction: 82,
					lock: 83,
					delay: 84,
					localFiltering: 85,
					localSorting: 86,
					cleanUserText: 87,
					lowercaseKeywords: 88,
					closeOnBlur: 89,
					orderableSelection: 90,
					hideArrow: 7,
					showClear: 91,
					clearText: 8,
					showLoadingIndicator: 9,
					noResultsText: 10,
					loadingText: 11,
					moreItemsText: 12,
					createText: 13,
					placeholder: 14,
					className: 15,
					inputClassName: 16,
					inputId: 17,
					name: 18,
					selectName: 19,
					selectId: 20,
					title: 21,
					html5autocomplete: 22,
					autocompleteOffValue: 23,
					readonly: 24,
					dropdownClassName: 25,
					disabled: 26,
					noInputStyles: 27,
					required: 28,
					debug: 92,
					tabindex: 29,
					selectedItem: 1,
					value: 61,
					highlightedItem: 62,
					text: 2,
					highlightFilter: 93
				},
				null,
				[-1, -1, -1, -1, -1]
			);
		}

		get highlightFilter() {
			return this.$$.ctx[93];
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.autocomplete.svelte generated by Svelte v4.2.19 */

	function create_else_block$w(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		const if_block_creators = [create_if_block_1$A, create_else_block_1$6];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*readonly*/ ctx[11]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[26](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[27](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[28](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[9]
		};

		if (/*allErrors*/ ctx[16] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[16];
		}

		if (/*showErrors*/ ctx[15] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[15];
		}

		if (/*validationClasses*/ ctx[14] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[14];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", "control");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 512) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[9];

				if (!updating_errors && dirty[0] & /*allErrors*/ 65536) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[16];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 32768) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[15];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 16384) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[14];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	// (63:0) {#if readonly}
	function create_if_block$L(ctx) {
		let uitextfield;
		let current;

		uitextfield = new Ui_textfield({
				props: {
					value: /*value*/ ctx[0] ? /*value*/ ctx[0].title : "",
					fieldname: /*fieldname*/ ctx[9],
					placeholder: /*placeholder*/ ctx[8],
					icon: /*icon*/ ctx[12]
				}
			});

		return {
			c() {
				create_component(uitextfield.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitextfield, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitextfield_changes = {};
				if (dirty[0] & /*value*/ 1) uitextfield_changes.value = /*value*/ ctx[0] ? /*value*/ ctx[0].title : "";
				if (dirty[0] & /*fieldname*/ 512) uitextfield_changes.fieldname = /*fieldname*/ ctx[9];
				if (dirty[0] & /*placeholder*/ 256) uitextfield_changes.placeholder = /*placeholder*/ ctx[8];
				if (dirty[0] & /*icon*/ 4096) uitextfield_changes.icon = /*icon*/ ctx[12];
				uitextfield.$set(uitextfield_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitextfield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitextfield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitextfield, detaching);
			}
		};
	}

	// (74:8) {:else}
	function create_else_block_1$6(ctx) {
		let autocomplete;
		let updating_selectedItem;
		let current;

		function autocomplete_selectedItem_binding(value) {
			/*autocomplete_selectedItem_binding*/ ctx[25](value);
		}

		let autocomplete_props = {
			showClear: /*showClear*/ ctx[7],
			disabled: /*disabled*/ ctx[10],
			placeholder: /*placeholder*/ ctx[8],
			noResultsText: /*noResultsText*/ ctx[6],
			onChange: /*onChange*/ ctx[18],
			searchFunction: /*searchFunction*/ ctx[13],
			hideArrow: true,
			labelFieldName: /*labelField*/ ctx[2],
			valueFieldName: /*idField*/ ctx[1],
			minCharactersToSearch: /*minCharactersToSearch*/ ctx[3],
			selectFirstIfEmpty: /*selectFirstIfEmpty*/ ctx[4],
			maxItemsToShowInList: /*maxItemsToShowInList*/ ctx[5]
		};

		if (/*value*/ ctx[0] !== void 0) {
			autocomplete_props.selectedItem = /*value*/ ctx[0];
		}

		autocomplete = new SimpleAutocomplete({ props: autocomplete_props });
		binding_callbacks.push(() => bind(autocomplete, 'selectedItem', autocomplete_selectedItem_binding));

		return {
			c() {
				create_component(autocomplete.$$.fragment);
			},
			m(target, anchor) {
				mount_component(autocomplete, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const autocomplete_changes = {};
				if (dirty[0] & /*showClear*/ 128) autocomplete_changes.showClear = /*showClear*/ ctx[7];
				if (dirty[0] & /*disabled*/ 1024) autocomplete_changes.disabled = /*disabled*/ ctx[10];
				if (dirty[0] & /*placeholder*/ 256) autocomplete_changes.placeholder = /*placeholder*/ ctx[8];
				if (dirty[0] & /*noResultsText*/ 64) autocomplete_changes.noResultsText = /*noResultsText*/ ctx[6];
				if (dirty[0] & /*searchFunction*/ 8192) autocomplete_changes.searchFunction = /*searchFunction*/ ctx[13];
				if (dirty[0] & /*labelField*/ 4) autocomplete_changes.labelFieldName = /*labelField*/ ctx[2];
				if (dirty[0] & /*idField*/ 2) autocomplete_changes.valueFieldName = /*idField*/ ctx[1];
				if (dirty[0] & /*minCharactersToSearch*/ 8) autocomplete_changes.minCharactersToSearch = /*minCharactersToSearch*/ ctx[3];
				if (dirty[0] & /*selectFirstIfEmpty*/ 16) autocomplete_changes.selectFirstIfEmpty = /*selectFirstIfEmpty*/ ctx[4];
				if (dirty[0] & /*maxItemsToShowInList*/ 32) autocomplete_changes.maxItemsToShowInList = /*maxItemsToShowInList*/ ctx[5];

				if (!updating_selectedItem && dirty[0] & /*value*/ 1) {
					updating_selectedItem = true;
					autocomplete_changes.selectedItem = /*value*/ ctx[0];
					add_flush_callback(() => updating_selectedItem = false);
				}

				autocomplete.$set(autocomplete_changes);
			},
			i(local) {
				if (current) return;
				transition_in(autocomplete.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(autocomplete.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(autocomplete, detaching);
			}
		};
	}

	// (72:8) {#if readonly}
	function create_if_block_1$A(ctx) {
		let p;
		let t_value = /*$LOCALE*/ ctx[17][/*value*/ ctx[0]] + "";
		let t;

		return {
			c() {
				p = element("p");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, value*/ 131073 && t_value !== (t_value = /*$LOCALE*/ ctx[17][/*value*/ ctx[0]] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	function create_fragment$1c(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$L, create_else_block$w];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[11]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$1b($$self, $$props, $$invalidate) {
		let allErrors;
		let showErrors;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(17, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { idField = "_id" } = $$props;
		let { labelField = "title" } = $$props;
		let { minCharactersToSearch = 3 } = $$props;
		let { selectFirstIfEmpty = false } = $$props;
		let { maxItemsToShowInList = 20 } = $$props;
		let { noResultsText = "Ничего не найдено" } = $$props;
		let { showClear = true } = $$props;
		let { value } = $$props;
		let { placeholder = "" } = $$props;
		let { fieldname = "checkbox-list" } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { icon = false } = $$props;
		let { inputStarted = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		let { searchFunction = () => /*term*/ {
			return [];
		} } = $$props;

		function onChange() {
			let data = { field: fieldname, value };
			$$invalidate(19, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function autocomplete_selectedItem_binding(value$1) {
			value = value$1;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(16, allErrors), $$invalidate(22, errors)), $$invalidate(23, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(15, showErrors), $$invalidate(21, validated)), $$invalidate(20, valid)), $$invalidate(19, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(14, validationClasses), $$invalidate(20, valid)), $$invalidate(19, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('idField' in $$props) $$invalidate(1, idField = $$props.idField);
			if ('labelField' in $$props) $$invalidate(2, labelField = $$props.labelField);
			if ('minCharactersToSearch' in $$props) $$invalidate(3, minCharactersToSearch = $$props.minCharactersToSearch);
			if ('selectFirstIfEmpty' in $$props) $$invalidate(4, selectFirstIfEmpty = $$props.selectFirstIfEmpty);
			if ('maxItemsToShowInList' in $$props) $$invalidate(5, maxItemsToShowInList = $$props.maxItemsToShowInList);
			if ('noResultsText' in $$props) $$invalidate(6, noResultsText = $$props.noResultsText);
			if ('showClear' in $$props) $$invalidate(7, showClear = $$props.showClear);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(8, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(9, fieldname = $$props.fieldname);
			if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(11, readonly = $$props.readonly);
			if ('icon' in $$props) $$invalidate(12, icon = $$props.icon);
			if ('inputStarted' in $$props) $$invalidate(19, inputStarted = $$props.inputStarted);
			if ('valid' in $$props) $$invalidate(20, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(21, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(22, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(23, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(24, formLevelError = $$props.formLevelError);
			if ('searchFunction' in $$props) $$invalidate(13, searchFunction = $$props.searchFunction);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 4096) ;

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 12582912) {
				$$invalidate(16, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 3670016) {
				$$invalidate(15, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 17825792) ;

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 1572864) {
				$$invalidate(14, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			idField,
			labelField,
			minCharactersToSearch,
			selectFirstIfEmpty,
			maxItemsToShowInList,
			noResultsText,
			showClear,
			placeholder,
			fieldname,
			disabled,
			readonly,
			icon,
			searchFunction,
			validationClasses,
			showErrors,
			allErrors,
			$LOCALE,
			onChange,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			autocomplete_selectedItem_binding,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_autocomplete extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$1b,
				create_fragment$1c,
				safe_not_equal,
				{
					idField: 1,
					labelField: 2,
					minCharactersToSearch: 3,
					selectFirstIfEmpty: 4,
					maxItemsToShowInList: 5,
					noResultsText: 6,
					showClear: 7,
					value: 0,
					placeholder: 8,
					fieldname: 9,
					disabled: 10,
					readonly: 11,
					icon: 12,
					inputStarted: 19,
					valid: 20,
					validated: 21,
					errors: 22,
					formErrors: 23,
					formLevelError: 24,
					searchFunction: 13
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.checkbox.svelte generated by Svelte v4.2.19 */

	function create_else_block$v(ctx) {
		let input;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1_value = /*$LOCALE*/ ctx[12][/*label*/ ctx[1]] + "";
		let t1;
		let mounted;
		let dispose;

		return {
			c() {
				input = element("input");
				t0 = space();
				t1 = text(t1_value);
				attr(input, "type", "checkbox");
				attr(input, "id", input_id_value = "form-field-checkbox-" + /*fieldname*/ ctx[3]);
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[12][/*placeholder*/ ctx[2]]);
				attr(input, "name", /*fieldname*/ ctx[3]);
				input.required = /*required*/ ctx[4];
				input.readOnly = /*readonly*/ ctx[5];
				attr(input, "invalid", /*invalid*/ ctx[8]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[3]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[3]);
				input.disabled = /*disabled*/ ctx[6];
			},
			m(target, anchor) {
				insert(target, input, anchor);
				input.checked = /*value*/ ctx[0];
				insert(target, t0, anchor);
				insert(target, t1, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[22]),
						listen(input, "change", /*onBlur*/ ctx[13]),
						listen(input, "input", /*onInput*/ ctx[14])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 8 && input_id_value !== (input_id_value = "form-field-checkbox-" + /*fieldname*/ ctx[3])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*$LOCALE, placeholder*/ 4100 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[12][/*placeholder*/ ctx[2]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 8) {
					attr(input, "name", /*fieldname*/ ctx[3]);
				}

				if (dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (dirty & /*invalid*/ 256) {
					attr(input, "invalid", /*invalid*/ ctx[8]);
				}

				if (dirty & /*fieldname*/ 8 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[3])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[3])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*disabled*/ 64) {
					input.disabled = /*disabled*/ ctx[6];
				}

				if (dirty & /*value*/ 1) {
					input.checked = /*value*/ ctx[0];
				}

				if (dirty & /*$LOCALE, label*/ 4098 && t1_value !== (t1_value = /*$LOCALE*/ ctx[12][/*label*/ ctx[1]] + "")) set_data(t1, t1_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (66:8) {#if readonly}
	function create_if_block$K(ctx) {
		let uibooleans;
		let current;

		uibooleans = new Ui_booleans({
				props: {
					LC_TRUE: /*label*/ ctx[1],
					LC_FALSE: /*label*/ ctx[1],
					values: [{ value: /*value*/ ctx[0] }]
				}
			});

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibooleans_changes = {};
				if (dirty & /*label*/ 2) uibooleans_changes.LC_TRUE = /*label*/ ctx[1];
				if (dirty & /*label*/ 2) uibooleans_changes.LC_FALSE = /*label*/ ctx[1];
				if (dirty & /*value*/ 1) uibooleans_changes.values = [{ value: /*value*/ ctx[0] }];
				uibooleans.$set(uibooleans_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	function create_fragment$1b(ctx) {
		let div;
		let label_1;
		let current_block_type_index;
		let if_block;
		let label_1_for_value;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		const if_block_creators = [create_if_block$K, create_else_block$v];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[5]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[23](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[24](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[25](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[3]
		};

		if (/*allErrors*/ ctx[10] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[10];
		}

		if (/*showErrors*/ ctx[9] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[9];
		}

		if (/*validationClasses*/ ctx[7] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[7];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				label_1 = element("label");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(label_1, "class", "checkbox");
				attr(label_1, "disabled", /*disabled*/ ctx[6]);
				attr(label_1, "for", label_1_for_value = "form-field-checkbox-" + /*fieldname*/ ctx[3]);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[11]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, label_1);
				if_blocks[current_block_type_index].m(label_1, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(label_1, null);
				}

				if (!current || dirty & /*disabled*/ 64) {
					attr(label_1, "disabled", /*disabled*/ ctx[6]);
				}

				if (!current || dirty & /*fieldname*/ 8 && label_1_for_value !== (label_1_for_value = "form-field-checkbox-" + /*fieldname*/ ctx[3])) {
					attr(label_1, "for", label_1_for_value);
				}

				if (!current || dirty & /*iconClasses*/ 2048 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[11])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 8) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[3];

				if (!updating_errors && dirty & /*allErrors*/ 1024) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[10];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 512) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[9];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 128) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[7];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$1a($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(12, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = false } = $$props;
		let { label = "checkbox" } = $$props;
		let { placeholder = "checkbox placeholder" } = $$props;
		let { fieldname = "checkbox" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.type === "checkbox"
				? ev.currentTarget.checked
				: value
			};

			$$invalidate(15, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.type === "checkbox"
				? ev.currentTarget.checked
				: value
			};

			$$invalidate(15, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_change_handler() {
			value = this.checked;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(10, allErrors), $$invalidate(19, errors)), $$invalidate(20, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(9, showErrors), $$invalidate(18, validated)), $$invalidate(17, valid)), $$invalidate(15, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(7, validationClasses), $$invalidate(17, valid)), $$invalidate(15, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(15, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
			if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(3, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(16, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(6, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(17, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(18, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(19, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(20, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(21, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 65536) {
				$$invalidate(11, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 1572864) {
				$$invalidate(10, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 425984) {
				$$invalidate(9, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 2228224) {
				$$invalidate(8, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 163840) {
				$$invalidate(7, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			label,
			placeholder,
			fieldname,
			required,
			readonly,
			disabled,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			icon,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_checkbox extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1a, create_fragment$1b, safe_not_equal, {
				inputStarted: 15,
				value: 0,
				label: 1,
				placeholder: 2,
				fieldname: 3,
				icon: 16,
				required: 4,
				readonly: 5,
				disabled: 6,
				valid: 17,
				validated: 18,
				errors: 19,
				formErrors: 20,
				formLevelError: 21
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.checkbox.list.svelte generated by Svelte v4.2.19 */

	function get_each_context$i(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[22] = list[i];
		child_ctx[23] = list;
		child_ctx[24] = i;
		return child_ctx;
	}

	// (62:4) {#each value as item (item.id)}
	function create_each_block$i(key_1, ctx) {
		let label;
		let input;
		let input_data_id_value;
		let input_id_value;
		let input_placeholder_value;
		let input_name_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let input_disabled_value;
		let t0;
		let t1_value = /*$LOCALE*/ ctx[8][/*item*/ ctx[22].label] + "";
		let t1;
		let t2;
		let label_disabled_value;
		let label_for_value;
		let mounted;
		let dispose;

		function input_change_handler() {
			/*input_change_handler*/ ctx[17].call(input, /*each_value*/ ctx[23], /*item_index*/ ctx[24]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				label = element("label");
				input = element("input");
				t0 = space();
				t1 = text(t1_value);
				t2 = space();
				attr(input, "data-id", input_data_id_value = /*item*/ ctx[22].id);
				attr(input, "id", input_id_value = "form-field-checkboxlist-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id));
				attr(input, "type", "checkbox");
				attr(input, "placeholder", input_placeholder_value = LOCALE[/*item*/ ctx[22].placeholder]);
				attr(input, "name", input_name_value = /*fieldname*/ ctx[1] + "_" + /*item*/ ctx[22].id);
				input.readOnly = /*readonly*/ ctx[2];
				attr(input, "invalid", /*invalid*/ ctx[5]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id));
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id));
				input.disabled = input_disabled_value = /*disabled*/ ctx[3] || /*item*/ ctx[22].disabled;
				attr(label, "class", "checkbox pr-2");
				attr(label, "disabled", label_disabled_value = /*disabled*/ ctx[3] || /*item*/ ctx[22].disabled);
				attr(label, "for", label_for_value = "form-field-checkbox-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id));
				this.first = label;
			},
			m(target, anchor) {
				insert(target, label, anchor);
				append(label, input);
				input.checked = /*item*/ ctx[22].value;
				append(label, t0);
				append(label, t1);
				append(label, t2);

				if (!mounted) {
					dispose = [
						listen(input, "change", input_change_handler),
						listen(input, "change", /*onBlur*/ ctx[9]),
						listen(input, "input", /*onInput*/ ctx[10])
					];

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*value*/ 1 && input_data_id_value !== (input_data_id_value = /*item*/ ctx[22].id)) {
					attr(input, "data-id", input_data_id_value);
				}

				if (dirty & /*fieldname, value*/ 3 && input_id_value !== (input_id_value = "form-field-checkboxlist-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id))) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*value*/ 1 && input_placeholder_value !== (input_placeholder_value = LOCALE[/*item*/ ctx[22].placeholder])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname, value*/ 3 && input_name_value !== (input_name_value = /*fieldname*/ ctx[1] + "_" + /*item*/ ctx[22].id)) {
					attr(input, "name", input_name_value);
				}

				if (dirty & /*readonly*/ 4) {
					input.readOnly = /*readonly*/ ctx[2];
				}

				if (dirty & /*invalid*/ 32) {
					attr(input, "invalid", /*invalid*/ ctx[5]);
				}

				if (dirty & /*fieldname, value*/ 3 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id))) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname, value*/ 3 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id))) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*disabled, value*/ 9 && input_disabled_value !== (input_disabled_value = /*disabled*/ ctx[3] || /*item*/ ctx[22].disabled)) {
					input.disabled = input_disabled_value;
				}

				if (dirty & /*value*/ 1) {
					input.checked = /*item*/ ctx[22].value;
				}

				if (dirty & /*$LOCALE, value*/ 257 && t1_value !== (t1_value = /*$LOCALE*/ ctx[8][/*item*/ ctx[22].label] + "")) set_data(t1, t1_value);

				if (dirty & /*disabled, value*/ 9 && label_disabled_value !== (label_disabled_value = /*disabled*/ ctx[3] || /*item*/ ctx[22].disabled)) {
					attr(label, "disabled", label_disabled_value);
				}

				if (dirty & /*fieldname, value*/ 3 && label_for_value !== (label_for_value = "form-field-checkbox-" + (/*fieldname*/ ctx[1] + '_' + /*item*/ ctx[22].id))) {
					attr(label, "for", label_for_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(label);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	function create_fragment$1a(ctx) {
		let div;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		let each_value = ensure_array_like(/*value*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[22].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$i(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$i(key, child_ctx));
		}

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[18](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[19](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[20](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[1]
		};

		if (/*allErrors*/ ctx[7] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[7];
		}

		if (/*showErrors*/ ctx[6] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[6];
		}

		if (/*validationClasses*/ ctx[4] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[4];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", "control");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*disabled, value, fieldname, $LOCALE, readonly, invalid, onBlur, onInput*/ 1839) {
					each_value = ensure_array_like(/*value*/ ctx[0]);
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, destroy_block, create_each_block$i, null, get_each_context$i);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 2) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[1];

				if (!updating_errors && dirty & /*allErrors*/ 128) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[7];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 64) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[6];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 16) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[4];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}

				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$19($$self, $$props, $$invalidate) {
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(8, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = [] } = $$props;
		let { fieldname = "checkbox-list" } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let id = parseInt(ev.currentTarget.dataset.id);
			let copy = [...value];
			copy.find(itm => itm.id == id).value = ev.currentTarget.checked;
			let data = { id, field: fieldname, value: copy };
			$$invalidate(11, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let id = parseInt(ev.currentTarget.dataset.id);
			let copy = [...value];
			copy.find(itm => itm.id === id).value = ev.currentTarget.checked;
			let data = { id, field: fieldname, value: copy };
			$$invalidate(11, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_change_handler(each_value, item_index) {
			each_value[item_index].value = this.checked;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(7, allErrors), $$invalidate(14, errors)), $$invalidate(15, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(6, showErrors), $$invalidate(13, validated)), $$invalidate(12, valid)), $$invalidate(11, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(4, validationClasses), $$invalidate(12, valid)), $$invalidate(11, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(11, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('readonly' in $$props) $$invalidate(2, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(12, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(13, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(14, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(15, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(16, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*errors, formErrors*/ 49152) {
				$$invalidate(7, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 14336) {
				$$invalidate(6, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 69632) {
				$$invalidate(5, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 6144) {
				$$invalidate(4, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			fieldname,
			readonly,
			disabled,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_checkbox_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$19, create_fragment$1a, safe_not_equal, {
				inputStarted: 11,
				value: 0,
				fieldname: 1,
				readonly: 2,
				disabled: 3,
				valid: 12,
				validated: 13,
				errors: 14,
				formErrors: 15,
				formLevelError: 16
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.color.svelte generated by Svelte v4.2.19 */

	function create_if_block_3$l(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (74:4) {#if validated === true}
	function create_if_block$J(ctx) {
		let span;

		function select_block_type(ctx, dirty) {
			if (/*valid*/ ctx[6] === true) return create_if_block_1$z;
			if (/*valid*/ ctx[6] === false) return create_if_block_2$p;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (78:38) 
	function create_if_block_2$p(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (76:12) {#if valid === true}
	function create_if_block_1$z(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$19(ctx) {
		let div;
		let input;
		let input_id_value;
		let input_class_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let div_class_value;
		let t2;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_3$l(ctx);
		let if_block1 = /*validated*/ ctx[7] === true && create_if_block$J(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[21](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[22](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[23](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[11] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[11];
		}

		if (/*showErrors*/ ctx[10] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[10];
		}

		if (/*validationClasses*/ ctx[8] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[8];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				t2 = space();
				create_component(errorslist.$$.fragment);
				attr(input, "id", input_id_value = "form-field-color-" + /*fieldname*/ ctx[2]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[8]);
				attr(input, "type", "color");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[9]);
				input.required = /*required*/ ctx[4];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				input.readOnly = /*readonly*/ ctx[5];
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[12]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, input);
				set_input_value(input, /*value*/ ctx[0]);
				append(div, t0);
				if (if_block0) if_block0.m(div, null);
				append(div, t1);
				if (if_block1) if_block1.m(div, null);
				insert(target, t2, anchor);
				mount_component(errorslist, target, anchor);
				current = true;

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[20]),
						listen(input, "change", /*onBlur*/ ctx[14]),
						listen(input, "input", /*onInput*/ ctx[15])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-color-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (!current || dirty & /*validationClasses*/ 256 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[8])) {
					attr(input, "class", input_class_value);
				}

				if (!current || dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (!current || dirty & /*invalid*/ 512) {
					attr(input, "invalid", /*invalid*/ ctx[9]);
				}

				if (!current || dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (!current || dirty & /*$LOCALE, placeholder*/ 8194 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (!current || dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (!current || dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (!current || dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (!current || dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$l(ctx);
						if_block0.c();
						if_block0.m(div, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[7] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$J(ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (!current || dirty & /*iconClasses*/ 4096 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[12])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 2048) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[11];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 1024) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[10];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 256) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[8];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				destroy_component(errorslist, detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$18($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "Select you favorite color" } = $$props;
		let { fieldname = "color" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(11, allErrors), $$invalidate(17, errors)), $$invalidate(18, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(10, showErrors), $$invalidate(7, validated)), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(8, validationClasses), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(16, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(7, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(17, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(18, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(19, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(12, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 393216) {
				$$invalidate(11, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 65728) {
				$$invalidate(10, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 524352) {
				$$invalidate(9, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 65600) {
				$$invalidate(8, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_color extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$18, create_fragment$19, safe_not_equal, {
				inputStarted: 16,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				readonly: 5,
				valid: 6,
				validated: 7,
				errors: 17,
				formErrors: 18,
				formLevelError: 19
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.control.svelte generated by Svelte v4.2.19 */

	function create_fragment$18(ctx) {
		let div;
		let div_class_value;
		let current;
		const default_slot_template = /*#slots*/ ctx[2].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "class", div_class_value = "control " + /*classes*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[1],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*classes*/ 1 && div_class_value !== (div_class_value = "control " + /*classes*/ ctx[0])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$17($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { classes = "" } = $$props;

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
		};

		return [classes, $$scope, slots];
	}

	class Ui_control extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$17, create_fragment$18, safe_not_equal, { classes: 0 });
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.date.svelte generated by Svelte v4.2.19 */

	function create_else_block$u(ctx) {
		let input;
		let input_class_value;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[4] && create_if_block_4$e(ctx);
		let if_block1 = /*validated*/ ctx[8] === true && create_if_block_1$y(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[9]);
				attr(input, "id", input_id_value = "form-field-date-" + /*fieldname*/ ctx[2]);
				attr(input, "type", "date");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[11]);
				input.required = /*required*/ ctx[5];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]]);
				attr(input, "pattern", /*pattern*/ ctx[3]);
				input.readOnly = /*readonly*/ ctx[6];
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[21]),
						listen(input, "change", /*onBlur*/ ctx[15]),
						listen(input, "input", /*onInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-date-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*invalid*/ 2048) {
					attr(input, "invalid", /*invalid*/ ctx[11]);
				}

				if (dirty & /*required*/ 32) {
					input.required = /*required*/ ctx[5];
				}

				if (dirty & /*$LOCALE, placeholder*/ 16386 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*pattern*/ 8) {
					attr(input, "pattern", /*pattern*/ ctx[3]);
				}

				if (dirty & /*readonly*/ 64) {
					input.readOnly = /*readonly*/ ctx[6];
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[4]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$e(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[8] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$y(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (66:4) {#if readonly}
	function create_if_block$I(ctx) {
		let p;
		let time;
		let t_value = UICommon$1.tryFormatLocaleDateTime(/*value*/ ctx[0]) + "";
		let t;

		return {
			c() {
				p = element("p");
				time = element("time");
				t = text(t_value);
				attr(time, "datetime", /*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, time);
				append(time, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1 && t_value !== (t_value = UICommon$1.tryFormatLocaleDateTime(/*value*/ ctx[0]) + "")) set_data(t, t_value);

				if (dirty & /*value*/ 1) {
					attr(time, "datetime", /*value*/ ctx[0]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (90:8) {#if icon}
	function create_if_block_4$e(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[4]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 16 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[4])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (95:8) {#if validated === true}
	function create_if_block_1$y(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[7] === true) return create_if_block_2$o;
			if (/*valid*/ ctx[7] === false) return create_if_block_3$k;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (99:42) 
	function create_if_block_3$k(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (97:16) {#if valid === true}
	function create_if_block_2$o(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$17(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return create_if_block$I;
			return create_else_block$u;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[10] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[10];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 1024) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[10];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$16($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let invalid;
		let showErrors;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(14, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = new Date() } = $$props;
		let { placeholder = "Date and time of event" } = $$props;
		let { fieldname = "datetime" } = $$props;
		let { pattern = "d{4}-d{2}-d{2}" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		onMount(() => {
			if (value instanceof Date) {
				$$invalidate(0, value = value.toISOString().split("T")[0]);
			} else if (value.indexOf("T") > 0) {
				$$invalidate(0, value = value.split("T")[0]);
			}
		});

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(10, showErrors), $$invalidate(8, validated)), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('pattern' in $$props) $$invalidate(3, pattern = $$props.pattern);
			if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(7, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(8, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 16) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 786432) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 1048704) {
				$$invalidate(11, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131456) {
				$$invalidate(10, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131200) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			pattern,
			icon,
			required,
			readonly,
			valid,
			validated,
			validationClasses,
			showErrors,
			invalid,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_date extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$16, create_fragment$17, safe_not_equal, {
				inputStarted: 17,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				pattern: 3,
				icon: 4,
				required: 5,
				readonly: 6,
				valid: 7,
				validated: 8,
				errors: 18,
				formErrors: 19,
				formLevelError: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.datetime.in.tz.svelte generated by Svelte v4.2.19 */

	function create_if_block$H(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[4]) return create_if_block_1$x;
			return create_else_block$t;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[0]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty[0] & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 1) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[0];

				if (!updating_errors && dirty[0] & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	// (128:8) {:else}
	function create_else_block$t(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[1] && create_if_block_5$6(ctx);
		let if_block1 = /*validated*/ ctx[6] === true && create_if_block_2$n(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-datetime-in-timezone-" + /*fieldname*/ ctx[0]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[9]);
				attr(input, "type", "datetime-local");
				attr(input, "name", /*fieldname*/ ctx[0]);
				attr(input, "invalid", /*invalid*/ ctx[10]);
				input.disabled = /*disabled*/ ctx[3];
				input.required = /*required*/ ctx[2];
				input.readOnly = /*readonly*/ ctx[4];
				attr(input, "autocomplete", /*fieldname*/ ctx[0]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[0]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*shiftedValue*/ ctx[7]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[21]),
						listen(input, "change", /*onChange*/ ctx[14]),
						listen(input, "blur", /*onChange*/ ctx[14]),
						listen(input, "input", /*onChange*/ ctx[14])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fieldname*/ 1 && input_id_value !== (input_id_value = "form-field-datetime-in-timezone-" + /*fieldname*/ ctx[0])) {
					attr(input, "id", input_id_value);
				}

				if (dirty[0] & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty[0] & /*fieldname*/ 1) {
					attr(input, "name", /*fieldname*/ ctx[0]);
				}

				if (dirty[0] & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty[0] & /*disabled*/ 8) {
					input.disabled = /*disabled*/ ctx[3];
				}

				if (dirty[0] & /*required*/ 4) {
					input.required = /*required*/ ctx[2];
				}

				if (dirty[0] & /*readonly*/ 16) {
					input.readOnly = /*readonly*/ ctx[4];
				}

				if (dirty[0] & /*fieldname*/ 1) {
					attr(input, "autocomplete", /*fieldname*/ ctx[0]);
				}

				if (dirty[0] & /*fieldname*/ 1 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[0])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty[0] & /*fieldname*/ 1 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[0])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty[0] & /*shiftedValue*/ 128) {
					set_input_value(input, /*shiftedValue*/ ctx[7]);
				}

				if (/*icon*/ ctx[1]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_5$6(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[6] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$n(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (126:8) {#if readonly}
	function create_if_block_1$x(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*shiftedValue*/ ctx[7]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*shiftedValue*/ 128) set_data(t, /*shiftedValue*/ ctx[7]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (146:12) {#if icon}
	function create_if_block_5$6(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[1]);
				attr(span, "class", "icon is-small is-left");
				attr(span, "title", /*GMTMark*/ ctx[8]);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*icon*/ 2 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[1])) {
					attr(i, "class", i_class_value);
				}

				if (dirty[0] & /*GMTMark*/ 256) {
					attr(span, "title", /*GMTMark*/ ctx[8]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (151:12) {#if validated === true}
	function create_if_block_2$n(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[5] === true) return create_if_block_3$j;
			if (/*valid*/ ctx[5] === false) return create_if_block_4$d;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (155:46) 
	function create_if_block_4$d(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (153:20) {#if valid === true}
	function create_if_block_3$j(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$16(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*shiftedValue*/ ctx[7] && create_if_block$H(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*shiftedValue*/ ctx[7]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*shiftedValue*/ 128) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$H(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function removeMsFromDate(isoDate, markAsZULU = false) {
		return isoDate.split(".")[0] + (markAsZULU ? "" : "Z");
	}

	function markAsZULU(dateString) {
		return dateString && dateString.at(-1) !== "Z"
		? dateString + "Z"
		: dateString;
	}

	function instance$15($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let dispatch = createEventDispatcher();

		function shiftDatetime(isoDate, shift) {
			try {
				const dateUtc = new Date(markAsZULU(isoDate)).getTime();
				const offset = shift * -60000;

				if (dateIsValid(dateUtc + offset)) {
					const newDate = new Date(dateUtc + offset);
					const newIsoDate = newDate.toISOString();
					return removeMsFromDate(newIsoDate, true);
				}
			} catch(e) {
				return;
			}
		}

		let { inputStarted = false } = $$props;
		let { fieldname = "datetime" } = $$props;
		let { value = removeMsFromDate(new Date().toISOString()) } = $$props;
		let { timezoneOffset = 0 } = $$props;
		let { icon = false } = $$props;
		let { required = false } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let shiftedValue, prevShiftedValue;

		const setShifted = val => {
			if (dateIsValid(val)) {
				prevShiftedValue = shiftedValue;
				$$invalidate(7, shiftedValue = val);
			}
		};

		const resetShiftedValue = () => {
			$$invalidate(7, shiftedValue = prevShiftedValue);
		};

		onMount(() => {
			setShifted(shiftDatetime(value, timezoneOffset));
		});

		const dateIsValid = date => {
			try {
				new Date(date);
				return true;
			} catch(e) {
				return false;
			}
		};

		let GMTMark;
		const changed = () => value !== shiftDatetime(shiftedValue, -timezoneOffset);

		const dispatchChange = () => {
			setShifted(shiftedValue);
			$$invalidate(16, value = markAsZULU(shiftDatetime(shiftedValue, -timezoneOffset)));
			let data = { field: fieldname, value };
			$$invalidate(15, inputStarted = true);
			dispatch("change", data);
		};

		function onChange(ev) {
			if (ev.currentTarget.value && shiftedValue && dateIsValid(shiftedValue)) {
				if (changed()) {
					dispatchChange();
				}

				return true;
			} else {
				resetShiftedValue();
			}

			return false;
		}

		function input_input_handler() {
			shiftedValue = this.value;
			$$invalidate(7, shiftedValue);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(6, validated)), $$invalidate(5, valid)), $$invalidate(15, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(5, valid)), $$invalidate(15, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(15, inputStarted = $$props.inputStarted);
			if ('fieldname' in $$props) $$invalidate(0, fieldname = $$props.fieldname);
			if ('value' in $$props) $$invalidate(16, value = $$props.value);
			if ('timezoneOffset' in $$props) $$invalidate(17, timezoneOffset = $$props.timezoneOffset);
			if ('icon' in $$props) $$invalidate(1, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(2, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(4, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(5, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(6, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 2) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 786432) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 32864) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 1048608) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 32800) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}

			if ($$self.$$.dirty[0] & /*timezoneOffset*/ 131072) {
				{
					$$invalidate(8, GMTMark = isNaN(timezoneOffset)
					? ""
					: (timezoneOffset > 0 ? "" : "+") + (timezoneOffset / -60).toFixed(1));
				}
			}
		};

		return [
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			valid,
			validated,
			shiftedValue,
			GMTMark,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			onChange,
			inputStarted,
			value,
			timezoneOffset,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_datetime_in_tz extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$15,
				create_fragment$16,
				safe_not_equal,
				{
					inputStarted: 15,
					fieldname: 0,
					value: 16,
					timezoneOffset: 17,
					icon: 1,
					required: 2,
					disabled: 3,
					readonly: 4,
					valid: 5,
					validated: 6,
					errors: 18,
					formErrors: 19,
					formLevelError: 20
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.email.svelte generated by Svelte v4.2.19 */

	function create_else_block$s(ctx) {
		let input;
		let input_class_value;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4$c(ctx);
		let if_block1 = /*validated*/ ctx[8] === true && create_if_block_1$w(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[9]);
				attr(input, "id", input_id_value = "form-field-email-" + /*fieldname*/ ctx[2]);
				attr(input, "type", "email");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[10]);
				input.required = /*required*/ ctx[4];
				input.readOnly = /*readonly*/ ctx[5];
				input.disabled = /*disabled*/ ctx[6];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[21]),
						listen(input, "change", /*onBlur*/ ctx[15]),
						listen(input, "input", /*onInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-email-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (dirty & /*disabled*/ 64) {
					input.disabled = /*disabled*/ ctx[6];
				}

				if (dirty & /*$LOCALE, placeholder*/ 16386 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$c(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[8] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$w(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (57:4) {#if readonly}
	function create_if_block$G(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (77:8) {#if icon}
	function create_if_block_4$c(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (82:8) {#if validated === true}
	function create_if_block_1$w(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[7] === true) return create_if_block_2$m;
			if (/*valid*/ ctx[7] === false) return create_if_block_3$i;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (86:42) 
	function create_if_block_3$i(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (84:16) {#if valid === true}
	function create_if_block_2$m(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$15(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[5]) return create_if_block$G;
			return create_else_block$s;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$14($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(14, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "" } = $$props;
		let { fieldname = "email" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(8, validated)), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(7, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(6, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(7, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(8, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 786432) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131456) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 1048704) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131200) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			disabled,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_email extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$14, create_fragment$15, safe_not_equal, {
				inputStarted: 17,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				readonly: 5,
				disabled: 6,
				valid: 7,
				validated: 8,
				errors: 18,
				formErrors: 19,
				formLevelError: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.hidden.svelte generated by Svelte v4.2.19 */

	function create_fragment$14(ctx) {
		let input;
		let mounted;
		let dispose;

		return {
			c() {
				input = element("input");
				attr(input, "type", "hidden");
				input.required = /*required*/ ctx[2];
				input.readOnly = /*readonly*/ ctx[3];
				attr(input, "name", /*fieldname*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);

				if (!mounted) {
					dispose = listen(input, "input", /*input_input_handler*/ ctx[4]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*required*/ 4) {
					input.required = /*required*/ ctx[2];
				}

				if (dirty & /*readonly*/ 8) {
					input.readOnly = /*readonly*/ ctx[3];
				}

				if (dirty & /*fieldname*/ 2) {
					attr(input, "name", /*fieldname*/ ctx[1]);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(input);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function instance$13($$self, $$props, $$invalidate) {
		let { value = "" } = $$props;
		let { fieldname = "hidden" } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('required' in $$props) $$invalidate(2, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(3, readonly = $$props.readonly);
		};

		return [value, fieldname, required, readonly, input_input_handler];
	}

	class Ui_hidden extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$13, create_fragment$14, safe_not_equal, {
				value: 0,
				fieldname: 1,
				required: 2,
				readonly: 3
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.label.svelte generated by Svelte v4.2.19 */

	function create_fragment$13(ctx) {
		let label_1;
		let t_value = /*$LOCALE*/ ctx[2][/*label*/ ctx[1]] + "";
		let t;

		return {
			c() {
				label_1 = element("label");
				t = text(t_value);
				attr(label_1, "class", "label");
				attr(label_1, "for", /*id*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, label_1, anchor);
				append(label_1, t);
			},
			p(ctx, [dirty]) {
				if (dirty & /*$LOCALE, label*/ 6 && t_value !== (t_value = /*$LOCALE*/ ctx[2][/*label*/ ctx[1]] + "")) set_data(t, t_value);

				if (dirty & /*id*/ 1) {
					attr(label_1, "for", /*id*/ ctx[0]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(label_1);
				}
			}
		};
	}

	function instance$12($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		let { id } = $$props;
		let { label = "label" } = $$props;

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
		};

		return [id, label, $LOCALE];
	}

	class Ui_label extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$12, create_fragment$13, safe_not_equal, { id: 0, label: 1 });
		}
	}

	class Lib {
	    #lib = {};

	    constructor(seedLib) {
	        if (seedLib instanceof Lib) {
	            this.import(seedLib.getContent());
	        }
	    }

	    /**
	     *
	     * @params {string}  mode what to do if element exists [replace|add|skip]
	     */
	    add(name, comp, mode = "replace") {
	        if (this.contains(name)) {
	            if (mode === "replace") {
	                this.#lib[name] = comp;
	            } else if (mode === "add") {
	                this.#lib[name] = Object.assign(this.#lib[name], comp);
	            }
	        } else {
	            this.#lib[name] = comp;
	        }
	    }

	    get(name) {
	        return this.#lib[name];
	    }

	    contains(name) {
	        return Object.hasOwn(this.#lib, name);
	    }

	    import(bulk, mode = "replace") {
	        for (let f in bulk) {
	            this.add(f, bulk[f], mode);
	        }
	    }

	    isEmpty() {
	        return Object.keys(this.#lib).length === 0;
	    }

	    getContent() {
	        return {
	            ...this.#lib,
	        };
	    }
	}

	/*
	 * Библиотека UI конструкторов
	 */


	const COMPONENTS$2 = new Lib();
	const FIELDS$2 = new Lib();
	const VARIANTS$1 = new Lib();

	/* node_modules/not-bulma/src/elements/list/ui.list.empty.placeholder.svelte generated by Svelte v4.2.19 */

	function create_fragment$12(ctx) {
		let uititle;
		let current;

		uititle = new Ui_title({
				props: {
					title: "not-node:empty_list_placeholder",
					size: 4,
					align: "center"
				}
			});

		return {
			c() {
				create_component(uititle.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uititle, target, anchor);
				current = true;
			},
			p: noop$1,
			i(local) {
				if (current) return;
				transition_in(uititle.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uititle.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uititle, detaching);
			}
		};
	}

	class Ui_list_empty_placeholder extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, null, create_fragment$12, safe_not_equal, {});
		}
	}

	/* node_modules/not-bulma/src/elements/link/ui.link.svelte generated by Svelte v4.2.19 */

	function create_else_block$r(ctx) {
		let t0_value = /*$LOCALE*/ ctx[19][/*title*/ ctx[1]] + "";
		let t0;
		let t1;
		let current;
		const default_slot_template = /*#slots*/ ctx[22].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

		return {
			c() {
				t0 = text(t0_value);
				t1 = space();
				if (default_slot) default_slot.c();
			},
			m(target, anchor) {
				insert(target, t0, anchor);
				insert(target, t1, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p(ctx, dirty) {
				if ((!current || dirty & /*$LOCALE, title*/ 524290) && t0_value !== (t0_value = /*$LOCALE*/ ctx[19][/*title*/ ctx[1]] + "")) set_data(t0, t0_value);

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[21],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
							null
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (57:4) {#if icon}
	function create_if_block$F(ctx) {
		let t0;
		let t1;
		let t2;
		let if_block2_anchor;
		let current;
		let if_block0 = /*iconSide*/ ctx[17] === "left" && create_if_block_3$h(ctx);
		let if_block1 = /*title*/ ctx[1] && create_if_block_2$l(ctx);
		const default_slot_template = /*#slots*/ ctx[22].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
		let if_block2 = /*iconSide*/ ctx[17] === "right" && create_if_block_1$v(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (default_slot) default_slot.c();
				t2 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				insert(target, t2, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*iconSide*/ ctx[17] === "left") {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$h(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*title*/ ctx[1]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$l(ctx);
						if_block1.c();
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[21],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
							null
						);
					}
				}

				if (/*iconSide*/ ctx[17] === "right") {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_1$v(ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(if_block2_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (default_slot) default_slot.d(detaching);
				if (if_block2) if_block2.d(detaching);
			}
		};
	}

	// (58:8) {#if iconSide === "left"}
	function create_if_block_3$h(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[16] + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : ''));
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon, size*/ 98304 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[16] + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : ''))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (63:8) {#if title}
	function create_if_block_2$l(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[19][/*title*/ ctx[1]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, title*/ 524290 && t_value !== (t_value = /*$LOCALE*/ ctx[19][/*title*/ ctx[1]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (67:8) {#if iconSide === "right"}
	function create_if_block_1$v(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[16] + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : ''));
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon, size*/ 98304 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[16] + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : ''))) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$11(ctx) {
		let a;
		let current_block_type_index;
		let if_block;
		let a_class_value;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block$F, create_else_block$r];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*icon*/ ctx[16]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				a = element("a");
				if_block.c();
				attr(a, "target", /*target*/ ctx[4]);
				attr(a, "href", /*url*/ ctx[2]);
				attr(a, "download", /*download*/ ctx[3]);
				attr(a, "rel", /*rel*/ ctx[5]);
				attr(a, "class", a_class_value = "" + (/*classes*/ ctx[0] + " " + (/*state*/ ctx[12] ? `is-${/*state*/ ctx[12]}` : '') + " " + (/*inverted*/ ctx[10] ? `is-inverted` : '') + " " + (/*outlined*/ ctx[9] ? `is-outlined` : '') + " " + (/*raised*/ ctx[8] ? `is-raised` : '') + " " + (/*rounded*/ ctx[11] ? `is-rounded` : '') + " " + (/*light*/ ctx[6] ? `is-light` : '') + " " + (/*loading*/ ctx[7] ? `is-loading` : '') + " " + (/*color*/ ctx[14] ? `is-${/*color*/ ctx[14]}` : '') + " " + (/*type*/ ctx[13] ? `is-${/*type*/ ctx[13]}` : '') + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : '')));
			},
			m(target, anchor) {
				insert(target, a, anchor);
				if_blocks[current_block_type_index].m(a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", function () {
						if (is_function(/*action*/ ctx[18])) /*action*/ ctx[18].apply(this, arguments);
					});

					mounted = true;
				}
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(a, null);
				}

				if (!current || dirty & /*target*/ 16) {
					attr(a, "target", /*target*/ ctx[4]);
				}

				if (!current || dirty & /*url*/ 4) {
					attr(a, "href", /*url*/ ctx[2]);
				}

				if (!current || dirty & /*download*/ 8) {
					attr(a, "download", /*download*/ ctx[3]);
				}

				if (!current || dirty & /*rel*/ 32) {
					attr(a, "rel", /*rel*/ ctx[5]);
				}

				if (!current || dirty & /*classes, state, inverted, outlined, raised, rounded, light, loading, color, type, size*/ 65473 && a_class_value !== (a_class_value = "" + (/*classes*/ ctx[0] + " " + (/*state*/ ctx[12] ? `is-${/*state*/ ctx[12]}` : '') + " " + (/*inverted*/ ctx[10] ? `is-inverted` : '') + " " + (/*outlined*/ ctx[9] ? `is-outlined` : '') + " " + (/*raised*/ ctx[8] ? `is-raised` : '') + " " + (/*rounded*/ ctx[11] ? `is-rounded` : '') + " " + (/*light*/ ctx[6] ? `is-light` : '') + " " + (/*loading*/ ctx[7] ? `is-loading` : '') + " " + (/*color*/ ctx[14] ? `is-${/*color*/ ctx[14]}` : '') + " " + (/*type*/ ctx[13] ? `is-${/*type*/ ctx[13]}` : '') + " " + (/*size*/ ctx[15] ? `is-${/*size*/ ctx[15]}` : '')))) {
					attr(a, "class", a_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};
	}

	function instance$11($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(19, $LOCALE = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		let { title = "" } = $$props;
		let { url = "" } = $$props;
		let { download } = $$props;
		let { target = "_blank" } = $$props;
		let { rel } = $$props;
		let { light = false } = $$props;
		let { loading = false } = $$props;
		let { raised = false } = $$props;
		let { outlined = false } = $$props;
		let { inverted = false } = $$props;
		let { rounded = false } = $$props;
		let { button = true } = $$props;
		let { state = "" } = $$props;
		let { type = "" } = $$props;
		let { color = "" } = $$props;
		let { size = "" } = $$props;
		let { classes = "" } = $$props;
		let { icon = false } = $$props;
		let { iconSide = "right" } = $$props;

		let { action = () => {
			return true;
		} } = $$props;

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('url' in $$props) $$invalidate(2, url = $$props.url);
			if ('download' in $$props) $$invalidate(3, download = $$props.download);
			if ('target' in $$props) $$invalidate(4, target = $$props.target);
			if ('rel' in $$props) $$invalidate(5, rel = $$props.rel);
			if ('light' in $$props) $$invalidate(6, light = $$props.light);
			if ('loading' in $$props) $$invalidate(7, loading = $$props.loading);
			if ('raised' in $$props) $$invalidate(8, raised = $$props.raised);
			if ('outlined' in $$props) $$invalidate(9, outlined = $$props.outlined);
			if ('inverted' in $$props) $$invalidate(10, inverted = $$props.inverted);
			if ('rounded' in $$props) $$invalidate(11, rounded = $$props.rounded);
			if ('button' in $$props) $$invalidate(20, button = $$props.button);
			if ('state' in $$props) $$invalidate(12, state = $$props.state);
			if ('type' in $$props) $$invalidate(13, type = $$props.type);
			if ('color' in $$props) $$invalidate(14, color = $$props.color);
			if ('size' in $$props) $$invalidate(15, size = $$props.size);
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('icon' in $$props) $$invalidate(16, icon = $$props.icon);
			if ('iconSide' in $$props) $$invalidate(17, iconSide = $$props.iconSide);
			if ('action' in $$props) $$invalidate(18, action = $$props.action);
			if ('$$scope' in $$props) $$invalidate(21, $$scope = $$props.$$scope);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*button, state, light, type, size*/ 1093696) {
				{
					$$invalidate(0, classes = (button ? "button " : "") + (state && state.length > 0 ? ` is-${state} ` : "") + (light ? ` is-light ` : "") + (type && type.length > 0 ? ` is-${type} ` : "") + (size && size.length > 0 ? ` is-${size} ` : ""));
				}
			}
		};

		return [
			classes,
			title,
			url,
			download,
			target,
			rel,
			light,
			loading,
			raised,
			outlined,
			inverted,
			rounded,
			state,
			type,
			color,
			size,
			icon,
			iconSide,
			action,
			$LOCALE,
			button,
			$$scope,
			slots
		];
	}

	class Ui_link extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$11, create_fragment$11, safe_not_equal, {
				title: 1,
				url: 2,
				download: 3,
				target: 4,
				rel: 5,
				light: 6,
				loading: 7,
				raised: 8,
				outlined: 9,
				inverted: 10,
				rounded: 11,
				button: 20,
				state: 12,
				type: 13,
				color: 14,
				size: 15,
				classes: 0,
				icon: 16,
				iconSide: 17,
				action: 18
			});
		}
	}

	/* node_modules/not-bulma/src/elements/link/ui.links.svelte generated by Svelte v4.2.19 */

	function get_each_context_1$5(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	function get_each_context$h(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	// (22:0) {:else}
	function create_else_block$q(ctx) {
		let div;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div_class_value;
		let current;
		let each_value_1 = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[5].id;

		for (let i = 0; i < each_value_1.length; i += 1) {
			let child_ctx = get_each_context_1$5(ctx, each_value_1, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block_1$5(key, child_ctx));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", div_class_value = "buttons " + (/*centered*/ ctx[2] ? 'is-centered' : '') + " " + (/*right*/ ctx[3] ? 'is-right' : '') + " " + /*classes*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1) {
					each_value_1 = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1$5, null, get_each_context_1$5);
					check_outros();
				}

				if (!current || dirty & /*centered, right, classes*/ 14 && div_class_value !== (div_class_value = "buttons " + (/*centered*/ ctx[2] ? 'is-centered' : '') + " " + (/*right*/ ctx[3] ? 'is-right' : '') + " " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	// (10:0) {#if joined}
	function create_if_block$E(ctx) {
		let div;
		let p;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div_class_value;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[5].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$h(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$h(key, child_ctx));
		}

		return {
			c() {
				div = element("div");
				p = element("p");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(p, "class", "control");
				attr(div, "class", div_class_value = "field has-addons " + (/*centered*/ ctx[2] ? 'is-centered' : '') + " " + (/*right*/ ctx[3] ? 'is-right' : '') + " " + /*classes*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, p);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(p, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, p, outro_and_destroy_block, create_each_block$h, null, get_each_context$h);
					check_outros();
				}

				if (!current || dirty & /*centered, right, classes*/ 14 && div_class_value !== (div_class_value = "field has-addons " + (/*centered*/ ctx[2] ? 'is-centered' : '') + " " + (/*right*/ ctx[3] ? 'is-right' : '') + " " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	// (28:8) {#each values as item (item.id)}
	function create_each_block_1$5(key_1, ctx) {
		let first;
		let uilink;
		let current;
		const uilink_spread_levels = [/*item*/ ctx[5]];
		let uilink_props = {};

		for (let i = 0; i < uilink_spread_levels.length; i += 1) {
			uilink_props = assign(uilink_props, uilink_spread_levels[i]);
		}

		uilink = new Ui_link({ props: uilink_props });

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uilink.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uilink, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				const uilink_changes = (dirty & /*values*/ 1)
				? get_spread_update(uilink_spread_levels, [get_spread_object(/*item*/ ctx[5])])
				: {};

				uilink.$set(uilink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uilink, detaching);
			}
		};
	}

	// (17:12) {#each values as item (item.id)}
	function create_each_block$h(key_1, ctx) {
		let first;
		let uilink;
		let current;
		const uilink_spread_levels = [/*item*/ ctx[5]];
		let uilink_props = {};

		for (let i = 0; i < uilink_spread_levels.length; i += 1) {
			uilink_props = assign(uilink_props, uilink_spread_levels[i]);
		}

		uilink = new Ui_link({ props: uilink_props });

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uilink.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uilink, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				const uilink_changes = (dirty & /*values*/ 1)
				? get_spread_update(uilink_spread_levels, [get_spread_object(/*item*/ ctx[5])])
				: {};

				uilink.$set(uilink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uilink, detaching);
			}
		};
	}

	function create_fragment$10(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$E, create_else_block$q];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*joined*/ ctx[4]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$10($$self, $$props, $$invalidate) {
		let { values = [] } = $$props;
		let { classes = "" } = $$props;
		let { centered = false } = $$props;
		let { right = false } = $$props;
		let { joined = true } = $$props;

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('centered' in $$props) $$invalidate(2, centered = $$props.centered);
			if ('right' in $$props) $$invalidate(3, right = $$props.right);
			if ('joined' in $$props) $$invalidate(4, joined = $$props.joined);
		};

		return [values, classes, centered, right, joined];
	}

	class Ui_links extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$10, create_fragment$10, safe_not_equal, {
				values: 0,
				classes: 1,
				centered: 2,
				right: 3,
				joined: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.item.svelte generated by Svelte v4.2.19 */

	function create_if_block_9$1(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_10$1, create_else_block_5];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*imageComponent*/ ctx[13]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div = element("div");
				if_block.c();
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				attr(div, "class", "list-item-image");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "keyup", prevent_default(/*keyup_handler*/ ctx[23])),
						listen(div, "click", prevent_default(/*click_handler_2*/ ctx[24]))
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (95:12) {:else}
	function create_else_block_5(ctx) {
		let figure;
		let img;
		let img_src_value;

		return {
			c() {
				figure = element("figure");
				img = element("img");
				attr(img, "class", "is-rounded");
				if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[4])) attr(img, "src", img_src_value);
				attr(img, "alt", /*title*/ ctx[0]);
				attr(figure, "class", "image is-64x64");
			},
			m(target, anchor) {
				insert(target, figure, anchor);
				append(figure, img);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*image*/ 16 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[4])) {
					attr(img, "src", img_src_value);
				}

				if (dirty[0] & /*title*/ 1) {
					attr(img, "alt", /*title*/ ctx[0]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(figure);
				}
			}
		};
	}

	// (81:12) {#if imageComponent}
	function create_if_block_10$1(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_11$1, create_else_block_4];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (typeof /*image*/ ctx[4] === "string") return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (88:16) {:else}
	function create_else_block_4(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*image*/ ctx[4], /*imageComponentProps*/ ctx[14]];
		var switch_value = /*imageComponent*/ ctx[13];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*image, imageComponentProps*/ 16400) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*image*/ 16 && get_spread_object(/*image*/ ctx[4]),
					dirty[0] & /*imageComponentProps*/ 16384 && get_spread_object(/*imageComponentProps*/ ctx[14])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*imageComponent*/ 8192 && switch_value !== (switch_value = /*imageComponent*/ ctx[13])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*image, imageComponentProps*/ 16400)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*image*/ 16 && get_spread_object(/*image*/ ctx[4]),
							dirty[0] & /*imageComponentProps*/ 16384 && get_spread_object(/*imageComponentProps*/ ctx[14])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (82:16) {#if typeof image === "string"}
	function create_if_block_11$1(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ value: /*image*/ ctx[4] }, /*imageComponentProps*/ ctx[14]];
		var switch_value = /*imageComponent*/ ctx[13];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*image, imageComponentProps*/ 16400) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*image*/ 16 && { value: /*image*/ ctx[4] },
					dirty[0] & /*imageComponentProps*/ 16384 && get_spread_object(/*imageComponentProps*/ ctx[14])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*imageComponent*/ 8192 && switch_value !== (switch_value = /*imageComponent*/ ctx[13])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*image, imageComponentProps*/ 16400)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*image*/ 16 && { value: /*image*/ ctx[4] },
							dirty[0] & /*imageComponentProps*/ 16384 && get_spread_object(/*imageComponentProps*/ ctx[14])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (117:8) {#if title}
	function create_if_block_6$3(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_7$3, create_else_block_3];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*titleComponent*/ ctx[9]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div = element("div");
				if_block.c();
				attr(div, "class", "list-item-title");
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "keyup", prevent_default(/*keyup_handler_1*/ ctx[27])),
						listen(div, "click", prevent_default(/*click_handler_3*/ ctx[28]))
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (149:16) {:else}
	function create_else_block_3(ctx) {
		let t;

		return {
			c() {
				t = text(/*title*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*title*/ 1) set_data(t, /*title*/ ctx[0]);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (133:16) {#if titleComponent}
	function create_if_block_7$3(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_8$1, create_else_block_2$4];
		const if_blocks = [];

		function select_block_type_3(ctx, dirty) {
			if (typeof /*title*/ ctx[0] === "string") return 0;
			return 1;
		}

		current_block_type_index = select_block_type_3(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_3(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (141:20) {:else}
	function create_else_block_2$4(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*title*/ ctx[0], /*titleComponentProps*/ ctx[10]];
		var switch_value = /*titleComponent*/ ctx[9];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*title, titleComponentProps*/ 1025) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*title*/ 1 && get_spread_object(/*title*/ ctx[0]),
					dirty[0] & /*titleComponentProps*/ 1024 && get_spread_object(/*titleComponentProps*/ ctx[10])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*change_handler_1*/ ctx[26]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*titleComponent*/ 512 && switch_value !== (switch_value = /*titleComponent*/ ctx[9])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*change_handler_1*/ ctx[26]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*title, titleComponentProps*/ 1025)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*title*/ 1 && get_spread_object(/*title*/ ctx[0]),
							dirty[0] & /*titleComponentProps*/ 1024 && get_spread_object(/*titleComponentProps*/ ctx[10])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (134:20) {#if typeof title === "string"}
	function create_if_block_8$1(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ title: /*title*/ ctx[0] }, /*titleComponentProps*/ ctx[10]];
		var switch_value = /*titleComponent*/ ctx[9];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*title, titleComponentProps*/ 1025) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*title*/ 1 && { title: /*title*/ ctx[0] },
					dirty[0] & /*titleComponentProps*/ 1024 && get_spread_object(/*titleComponentProps*/ ctx[10])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*change_handler*/ ctx[25]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*titleComponent*/ 512 && switch_value !== (switch_value = /*titleComponent*/ ctx[9])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*change_handler*/ ctx[25]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*title, titleComponentProps*/ 1025)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*title*/ 1 && { title: /*title*/ ctx[0] },
							dirty[0] & /*titleComponentProps*/ 1024 && get_spread_object(/*titleComponentProps*/ ctx[10])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (154:8) {#if description}
	function create_if_block_3$g(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_4$b, create_else_block_1$5];
		const if_blocks = [];

		function select_block_type_4(ctx, dirty) {
			if (/*descriptionComponent*/ ctx[11]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_4(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div = element("div");
				if_block.c();
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				attr(div, "class", "list-item-description");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "keyup", prevent_default(/*keyup_handler_2*/ ctx[33])),
						listen(div, "click", prevent_default(/*click_handler_4*/ ctx[34]))
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_4(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (188:16) {:else}
	function create_else_block_1$5(ctx) {
		let t;

		return {
			c() {
				t = text(/*description*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*description*/ 2) set_data(t, /*description*/ ctx[1]);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (170:16) {#if descriptionComponent}
	function create_if_block_4$b(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_5$5, create_else_block$p];
		const if_blocks = [];

		function select_block_type_5(ctx, dirty) {
			if (typeof /*description*/ ctx[1] === "string") return 0;
			return 1;
		}

		current_block_type_index = select_block_type_5(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_5(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (179:20) {:else}
	function create_else_block$p(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*description*/ ctx[1], /*descriptionComponentProps*/ ctx[12]];
		var switch_value = /*descriptionComponent*/ ctx[11];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*description, descriptionComponentProps*/ 4098) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*description*/ 2 && get_spread_object(/*description*/ ctx[1]),
					dirty[0] & /*descriptionComponentProps*/ 4096 && get_spread_object(/*descriptionComponentProps*/ ctx[12])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*change_handler_3*/ ctx[31]);
			switch_instance.$on("click", /*click_handler_1*/ ctx[32]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*descriptionComponent*/ 2048 && switch_value !== (switch_value = /*descriptionComponent*/ ctx[11])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*change_handler_3*/ ctx[31]);
						switch_instance.$on("click", /*click_handler_1*/ ctx[32]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*description, descriptionComponentProps*/ 4098)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*description*/ 2 && get_spread_object(/*description*/ ctx[1]),
							dirty[0] & /*descriptionComponentProps*/ 4096 && get_spread_object(/*descriptionComponentProps*/ ctx[12])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (171:20) {#if typeof description === "string"}
	function create_if_block_5$5(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ value: /*description*/ ctx[1] }, /*descriptionComponentProps*/ ctx[12]];
		var switch_value = /*descriptionComponent*/ ctx[11];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*description, descriptionComponentProps*/ 4098) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*description*/ 2 && { value: /*description*/ ctx[1] },
					dirty[0] & /*descriptionComponentProps*/ 4096 && get_spread_object(/*descriptionComponentProps*/ ctx[12])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*change_handler_2*/ ctx[29]);
			switch_instance.$on("click", /*click_handler*/ ctx[30]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*descriptionComponent*/ 2048 && switch_value !== (switch_value = /*descriptionComponent*/ ctx[11])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*change_handler_2*/ ctx[29]);
						switch_instance.$on("click", /*click_handler*/ ctx[30]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*description, descriptionComponentProps*/ 4098)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*description*/ 2 && { value: /*description*/ ctx[1] },
							dirty[0] & /*descriptionComponentProps*/ 4096 && get_spread_object(/*descriptionComponentProps*/ ctx[12])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (195:4) {#if (allActions && allActions.length) || (allLinks && allLinks.length)}
	function create_if_block$D(ctx) {
		let div;
		let t;
		let current;
		let if_block0 = /*allActions*/ ctx[15] && /*allActions*/ ctx[15].length && create_if_block_2$k(ctx);
		let if_block1 = /*allLinks*/ ctx[16] && /*allLinks*/ ctx[16].length && create_if_block_1$u(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				attr(div, "class", "list-item-controls");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},
			p(ctx, dirty) {
				if (/*allActions*/ ctx[15] && /*allActions*/ ctx[15].length) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*allActions*/ 32768) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$k(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*allLinks*/ ctx[16] && /*allLinks*/ ctx[16].length) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*allLinks*/ 65536) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$u(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (197:12) {#if allActions && allActions.length}
	function create_if_block_2$k(ctx) {
		let uibuttons;
		let current;

		uibuttons = new Ui_buttons({
				props: {
					values: /*allActions*/ ctx[15],
					right: true
				}
			});

		return {
			c() {
				create_component(uibuttons.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttons, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttons_changes = {};
				if (dirty[0] & /*allActions*/ 32768) uibuttons_changes.values = /*allActions*/ ctx[15];
				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttons, detaching);
			}
		};
	}

	// (200:12) {#if allLinks && allLinks.length}
	function create_if_block_1$u(ctx) {
		let uilinks;
		let current;

		uilinks = new Ui_links({
				props: {
					values: /*allLinks*/ ctx[16],
					right: true
				}
			});

		return {
			c() {
				create_component(uilinks.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uilinks, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uilinks_changes = {};
				if (dirty[0] & /*allLinks*/ 65536) uilinks_changes.values = /*allLinks*/ ctx[16];
				uilinks.$set(uilinks_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilinks.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilinks.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uilinks, detaching);
			}
		};
	}

	function create_fragment$$(ctx) {
		let div1;
		let t0;
		let div0;
		let t1;
		let t2;
		let div1_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*image*/ ctx[4] && create_if_block_9$1(ctx);
		let if_block1 = /*title*/ ctx[0] && create_if_block_6$3(ctx);
		let if_block2 = /*description*/ ctx[1] && create_if_block_3$g(ctx);
		let if_block3 = (/*allActions*/ ctx[15] && /*allActions*/ ctx[15].length || /*allLinks*/ ctx[16] && /*allLinks*/ ctx[16].length) && create_if_block$D(ctx);

		return {
			c() {
				div1 = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				div0 = element("div");
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				if (if_block3) if_block3.c();
				attr(div0, "role", "button");
				attr(div0, "tabindex", "0");
				attr(div0, "class", "list-item-content");
				attr(div1, "role", "button");
				attr(div1, "tabindex", "0");
				attr(div1, "class", div1_class_value = "list-item " + /*classes*/ ctx[2] + " " + /*commonClasses*/ ctx[3] + " " + (/*last*/ ctx[8] ? 'list-item-last' : '') + " " + (/*first*/ ctx[7] ? 'list-item-first' : '') + " " + `list-item-at-${/*index*/ ctx[6]}` + " " + (`list-item-` + (/*index*/ ctx[6] % 2 ? 'odd' : 'even')));
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				if (if_block0) if_block0.m(div1, null);
				append(div1, t0);
				append(div1, div0);
				if (if_block1) if_block1.m(div0, null);
				append(div0, t1);
				if (if_block2) if_block2.m(div0, null);
				append(div1, t2);
				if (if_block3) if_block3.m(div1, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div0, "click", prevent_default(/*click_handler_5*/ ctx[35])),
						listen(div0, "keyup", prevent_default(/*keyup_handler_3*/ ctx[36])),
						listen(div1, "click", /*onClick*/ ctx[18]),
						listen(div1, "keyup", /*keyup_handler_4*/ ctx[37])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (/*image*/ ctx[4]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*image*/ 16) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_9$1(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div1, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*title*/ ctx[0]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*title*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_6$3(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div0, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*description*/ ctx[1]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*description*/ 2) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_3$g(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div0, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*allActions*/ ctx[15] && /*allActions*/ ctx[15].length || /*allLinks*/ ctx[16] && /*allLinks*/ ctx[16].length) {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty[0] & /*allActions, allLinks*/ 98304) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block$D(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(div1, null);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				if (!current || dirty[0] & /*classes, commonClasses, last, first, index*/ 460 && div1_class_value !== (div1_class_value = "list-item " + /*classes*/ ctx[2] + " " + /*commonClasses*/ ctx[3] + " " + (/*last*/ ctx[8] ? 'list-item-last' : '') + " " + (/*first*/ ctx[7] ? 'list-item-first' : '') + " " + `list-item-at-${/*index*/ ctx[6]}` + " " + (`list-item-` + (/*index*/ ctx[6] % 2 ? 'odd' : 'even')))) {
					attr(div1, "class", div1_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$$($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { title } = $$props;
		let { description } = $$props;
		let { actions = [] } = $$props;
		let { links = [] } = $$props;
		let { listActions = [] } = $$props;
		let { listLinks = [] } = $$props;
		let { classes = "" } = $$props;
		let { commonClasses = "" } = $$props;
		let { image = "" } = $$props;
		let { value } = $$props;
		let { index = -1 } = $$props;
		let { first = false } = $$props;
		let { last = false } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 6 } } = $$props;
		let { descriptionComponent } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { imageComponent } = $$props;
		let { imageComponentProps = {} } = $$props;

		function onClick() {
			dispatch("click", value);
		}

		let allActions = [];
		let allLinks = [];

		const keyup_handler = e => {
			if (e && e.key == "Enter") {
				onClick();
				dispatch("clickImage", value);
			}
		};

		const click_handler_2 = () => {
			onClick();
			dispatch("clickImage", value);
		};

		function change_handler(event) {
			bubble.call(this, $$self, event);
		}

		function change_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler_1 = e => {
			if (e && e.key == "Enter") {
				onClick();
				dispatch("clickTitle", value);
			}
		};

		const click_handler_3 = () => {
			onClick();
			dispatch("clickTitle", value);
		};

		function change_handler_2(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function change_handler_3(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		const keyup_handler_2 = e => {
			if (e && e.key == "Enter") {
				onClick();
				dispatch("clickDescription", value);
			}
		};

		const click_handler_4 = () => {
			onClick();
			dispatch("clickDescription", value);
		};

		const click_handler_5 = () => {
			onClick();
			dispatch("clickContent", value);
		};

		const keyup_handler_3 = e => {
			if (e && e.key == "Enter") {
				onClick();
				dispatch("clickContent", value);
			}
		};

		const keyup_handler_4 = e => {
			if (e && e.key == "Enter") {
				onClick();
			}
		};

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('description' in $$props) $$invalidate(1, description = $$props.description);
			if ('actions' in $$props) $$invalidate(19, actions = $$props.actions);
			if ('links' in $$props) $$invalidate(20, links = $$props.links);
			if ('listActions' in $$props) $$invalidate(21, listActions = $$props.listActions);
			if ('listLinks' in $$props) $$invalidate(22, listLinks = $$props.listLinks);
			if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
			if ('commonClasses' in $$props) $$invalidate(3, commonClasses = $$props.commonClasses);
			if ('image' in $$props) $$invalidate(4, image = $$props.image);
			if ('value' in $$props) $$invalidate(5, value = $$props.value);
			if ('index' in $$props) $$invalidate(6, index = $$props.index);
			if ('first' in $$props) $$invalidate(7, first = $$props.first);
			if ('last' in $$props) $$invalidate(8, last = $$props.last);
			if ('titleComponent' in $$props) $$invalidate(9, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(10, titleComponentProps = $$props.titleComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(11, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(12, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('imageComponent' in $$props) $$invalidate(13, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(14, imageComponentProps = $$props.imageComponentProps);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*actions, listActions, value*/ 2621472) {
				$$invalidate(15, allActions = [...actions, ...listActions].map(btn => {
					return { ...btn, action: () => btn.action(value) };
				}));
			}

			if ($$self.$$.dirty[0] & /*links, listLinks*/ 5242880) {
				$$invalidate(16, allLinks = [...links, ...listLinks]);
			}
		};

		return [
			title,
			description,
			classes,
			commonClasses,
			image,
			value,
			index,
			first,
			last,
			titleComponent,
			titleComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			imageComponent,
			imageComponentProps,
			allActions,
			allLinks,
			dispatch,
			onClick,
			actions,
			links,
			listActions,
			listLinks,
			keyup_handler,
			click_handler_2,
			change_handler,
			change_handler_1,
			keyup_handler_1,
			click_handler_3,
			change_handler_2,
			click_handler,
			change_handler_3,
			click_handler_1,
			keyup_handler_2,
			click_handler_4,
			click_handler_5,
			keyup_handler_3,
			keyup_handler_4
		];
	}

	class Ui_list_item extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$$,
				create_fragment$$,
				safe_not_equal,
				{
					title: 0,
					description: 1,
					actions: 19,
					links: 20,
					listActions: 21,
					listLinks: 22,
					classes: 2,
					commonClasses: 3,
					image: 4,
					value: 5,
					index: 6,
					first: 7,
					last: 8,
					titleComponent: 9,
					titleComponentProps: 10,
					descriptionComponent: 11,
					descriptionComponentProps: 12,
					imageComponent: 13,
					imageComponentProps: 14
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.block.svelte generated by Svelte v4.2.19 */

	function get_each_context$g(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[19] = list[i];
		child_ctx[20] = list;
		child_ctx[21] = i;
		return child_ctx;
	}

	// (22:0) {#each items as item, index (item[idFieldName])}
	function create_each_block$g(key_1, ctx) {
		let first;
		let switch_instance;
		let updating_value;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*listItemComponentProps*/ ctx[6],
			{
				titleComponent: /*titleComponent*/ ctx[7]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[8]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[9]
			},
			{
				descriptionComponentProps: /*descriptionComponentProps*/ ctx[10]
			},
			{
				imageComponent: /*imageComponent*/ ctx[11]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[12]
			},
			/*item*/ ctx[19],
			{ listActions: /*actions*/ ctx[2] },
			{ listLinks: /*links*/ ctx[3] },
			{ commonClasses: /*itemClasses*/ ctx[4] },
			{ index: /*index*/ ctx[21] },
			{ first: /*index*/ ctx[21] === 0 },
			{
				last: /*index*/ ctx[21] === /*items*/ ctx[0].length - 1
			}
		];

		function switch_instance_value_binding(value) {
			/*switch_instance_value_binding*/ ctx[13](value, /*item*/ ctx[19], /*each_value*/ ctx[20], /*index*/ ctx[21]);
		}

		var switch_value = /*listItemComponent*/ ctx[5];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listItemComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, imageComponent, imageComponentProps, items, actions, links, itemClasses*/ 8157) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listItemComponentProps*/ 64 && get_spread_object(/*listItemComponentProps*/ ctx[6]),
					dirty & /*titleComponent*/ 128 && {
						titleComponent: /*titleComponent*/ ctx[7]
					},
					dirty & /*titleComponentProps*/ 256 && {
						titleComponentProps: /*titleComponentProps*/ ctx[8]
					},
					dirty & /*descriptionComponent*/ 512 && {
						descriptionComponent: /*descriptionComponent*/ ctx[9]
					},
					dirty & /*descriptionComponentProps*/ 1024 && {
						descriptionComponentProps: /*descriptionComponentProps*/ ctx[10]
					},
					dirty & /*imageComponent*/ 2048 && {
						imageComponent: /*imageComponent*/ ctx[11]
					},
					dirty & /*imageComponentProps*/ 4096 && {
						imageComponentProps: /*imageComponentProps*/ ctx[12]
					},
					dirty & /*items*/ 1 && get_spread_object(/*item*/ ctx[19]),
					dirty & /*actions*/ 4 && { listActions: /*actions*/ ctx[2] },
					dirty & /*links*/ 8 && { listLinks: /*links*/ ctx[3] },
					dirty & /*itemClasses*/ 16 && { commonClasses: /*itemClasses*/ ctx[4] },
					dirty & /*items*/ 1 && { index: /*index*/ ctx[21] },
					dirty & /*items*/ 1 && { first: /*index*/ ctx[21] === 0 },
					dirty & /*items*/ 1 && {
						last: /*index*/ ctx[21] === /*items*/ ctx[0].length - 1
					}
				]));
			}

			if (/*item*/ ctx[19] !== void 0) {
				switch_instance_props.value = /*item*/ ctx[19];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
			switch_instance.$on("click", /*click_handler*/ ctx[14]);
			switch_instance.$on("clickContent", /*clickContent_handler*/ ctx[15]);
			switch_instance.$on("clickDescription", /*clickDescription_handler*/ ctx[16]);
			switch_instance.$on("clickImage", /*clickImage_handler*/ ctx[17]);
			switch_instance.$on("clickTitle", /*clickTitle_handler*/ ctx[18]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*listItemComponent*/ 32 && switch_value !== (switch_value = /*listItemComponent*/ ctx[5])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'value', switch_instance_value_binding));
						switch_instance.$on("click", /*click_handler*/ ctx[14]);
						switch_instance.$on("clickContent", /*clickContent_handler*/ ctx[15]);
						switch_instance.$on("clickDescription", /*clickDescription_handler*/ ctx[16]);
						switch_instance.$on("clickImage", /*clickImage_handler*/ ctx[17]);
						switch_instance.$on("clickTitle", /*clickTitle_handler*/ ctx[18]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listItemComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, imageComponent, imageComponentProps, items, actions, links, itemClasses*/ 8157)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listItemComponentProps*/ 64 && get_spread_object(/*listItemComponentProps*/ ctx[6]),
							dirty & /*titleComponent*/ 128 && {
								titleComponent: /*titleComponent*/ ctx[7]
							},
							dirty & /*titleComponentProps*/ 256 && {
								titleComponentProps: /*titleComponentProps*/ ctx[8]
							},
							dirty & /*descriptionComponent*/ 512 && {
								descriptionComponent: /*descriptionComponent*/ ctx[9]
							},
							dirty & /*descriptionComponentProps*/ 1024 && {
								descriptionComponentProps: /*descriptionComponentProps*/ ctx[10]
							},
							dirty & /*imageComponent*/ 2048 && {
								imageComponent: /*imageComponent*/ ctx[11]
							},
							dirty & /*imageComponentProps*/ 4096 && {
								imageComponentProps: /*imageComponentProps*/ ctx[12]
							},
							dirty & /*items*/ 1 && get_spread_object(/*item*/ ctx[19]),
							dirty & /*actions*/ 4 && { listActions: /*actions*/ ctx[2] },
							dirty & /*links*/ 8 && { listLinks: /*links*/ ctx[3] },
							dirty & /*itemClasses*/ 16 && { commonClasses: /*itemClasses*/ ctx[4] },
							dirty & /*items*/ 1 && { index: /*index*/ ctx[21] },
							dirty & /*items*/ 1 && { first: /*index*/ ctx[21] === 0 },
							dirty & /*items*/ 1 && {
								last: /*index*/ ctx[21] === /*items*/ ctx[0].length - 1
							}
						])
					: {};

					if (!updating_value && dirty & /*items*/ 1) {
						updating_value = true;
						switch_instance_changes.value = /*item*/ ctx[19];
						add_flush_callback(() => updating_value = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$_(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*items*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[19][/*idFieldName*/ ctx[1]];

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$g(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*listItemComponent, listItemComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, imageComponent, imageComponentProps, items, actions, links, itemClasses, idFieldName*/ 8191) {
					each_value = ensure_array_like(/*items*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$g, each_1_anchor, get_each_context$g);
					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	function instance$_($$self, $$props, $$invalidate) {
		let { idFieldName = "id" } = $$props;
		let { items = [] } = $$props;
		let { actions = [] } = $$props;
		let { links = [] } = $$props;
		let { itemClasses = "" } = $$props;
		let { listItemComponent = Ui_list_item } = $$props;
		let { listItemComponentProps = {} } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 6 } } = $$props;
		let { descriptionComponent } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { imageComponent } = $$props;
		let { imageComponentProps = {} } = $$props;

		function switch_instance_value_binding(value, item, each_value, index) {
			each_value[index] = value;
			$$invalidate(0, items);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickContent_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickDescription_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickImage_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickTitle_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('idFieldName' in $$props) $$invalidate(1, idFieldName = $$props.idFieldName);
			if ('items' in $$props) $$invalidate(0, items = $$props.items);
			if ('actions' in $$props) $$invalidate(2, actions = $$props.actions);
			if ('links' in $$props) $$invalidate(3, links = $$props.links);
			if ('itemClasses' in $$props) $$invalidate(4, itemClasses = $$props.itemClasses);
			if ('listItemComponent' in $$props) $$invalidate(5, listItemComponent = $$props.listItemComponent);
			if ('listItemComponentProps' in $$props) $$invalidate(6, listItemComponentProps = $$props.listItemComponentProps);
			if ('titleComponent' in $$props) $$invalidate(7, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(8, titleComponentProps = $$props.titleComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(9, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(10, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('imageComponent' in $$props) $$invalidate(11, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(12, imageComponentProps = $$props.imageComponentProps);
		};

		return [
			items,
			idFieldName,
			actions,
			links,
			itemClasses,
			listItemComponent,
			listItemComponentProps,
			titleComponent,
			titleComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			imageComponent,
			imageComponentProps,
			switch_instance_value_binding,
			click_handler,
			clickContent_handler,
			clickDescription_handler,
			clickImage_handler,
			clickTitle_handler
		];
	}

	class Ui_list_block extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$_, create_fragment$_, safe_not_equal, {
				idFieldName: 1,
				items: 0,
				actions: 2,
				links: 3,
				itemClasses: 4,
				listItemComponent: 5,
				listItemComponentProps: 6,
				titleComponent: 7,
				titleComponentProps: 8,
				descriptionComponent: 9,
				descriptionComponentProps: 10,
				imageComponent: 11,
				imageComponentProps: 12
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.svelte generated by Svelte v4.2.19 */

	function create_else_block$o(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*emptyListPlaceholderComponentProps*/ ctx[12]];
		var switch_value = /*emptyListPlaceholderComponent*/ ctx[11];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*emptyListPlaceholderComponentProps*/ 4096) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*emptyListPlaceholderComponentProps*/ ctx[12])]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*emptyListPlaceholderComponent*/ 2048 && switch_value !== (switch_value = /*emptyListPlaceholderComponent*/ ctx[11])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*emptyListPlaceholderComponentProps*/ 4096)
					? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*emptyListPlaceholderComponentProps*/ ctx[12])])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (37:0) {#if items.length}
	function create_if_block$C(ctx) {
		let div;
		let uilistblock;
		let updating_items;
		let div_style_value;
		let div_class_value;
		let current;

		function uilistblock_items_binding(value) {
			/*uilistblock_items_binding*/ ctx[21](value);
		}

		let uilistblock_props = {
			itemClasses: /*itemClasses*/ ctx[8],
			listItemComponent: /*listItemComponent*/ ctx[13],
			listItemComponentProps: /*listItemComponentProps*/ ctx[14],
			idFieldName: /*idFieldName*/ ctx[10],
			titleComponent: /*titleComponent*/ ctx[15],
			titleComponentProps: /*titleComponentProps*/ ctx[16],
			descriptionComponent: /*descriptionComponent*/ ctx[17],
			descriptionComponentProps: /*descriptionComponentProps*/ ctx[18],
			imageComponent: /*imageComponent*/ ctx[19],
			imageComponentProps: /*imageComponentProps*/ ctx[20],
			actions: /*actions*/ ctx[2],
			links: /*links*/ ctx[3]
		};

		if (/*items*/ ctx[0] !== void 0) {
			uilistblock_props.items = /*items*/ ctx[0];
		}

		uilistblock = new Ui_list_block({ props: uilistblock_props });
		binding_callbacks.push(() => bind(uilistblock, 'items', uilistblock_items_binding));
		uilistblock.$on("change", /*change_handler*/ ctx[22]);
		uilistblock.$on("click", /*click_handler*/ ctx[23]);
		uilistblock.$on("clickContent", /*clickContent_handler*/ ctx[24]);
		uilistblock.$on("clickDescription", /*clickDescription_handler*/ ctx[25]);
		uilistblock.$on("clickImage", /*clickImage_handler*/ ctx[26]);
		uilistblock.$on("clickTitle", /*clickTitle_handler*/ ctx[27]);

		return {
			c() {
				div = element("div");
				create_component(uilistblock.$$.fragment);

				attr(div, "style", div_style_value = /*itemLength*/ ctx[9]
				? `--length: ${/*itemLength*/ ctx[9]};`
				: "");

				attr(div, "class", div_class_value = "list " + /*classes*/ ctx[1] + " " + (/*actionsVisible*/ ctx[4]
				? 'has-visible-pointer-controls'
				: '') + " " + (/*itemsHoverable*/ ctx[5]
				? 'has-hoverable-list-items'
				: '') + " " + (/*overflowEllipsis*/ ctx[6]
				? 'has-overflow-ellipsis'
				: '') + " " + (/*hiddenImages*/ ctx[7] ? 'has-hidden-images' : ''));
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uilistblock, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const uilistblock_changes = {};
				if (dirty & /*itemClasses*/ 256) uilistblock_changes.itemClasses = /*itemClasses*/ ctx[8];
				if (dirty & /*listItemComponent*/ 8192) uilistblock_changes.listItemComponent = /*listItemComponent*/ ctx[13];
				if (dirty & /*listItemComponentProps*/ 16384) uilistblock_changes.listItemComponentProps = /*listItemComponentProps*/ ctx[14];
				if (dirty & /*idFieldName*/ 1024) uilistblock_changes.idFieldName = /*idFieldName*/ ctx[10];
				if (dirty & /*titleComponent*/ 32768) uilistblock_changes.titleComponent = /*titleComponent*/ ctx[15];
				if (dirty & /*titleComponentProps*/ 65536) uilistblock_changes.titleComponentProps = /*titleComponentProps*/ ctx[16];
				if (dirty & /*descriptionComponent*/ 131072) uilistblock_changes.descriptionComponent = /*descriptionComponent*/ ctx[17];
				if (dirty & /*descriptionComponentProps*/ 262144) uilistblock_changes.descriptionComponentProps = /*descriptionComponentProps*/ ctx[18];
				if (dirty & /*imageComponent*/ 524288) uilistblock_changes.imageComponent = /*imageComponent*/ ctx[19];
				if (dirty & /*imageComponentProps*/ 1048576) uilistblock_changes.imageComponentProps = /*imageComponentProps*/ ctx[20];
				if (dirty & /*actions*/ 4) uilistblock_changes.actions = /*actions*/ ctx[2];
				if (dirty & /*links*/ 8) uilistblock_changes.links = /*links*/ ctx[3];

				if (!updating_items && dirty & /*items*/ 1) {
					updating_items = true;
					uilistblock_changes.items = /*items*/ ctx[0];
					add_flush_callback(() => updating_items = false);
				}

				uilistblock.$set(uilistblock_changes);

				if (!current || dirty & /*itemLength*/ 512 && div_style_value !== (div_style_value = /*itemLength*/ ctx[9]
				? `--length: ${/*itemLength*/ ctx[9]};`
				: "")) {
					attr(div, "style", div_style_value);
				}

				if (!current || dirty & /*classes, actionsVisible, itemsHoverable, overflowEllipsis, hiddenImages*/ 242 && div_class_value !== (div_class_value = "list " + /*classes*/ ctx[1] + " " + (/*actionsVisible*/ ctx[4]
				? 'has-visible-pointer-controls'
				: '') + " " + (/*itemsHoverable*/ ctx[5]
				? 'has-hoverable-list-items'
				: '') + " " + (/*overflowEllipsis*/ ctx[6]
				? 'has-overflow-ellipsis'
				: '') + " " + (/*hiddenImages*/ ctx[7] ? 'has-hidden-images' : ''))) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uilistblock.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilistblock.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uilistblock);
			}
		};
	}

	function create_fragment$Z(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$C, create_else_block$o];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*items*/ ctx[0].length) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$Z($$self, $$props, $$invalidate) {
		let { classes = "" } = $$props;
		let { items = [] } = $$props;
		let { actions = [] } = $$props;
		let { links = [] } = $$props;
		let { actionsVisible = false } = $$props;
		let { itemsHoverable = false } = $$props;
		let { overflowEllipsis = false } = $$props;
		let { hiddenImages = false } = $$props;
		let { itemClasses = "" } = $$props;
		let { itemLength } = $$props;
		let { idFieldName = "id" } = $$props;
		let { emptyListPlaceholderComponent = Ui_list_empty_placeholder } = $$props;
		let { emptyListPlaceholderComponentProps = {} } = $$props;
		let { listItemComponent = Ui_list_item } = $$props;
		let { listItemComponentProps = {} } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 6 } } = $$props;
		let { descriptionComponent } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { imageComponent } = $$props;
		let { imageComponentProps = {} } = $$props;

		function uilistblock_items_binding(value) {
			items = value;
			$$invalidate(0, items);
		}

		function change_handler(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickContent_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickDescription_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickImage_handler(event) {
			bubble.call(this, $$self, event);
		}

		function clickTitle_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('items' in $$props) $$invalidate(0, items = $$props.items);
			if ('actions' in $$props) $$invalidate(2, actions = $$props.actions);
			if ('links' in $$props) $$invalidate(3, links = $$props.links);
			if ('actionsVisible' in $$props) $$invalidate(4, actionsVisible = $$props.actionsVisible);
			if ('itemsHoverable' in $$props) $$invalidate(5, itemsHoverable = $$props.itemsHoverable);
			if ('overflowEllipsis' in $$props) $$invalidate(6, overflowEllipsis = $$props.overflowEllipsis);
			if ('hiddenImages' in $$props) $$invalidate(7, hiddenImages = $$props.hiddenImages);
			if ('itemClasses' in $$props) $$invalidate(8, itemClasses = $$props.itemClasses);
			if ('itemLength' in $$props) $$invalidate(9, itemLength = $$props.itemLength);
			if ('idFieldName' in $$props) $$invalidate(10, idFieldName = $$props.idFieldName);
			if ('emptyListPlaceholderComponent' in $$props) $$invalidate(11, emptyListPlaceholderComponent = $$props.emptyListPlaceholderComponent);
			if ('emptyListPlaceholderComponentProps' in $$props) $$invalidate(12, emptyListPlaceholderComponentProps = $$props.emptyListPlaceholderComponentProps);
			if ('listItemComponent' in $$props) $$invalidate(13, listItemComponent = $$props.listItemComponent);
			if ('listItemComponentProps' in $$props) $$invalidate(14, listItemComponentProps = $$props.listItemComponentProps);
			if ('titleComponent' in $$props) $$invalidate(15, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(16, titleComponentProps = $$props.titleComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(17, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(18, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('imageComponent' in $$props) $$invalidate(19, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(20, imageComponentProps = $$props.imageComponentProps);
		};

		return [
			items,
			classes,
			actions,
			links,
			actionsVisible,
			itemsHoverable,
			overflowEllipsis,
			hiddenImages,
			itemClasses,
			itemLength,
			idFieldName,
			emptyListPlaceholderComponent,
			emptyListPlaceholderComponentProps,
			listItemComponent,
			listItemComponentProps,
			titleComponent,
			titleComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			imageComponent,
			imageComponentProps,
			uilistblock_items_binding,
			change_handler,
			click_handler,
			clickContent_handler,
			clickDescription_handler,
			clickImage_handler,
			clickTitle_handler
		];
	}

	class Ui_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
				classes: 1,
				items: 0,
				actions: 2,
				links: 3,
				actionsVisible: 4,
				itemsHoverable: 5,
				overflowEllipsis: 6,
				hiddenImages: 7,
				itemClasses: 8,
				itemLength: 9,
				idFieldName: 10,
				emptyListPlaceholderComponent: 11,
				emptyListPlaceholderComponentProps: 12,
				listItemComponent: 13,
				listItemComponentProps: 14,
				titleComponent: 15,
				titleComponentProps: 16,
				descriptionComponent: 17,
				descriptionComponentProps: 18,
				imageComponent: 19,
				imageComponentProps: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.list.of.models.svelte generated by Svelte v4.2.19 */

	function create_if_block$B(ctx) {
		let switch_instance;
		let updating_placeholder;
		let updating_fieldname;
		let updating_required;
		let updating_multiple;
		let updating_size;
		let updating_valid;
		let updating_validated;
		let updating_errors;
		let updating_formErrors;
		let updating_formLevelError;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*selectorUIProps*/ ctx[20],
			{ modelName: /*modelName*/ ctx[11] },
			{ actionName: /*actionName*/ ctx[12] },
			{ actionFilter: /*actionFilter*/ ctx[13] },
			{ actionSorter: /*actionSorter*/ ctx[14] },
			{ actionPager: /*actionPager*/ ctx[15] },
			{ actionSearch: /*actionSearch*/ ctx[16] },
			{ optionId: /*optionId*/ ctx[17] },
			{ optionTitle: /*optionTitle*/ ctx[18] }
		];

		function switch_instance_placeholder_binding(value) {
			/*switch_instance_placeholder_binding*/ ctx[29](value);
		}

		function switch_instance_fieldname_binding(value) {
			/*switch_instance_fieldname_binding*/ ctx[30](value);
		}

		function switch_instance_required_binding(value) {
			/*switch_instance_required_binding*/ ctx[31](value);
		}

		function switch_instance_multiple_binding(value) {
			/*switch_instance_multiple_binding*/ ctx[32](value);
		}

		function switch_instance_size_binding(value) {
			/*switch_instance_size_binding*/ ctx[33](value);
		}

		function switch_instance_valid_binding(value) {
			/*switch_instance_valid_binding*/ ctx[34](value);
		}

		function switch_instance_validated_binding(value) {
			/*switch_instance_validated_binding*/ ctx[35](value);
		}

		function switch_instance_errors_binding(value) {
			/*switch_instance_errors_binding*/ ctx[36](value);
		}

		function switch_instance_formErrors_binding(value) {
			/*switch_instance_formErrors_binding*/ ctx[37](value);
		}

		function switch_instance_formLevelError_binding(value) {
			/*switch_instance_formLevelError_binding*/ ctx[38](value);
		}

		var switch_value = COMPONENTS$2.get(/*selectorUI*/ ctx[19]);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty[0] & /*selectorUIProps, modelName, actionName, actionFilter, actionSorter, actionPager, actionSearch, optionId, optionTitle*/ 1570816) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*selectorUIProps*/ 1048576 && get_spread_object(/*selectorUIProps*/ ctx[20]),
					dirty[0] & /*modelName*/ 2048 && { modelName: /*modelName*/ ctx[11] },
					dirty[0] & /*actionName*/ 4096 && { actionName: /*actionName*/ ctx[12] },
					dirty[0] & /*actionFilter*/ 8192 && { actionFilter: /*actionFilter*/ ctx[13] },
					dirty[0] & /*actionSorter*/ 16384 && { actionSorter: /*actionSorter*/ ctx[14] },
					dirty[0] & /*actionPager*/ 32768 && { actionPager: /*actionPager*/ ctx[15] },
					dirty[0] & /*actionSearch*/ 65536 && { actionSearch: /*actionSearch*/ ctx[16] },
					dirty[0] & /*optionId*/ 131072 && { optionId: /*optionId*/ ctx[17] },
					dirty[0] & /*optionTitle*/ 262144 && { optionTitle: /*optionTitle*/ ctx[18] }
				]));
			}

			if (/*placeholder*/ ctx[0] !== void 0) {
				switch_instance_props.placeholder = /*placeholder*/ ctx[0];
			}

			if (/*fieldname*/ ctx[1] !== void 0) {
				switch_instance_props.fieldname = /*fieldname*/ ctx[1];
			}

			if (/*required*/ ctx[2] !== void 0) {
				switch_instance_props.required = /*required*/ ctx[2];
			}

			if (/*multiple*/ ctx[3] !== void 0) {
				switch_instance_props.multiple = /*multiple*/ ctx[3];
			}

			if (/*size*/ ctx[4] !== void 0) {
				switch_instance_props.size = /*size*/ ctx[4];
			}

			if (/*valid*/ ctx[5] !== void 0) {
				switch_instance_props.valid = /*valid*/ ctx[5];
			}

			if (/*validated*/ ctx[6] !== void 0) {
				switch_instance_props.validated = /*validated*/ ctx[6];
			}

			if (/*errors*/ ctx[7] !== void 0) {
				switch_instance_props.errors = /*errors*/ ctx[7];
			}

			if (/*formErrors*/ ctx[8] !== void 0) {
				switch_instance_props.formErrors = /*formErrors*/ ctx[8];
			}

			if (/*formLevelError*/ ctx[9] !== void 0) {
				switch_instance_props.formLevelError = /*formLevelError*/ ctx[9];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'placeholder', switch_instance_placeholder_binding));
			binding_callbacks.push(() => bind(switch_instance, 'fieldname', switch_instance_fieldname_binding));
			binding_callbacks.push(() => bind(switch_instance, 'required', switch_instance_required_binding));
			binding_callbacks.push(() => bind(switch_instance, 'multiple', switch_instance_multiple_binding));
			binding_callbacks.push(() => bind(switch_instance, 'size', switch_instance_size_binding));
			binding_callbacks.push(() => bind(switch_instance, 'valid', switch_instance_valid_binding));
			binding_callbacks.push(() => bind(switch_instance, 'validated', switch_instance_validated_binding));
			binding_callbacks.push(() => bind(switch_instance, 'errors', switch_instance_errors_binding));
			binding_callbacks.push(() => bind(switch_instance, 'formErrors', switch_instance_formErrors_binding));
			binding_callbacks.push(() => bind(switch_instance, 'formLevelError', switch_instance_formLevelError_binding));
			switch_instance.$on("resolve", /*resolve_handler*/ ctx[39]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectorUI*/ 524288 && switch_value !== (switch_value = COMPONENTS$2.get(/*selectorUI*/ ctx[19]))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'placeholder', switch_instance_placeholder_binding));
						binding_callbacks.push(() => bind(switch_instance, 'fieldname', switch_instance_fieldname_binding));
						binding_callbacks.push(() => bind(switch_instance, 'required', switch_instance_required_binding));
						binding_callbacks.push(() => bind(switch_instance, 'multiple', switch_instance_multiple_binding));
						binding_callbacks.push(() => bind(switch_instance, 'size', switch_instance_size_binding));
						binding_callbacks.push(() => bind(switch_instance, 'valid', switch_instance_valid_binding));
						binding_callbacks.push(() => bind(switch_instance, 'validated', switch_instance_validated_binding));
						binding_callbacks.push(() => bind(switch_instance, 'errors', switch_instance_errors_binding));
						binding_callbacks.push(() => bind(switch_instance, 'formErrors', switch_instance_formErrors_binding));
						binding_callbacks.push(() => bind(switch_instance, 'formLevelError', switch_instance_formLevelError_binding));
						switch_instance.$on("resolve", /*resolve_handler*/ ctx[39]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty[0] & /*selectorUIProps, modelName, actionName, actionFilter, actionSorter, actionPager, actionSearch, optionId, optionTitle*/ 1570816)
					? get_spread_update(switch_instance_spread_levels, [
							dirty[0] & /*selectorUIProps*/ 1048576 && get_spread_object(/*selectorUIProps*/ ctx[20]),
							dirty[0] & /*modelName*/ 2048 && { modelName: /*modelName*/ ctx[11] },
							dirty[0] & /*actionName*/ 4096 && { actionName: /*actionName*/ ctx[12] },
							dirty[0] & /*actionFilter*/ 8192 && { actionFilter: /*actionFilter*/ ctx[13] },
							dirty[0] & /*actionSorter*/ 16384 && { actionSorter: /*actionSorter*/ ctx[14] },
							dirty[0] & /*actionPager*/ 32768 && { actionPager: /*actionPager*/ ctx[15] },
							dirty[0] & /*actionSearch*/ 65536 && { actionSearch: /*actionSearch*/ ctx[16] },
							dirty[0] & /*optionId*/ 131072 && { optionId: /*optionId*/ ctx[17] },
							dirty[0] & /*optionTitle*/ 262144 && { optionTitle: /*optionTitle*/ ctx[18] }
						])
					: {};

					if (!updating_placeholder && dirty[0] & /*placeholder*/ 1) {
						updating_placeholder = true;
						switch_instance_changes.placeholder = /*placeholder*/ ctx[0];
						add_flush_callback(() => updating_placeholder = false);
					}

					if (!updating_fieldname && dirty[0] & /*fieldname*/ 2) {
						updating_fieldname = true;
						switch_instance_changes.fieldname = /*fieldname*/ ctx[1];
						add_flush_callback(() => updating_fieldname = false);
					}

					if (!updating_required && dirty[0] & /*required*/ 4) {
						updating_required = true;
						switch_instance_changes.required = /*required*/ ctx[2];
						add_flush_callback(() => updating_required = false);
					}

					if (!updating_multiple && dirty[0] & /*multiple*/ 8) {
						updating_multiple = true;
						switch_instance_changes.multiple = /*multiple*/ ctx[3];
						add_flush_callback(() => updating_multiple = false);
					}

					if (!updating_size && dirty[0] & /*size*/ 16) {
						updating_size = true;
						switch_instance_changes.size = /*size*/ ctx[4];
						add_flush_callback(() => updating_size = false);
					}

					if (!updating_valid && dirty[0] & /*valid*/ 32) {
						updating_valid = true;
						switch_instance_changes.valid = /*valid*/ ctx[5];
						add_flush_callback(() => updating_valid = false);
					}

					if (!updating_validated && dirty[0] & /*validated*/ 64) {
						updating_validated = true;
						switch_instance_changes.validated = /*validated*/ ctx[6];
						add_flush_callback(() => updating_validated = false);
					}

					if (!updating_errors && dirty[0] & /*errors*/ 128) {
						updating_errors = true;
						switch_instance_changes.errors = /*errors*/ ctx[7];
						add_flush_callback(() => updating_errors = false);
					}

					if (!updating_formErrors && dirty[0] & /*formErrors*/ 256) {
						updating_formErrors = true;
						switch_instance_changes.formErrors = /*formErrors*/ ctx[8];
						add_flush_callback(() => updating_formErrors = false);
					}

					if (!updating_formLevelError && dirty[0] & /*formLevelError*/ 512) {
						updating_formLevelError = true;
						switch_instance_changes.formLevelError = /*formLevelError*/ ctx[9];
						add_flush_callback(() => updating_formLevelError = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$Y(ctx) {
		let uilist;
		let t;
		let if_block_anchor;
		let current;

		const uilist_spread_levels = [
			{
				listItemComponent: COMPONENTS$2.get(/*itemUI*/ ctx[21])
			},
			/*itemUIProps*/ ctx[22],
			{ items: /*items*/ ctx[23] },
			{ actions: /*ACTIONS*/ ctx[25] }
		];

		let uilist_props = {};

		for (let i = 0; i < uilist_spread_levels.length; i += 1) {
			uilist_props = assign(uilist_props, uilist_spread_levels[i]);
		}

		uilist = new Ui_list({ props: uilist_props });
		let if_block = !/*readonly*/ ctx[10] && create_if_block$B(ctx);

		return {
			c() {
				create_component(uilist.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				mount_component(uilist, target, anchor);
				insert(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uilist_changes = (dirty[0] & /*itemUI, itemUIProps, items, ACTIONS*/ 48234496)
				? get_spread_update(uilist_spread_levels, [
						dirty[0] & /*itemUI*/ 2097152 && {
							listItemComponent: COMPONENTS$2.get(/*itemUI*/ ctx[21])
						},
						dirty[0] & /*itemUIProps*/ 4194304 && get_spread_object(/*itemUIProps*/ ctx[22]),
						dirty[0] & /*items*/ 8388608 && { items: /*items*/ ctx[23] },
						dirty[0] & /*ACTIONS*/ 33554432 && { actions: /*ACTIONS*/ ctx[25] }
					])
				: {};

				uilist.$set(uilist_changes);

				if (!/*readonly*/ ctx[10]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*readonly*/ 1024) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$B(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(uilist.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(uilist.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block_anchor);
				}

				destroy_component(uilist, detaching);
				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$Y($$self, $$props, $$invalidate) {
		let items;
		createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = [] } = $$props;
		let { placeholder = "" } = $$props;
		let { fieldname = "selectFromModel" } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { multiple = false } = $$props;
		let { size = 8 } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let { modelName = "" } = $$props;
		let { actionName = "" } = $$props;
		let { actionFilter = {} } = $$props;
		let { actionSorter = {} } = $$props;
		let { actionPager = {} } = $$props;
		let { actionSearch = undefined } = $$props;
		let { optionId = ":_id" } = $$props;
		let { optionTitle = ":title" } = $$props;
		let { selectorUI = "UISelectFromModelOnDemandInline" } = $$props;
		let { selectorUIProps = {} } = $$props;
		let { itemUI = "UIListItem" } = $$props;
		let { itemUIProps = {} } = $$props;

		let { transformValueItemToListItem = item => {
			return item
			? {
					id: item._id,
					title: item.title,
					description: item.description,
					value: item
				}
			: undefined;
		} } = $$props;

		function addItem(item) {
			if (!Array.isArray(value)) {
				$$invalidate(26, value = []);
			}

			value.push(item);
			$$invalidate(26, value);
		}

		const ACTIONS = [
			{
				action(listItem) {
					const val = listItem.value;
					const itemIndex = value.findIndex(valueItem => valueItem === val);

					if (itemIndex > -1) {
						const valCopy = [...value];
						notCommon$3.moveItem(valCopy, itemIndex, itemIndex - 1);
						$$invalidate(26, value = valCopy);
					}
				},
				title: "",
				icon: "arrow-up",
				color: "normal"
			},
			{
				action: listItem => {
					const val = listItem.value;
					const itemIndex = value.findIndex(valueItem => valueItem === val);

					if (itemIndex > -1) {
						const valCopy = [...value];
						notCommon$3.moveItem(valCopy, itemIndex, itemIndex + 1);
						$$invalidate(26, value = valCopy);
					}
				},
				title: "",
				icon: "arrow-down",
				color: "normal"
			},
			{
				action: listItem => {
					const val = listItem.value;
					const itemIndex = value.findIndex(valueItem => valueItem === val);

					if (itemIndex > -1) {
						value.splice(itemIndex, 1);
						$$invalidate(26, value);
					}
				},
				title: "",
				icon: "trash",
				color: "danger"
			}
		];

		function switch_instance_placeholder_binding(value) {
			placeholder = value;
			$$invalidate(0, placeholder);
		}

		function switch_instance_fieldname_binding(value) {
			fieldname = value;
			$$invalidate(1, fieldname);
		}

		function switch_instance_required_binding(value) {
			required = value;
			$$invalidate(2, required);
		}

		function switch_instance_multiple_binding(value) {
			multiple = value;
			$$invalidate(3, multiple);
		}

		function switch_instance_size_binding(value) {
			size = value;
			$$invalidate(4, size);
		}

		function switch_instance_valid_binding(value) {
			valid = value;
			$$invalidate(5, valid);
		}

		function switch_instance_validated_binding(value) {
			validated = value;
			$$invalidate(6, validated);
		}

		function switch_instance_errors_binding(value) {
			errors = value;
			$$invalidate(7, errors);
		}

		function switch_instance_formErrors_binding(value) {
			formErrors = value;
			$$invalidate(8, formErrors);
		}

		function switch_instance_formLevelError_binding(value) {
			formLevelError = value;
			$$invalidate(9, formLevelError);
		}

		const resolve_handler = e => addItem(e.detail);

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(27, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(26, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(0, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('required' in $$props) $$invalidate(2, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(10, readonly = $$props.readonly);
			if ('multiple' in $$props) $$invalidate(3, multiple = $$props.multiple);
			if ('size' in $$props) $$invalidate(4, size = $$props.size);
			if ('valid' in $$props) $$invalidate(5, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(6, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(7, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(8, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(9, formLevelError = $$props.formLevelError);
			if ('modelName' in $$props) $$invalidate(11, modelName = $$props.modelName);
			if ('actionName' in $$props) $$invalidate(12, actionName = $$props.actionName);
			if ('actionFilter' in $$props) $$invalidate(13, actionFilter = $$props.actionFilter);
			if ('actionSorter' in $$props) $$invalidate(14, actionSorter = $$props.actionSorter);
			if ('actionPager' in $$props) $$invalidate(15, actionPager = $$props.actionPager);
			if ('actionSearch' in $$props) $$invalidate(16, actionSearch = $$props.actionSearch);
			if ('optionId' in $$props) $$invalidate(17, optionId = $$props.optionId);
			if ('optionTitle' in $$props) $$invalidate(18, optionTitle = $$props.optionTitle);
			if ('selectorUI' in $$props) $$invalidate(19, selectorUI = $$props.selectorUI);
			if ('selectorUIProps' in $$props) $$invalidate(20, selectorUIProps = $$props.selectorUIProps);
			if ('itemUI' in $$props) $$invalidate(21, itemUI = $$props.itemUI);
			if ('itemUIProps' in $$props) $$invalidate(22, itemUIProps = $$props.itemUIProps);
			if ('transformValueItemToListItem' in $$props) $$invalidate(28, transformValueItemToListItem = $$props.transformValueItemToListItem);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*value, transformValueItemToListItem*/ 335544320) {
				$$invalidate(23, items = value.map ? value.map(transformValueItemToListItem) : []);
			}
		};

		return [
			placeholder,
			fieldname,
			required,
			multiple,
			size,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			readonly,
			modelName,
			actionName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch,
			optionId,
			optionTitle,
			selectorUI,
			selectorUIProps,
			itemUI,
			itemUIProps,
			items,
			addItem,
			ACTIONS,
			value,
			inputStarted,
			transformValueItemToListItem,
			switch_instance_placeholder_binding,
			switch_instance_fieldname_binding,
			switch_instance_required_binding,
			switch_instance_multiple_binding,
			switch_instance_size_binding,
			switch_instance_valid_binding,
			switch_instance_validated_binding,
			switch_instance_errors_binding,
			switch_instance_formErrors_binding,
			switch_instance_formLevelError_binding,
			resolve_handler
		];
	}

	class Ui_list_of_models extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$Y,
				create_fragment$Y,
				safe_not_equal,
				{
					inputStarted: 27,
					value: 26,
					placeholder: 0,
					fieldname: 1,
					required: 2,
					readonly: 10,
					multiple: 3,
					size: 4,
					valid: 5,
					validated: 6,
					errors: 7,
					formErrors: 8,
					formLevelError: 9,
					modelName: 11,
					actionName: 12,
					actionFilter: 13,
					actionSorter: 14,
					actionPager: 15,
					actionSearch: 16,
					optionId: 17,
					optionTitle: 18,
					selectorUI: 19,
					selectorUIProps: 20,
					itemUI: 21,
					itemUIProps: 22,
					transformValueItemToListItem: 28
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.column.svelte generated by Svelte v4.2.19 */

	function create_fragment$X(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[4].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "title", /*title*/ ctx[1]);
				attr(div, "class", div_class_value = "column " + /*classes*/ ctx[0] + " " + (/*narrow*/ ctx[2] ? 'is-narrow' : ''));
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[5]),
						listen(div, "keyup", /*keyup_handler*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[3],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*title*/ 2) {
					attr(div, "title", /*title*/ ctx[1]);
				}

				if (!current || dirty & /*classes, narrow*/ 5 && div_class_value !== (div_class_value = "column " + /*classes*/ ctx[0] + " " + (/*narrow*/ ctx[2] ? 'is-narrow' : ''))) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$X($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { classes = "" } = $$props;
		let { title = "" } = $$props;
		let { narrow = false } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('narrow' in $$props) $$invalidate(2, narrow = $$props.narrow);
			if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
		};

		return [classes, title, narrow, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_column extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$X, create_fragment$X, safe_not_equal, { classes: 0, title: 1, narrow: 2 });
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.columns.svelte generated by Svelte v4.2.19 */

	function create_fragment$W(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[2].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "class", div_class_value = "columns " + /*classes*/ ctx[0]);
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[3]),
						listen(div, "keyup", /*keyup_handler*/ ctx[4])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[1],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*classes*/ 1 && div_class_value !== (div_class_value = "columns " + /*classes*/ ctx[0])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$W($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
		};

		return [classes, $$scope, slots, click_handler, keyup_handler];
	}

	class Ui_columns extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$W, create_fragment$W, safe_not_equal, { classes: 0 });
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.container.svelte generated by Svelte v4.2.19 */

	function create_fragment$V(ctx) {
		let div;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[8].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
				attr(div, "id", /*id*/ ctx[0]);
				attr(div, "class", div_class_value = "container " + /*classes*/ ctx[1]);
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				toggle_class(div, "is-widescreen", /*widescreen*/ ctx[2]);
				toggle_class(div, "is-fullhd", /*fullhd*/ ctx[3]);
				toggle_class(div, "is-max-desktop", /*maxDesktop*/ ctx[4]);
				toggle_class(div, "is-max-widescreen", /*maxWidescreen*/ ctx[5]);
				toggle_class(div, "is-fluid", /*fluid*/ ctx[6]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*click_handler*/ ctx[9]),
						listen(div, "keyup", /*keyup_handler*/ ctx[10])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[7],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(div, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && div_class_value !== (div_class_value = "container " + /*classes*/ ctx[1])) {
					attr(div, "class", div_class_value);
				}

				if (!current || dirty & /*classes, widescreen*/ 6) {
					toggle_class(div, "is-widescreen", /*widescreen*/ ctx[2]);
				}

				if (!current || dirty & /*classes, fullhd*/ 10) {
					toggle_class(div, "is-fullhd", /*fullhd*/ ctx[3]);
				}

				if (!current || dirty & /*classes, maxDesktop*/ 18) {
					toggle_class(div, "is-max-desktop", /*maxDesktop*/ ctx[4]);
				}

				if (!current || dirty & /*classes, maxWidescreen*/ 34) {
					toggle_class(div, "is-max-widescreen", /*maxWidescreen*/ ctx[5]);
				}

				if (!current || dirty & /*classes, fluid*/ 66) {
					toggle_class(div, "is-fluid", /*fluid*/ ctx[6]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$V($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { id = "" } = $$props;
		let { classes = "" } = $$props;
		let { widescreen = false } = $$props;
		let { fullhd = false } = $$props;
		let { maxDesktop = false } = $$props;
		let { maxWidescreen = false } = $$props;
		let { fluid = false } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('widescreen' in $$props) $$invalidate(2, widescreen = $$props.widescreen);
			if ('fullhd' in $$props) $$invalidate(3, fullhd = $$props.fullhd);
			if ('maxDesktop' in $$props) $$invalidate(4, maxDesktop = $$props.maxDesktop);
			if ('maxWidescreen' in $$props) $$invalidate(5, maxWidescreen = $$props.maxWidescreen);
			if ('fluid' in $$props) $$invalidate(6, fluid = $$props.fluid);
			if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
		};

		return [
			id,
			classes,
			widescreen,
			fullhd,
			maxDesktop,
			maxWidescreen,
			fluid,
			$$scope,
			slots,
			click_handler,
			keyup_handler
		];
	}

	class Ui_container extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$V, create_fragment$V, safe_not_equal, {
				id: 0,
				classes: 1,
				widescreen: 2,
				fullhd: 3,
				maxDesktop: 4,
				maxWidescreen: 5,
				fluid: 6
			});
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.footer.svelte generated by Svelte v4.2.19 */

	function create_fragment$U(ctx) {
		let footer;
		let footer_class_value;
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		return {
			c() {
				footer = element("footer");
				if (default_slot) default_slot.c();
				attr(footer, "id", /*id*/ ctx[0]);
				attr(footer, "class", footer_class_value = "footer " + /*classes*/ ctx[1] + "");
			},
			m(target, anchor) {
				insert(target, footer, anchor);

				if (default_slot) {
					default_slot.m(footer, null);
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(footer, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*classes*/ 2 && footer_class_value !== (footer_class_value = "footer " + /*classes*/ ctx[1] + "")) {
					attr(footer, "class", footer_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(footer);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$U($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { id = '' } = $$props;
		let { classes = '' } = $$props;

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
		};

		return [id, classes, $$scope, slots];
	}

	class Ui_footer extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$U, create_fragment$U, safe_not_equal, { id: 0, classes: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.section.svelte generated by Svelte v4.2.19 */

	function create_fragment$T(ctx) {
		let section;
		let section_class_value;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[5].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

		return {
			c() {
				section = element("section");
				if (default_slot) default_slot.c();
				attr(section, "id", /*id*/ ctx[0]);
				attr(section, "class", section_class_value = "section " + (/*size*/ ctx[1] ? 'is-' + /*size*/ ctx[1] : '') + " " + /*classes*/ ctx[2]);
				attr(section, "role", "button");
				attr(section, "tabindex", /*tabindex*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, section, anchor);

				if (default_slot) {
					default_slot.m(section, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(section, "click", /*click_handler*/ ctx[6]),
						listen(section, "keyup", /*keyup_handler*/ ctx[7])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[4],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*id*/ 1) {
					attr(section, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*size, classes*/ 6 && section_class_value !== (section_class_value = "section " + (/*size*/ ctx[1] ? 'is-' + /*size*/ ctx[1] : '') + " " + /*classes*/ ctx[2])) {
					attr(section, "class", section_class_value);
				}

				if (!current || dirty & /*tabindex*/ 8) {
					attr(section, "tabindex", /*tabindex*/ ctx[3]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(section);
				}

				if (default_slot) default_slot.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$T($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { id = "" } = $$props;
		let { size } = $$props;
		let { classes = "" } = $$props;
		let { tabindex = 0 } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
			if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
			if ('tabindex' in $$props) $$invalidate(3, tabindex = $$props.tabindex);
			if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
		};

		return [id, size, classes, tabindex, $$scope, slots, click_handler, keyup_handler];
	}

	let Ui_section$2 = class Ui_section extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$T, create_fragment$T, safe_not_equal, { id: 0, size: 1, classes: 2, tabindex: 3 });
		}
	};

	/* node_modules/not-bulma/src/elements/layout/ui.level.item.svelte generated by Svelte v4.2.19 */

	function create_dynamic_element(ctx) {
		let svelte_element;
		let current;
		const default_slot_template = /*#slots*/ ctx[2].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

		return {
			c() {
				svelte_element = element(/*tag*/ ctx[0]);
				if (default_slot) default_slot.c();
			},
			m(target, anchor) {
				insert(target, svelte_element, anchor);

				if (default_slot) {
					default_slot.m(svelte_element, null);
				}

				current = true;
			},
			p(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[1],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
							null
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(svelte_element);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function create_fragment$S(ctx) {
		let previous_tag = /*tag*/ ctx[0];
		let svelte_element_anchor;
		let current;
		let svelte_element = /*tag*/ ctx[0] && create_dynamic_element(ctx);

		return {
			c() {
				if (svelte_element) svelte_element.c();
				svelte_element_anchor = empty();
			},
			m(target, anchor) {
				if (svelte_element) svelte_element.m(target, anchor);
				insert(target, svelte_element_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*tag*/ ctx[0]) {
					if (!previous_tag) {
						svelte_element = create_dynamic_element(ctx);
						previous_tag = /*tag*/ ctx[0];
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else if (safe_not_equal(previous_tag, /*tag*/ ctx[0])) {
						svelte_element.d(1);
						svelte_element = create_dynamic_element(ctx);
						previous_tag = /*tag*/ ctx[0];
						svelte_element.c();
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else {
						svelte_element.p(ctx, dirty);
					}
				} else if (previous_tag) {
					svelte_element.d(1);
					svelte_element = null;
					previous_tag = /*tag*/ ctx[0];
				}
			},
			i(local) {
				if (current) return;
				transition_in(svelte_element, local);
				current = true;
			},
			o(local) {
				transition_out(svelte_element, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(svelte_element_anchor);
				}

				if (svelte_element) svelte_element.d(detaching);
			}
		};
	}

	function instance$S($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { tag = "div" } = $$props;

		$$self.$$set = $$props => {
			if ('tag' in $$props) $$invalidate(0, tag = $$props.tag);
			if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
		};

		return [tag, $$scope, slots];
	}

	class Ui_level_item extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$S, create_fragment$S, safe_not_equal, { tag: 0 });
		}
	}

	/* node_modules/not-bulma/src/elements/layout/ui.level.svelte generated by Svelte v4.2.19 */
	const get_right_slot_changes = dirty => ({});
	const get_right_slot_context = ctx => ({});
	const get_left_slot_changes = dirty => ({});
	const get_left_slot_context = ctx => ({});

	function create_fragment$R(ctx) {
		let nav;
		let div0;
		let t;
		let div1;
		let current;
		const left_slot_template = /*#slots*/ ctx[1].left;
		const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[0], get_left_slot_context);
		const right_slot_template = /*#slots*/ ctx[1].right;
		const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[0], get_right_slot_context);

		return {
			c() {
				nav = element("nav");
				div0 = element("div");
				if (left_slot) left_slot.c();
				t = space();
				div1 = element("div");
				if (right_slot) right_slot.c();
				attr(div0, "class", "level-left");
				attr(div1, "class", "level-right");
				attr(nav, "class", "level");
			},
			m(target, anchor) {
				insert(target, nav, anchor);
				append(nav, div0);

				if (left_slot) {
					left_slot.m(div0, null);
				}

				append(nav, t);
				append(nav, div1);

				if (right_slot) {
					right_slot.m(div1, null);
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (left_slot) {
					if (left_slot.p && (!current || dirty & /*$$scope*/ 1)) {
						update_slot_base(
							left_slot,
							left_slot_template,
							ctx,
							/*$$scope*/ ctx[0],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
							: get_slot_changes(left_slot_template, /*$$scope*/ ctx[0], dirty, get_left_slot_changes),
							get_left_slot_context
						);
					}
				}

				if (right_slot) {
					if (right_slot.p && (!current || dirty & /*$$scope*/ 1)) {
						update_slot_base(
							right_slot,
							right_slot_template,
							ctx,
							/*$$scope*/ ctx[0],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
							: get_slot_changes(right_slot_template, /*$$scope*/ ctx[0], dirty, get_right_slot_changes),
							get_right_slot_context
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(left_slot, local);
				transition_in(right_slot, local);
				current = true;
			},
			o(local) {
				transition_out(left_slot, local);
				transition_out(right_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(nav);
				}

				if (left_slot) left_slot.d(detaching);
				if (right_slot) right_slot.d(detaching);
			}
		};
	}

	function instance$R($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;

		$$self.$$set = $$props => {
			if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
		};

		return [$$scope, slots];
	}

	class Ui_level extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$R, create_fragment$R, safe_not_equal, {});
		}
	}

	var index$8 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIColumn: Ui_column,
		UIColumns: Ui_columns,
		UIContainer: Ui_container,
		UIFooter: Ui_footer,
		UILevel: Ui_level,
		UILevelItem: Ui_level_item,
		UISection: Ui_section$2
	});

	/* node_modules/not-bulma/src/elements/form/ui.number.svelte generated by Svelte v4.2.19 */

	function create_else_block$n(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[6] && create_if_block_4$a(ctx);
		let if_block1 = /*validated*/ ctx[11] === true && create_if_block_1$t(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-textfield-" + /*fieldname*/ ctx[5]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[12]);
				attr(input, "type", "number");
				attr(input, "min", /*min*/ ctx[2]);
				attr(input, "max", /*max*/ ctx[3]);
				attr(input, "step", /*step*/ ctx[4]);
				attr(input, "name", /*fieldname*/ ctx[5]);
				attr(input, "invalid", /*invalid*/ ctx[13]);
				input.disabled = /*disabled*/ ctx[8];
				input.required = /*required*/ ctx[7];
				input.readOnly = /*readonly*/ ctx[9];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[17][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[5]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[5]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[5]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[24]),
						listen(input, "change", /*onBlur*/ ctx[18]),
						listen(input, "input", /*onInput*/ ctx[19])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 32 && input_id_value !== (input_id_value = "form-field-textfield-" + /*fieldname*/ ctx[5])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*validationClasses*/ 4096 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[12])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*min*/ 4) {
					attr(input, "min", /*min*/ ctx[2]);
				}

				if (dirty & /*max*/ 8) {
					attr(input, "max", /*max*/ ctx[3]);
				}

				if (dirty & /*step*/ 16) {
					attr(input, "step", /*step*/ ctx[4]);
				}

				if (dirty & /*fieldname*/ 32) {
					attr(input, "name", /*fieldname*/ ctx[5]);
				}

				if (dirty & /*invalid*/ 8192) {
					attr(input, "invalid", /*invalid*/ ctx[13]);
				}

				if (dirty & /*disabled*/ 256) {
					input.disabled = /*disabled*/ ctx[8];
				}

				if (dirty & /*required*/ 128) {
					input.required = /*required*/ ctx[7];
				}

				if (dirty & /*readonly*/ 512) {
					input.readOnly = /*readonly*/ ctx[9];
				}

				if (dirty & /*$LOCALE, placeholder*/ 131074 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[17][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 32) {
					attr(input, "autocomplete", /*fieldname*/ ctx[5]);
				}

				if (dirty & /*fieldname*/ 32 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[5])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 32 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[5])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1 && to_number(input.value) !== /*value*/ ctx[0]) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[6]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$a(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[11] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$t(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (59:4) {#if readonly}
	function create_if_block$A(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (82:8) {#if icon}
	function create_if_block_4$a(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[6]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 64 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[6])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (87:8) {#if validated === true}
	function create_if_block_1$t(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[10] === true) return create_if_block_2$j;
			if (/*valid*/ ctx[10] === false) return create_if_block_3$f;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (91:42) 
	function create_if_block_3$f(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (89:16) {#if valid === true}
	function create_if_block_2$j(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$Q(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[9]) return create_if_block$A;
			return create_else_block$n;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[25](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[26](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[27](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[5]
		};

		if (/*allErrors*/ ctx[15] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[15];
		}

		if (/*showErrors*/ ctx[14] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[14];
		}

		if (/*validationClasses*/ ctx[12] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[12];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[16]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 65536 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[16])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 32) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[5];

				if (!updating_errors && dirty & /*allErrors*/ 32768) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[15];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 16384) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[14];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 4096) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[12];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$Q($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(17, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = 0 } = $$props;
		let { placeholder = "0.0" } = $$props;
		let { min = 0 } = $$props;
		let { max = 100 } = $$props;
		let { step = 1 } = $$props;
		let { fieldname = "number" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur() /*ev*/ {
			let data = { field: fieldname, value };
			$$invalidate(20, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(20, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = to_number(this.value);
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(15, allErrors), $$invalidate(21, errors)), $$invalidate(22, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(14, showErrors), $$invalidate(11, validated)), $$invalidate(10, valid)), $$invalidate(20, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(12, validationClasses), $$invalidate(10, valid)), $$invalidate(20, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(20, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('min' in $$props) $$invalidate(2, min = $$props.min);
			if ('max' in $$props) $$invalidate(3, max = $$props.max);
			if ('step' in $$props) $$invalidate(4, step = $$props.step);
			if ('fieldname' in $$props) $$invalidate(5, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(7, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(8, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(9, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(10, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(11, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(21, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(22, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(23, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 64) {
				$$invalidate(16, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 6291456) {
				$$invalidate(15, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 1051648) {
				$$invalidate(14, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 8389632) {
				$$invalidate(13, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 1049600) {
				$$invalidate(12, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			min,
			max,
			step,
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_number extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
				inputStarted: 20,
				value: 0,
				placeholder: 1,
				min: 2,
				max: 3,
				step: 4,
				fieldname: 5,
				icon: 6,
				required: 7,
				disabled: 8,
				readonly: 9,
				valid: 10,
				validated: 11,
				errors: 21,
				formErrors: 22,
				formLevelError: 23
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.named.numbers.list.svelte generated by Svelte v4.2.19 */

	function get_each_context$f(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[27] = list[i];
		return child_ctx;
	}

	// (74:8) <UIColumn classes="is-6">
	function create_default_slot_7(ctx) {
		let t_value = /*item*/ ctx[27].title + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*list*/ 256 && t_value !== (t_value = /*item*/ ctx[27].title + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (77:8) <UIColumn classes="is-4">
	function create_default_slot_6(ctx) {
		let t_value = /*item*/ ctx[27].number + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*list*/ 256 && t_value !== (t_value = /*item*/ ctx[27].number + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (80:8) {#if !readonly}
	function create_if_block_1$s(ctx) {
		let uicolumn;
		let current;

		uicolumn = new Ui_column({
				props: {
					classes: "is-2",
					$$slots: { default: [create_default_slot_5] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uicolumn.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uicolumn, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uicolumn_changes = {};

				if (dirty & /*$$scope, list*/ 1073742080) {
					uicolumn_changes.$$scope = { dirty, ctx };
				}

				uicolumn.$set(uicolumn_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uicolumn.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uicolumn.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uicolumn, detaching);
			}
		};
	}

	// (81:12) <UIColumn classes="is-2">
	function create_default_slot_5(ctx) {
		let uibutton;
		let current;

		function func() {
			return /*func*/ ctx[17](/*item*/ ctx[27]);
		}

		uibutton = new Ui_button({ props: { icon: "minus", action: func } });

		return {
			c() {
				create_component(uibutton.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const uibutton_changes = {};
				if (dirty & /*list*/ 256) uibutton_changes.action = func;
				uibutton.$set(uibutton_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibutton, detaching);
			}
		};
	}

	// (73:4) <UIColumns>
	function create_default_slot_4(ctx) {
		let uicolumn0;
		let t0;
		let uicolumn1;
		let t1;
		let if_block_anchor;
		let current;

		uicolumn0 = new Ui_column({
				props: {
					classes: "is-6",
					$$slots: { default: [create_default_slot_7] },
					$$scope: { ctx }
				}
			});

		uicolumn1 = new Ui_column({
				props: {
					classes: "is-4",
					$$slots: { default: [create_default_slot_6] },
					$$scope: { ctx }
				}
			});

		let if_block = !/*readonly*/ ctx[3] && create_if_block_1$s(ctx);

		return {
			c() {
				create_component(uicolumn0.$$.fragment);
				t0 = space();
				create_component(uicolumn1.$$.fragment);
				t1 = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				mount_component(uicolumn0, target, anchor);
				insert(target, t0, anchor);
				mount_component(uicolumn1, target, anchor);
				insert(target, t1, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uicolumn0_changes = {};

				if (dirty & /*$$scope, list*/ 1073742080) {
					uicolumn0_changes.$$scope = { dirty, ctx };
				}

				uicolumn0.$set(uicolumn0_changes);
				const uicolumn1_changes = {};

				if (dirty & /*$$scope, list*/ 1073742080) {
					uicolumn1_changes.$$scope = { dirty, ctx };
				}

				uicolumn1.$set(uicolumn1_changes);

				if (!/*readonly*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*readonly*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_1$s(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(uicolumn0.$$.fragment, local);
				transition_in(uicolumn1.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(uicolumn0.$$.fragment, local);
				transition_out(uicolumn1.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(if_block_anchor);
				}

				destroy_component(uicolumn0, detaching);
				destroy_component(uicolumn1, detaching);
				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (72:0) {#each list as item (item.id)}
	function create_each_block$f(key_1, ctx) {
		let first;
		let uicolumns;
		let current;

		uicolumns = new Ui_columns({
				props: {
					$$slots: { default: [create_default_slot_4] },
					$$scope: { ctx }
				}
			});

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uicolumns.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uicolumns, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const uicolumns_changes = {};

				if (dirty & /*$$scope, list, readonly*/ 1073742088) {
					uicolumns_changes.$$scope = { dirty, ctx };
				}

				uicolumns.$set(uicolumns_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uicolumns.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uicolumns.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uicolumns, detaching);
			}
		};
	}

	// (87:0) {#if !readonly}
	function create_if_block$z(ctx) {
		let uicolumns;
		let current;

		uicolumns = new Ui_columns({
				props: {
					$$slots: { default: [create_default_slot$5] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uicolumns.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uicolumns, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uicolumns_changes = {};

				if (dirty & /*$$scope, newVal, placeholder*/ 1073741841) {
					uicolumns_changes.$$scope = { dirty, ctx };
				}

				uicolumns.$set(uicolumns_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uicolumns.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uicolumns.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uicolumns, detaching);
			}
		};
	}

	// (89:8) <UIColumn classes="is-6">
	function create_default_slot_3(ctx) {
		let uitextfield;
		let updating_value;
		let updating_placeholder;
		let current;

		function uitextfield_value_binding(value) {
			/*uitextfield_value_binding*/ ctx[18](value);
		}

		function uitextfield_placeholder_binding(value) {
			/*uitextfield_placeholder_binding*/ ctx[19](value);
		}

		let uitextfield_props = {};

		if (/*newVal*/ ctx[4].id !== void 0) {
			uitextfield_props.value = /*newVal*/ ctx[4].id;
		}

		if (/*placeholder*/ ctx[0] !== void 0) {
			uitextfield_props.placeholder = /*placeholder*/ ctx[0];
		}

		uitextfield = new Ui_textfield({ props: uitextfield_props });
		binding_callbacks.push(() => bind(uitextfield, 'value', uitextfield_value_binding));
		binding_callbacks.push(() => bind(uitextfield, 'placeholder', uitextfield_placeholder_binding));

		return {
			c() {
				create_component(uitextfield.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitextfield, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitextfield_changes = {};

				if (!updating_value && dirty & /*newVal*/ 16) {
					updating_value = true;
					uitextfield_changes.value = /*newVal*/ ctx[4].id;
					add_flush_callback(() => updating_value = false);
				}

				if (!updating_placeholder && dirty & /*placeholder*/ 1) {
					updating_placeholder = true;
					uitextfield_changes.placeholder = /*placeholder*/ ctx[0];
					add_flush_callback(() => updating_placeholder = false);
				}

				uitextfield.$set(uitextfield_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitextfield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitextfield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitextfield, detaching);
			}
		};
	}

	// (92:8) <UIColumn classes="is-4">
	function create_default_slot_2$1(ctx) {
		let uinumber;
		let updating_value;
		let current;

		function uinumber_value_binding(value) {
			/*uinumber_value_binding*/ ctx[20](value);
		}

		let uinumber_props = {};

		if (/*newVal*/ ctx[4].number !== void 0) {
			uinumber_props.value = /*newVal*/ ctx[4].number;
		}

		uinumber = new Ui_number({ props: uinumber_props });
		binding_callbacks.push(() => bind(uinumber, 'value', uinumber_value_binding));

		return {
			c() {
				create_component(uinumber.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinumber, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinumber_changes = {};

				if (!updating_value && dirty & /*newVal*/ 16) {
					updating_value = true;
					uinumber_changes.value = /*newVal*/ ctx[4].number;
					add_flush_callback(() => updating_value = false);
				}

				uinumber.$set(uinumber_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinumber.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinumber.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinumber, detaching);
			}
		};
	}

	// (95:8) <UIColumn classes="is-2">
	function create_default_slot_1$3(ctx) {
		let uibutton;
		let current;

		uibutton = new Ui_button({
				props: { icon: "plus", action: /*func_1*/ ctx[21] }
			});

		return {
			c() {
				create_component(uibutton.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				current = true;
			},
			p: noop$1,
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibutton, detaching);
			}
		};
	}

	// (88:4) <UIColumns>
	function create_default_slot$5(ctx) {
		let uicolumn0;
		let t0;
		let uicolumn1;
		let t1;
		let uicolumn2;
		let current;

		uicolumn0 = new Ui_column({
				props: {
					classes: "is-6",
					$$slots: { default: [create_default_slot_3] },
					$$scope: { ctx }
				}
			});

		uicolumn1 = new Ui_column({
				props: {
					classes: "is-4",
					$$slots: { default: [create_default_slot_2$1] },
					$$scope: { ctx }
				}
			});

		uicolumn2 = new Ui_column({
				props: {
					classes: "is-2",
					$$slots: { default: [create_default_slot_1$3] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uicolumn0.$$.fragment);
				t0 = space();
				create_component(uicolumn1.$$.fragment);
				t1 = space();
				create_component(uicolumn2.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uicolumn0, target, anchor);
				insert(target, t0, anchor);
				mount_component(uicolumn1, target, anchor);
				insert(target, t1, anchor);
				mount_component(uicolumn2, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uicolumn0_changes = {};

				if (dirty & /*$$scope, newVal, placeholder*/ 1073741841) {
					uicolumn0_changes.$$scope = { dirty, ctx };
				}

				uicolumn0.$set(uicolumn0_changes);
				const uicolumn1_changes = {};

				if (dirty & /*$$scope, newVal*/ 1073741840) {
					uicolumn1_changes.$$scope = { dirty, ctx };
				}

				uicolumn1.$set(uicolumn1_changes);
				const uicolumn2_changes = {};

				if (dirty & /*$$scope*/ 1073741824) {
					uicolumn2_changes.$$scope = { dirty, ctx };
				}

				uicolumn2.$set(uicolumn2_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uicolumn0.$$.fragment, local);
				transition_in(uicolumn1.$$.fragment, local);
				transition_in(uicolumn2.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uicolumn0.$$.fragment, local);
				transition_out(uicolumn1.$$.fragment, local);
				transition_out(uicolumn2.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
				}

				destroy_component(uicolumn0, detaching);
				destroy_component(uicolumn1, detaching);
				destroy_component(uicolumn2, detaching);
			}
		};
	}

	function create_fragment$P(ctx) {
		let uititle;
		let t0;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let t1;
		let t2;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		uititle = new Ui_title({
				props: { title: /*label*/ ctx[2], size: 5 }
			});

		let each_value = ensure_array_like(/*list*/ ctx[8]);
		const get_key = ctx => /*item*/ ctx[27].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$f(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$f(key, child_ctx));
		}

		let if_block = !/*readonly*/ ctx[3] && create_if_block$z(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[1]
		};

		if (/*allErrors*/ ctx[7] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[7];
		}

		if (/*showErrors*/ ctx[6] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[6];
		}

		if (/*validationClasses*/ ctx[5] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[5];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				create_component(uititle.$$.fragment);
				t0 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t1 = space();
				if (if_block) if_block.c();
				t2 = space();
				create_component(errorslist.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uititle, target, anchor);
				insert(target, t0, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, t1, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, t2, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uititle_changes = {};
				if (dirty & /*label*/ 4) uititle_changes.title = /*label*/ ctx[2];
				uititle.$set(uititle_changes);

				if (dirty & /*remove, list, readonly*/ 776) {
					each_value = ensure_array_like(/*list*/ ctx[8]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, t1.parentNode, outro_and_destroy_block, create_each_block$f, t1, get_each_context$f);
					check_outros();
				}

				if (!/*readonly*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*readonly*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$z(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(t2.parentNode, t2);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 2) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[1];

				if (!updating_errors && dirty & /*allErrors*/ 128) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[7];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 64) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[6];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 32) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[5];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uititle.$$.fragment, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uititle.$$.fragment, local);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
				}

				destroy_component(uititle, detaching);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}

				if (if_block) if_block.d(detaching);
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$P($$self, $$props, $$invalidate) {
		let list;
		let allErrors;
		let showErrors;
		let validationClasses;
		let dispatch = createEventDispatcher();
		let { fieldname = "numbers_list" } = $$props;
		let { value = {} } = $$props;
		let { label = "named numbers list" } = $$props;
		let { inputStarted = false } = $$props;
		let { placeholder = "new item" } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;

		function remove(id) {
			if (notCommon$3.objHas(value, id)) {
				delete value[id];
				$$invalidate(11, value);
				dispatch("change", { value, field: fieldname });
			}
		}

		function add() {
			const id = newVal.id.trim();
			const number = parseInt(newVal.number);

			if (id && id !== "" && !isNaN(number) && !notCommon$3.objHas(value, id)) {
				$$invalidate(11, value[id] = number, value);
			}

			dispatch("change", { value, field: fieldname });
		}

		const createNewVal = () => {
			return { id: "", number: 0 };
		};

		let newVal = createNewVal();
		const func = item => remove(item.id);

		function uitextfield_value_binding(value) {
			if ($$self.$$.not_equal(newVal.id, value)) {
				newVal.id = value;
				$$invalidate(4, newVal);
			}
		}

		function uitextfield_placeholder_binding(value) {
			placeholder = value;
			$$invalidate(0, placeholder);
		}

		function uinumber_value_binding(value) {
			if ($$self.$$.not_equal(newVal.number, value)) {
				newVal.number = value;
				$$invalidate(4, newVal);
			}
		}

		const func_1 = () => add();

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(7, allErrors), $$invalidate(15, errors)), $$invalidate(16, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(6, showErrors), $$invalidate(14, validated)), $$invalidate(13, valid)), $$invalidate(12, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(5, validationClasses), $$invalidate(13, valid)), $$invalidate(12, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('value' in $$props) $$invalidate(11, value = $$props.value);
			if ('label' in $$props) $$invalidate(2, label = $$props.label);
			if ('inputStarted' in $$props) $$invalidate(12, inputStarted = $$props.inputStarted);
			if ('placeholder' in $$props) $$invalidate(0, placeholder = $$props.placeholder);
			if ('readonly' in $$props) $$invalidate(3, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(13, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(14, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(15, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(16, formErrors = $$props.formErrors);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*value*/ 2048) {
				$$invalidate(8, list = Object.keys(value).map(name => {
					return {
						id: name,
						title: name,
						number: value[name]
					};
				}));
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 98304) {
				$$invalidate(7, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 28672) {
				$$invalidate(6, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 12288) {
				$$invalidate(5, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			placeholder,
			fieldname,
			label,
			readonly,
			newVal,
			validationClasses,
			showErrors,
			allErrors,
			list,
			remove,
			add,
			value,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			func,
			uitextfield_value_binding,
			uitextfield_placeholder_binding,
			uinumber_value_binding,
			func_1,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_named_numbers_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$P, create_fragment$P, safe_not_equal, {
				fieldname: 1,
				value: 11,
				label: 2,
				inputStarted: 12,
				placeholder: 0,
				readonly: 3,
				valid: 13,
				validated: 14,
				errors: 15,
				formErrors: 16
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.password.svelte generated by Svelte v4.2.19 */

	function create_if_block_3$e(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (77:4) {#if validated === true}
	function create_if_block$y(ctx) {
		let span;

		function select_block_type(ctx, dirty) {
			if (/*valid*/ ctx[6] === true) return create_if_block_1$r;
			if (/*valid*/ ctx[6] === false) return create_if_block_2$i;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (81:38) 
	function create_if_block_2$i(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (79:12) {#if valid === true}
	function create_if_block_1$r(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$O(ctx) {
		let div;
		let input;
		let input_class_value;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let div_class_value;
		let t2;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_3$e(ctx);
		let if_block1 = /*validated*/ ctx[7] === true && create_if_block$y(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[21](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[22](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[23](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[11] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[11];
		}

		if (/*showErrors*/ ctx[10] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[10];
		}

		if (/*validationClasses*/ ctx[8] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[8];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				t2 = space();
				create_component(errorslist.$$.fragment);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[8]);
				input.readOnly = /*readonly*/ ctx[5];
				attr(input, "id", input_id_value = "form-field-password-" + /*fieldname*/ ctx[2]);
				attr(input, "type", "password");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[9]);
				input.required = /*required*/ ctx[4];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[12]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, input);
				set_input_value(input, /*value*/ ctx[0]);
				append(div, t0);
				if (if_block0) if_block0.m(div, null);
				append(div, t1);
				if (if_block1) if_block1.m(div, null);
				insert(target, t2, anchor);
				mount_component(errorslist, target, anchor);
				current = true;

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[20]),
						listen(input, "change", /*onBlur*/ ctx[14]),
						listen(input, "input", /*onInput*/ ctx[15])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*validationClasses*/ 256 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[8])) {
					attr(input, "class", input_class_value);
				}

				if (!current || dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (!current || dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-password-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (!current || dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (!current || dirty & /*invalid*/ 512) {
					attr(input, "invalid", /*invalid*/ ctx[9]);
				}

				if (!current || dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (!current || dirty & /*$LOCALE, placeholder*/ 8194 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (!current || dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (!current || dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (!current || dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$e(ctx);
						if_block0.c();
						if_block0.m(div, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[7] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$y(ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (!current || dirty & /*iconClasses*/ 4096 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[12])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 2048) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[11];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 1024) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[10];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 256) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[8];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				destroy_component(errorslist, detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$O($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "input some text here, please" } = $$props;
		let { fieldname = "password" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(11, allErrors), $$invalidate(17, errors)), $$invalidate(18, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(10, showErrors), $$invalidate(7, validated)), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(8, validationClasses), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(16, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(7, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(17, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(18, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(19, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(12, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 393216) {
				$$invalidate(11, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 65728) {
				$$invalidate(10, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 524352) {
				$$invalidate(9, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 65600) {
				$$invalidate(8, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_password extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$O, create_fragment$O, safe_not_equal, {
				inputStarted: 16,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				readonly: 5,
				valid: 6,
				validated: 7,
				errors: 17,
				formErrors: 18,
				formLevelError: 19
			});
		}
	}

	/* node_modules/not-bulma/src/elements/image/ui.image.svelte generated by Svelte v4.2.19 */

	function create_else_block$m(ctx) {
		let figure;
		let img;
		let img_src_value;
		let figure_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				figure = element("figure");
				img = element("img");
				attr(img, "class", "");
				attr(img, "alt", /*title*/ ctx[2]);
				if (!src_url_equal(img.src, img_src_value = /*url*/ ctx[1])) attr(img, "src", img_src_value);
				attr(img, "crossorigin", /*cors*/ ctx[3]);
				attr(figure, "class", figure_class_value = "image " + /*sizeStyle*/ ctx[7] + " " + /*containedStyle*/ ctx[6] + " " + /*coveredStyle*/ ctx[5] + " " + /*classes*/ ctx[4]);
				attr(figure, "role", "button");
				attr(figure, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, figure, anchor);
				append(figure, img);

				if (!mounted) {
					dispose = [
						listen(figure, "click", /*click_handler_1*/ ctx[12]),
						listen(figure, "keyup", /*keyup_handler*/ ctx[13])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*title*/ 4) {
					attr(img, "alt", /*title*/ ctx[2]);
				}

				if (dirty & /*url*/ 2 && !src_url_equal(img.src, img_src_value = /*url*/ ctx[1])) {
					attr(img, "src", img_src_value);
				}

				if (dirty & /*cors*/ 8) {
					attr(img, "crossorigin", /*cors*/ ctx[3]);
				}

				if (dirty & /*sizeStyle, containedStyle, coveredStyle, classes*/ 240 && figure_class_value !== (figure_class_value = "image " + /*sizeStyle*/ ctx[7] + " " + /*containedStyle*/ ctx[6] + " " + /*coveredStyle*/ ctx[5] + " " + /*classes*/ ctx[4])) {
					attr(figure, "class", figure_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(figure);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (16:0) {#if urlFull}
	function create_if_block$x(ctx) {
		let a;
		let figure;
		let img;
		let img_src_value;
		let figure_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				a = element("a");
				figure = element("figure");
				img = element("img");
				attr(img, "class", "");
				attr(img, "alt", /*title*/ ctx[2]);
				if (!src_url_equal(img.src, img_src_value = /*url*/ ctx[1])) attr(img, "src", img_src_value);
				attr(img, "crossorigin", /*cors*/ ctx[3]);
				attr(figure, "class", figure_class_value = "image " + /*sizeStyle*/ ctx[7] + " " + /*containedStyle*/ ctx[6] + " " + /*coveredStyle*/ ctx[5] + " " + /*classes*/ ctx[4]);
				attr(a, "href", /*urlFull*/ ctx[0]);
				attr(a, "alt", /*title*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, figure);
				append(figure, img);

				if (!mounted) {
					dispose = listen(a, "click", /*click_handler*/ ctx[11]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*title*/ 4) {
					attr(img, "alt", /*title*/ ctx[2]);
				}

				if (dirty & /*url*/ 2 && !src_url_equal(img.src, img_src_value = /*url*/ ctx[1])) {
					attr(img, "src", img_src_value);
				}

				if (dirty & /*cors*/ 8) {
					attr(img, "crossorigin", /*cors*/ ctx[3]);
				}

				if (dirty & /*sizeStyle, containedStyle, coveredStyle, classes*/ 240 && figure_class_value !== (figure_class_value = "image " + /*sizeStyle*/ ctx[7] + " " + /*containedStyle*/ ctx[6] + " " + /*coveredStyle*/ ctx[5] + " " + /*classes*/ ctx[4])) {
					attr(figure, "class", figure_class_value);
				}

				if (dirty & /*urlFull*/ 1) {
					attr(a, "href", /*urlFull*/ ctx[0]);
				}

				if (dirty & /*title*/ 4) {
					attr(a, "alt", /*title*/ ctx[2]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$N(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*urlFull*/ ctx[0]) return create_if_block$x;
			return create_else_block$m;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function instance$N($$self, $$props, $$invalidate) {
		let sizeStyle;
		let containedStyle;
		let coveredStyle;
		let { urlFull } = $$props;
		let { url } = $$props;
		let { title } = $$props;
		let { cors = "anonymous" } = $$props;
		let { size = 64 } = $$props;
		let { contained = true } = $$props;
		let { covered = true } = $$props;
		let { classes = "" } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function keyup_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('urlFull' in $$props) $$invalidate(0, urlFull = $$props.urlFull);
			if ('url' in $$props) $$invalidate(1, url = $$props.url);
			if ('title' in $$props) $$invalidate(2, title = $$props.title);
			if ('cors' in $$props) $$invalidate(3, cors = $$props.cors);
			if ('size' in $$props) $$invalidate(8, size = $$props.size);
			if ('contained' in $$props) $$invalidate(9, contained = $$props.contained);
			if ('covered' in $$props) $$invalidate(10, covered = $$props.covered);
			if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*size*/ 256) {
				$$invalidate(7, sizeStyle = isNaN(size) ? `is-${size}` : `is-${size}x${size}`);
			}

			if ($$self.$$.dirty & /*contained*/ 512) {
				$$invalidate(6, containedStyle = contained ? "is-contained" : "");
			}

			if ($$self.$$.dirty & /*covered*/ 1024) {
				$$invalidate(5, coveredStyle = covered ? "is-covered" : "");
			}
		};

		return [
			urlFull,
			url,
			title,
			cors,
			classes,
			coveredStyle,
			containedStyle,
			sizeStyle,
			size,
			contained,
			covered,
			click_handler,
			click_handler_1,
			keyup_handler
		];
	}

	class Ui_image extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$N, create_fragment$N, safe_not_equal, {
				urlFull: 0,
				url: 1,
				title: 2,
				cors: 3,
				size: 8,
				contained: 9,
				covered: 10,
				classes: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.radio.buttons.svelte generated by Svelte v4.2.19 */

	function create_fragment$M(ctx) {
		let switch_instance;
		let updating_items;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*listComponentProps*/ ctx[7],
			{
				titleComponent: /*titleComponent*/ ctx[0]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[1]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[4]
			},
			{
				descriptionComponentProps: {
					.../*descriptionComponentProps*/ ctx[5],
					action: /*func*/ ctx[20]
				}
			},
			{
				imageComponent: /*imageComponent*/ ctx[2]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[3]
			}
		];

		function switch_instance_items_binding(value) {
			/*switch_instance_items_binding*/ ctx[21](value);
		}

		var switch_value = /*listComponent*/ ctx[6];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 703) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listComponentProps*/ 128 && get_spread_object(/*listComponentProps*/ ctx[7]),
					dirty & /*titleComponent*/ 1 && {
						titleComponent: /*titleComponent*/ ctx[0]
					},
					dirty & /*titleComponentProps*/ 2 && {
						titleComponentProps: /*titleComponentProps*/ ctx[1]
					},
					dirty & /*descriptionComponent*/ 16 && {
						descriptionComponent: /*descriptionComponent*/ ctx[4]
					},
					dirty & /*descriptionComponentProps, toggle*/ 544 && {
						descriptionComponentProps: {
							.../*descriptionComponentProps*/ ctx[5],
							action: /*func*/ ctx[20]
						}
					},
					dirty & /*imageComponent*/ 4 && {
						imageComponent: /*imageComponent*/ ctx[2]
					},
					dirty & /*imageComponentProps*/ 8 && {
						imageComponentProps: /*imageComponentProps*/ ctx[3]
					}
				]));
			}

			if (/*listItems*/ ctx[8] !== void 0) {
				switch_instance_props.items = /*listItems*/ ctx[8];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*listComponent*/ 64 && switch_value !== (switch_value = /*listComponent*/ ctx[6])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 703)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listComponentProps*/ 128 && get_spread_object(/*listComponentProps*/ ctx[7]),
							dirty & /*titleComponent*/ 1 && {
								titleComponent: /*titleComponent*/ ctx[0]
							},
							dirty & /*titleComponentProps*/ 2 && {
								titleComponentProps: /*titleComponentProps*/ ctx[1]
							},
							dirty & /*descriptionComponent*/ 16 && {
								descriptionComponent: /*descriptionComponent*/ ctx[4]
							},
							dirty & /*descriptionComponentProps, toggle*/ 544 && {
								descriptionComponentProps: {
									.../*descriptionComponentProps*/ ctx[5],
									action: /*func*/ ctx[20]
								}
							},
							dirty & /*imageComponent*/ 4 && {
								imageComponent: /*imageComponent*/ ctx[2]
							},
							dirty & /*imageComponentProps*/ 8 && {
								imageComponentProps: /*imageComponentProps*/ ctx[3]
							}
						])
					: {};

					if (!updating_items && dirty & /*listItems*/ 256) {
						updating_items = true;
						switch_instance_changes.items = /*listItems*/ ctx[8];
						add_flush_callback(() => updating_items = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$M($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { fieldname = "radio-buttons" } = $$props;
		let { variants = [] } = $$props;
		let { value } = $$props;
		let { title } = $$props;
		let { image } = $$props;
		let { buttonProps = {} } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 5 } } = $$props;
		let { imageComponent = Ui_image } = $$props;
		let { imageComponentProps = { covered: true } } = $$props;
		let { descriptionComponent = Ui_buttons } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { listComponent = Ui_list } = $$props;
		let { listComponentProps = {} } = $$props;

		let { getUIItem = valueId => {
			return variantsButtons.find(btnVal => btnVal.value === valueId);
		} } = $$props;

		let { getDefaultItemSublime = () => {
			return variants[0].value;
		} } = $$props;

		let { uiOn = item => {
			item.color = "success";
			item.outlined = false;
		} } = $$props;

		let { uiOff = item => {
			item.color = false;
			item.outlined = true;
		} } = $$props;

		onMount(() => {
			initVariantsButton();
			selectDefault();
		});

		let variantsButtons = [], listItems = [];

		function initVariantsButton() {
			variantsButtons = variants.map(variant => {
				return { ...buttonProps, ...variant };
			});

			$$invalidate(8, listItems = [
				{
					id: 0,
					title,
					image,
					description: { values: variantsButtons }
				}
			]);
		}

		//
		function toggle(selectedValue) {
			let ui = { on: undefined, off: undefined };

			//
			if (value) {
				ui.off = value;
				ui.on = selectedValue;
			}

			$$invalidate(10, value = selectedValue);
			updateUI(ui);

			//
			dispatch("change", { field: fieldname, value });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff(getUIItem(changes.off));
			}

			if (changes.on) {
				uiOn(getUIItem(changes.on));
			}

			variantsButtons = variantsButtons;
			$$invalidate(8, listItems);
		}

		//
		function selectDefault() {
			if (variants.length > 0) {
				if (typeof value !== "undefined") {
					updateUI({ on: value });
				} else {
					const defValue = getDefaultItemSublime();
					toggle(defValue);
				}
			}
		}

		const func = function (event, value) {
			toggle(value);
		};

		function switch_instance_items_binding(value) {
			listItems = value;
			$$invalidate(8, listItems);
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(11, fieldname = $$props.fieldname);
			if ('variants' in $$props) $$invalidate(12, variants = $$props.variants);
			if ('value' in $$props) $$invalidate(10, value = $$props.value);
			if ('title' in $$props) $$invalidate(13, title = $$props.title);
			if ('image' in $$props) $$invalidate(14, image = $$props.image);
			if ('buttonProps' in $$props) $$invalidate(15, buttonProps = $$props.buttonProps);
			if ('titleComponent' in $$props) $$invalidate(0, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(1, titleComponentProps = $$props.titleComponentProps);
			if ('imageComponent' in $$props) $$invalidate(2, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(3, imageComponentProps = $$props.imageComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(4, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(5, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('listComponent' in $$props) $$invalidate(6, listComponent = $$props.listComponent);
			if ('listComponentProps' in $$props) $$invalidate(7, listComponentProps = $$props.listComponentProps);
			if ('getUIItem' in $$props) $$invalidate(16, getUIItem = $$props.getUIItem);
			if ('getDefaultItemSublime' in $$props) $$invalidate(17, getDefaultItemSublime = $$props.getDefaultItemSublime);
			if ('uiOn' in $$props) $$invalidate(18, uiOn = $$props.uiOn);
			if ('uiOff' in $$props) $$invalidate(19, uiOff = $$props.uiOff);
		};

		return [
			titleComponent,
			titleComponentProps,
			imageComponent,
			imageComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			listComponent,
			listComponentProps,
			listItems,
			toggle,
			value,
			fieldname,
			variants,
			title,
			image,
			buttonProps,
			getUIItem,
			getDefaultItemSublime,
			uiOn,
			uiOff,
			func,
			switch_instance_items_binding
		];
	}

	class Ui_radio_buttons extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$M, create_fragment$M, safe_not_equal, {
				fieldname: 11,
				variants: 12,
				value: 10,
				title: 13,
				image: 14,
				buttonProps: 15,
				titleComponent: 0,
				titleComponentProps: 1,
				imageComponent: 2,
				imageComponentProps: 3,
				descriptionComponent: 4,
				descriptionComponentProps: 5,
				listComponent: 6,
				listComponentProps: 7,
				getUIItem: 16,
				getDefaultItemSublime: 17,
				uiOn: 18,
				uiOff: 19
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.range.svelte generated by Svelte v4.2.19 */

	function get_each_context$e(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		return child_ctx;
	}

	// (64:4) {:else}
	function create_else_block$l(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_list_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let output;
		let t1;
		let output_for_value;
		let t2;
		let show_if = Array.isArray(/*tickmarks*/ ctx[4]) && /*tickmarks*/ ctx[4].length;
		let t3;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = show_if && create_if_block_2$h(ctx);
		let if_block1 = /*icon*/ ctx[7] && create_if_block_1$q(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				output = element("output");
				t1 = text(/*value*/ ctx[0]);
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-range-" + /*fieldname*/ ctx[6]);
				attr(input, "class", input_class_value = "input big-number slider has-output is-fullwidth is-success " + /*validationClasses*/ ctx[11]);
				attr(input, "type", "range");
				attr(input, "name", /*fieldname*/ ctx[6]);
				attr(input, "min", /*min*/ ctx[1]);
				attr(input, "max", /*max*/ ctx[2]);
				attr(input, "step", /*step*/ ctx[3]);
				attr(input, "list", input_list_value = "form-field-range-" + /*fieldname*/ ctx[6] + "-tickmarks");
				attr(input, "invalid", /*invalid*/ ctx[12]);
				input.disabled = /*disabled*/ ctx[9];
				input.required = /*required*/ ctx[8];
				input.readOnly = /*readonly*/ ctx[10];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[16][/*placeholder*/ ctx[5]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[6]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[6]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[6]);
				attr(output, "for", output_for_value = "form-field-range-" + /*fieldname*/ ctx[6]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				insert(target, output, anchor);
				append(output, t1);
				insert(target, t2, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t3, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_input_handler*/ ctx[25]),
						listen(input, "input", /*input_change_input_handler*/ ctx[25]),
						listen(input, "change", /*onBlur*/ ctx[17]),
						listen(input, "input", /*onInput*/ ctx[18])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fieldname*/ 64 && input_id_value !== (input_id_value = "form-field-range-" + /*fieldname*/ ctx[6])) {
					attr(input, "id", input_id_value);
				}

				if (dirty[0] & /*validationClasses*/ 2048 && input_class_value !== (input_class_value = "input big-number slider has-output is-fullwidth is-success " + /*validationClasses*/ ctx[11])) {
					attr(input, "class", input_class_value);
				}

				if (dirty[0] & /*fieldname*/ 64) {
					attr(input, "name", /*fieldname*/ ctx[6]);
				}

				if (dirty[0] & /*min*/ 2) {
					attr(input, "min", /*min*/ ctx[1]);
				}

				if (dirty[0] & /*max*/ 4) {
					attr(input, "max", /*max*/ ctx[2]);
				}

				if (dirty[0] & /*step*/ 8) {
					attr(input, "step", /*step*/ ctx[3]);
				}

				if (dirty[0] & /*fieldname*/ 64 && input_list_value !== (input_list_value = "form-field-range-" + /*fieldname*/ ctx[6] + "-tickmarks")) {
					attr(input, "list", input_list_value);
				}

				if (dirty[0] & /*invalid*/ 4096) {
					attr(input, "invalid", /*invalid*/ ctx[12]);
				}

				if (dirty[0] & /*disabled*/ 512) {
					input.disabled = /*disabled*/ ctx[9];
				}

				if (dirty[0] & /*required*/ 256) {
					input.required = /*required*/ ctx[8];
				}

				if (dirty[0] & /*readonly*/ 1024) {
					input.readOnly = /*readonly*/ ctx[10];
				}

				if (dirty[0] & /*$LOCALE, placeholder*/ 65568 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[16][/*placeholder*/ ctx[5]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty[0] & /*fieldname*/ 64) {
					attr(input, "autocomplete", /*fieldname*/ ctx[6]);
				}

				if (dirty[0] & /*fieldname*/ 64 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[6])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty[0] & /*fieldname*/ 64 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[6])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty[0] & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (dirty[0] & /*value*/ 1) set_data(t1, /*value*/ ctx[0]);

				if (dirty[0] & /*fieldname*/ 64 && output_for_value !== (output_for_value = "form-field-range-" + /*fieldname*/ ctx[6])) {
					attr(output, "for", output_for_value);
				}

				if (dirty[0] & /*tickmarks*/ 16) show_if = Array.isArray(/*tickmarks*/ ctx[4]) && /*tickmarks*/ ctx[4].length;

				if (show_if) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_2$h(ctx);
						if_block0.c();
						if_block0.m(t3.parentNode, t3);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*icon*/ ctx[7]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$q(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(output);
					detach(t2);
					detach(t3);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (62:4) {#if readonly}
	function create_if_block$w(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (87:8) {#if Array.isArray(tickmarks) && tickmarks.length}
	function create_if_block_2$h(ctx) {
		let datalist;
		let datalist_id_value;
		let each_value = ensure_array_like(/*tickmarks*/ ctx[4]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
		}

		return {
			c() {
				datalist = element("datalist");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(datalist, "id", datalist_id_value = "form-field-range-" + /*fieldname*/ ctx[6] + "-tickmarks");
			},
			m(target, anchor) {
				insert(target, datalist, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(datalist, null);
					}
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*tickmarks*/ 16) {
					each_value = ensure_array_like(/*tickmarks*/ ctx[4]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$e(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$e(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(datalist, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty[0] & /*fieldname*/ 64 && datalist_id_value !== (datalist_id_value = "form-field-range-" + /*fieldname*/ ctx[6] + "-tickmarks")) {
					attr(datalist, "id", datalist_id_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(datalist);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (89:16) {#each tickmarks as tickmark}
	function create_each_block$e(ctx) {
		let option;
		let option_value_value;
		let option_label_value;

		return {
			c() {
				option = element("option");
				option.__value = option_value_value = /*tickmark*/ ctx[30].value;
				set_input_value(option, option.__value);
				attr(option, "label", option_label_value = /*tickmark*/ ctx[30].label);
			},
			m(target, anchor) {
				insert(target, option, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*tickmarks*/ 16 && option_value_value !== (option_value_value = /*tickmark*/ ctx[30].value)) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}

				if (dirty[0] & /*tickmarks*/ 16 && option_label_value !== (option_label_value = /*tickmark*/ ctx[30].label)) {
					attr(option, "label", option_label_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	// (95:8) {#if icon}
	function create_if_block_1$q(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[7]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*icon*/ 128 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[7])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$L(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[10]) return create_if_block$w;
			return create_else_block$l;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[26](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[27](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[28](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[6]
		};

		if (/*allErrors*/ ctx[14] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[14];
		}

		if (/*showErrors*/ ctx[13] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[13];
		}

		if (/*validationClasses*/ ctx[11] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[11];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[15]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty[0] & /*iconClasses*/ 32768 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[15])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 64) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[6];

				if (!updating_errors && dirty[0] & /*allErrors*/ 16384) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[14];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 8192) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[13];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 2048) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[11];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$L($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(16, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = 10 } = $$props;
		let { min = 0 } = $$props;
		let { max = 100 } = $$props;
		let { step = 1 } = $$props;
		let { tickmarks = false } = $$props;
		let { placeholder = "range placeholder" } = $$props;
		let { fieldname = "range" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur() /*ev*/ {
			let data = { field: fieldname, value };
			$$invalidate(19, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.value
			};

			$$invalidate(19, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_change_input_handler() {
			value = to_number(this.value);
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(14, allErrors), $$invalidate(22, errors)), $$invalidate(23, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(13, showErrors), $$invalidate(21, validated)), $$invalidate(20, valid)), $$invalidate(19, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(11, validationClasses), $$invalidate(20, valid)), $$invalidate(19, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(19, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('min' in $$props) $$invalidate(1, min = $$props.min);
			if ('max' in $$props) $$invalidate(2, max = $$props.max);
			if ('step' in $$props) $$invalidate(3, step = $$props.step);
			if ('tickmarks' in $$props) $$invalidate(4, tickmarks = $$props.tickmarks);
			if ('placeholder' in $$props) $$invalidate(5, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(6, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(7, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(8, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(9, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(10, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(20, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(21, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(22, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(23, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(24, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 128) {
				$$invalidate(15, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 12582912) {
				$$invalidate(14, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 3670016) {
				$$invalidate(13, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 17825792) {
				$$invalidate(12, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 1572864) {
				$$invalidate(11, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			min,
			max,
			step,
			tickmarks,
			placeholder,
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_range extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$L,
				create_fragment$L,
				safe_not_equal,
				{
					inputStarted: 19,
					value: 0,
					min: 1,
					max: 2,
					step: 3,
					tickmarks: 4,
					placeholder: 5,
					fieldname: 6,
					icon: 7,
					required: 8,
					disabled: 9,
					readonly: 10,
					valid: 20,
					validated: 21,
					errors: 22,
					formErrors: 23,
					formLevelError: 24
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.range.logarithmic.svelte generated by Svelte v4.2.19 */

	function get_each_context$d(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[40] = list[i];
		return child_ctx;
	}

	// (110:4) {:else}
	function create_else_block$k(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_list_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let output;
		let t1;
		let output_for_value;
		let t2;
		let show_if = Array.isArray(/*tickmarks*/ ctx[1]) && /*tickmarks*/ ctx[1].length;
		let t3;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = show_if && create_if_block_2$g(ctx);
		let if_block1 = /*icon*/ ctx[4] && create_if_block_1$p(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				output = element("output");
				t1 = text(/*value*/ ctx[0]);
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-range-" + /*fieldname*/ ctx[3]);
				attr(input, "class", input_class_value = "input big-number slider has-output is-fullwidth is-success " + /*validationClasses*/ ctx[9]);
				attr(input, "type", "range");
				attr(input, "name", /*fieldname*/ ctx[3]);
				attr(input, "min", /*posMin*/ ctx[17]);
				attr(input, "max", /*posMax*/ ctx[18]);
				attr(input, "step", /*lStep*/ ctx[19]);
				attr(input, "list", input_list_value = "form-field-range-" + /*fieldname*/ ctx[3] + "-tickmarks");
				attr(input, "invalid", /*invalid*/ ctx[10]);
				input.disabled = /*disabled*/ ctx[6];
				input.required = /*required*/ ctx[5];
				input.readOnly = /*readonly*/ ctx[7];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[2]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[3]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[3]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[3]);
				attr(output, "for", output_for_value = "form-field-range-" + /*fieldname*/ ctx[3]);
				attr(output, "editable", "true");
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*posValue*/ ctx[8]);
				insert(target, t0, anchor);
				insert(target, output, anchor);
				append(output, t1);
				insert(target, t2, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t3, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_input_handler*/ ctx[28]),
						listen(input, "input", /*input_change_input_handler*/ ctx[28]),
						listen(input, "change", /*onBlur*/ ctx[15]),
						listen(input, "input", /*onInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fieldname*/ 8 && input_id_value !== (input_id_value = "form-field-range-" + /*fieldname*/ ctx[3])) {
					attr(input, "id", input_id_value);
				}

				if (dirty[0] & /*validationClasses*/ 512 && input_class_value !== (input_class_value = "input big-number slider has-output is-fullwidth is-success " + /*validationClasses*/ ctx[9])) {
					attr(input, "class", input_class_value);
				}

				if (dirty[0] & /*fieldname*/ 8) {
					attr(input, "name", /*fieldname*/ ctx[3]);
				}

				if (dirty[0] & /*fieldname*/ 8 && input_list_value !== (input_list_value = "form-field-range-" + /*fieldname*/ ctx[3] + "-tickmarks")) {
					attr(input, "list", input_list_value);
				}

				if (dirty[0] & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty[0] & /*disabled*/ 64) {
					input.disabled = /*disabled*/ ctx[6];
				}

				if (dirty[0] & /*required*/ 32) {
					input.required = /*required*/ ctx[5];
				}

				if (dirty[0] & /*readonly*/ 128) {
					input.readOnly = /*readonly*/ ctx[7];
				}

				if (dirty[0] & /*$LOCALE, placeholder*/ 16388 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[14][/*placeholder*/ ctx[2]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty[0] & /*fieldname*/ 8) {
					attr(input, "autocomplete", /*fieldname*/ ctx[3]);
				}

				if (dirty[0] & /*fieldname*/ 8 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[3])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty[0] & /*fieldname*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[3])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty[0] & /*posValue*/ 256) {
					set_input_value(input, /*posValue*/ ctx[8]);
				}

				if (dirty[0] & /*value*/ 1) set_data(t1, /*value*/ ctx[0]);

				if (dirty[0] & /*fieldname*/ 8 && output_for_value !== (output_for_value = "form-field-range-" + /*fieldname*/ ctx[3])) {
					attr(output, "for", output_for_value);
				}

				if (dirty[0] & /*tickmarks*/ 2) show_if = Array.isArray(/*tickmarks*/ ctx[1]) && /*tickmarks*/ ctx[1].length;

				if (show_if) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_2$g(ctx);
						if_block0.c();
						if_block0.m(t3.parentNode, t3);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*icon*/ ctx[4]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$p(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(output);
					detach(t2);
					detach(t3);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (108:4) {#if readonly}
	function create_if_block$v(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (135:8) {#if Array.isArray(tickmarks) && tickmarks.length}
	function create_if_block_2$g(ctx) {
		let datalist;
		let datalist_id_value;
		let each_value = ensure_array_like(/*tickmarks*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
		}

		return {
			c() {
				datalist = element("datalist");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(datalist, "id", datalist_id_value = "form-field-range-" + /*fieldname*/ ctx[3] + "-tickmarks");
			},
			m(target, anchor) {
				insert(target, datalist, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(datalist, null);
					}
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*tickmarks*/ 2) {
					each_value = ensure_array_like(/*tickmarks*/ ctx[1]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$d(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$d(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(datalist, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty[0] & /*fieldname*/ 8 && datalist_id_value !== (datalist_id_value = "form-field-range-" + /*fieldname*/ ctx[3] + "-tickmarks")) {
					attr(datalist, "id", datalist_id_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(datalist);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (137:16) {#each tickmarks as tickmark}
	function create_each_block$d(ctx) {
		let option;
		let option_value_value;
		let option_label_value;

		return {
			c() {
				option = element("option");
				option.__value = option_value_value = /*tickmark*/ ctx[40].value;
				set_input_value(option, option.__value);
				attr(option, "label", option_label_value = /*tickmark*/ ctx[40].label);
			},
			m(target, anchor) {
				insert(target, option, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*tickmarks*/ 2 && option_value_value !== (option_value_value = /*tickmark*/ ctx[40].value)) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}

				if (dirty[0] & /*tickmarks*/ 2 && option_label_value !== (option_label_value = /*tickmark*/ ctx[40].label)) {
					attr(option, "label", option_label_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	// (143:8) {#if icon}
	function create_if_block_1$p(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[4]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[4])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$K(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[7]) return create_if_block$v;
			return create_else_block$k;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[29](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[30](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[31](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[3]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty[0] & /*iconClasses*/ 8192 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[13])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 8) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[3];

				if (!updating_errors && dirty[0] & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$K($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(14, $LOCALE = $$value));
		const MAX = Number.MAX_SAFE_INTEGER;
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = 10 } = $$props;
		let { min = 0 } = $$props;
		let { max = 100 } = $$props;
		let { tickmarks = false } = $$props;
		let { placeholder = "range placeholder" } = $$props;
		let { fieldname = "range" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			const val = getLogarithmicValue(ev.currentTarget.value);
			$$invalidate(0, value = val);
			let data = { field: fieldname, value };
			$$invalidate(20, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			const val = getLogarithmicValue(Math.round(parseInt(ev.currentTarget.value)));
			$$invalidate(0, value = val);
			let data = { field: fieldname, value };
			$$invalidate(20, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		let posMin = 0,
			posMax = 100,
			lMin = 0,
			lMax = 100,
			lScale = 10,
			lStep = 0.01,
			posValue = 1;

		function updateRange() {
			lMin = Math.log(min || 1);
			lMax = Math.log(max || MAX);
			lScale = (lMax - lMin) / (posMax - posMin);

			if (value > max) {
				$$invalidate(0, value = max);
			} else if (value < min) {
				$$invalidate(0, value = min);
			} else {
				$$invalidate(0, value);
			}
		}

		onMount(() => {
			updateRange();
		});

		function getLogarithmicValue(pos) {
			pos = parseInt(pos);
			return Math.round(Math.exp((pos - posMin) * lScale + lMin));
		}

		function input_change_input_handler() {
			posValue = to_number(this.value);
			$$invalidate(8, posValue);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(25, errors)), $$invalidate(26, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(24, validated)), $$invalidate(23, valid)), $$invalidate(20, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(23, valid)), $$invalidate(20, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(20, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('min' in $$props) $$invalidate(21, min = $$props.min);
			if ('max' in $$props) $$invalidate(22, max = $$props.max);
			if ('tickmarks' in $$props) $$invalidate(1, tickmarks = $$props.tickmarks);
			if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(3, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(6, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(7, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(23, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(24, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(25, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(26, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(27, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*icon*/ 16) {
				$$invalidate(13, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 100663296) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 26214400) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 142606336) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 9437184) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}

			if ($$self.$$.dirty[0] & /*min, max*/ 6291456) {
				{
					(updateRange());
				}
			}
		};

		return [
			value,
			tickmarks,
			placeholder,
			fieldname,
			icon,
			required,
			disabled,
			readonly,
			posValue,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			posMin,
			posMax,
			lStep,
			inputStarted,
			min,
			max,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_range_logarithmic extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$K,
				create_fragment$K,
				safe_not_equal,
				{
					inputStarted: 20,
					value: 0,
					min: 21,
					max: 22,
					tickmarks: 1,
					placeholder: 2,
					fieldname: 3,
					icon: 4,
					required: 5,
					disabled: 6,
					readonly: 7,
					valid: 23,
					validated: 24,
					errors: 25,
					formErrors: 26,
					formLevelError: 27
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.select.from.model.svelte generated by Svelte v4.2.19 */

	function create_fragment$J(ctx) {
		let uiselect;
		let updating_variants;
		let current;

		function uiselect_variants_binding(value) {
			/*uiselect_variants_binding*/ ctx[27](value);
		}

		let uiselect_props = {
			inputStarted: /*inputStarted*/ ctx[1],
			value: /*value*/ ctx[2],
			placeholder: /*placeholder*/ ctx[3],
			emptyValueTitle: /*emptyValueTitle*/ ctx[4],
			fieldname: /*fieldname*/ ctx[5],
			icon: /*icon*/ ctx[6],
			required: /*required*/ ctx[7],
			readonly: /*readonly*/ ctx[8],
			disabled: /*disabled*/ ctx[16],
			multiple: /*multiple*/ ctx[9],
			size: /*size*/ ctx[10],
			valid: /*valid*/ ctx[11],
			validated: /*validated*/ ctx[12],
			errors: /*errors*/ ctx[0],
			formErrors: /*formErrors*/ ctx[13],
			formLevelError: /*formLevelError*/ ctx[14]
		};

		if (/*variants*/ ctx[15] !== void 0) {
			uiselect_props.variants = /*variants*/ ctx[15];
		}

		uiselect = new Ui_select({ props: uiselect_props });
		binding_callbacks.push(() => bind(uiselect, 'variants', uiselect_variants_binding));
		uiselect.$on("change", /*onChange*/ ctx[17]);

		return {
			c() {
				create_component(uiselect.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiselect, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uiselect_changes = {};
				if (dirty & /*inputStarted*/ 2) uiselect_changes.inputStarted = /*inputStarted*/ ctx[1];
				if (dirty & /*value*/ 4) uiselect_changes.value = /*value*/ ctx[2];
				if (dirty & /*placeholder*/ 8) uiselect_changes.placeholder = /*placeholder*/ ctx[3];
				if (dirty & /*emptyValueTitle*/ 16) uiselect_changes.emptyValueTitle = /*emptyValueTitle*/ ctx[4];
				if (dirty & /*fieldname*/ 32) uiselect_changes.fieldname = /*fieldname*/ ctx[5];
				if (dirty & /*icon*/ 64) uiselect_changes.icon = /*icon*/ ctx[6];
				if (dirty & /*required*/ 128) uiselect_changes.required = /*required*/ ctx[7];
				if (dirty & /*readonly*/ 256) uiselect_changes.readonly = /*readonly*/ ctx[8];
				if (dirty & /*disabled*/ 65536) uiselect_changes.disabled = /*disabled*/ ctx[16];
				if (dirty & /*multiple*/ 512) uiselect_changes.multiple = /*multiple*/ ctx[9];
				if (dirty & /*size*/ 1024) uiselect_changes.size = /*size*/ ctx[10];
				if (dirty & /*valid*/ 2048) uiselect_changes.valid = /*valid*/ ctx[11];
				if (dirty & /*validated*/ 4096) uiselect_changes.validated = /*validated*/ ctx[12];
				if (dirty & /*errors*/ 1) uiselect_changes.errors = /*errors*/ ctx[0];
				if (dirty & /*formErrors*/ 8192) uiselect_changes.formErrors = /*formErrors*/ ctx[13];
				if (dirty & /*formLevelError*/ 16384) uiselect_changes.formLevelError = /*formLevelError*/ ctx[14];

				if (!updating_variants && dirty & /*variants*/ 32768) {
					updating_variants = true;
					uiselect_changes.variants = /*variants*/ ctx[15];
					add_flush_callback(() => updating_variants = false);
				}

				uiselect.$set(uiselect_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiselect.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiselect.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiselect, detaching);
			}
		};
	}

	let loaded = false;

	function instance$J($$self, $$props, $$invalidate) {
		let disabled;
		const dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value } = $$props;
		let { placeholder = "empty select item" } = $$props;
		let { emptyValueTitle = "" } = $$props;
		let { fieldname = "selectFromModel" } = $$props;
		let { modelName = "" } = $$props;
		let { actionName = "" } = $$props;
		let { actionFilter = {} } = $$props;
		let { actionSorter = {} } = $$props;
		let { actionPager = {} } = $$props;
		let { actionSearch = undefined } = $$props;
		let { optionId = ":_id" } = $$props;
		let { optionTitle = ":title" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { multiple = false } = $$props;
		let { size = 8 } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let { returnVariant = false } = $$props;

		function argumentsSetProvided() {
			return modelName && actionName && actionFilter;
		}

		let variants = [];

		onMount(async () => {
			if (argumentsSetProvided()) {
				const notApp = notCommon$3.getApp();
				const Model = notApp.getModel(modelName).setFilter(actionFilter).setSorter(actionSorter).setPager(actionPager).setSearch(actionSearch);
				const response = await Model[`$` + actionName]();

				if (response.status === DEFAULT_STATUS_SUCCESS) {
					const result = response.result;

					$$invalidate(15, variants = result.map(item => {
						return {
							id: notPath$1.get(optionId, item),
							title: notPath$1.get(optionTitle, item)
						};
					}));
				} else {
					$$invalidate(0, errors = result.errors || [result.message]);
				}
			}
		});

		function onChange(e) {
			if (returnVariant) {
				dispatch("change", {
					...e.detail,
					value: variants.find(itm => itm.id === e.detail.value)
				});
			} else {
				dispatch("change", e.detail);
			}
		}

		function uiselect_variants_binding(value) {
			variants = value;
			$$invalidate(15, variants);
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(1, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(2, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(3, placeholder = $$props.placeholder);
			if ('emptyValueTitle' in $$props) $$invalidate(4, emptyValueTitle = $$props.emptyValueTitle);
			if ('fieldname' in $$props) $$invalidate(5, fieldname = $$props.fieldname);
			if ('modelName' in $$props) $$invalidate(18, modelName = $$props.modelName);
			if ('actionName' in $$props) $$invalidate(19, actionName = $$props.actionName);
			if ('actionFilter' in $$props) $$invalidate(20, actionFilter = $$props.actionFilter);
			if ('actionSorter' in $$props) $$invalidate(21, actionSorter = $$props.actionSorter);
			if ('actionPager' in $$props) $$invalidate(22, actionPager = $$props.actionPager);
			if ('actionSearch' in $$props) $$invalidate(23, actionSearch = $$props.actionSearch);
			if ('optionId' in $$props) $$invalidate(24, optionId = $$props.optionId);
			if ('optionTitle' in $$props) $$invalidate(25, optionTitle = $$props.optionTitle);
			if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(7, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(8, readonly = $$props.readonly);
			if ('multiple' in $$props) $$invalidate(9, multiple = $$props.multiple);
			if ('size' in $$props) $$invalidate(10, size = $$props.size);
			if ('valid' in $$props) $$invalidate(11, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(12, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(0, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(13, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(14, formLevelError = $$props.formLevelError);
			if ('returnVariant' in $$props) $$invalidate(26, returnVariant = $$props.returnVariant);
		};

		$$invalidate(16, disabled = !loaded);

		return [
			errors,
			inputStarted,
			value,
			placeholder,
			emptyValueTitle,
			fieldname,
			icon,
			required,
			readonly,
			multiple,
			size,
			valid,
			validated,
			formErrors,
			formLevelError,
			variants,
			disabled,
			onChange,
			modelName,
			actionName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch,
			optionId,
			optionTitle,
			returnVariant,
			uiselect_variants_binding
		];
	}

	class Ui_select_from_model extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$J, create_fragment$J, safe_not_equal, {
				inputStarted: 1,
				value: 2,
				placeholder: 3,
				emptyValueTitle: 4,
				fieldname: 5,
				modelName: 18,
				actionName: 19,
				actionFilter: 20,
				actionSorter: 21,
				actionPager: 22,
				actionSearch: 23,
				optionId: 24,
				optionTitle: 25,
				icon: 6,
				required: 7,
				readonly: 8,
				multiple: 9,
				size: 10,
				valid: 11,
				validated: 12,
				errors: 0,
				formErrors: 13,
				formLevelError: 14,
				returnVariant: 26
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.switch.svelte generated by Svelte v4.2.19 */

	function create_else_block_1$4(ctx) {
		let t0;
		let input;
		let input_class_value;
		let input_id_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t1;
		let label_1;
		let label_1_for_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = !/*label*/ ctx[1] && create_if_block_4$9();
		let if_block1 = !/*hideLabel*/ ctx[2] && create_if_block_2$f(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				input = element("input");
				t1 = space();
				label_1 = element("label");
				if (if_block1) if_block1.c();
				attr(input, "type", "checkbox");
				attr(input, "class", input_class_value = "switch " + /*styling*/ ctx[8]);
				attr(input, "id", input_id_value = "form-field-switch-" + /*fieldname*/ ctx[4]);
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[3]]);
				attr(input, "name", /*fieldname*/ ctx[4]);
				input.disabled = /*disabled*/ ctx[7];
				input.required = /*required*/ ctx[5];
				input.readOnly = /*readonly*/ ctx[6];
				attr(input, "invalid", /*invalid*/ ctx[10]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[4]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[4]);
				attr(label_1, "class", "label");
				attr(label_1, "for", label_1_for_value = "form-field-switch-" + /*fieldname*/ ctx[4]);
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				insert(target, input, anchor);
				input.checked = /*value*/ ctx[0];
				insert(target, t1, anchor);
				insert(target, label_1, anchor);
				if (if_block1) if_block1.m(label_1, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[23]),
						listen(input, "blur", /*onBlur*/ ctx[14]),
						listen(input, "input", /*onInput*/ ctx[15])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (!/*label*/ ctx[1]) {
					if (if_block0) {
						if (dirty & /*label*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_4$9();
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*styling*/ 256 && input_class_value !== (input_class_value = "switch " + /*styling*/ ctx[8])) {
					attr(input, "class", input_class_value);
				}

				if (!current || dirty & /*fieldname*/ 16 && input_id_value !== (input_id_value = "form-field-switch-" + /*fieldname*/ ctx[4])) {
					attr(input, "id", input_id_value);
				}

				if (!current || dirty & /*$LOCALE, placeholder*/ 8200 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[3]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (!current || dirty & /*fieldname*/ 16) {
					attr(input, "name", /*fieldname*/ ctx[4]);
				}

				if (!current || dirty & /*disabled*/ 128) {
					input.disabled = /*disabled*/ ctx[7];
				}

				if (!current || dirty & /*required*/ 32) {
					input.required = /*required*/ ctx[5];
				}

				if (!current || dirty & /*readonly*/ 64) {
					input.readOnly = /*readonly*/ ctx[6];
				}

				if (!current || dirty & /*invalid*/ 1024) {
					attr(input, "invalid", /*invalid*/ ctx[10]);
				}

				if (!current || dirty & /*fieldname*/ 16 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[4])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (!current || dirty & /*fieldname*/ 16 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[4])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					input.checked = /*value*/ ctx[0];
				}

				if (!/*hideLabel*/ ctx[2]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*hideLabel*/ 4) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$f(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(label_1, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*fieldname*/ 16 && label_1_for_value !== (label_1_for_value = "form-field-switch-" + /*fieldname*/ ctx[4])) {
					attr(label_1, "for", label_1_for_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(input);
					detach(t1);
					detach(label_1);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (67:4) {#if readonly}
	function create_if_block$u(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_1$o, create_else_block$j];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*value*/ ctx[0]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (74:8) {#if !label}
	function create_if_block_4$9(ctx) {
		let uibooleans;
		let current;
		uibooleans = new Ui_booleans({ props: { values: [{ value: false }] } });

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	// (94:12) {#if !hideLabel}
	function create_if_block_2$f(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_3$d, create_else_block_2$3];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*label*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (97:16) {:else}
	function create_else_block_2$3(ctx) {
		let uibooleans;
		let current;
		uibooleans = new Ui_booleans({ props: { values: [{ value: true }] } });

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			p: noop$1,
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	// (95:16) {#if label}
	function create_if_block_3$d(ctx) {
		let t_value = /*$LOCALE*/ ctx[13][/*label*/ ctx[1]] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, label*/ 8194 && t_value !== (t_value = /*$LOCALE*/ ctx[13][/*label*/ ctx[1]] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (70:8) {:else}
	function create_else_block$j(ctx) {
		let uibooleans;
		let current;
		uibooleans = new Ui_booleans({ props: { values: [{ value: false }] } });

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	// (68:8) {#if value}
	function create_if_block_1$o(ctx) {
		let uibooleans;
		let current;
		uibooleans = new Ui_booleans({ props: { values: [{ value: true }] } });

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	function create_fragment$I(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		const if_block_creators = [create_if_block$u, create_else_block_1$4];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[24](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[25](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[26](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[4]
		};

		if (/*allErrors*/ ctx[12] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[12];
		}

		if (/*showErrors*/ ctx[11] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[11];
		}

		if (/*validationClasses*/ ctx[9] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[9];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", "control");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 16) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[4];

				if (!updating_errors && dirty & /*allErrors*/ 4096) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[12];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 2048) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[11];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 512) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[9];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$I($$self, $$props, $$invalidate) {
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = false } = $$props;
		let { label = "" } = $$props;
		let { hideLabel = false } = $$props;
		let { placeholder = "input some text here, please" } = $$props;
		let { fieldname = "textfield" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { styling = " is-rounded is-success " } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.type === "checkbox"
				? ev.currentTarget.checked
				: value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname,
				value: ev.currentTarget.type === "checkbox"
				? ev.currentTarget.checked
				: value
			};

			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function input_change_handler() {
			value = this.checked;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(12, allErrors), $$invalidate(20, errors)), $$invalidate(21, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(11, showErrors), $$invalidate(19, validated)), $$invalidate(18, valid)), $$invalidate(16, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(9, validationClasses), $$invalidate(18, valid)), $$invalidate(16, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(16, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
			if ('hideLabel' in $$props) $$invalidate(2, hideLabel = $$props.hideLabel);
			if ('placeholder' in $$props) $$invalidate(3, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(4, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(17, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(18, valid = $$props.valid);
			if ('styling' in $$props) $$invalidate(8, styling = $$props.styling);
			if ('validated' in $$props) $$invalidate(19, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(20, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(21, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(22, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 131072) ;

			if ($$self.$$.dirty & /*errors, formErrors*/ 3145728) {
				$$invalidate(12, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 851968) {
				$$invalidate(11, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 4456448) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 327680) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			label,
			hideLabel,
			placeholder,
			fieldname,
			required,
			readonly,
			disabled,
			styling,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			icon,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			input_change_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	let Ui_switch$1 = class Ui_switch extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$I, create_fragment$I, safe_not_equal, {
				inputStarted: 16,
				value: 0,
				label: 1,
				hideLabel: 2,
				placeholder: 3,
				fieldname: 4,
				icon: 17,
				required: 5,
				readonly: 6,
				disabled: 7,
				valid: 18,
				styling: 8,
				validated: 19,
				errors: 20,
				formErrors: 21,
				formLevelError: 22
			});
		}
	};

	/* node_modules/not-bulma/src/elements/form/ui.tag.select.svelte generated by Svelte v4.2.19 */

	function get_each_context$c(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		return child_ctx;
	}

	function get_each_context_1$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[33] = list[i];
		return child_ctx;
	}

	// (126:16) {#if !readonly}
	function create_if_block_1$n(ctx) {
		let button;
		let button_data_id_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				attr(button, "data-id", button_data_id_value = /*item*/ ctx[33].id);
				attr(button, "class", "delete is-small");
			},
			m(target, anchor) {
				insert(target, button, anchor);

				if (!mounted) {
					dispose = listen(button, "click", /*remove*/ ctx[8]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*items*/ 64 && button_data_id_value !== (button_data_id_value = /*item*/ ctx[33].id)) {
					attr(button, "data-id", button_data_id_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (123:8) {#each items as item (item.id)}
	function create_each_block_1$4(key_1, ctx) {
		let span;
		let t0_value = /*$LOCALE*/ ctx[7][/*item*/ ctx[33].title] + "";
		let t0;
		let t1;
		let t2;
		let span_class_value;
		let if_block = !/*readonly*/ ctx[2] && create_if_block_1$n(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				if (if_block) if_block.c();
				t2 = space();
				attr(span, "class", span_class_value = "mx-1 tag is-" + /*item*/ ctx[33].type);
				this.first = span;
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t0);
				append(span, t1);
				if (if_block) if_block.m(span, null);
				append(span, t2);
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty[0] & /*$LOCALE, items*/ 192 && t0_value !== (t0_value = /*$LOCALE*/ ctx[7][/*item*/ ctx[33].title] + "")) set_data(t0, t0_value);

				if (!/*readonly*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$n(ctx);
						if_block.c();
						if_block.m(span, t2);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty[0] & /*items*/ 64 && span_class_value !== (span_class_value = "mx-1 tag is-" + /*item*/ ctx[33].type)) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (136:4) {#if !readonly}
	function create_if_block$t(ctx) {
		let div2;
		let div1;
		let div0;
		let select;
		let option;
		let t0_value = /*$LOCALE*/ ctx[7][LC_SELECT_FROM_LIST] + "";
		let t0;
		let t1;
		let button;
		let t2_value = /*$LOCALE*/ ctx[7][LC_ADD] + "";
		let t2;
		let mounted;
		let dispose;
		let each_value = ensure_array_like(/*variants*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
		}

		return {
			c() {
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				select = element("select");
				option = element("option");
				t0 = text(t0_value);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t1 = space();
				button = element("button");
				t2 = text(t2_value);
				option.__value = "-1";
				set_input_value(option, option.__value);
				option.selected = true;
				attr(div0, "class", "select is-small");
				attr(button, "class", "button is-primary is-small");
				attr(div1, "class", "control");
				attr(div2, "class", "column");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				append(div1, div0);
				append(div0, select);
				append(select, option);
				append(option, t0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(select, null);
					}
				}

				append(div1, t1);
				append(div1, button);
				append(button, t2);

				if (!mounted) {
					dispose = listen(button, "click", /*add*/ ctx[9]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE*/ 128 && t0_value !== (t0_value = /*$LOCALE*/ ctx[7][LC_SELECT_FROM_LIST] + "")) set_data(t0, t0_value);

				if (dirty[0] & /*variants, $LOCALE*/ 129) {
					each_value = ensure_array_like(/*variants*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$c(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$c(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(select, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty[0] & /*$LOCALE*/ 128 && t2_value !== (t2_value = /*$LOCALE*/ ctx[7][LC_ADD] + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				destroy_each(each_blocks, detaching);
				mounted = false;
				dispose();
			}
		};
	}

	// (144:24) {#each variants as variant}
	function create_each_block$c(ctx) {
		let option;
		let t_value = /*$LOCALE*/ ctx[7][/*variant*/ ctx[30].title] + "";
		let t;
		let option_value_value;

		return {
			c() {
				option = element("option");
				t = text(t_value);
				option.__value = option_value_value = /*variant*/ ctx[30].id;
				set_input_value(option, option.__value);
			},
			m(target, anchor) {
				insert(target, option, anchor);
				append(option, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, variants*/ 129 && t_value !== (t_value = /*$LOCALE*/ ctx[7][/*variant*/ ctx[30].title] + "")) set_data(t, t_value);

				if (dirty[0] & /*variants*/ 1 && option_value_value !== (option_value_value = /*variant*/ ctx[30].id)) {
					option.__value = option_value_value;
					set_input_value(option, option.__value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	function create_fragment$H(ctx) {
		let div1;
		let div0;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div0_class_value;
		let t0;
		let t1;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;
		let each_value_1 = ensure_array_like(/*items*/ ctx[6]);
		const get_key = ctx => /*item*/ ctx[33].id;

		for (let i = 0; i < each_value_1.length; i += 1) {
			let child_ctx = get_each_context_1$4(ctx, each_value_1, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block_1$4(key, child_ctx));
		}

		let if_block = !/*readonly*/ ctx[2] && create_if_block$t(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[1]
		};

		if (/*allErrors*/ ctx[5] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[5];
		}

		if (/*showErrors*/ ctx[4] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[4];
		}

		if (/*validationClasses*/ ctx[3] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[3];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div1 = element("div");
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t0 = space();
				if (if_block) if_block.c();
				t1 = space();
				create_component(errorslist.$$.fragment);
				attr(div0, "class", div0_class_value = "column " + /*validationClasses*/ ctx[3]);
				attr(div1, "class", "control columns");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				append(div1, t0);
				if (if_block) if_block.m(div1, null);
				insert(target, t1, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*items, remove, readonly, $LOCALE*/ 452) {
					each_value_1 = ensure_array_like(/*items*/ ctx[6]);
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div0, destroy_block, create_each_block_1$4, null, get_each_context_1$4);
				}

				if (!current || dirty[0] & /*validationClasses*/ 8 && div0_class_value !== (div0_class_value = "column " + /*validationClasses*/ ctx[3])) {
					attr(div0, "class", div0_class_value);
				}

				if (!/*readonly*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$t(ctx);
						if_block.c();
						if_block.m(div1, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				const errorslist_changes = {};
				if (dirty[0] & /*fieldname*/ 2) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[1];

				if (!updating_errors && dirty[0] & /*allErrors*/ 32) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[5];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty[0] & /*showErrors*/ 16) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[4];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty[0] & /*validationClasses*/ 8) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[3];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
					detach(t1);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}

				if (if_block) if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	const LC_ADD = "not-node:add_label";
	const LC_SELECT_FROM_LIST = "not-node:select_from_list_label";

	function instance$H($$self, $$props, $$invalidate) {
		let items;
		let allErrors;
		let showErrors;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(7, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { value = [] } = $$props;
		let { inputStarted = false } = $$props;
		let { variants = [] } = $$props;
		let { fieldname = "tag" } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		onMount(() => {
			clearValueFromDeadVariants();
		});

		let { beforeAdd = () => /*variant, variants*/
		{
			return true;
		} } = $$props;

		let { getItemId = variant => {
			return variant.id;
		} } = $$props;

		let { getItemTitle = variant => {
			return variant.title;
		} } = $$props;

		let { getItemType = variant => {
			return "info";
		} } = $$props;

		let { buildItem = variant => {
			return {
				id: getItemId(variant),
				title: getItemTitle(variant),
				type: getItemType(variant)
			};
		} } = $$props;

		function variantIdToVariant(id) {
			return variants.find(variant => getItemId(variant) === id);
		}

		function changeEvent() {
			let data = { field: fieldname, value };
			dispatch("change", data);
		}

		function remove(e) {
			e && e.preventDefault();
			let id = e.currentTarget.dataset.id;

			if (value.includes(id)) {
				value.splice(value.indexOf(id), 1);
				$$invalidate(10, value);
				changeEvent();
			}

			return false;
		}

		function add(e) {
			e && e.preventDefault();
			let id = e.currentTarget.parentNode.querySelector("select").value;
			const variant = variantIdToVariant(id);

			if (!variant) {
				return false;
			}

			if (!beforeAdd(variant, variants)) {
				return false;
			}

			if (id && value.indexOf(id) === -1) {
				value.push(id);
				$$invalidate(10, value);
				changeEvent();
			}

			return false;
		}

		function clearValueFromDeadVariants() {
			$$invalidate(10, value = value.filter(id => {
				return variantIdToVariant(id);
			}));

			return value;
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(5, allErrors), $$invalidate(14, errors)), $$invalidate(15, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(4, showErrors), $$invalidate(13, validated)), $$invalidate(12, valid)), $$invalidate(11, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(3, validationClasses), $$invalidate(12, valid)), $$invalidate(11, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(10, value = $$props.value);
			if ('inputStarted' in $$props) $$invalidate(11, inputStarted = $$props.inputStarted);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('fieldname' in $$props) $$invalidate(1, fieldname = $$props.fieldname);
			if ('readonly' in $$props) $$invalidate(2, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(12, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(13, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(14, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(15, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(16, formLevelError = $$props.formLevelError);
			if ('beforeAdd' in $$props) $$invalidate(17, beforeAdd = $$props.beforeAdd);
			if ('getItemId' in $$props) $$invalidate(18, getItemId = $$props.getItemId);
			if ('getItemTitle' in $$props) $$invalidate(19, getItemTitle = $$props.getItemTitle);
			if ('getItemType' in $$props) $$invalidate(20, getItemType = $$props.getItemType);
			if ('buildItem' in $$props) $$invalidate(21, buildItem = $$props.buildItem);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*value, buildItem*/ 2098176) {
				/*
	item = {
	  id,        //unique
	  title,     //some text
	  type       //for coloring items, usual html template names danger, success, etc
	}
	*/
				$$invalidate(6, items = value.map(variantIdToVariant).filter(variant => variant).map(buildItem));
			}

			if ($$self.$$.dirty[0] & /*errors, formErrors*/ 49152) {
				$$invalidate(5, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty[0] & /*validated, valid, inputStarted*/ 14336) {
				$$invalidate(4, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty[0] & /*valid, formLevelError*/ 69632) ;

			if ($$self.$$.dirty[0] & /*valid, inputStarted*/ 6144) {
				$$invalidate(3, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			variants,
			fieldname,
			readonly,
			validationClasses,
			showErrors,
			allErrors,
			items,
			$LOCALE,
			remove,
			add,
			value,
			inputStarted,
			valid,
			validated,
			errors,
			formErrors,
			formLevelError,
			beforeAdd,
			getItemId,
			getItemTitle,
			getItemType,
			buildItem,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_tag_select extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$H,
				create_fragment$H,
				safe_not_equal,
				{
					value: 10,
					inputStarted: 11,
					variants: 0,
					fieldname: 1,
					readonly: 2,
					valid: 12,
					validated: 13,
					errors: 14,
					formErrors: 15,
					formLevelError: 16,
					beforeAdd: 17,
					getItemId: 18,
					getItemTitle: 19,
					getItemType: 20,
					buildItem: 21
				},
				null,
				[-1, -1]
			);
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.telephone.svelte generated by Svelte v4.2.19 */

	function create_else_block$i(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let input_placeholder_value;
		let input_aria_controls_value;
		let input_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4$8(ctx);
		let if_block1 = /*validated*/ ctx[7] === true && create_if_block_1$m(ctx);

		return {
			c() {
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", input_id_value = "form-field-telephone-" + /*fieldname*/ ctx[2]);
				attr(input, "class", input_class_value = "input " + /*validationClasses*/ ctx[8]);
				attr(input, "type", "tel");
				attr(input, "name", /*fieldname*/ ctx[2]);
				attr(input, "invalid", /*invalid*/ ctx[9]);
				input.required = /*required*/ ctx[4];
				input.readOnly = /*readonly*/ ctx[5];
				attr(input, "placeholder", input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]]);
				attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				attr(input, "aria-controls", input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(input, "aria-describedby", input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				set_input_value(input, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[20]),
						listen(input, "change", /*onBlur*/ ctx[14]),
						listen(input, "input", /*onInput*/ ctx[15])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 4 && input_id_value !== (input_id_value = "form-field-telephone-" + /*fieldname*/ ctx[2])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*validationClasses*/ 256 && input_class_value !== (input_class_value = "input " + /*validationClasses*/ ctx[8])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*invalid*/ 512) {
					attr(input, "invalid", /*invalid*/ ctx[9]);
				}

				if (dirty & /*required*/ 16) {
					input.required = /*required*/ ctx[4];
				}

				if (dirty & /*readonly*/ 32) {
					input.readOnly = /*readonly*/ ctx[5];
				}

				if (dirty & /*$LOCALE, placeholder*/ 8194 && input_placeholder_value !== (input_placeholder_value = /*$LOCALE*/ ctx[13][/*placeholder*/ ctx[1]])) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "autocomplete", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_controls_value !== (input_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-controls", input_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(input, "aria-describedby", input_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(input, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$8(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[7] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$m(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (61:4) {#if readonly}
	function create_if_block$s(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (80:8) {#if icon}
	function create_if_block_4$8(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (85:8) {#if validated === true}
	function create_if_block_1$m(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[6] === true) return create_if_block_2$e;
			if (/*valid*/ ctx[6] === false) return create_if_block_3$c;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (89:42) 
	function create_if_block_3$c(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (87:16) {#if valid === true}
	function create_if_block_2$e(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$G(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[5]) return create_if_block$s;
			return create_else_block$i;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[21](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[22](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[23](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[11] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[11];
		}

		if (/*showErrors*/ ctx[10] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[10];
		}

		if (/*validationClasses*/ ctx[8] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[8];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[12]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 4096 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[12])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 2048) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[11];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 1024) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[10];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 256) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[8];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$G($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(13, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "+7 (987) 654-32-10" } = $$props;
		let { fieldname = "telephone" } = $$props;
		let { icon = false } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			ev.preventDefault();
			let val = UICommon$1.formatPhone(ev.currentTarget.value);
			let data = { field: fieldname, value: val };
			$$invalidate(0, value = val);
			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return false;
		}

		function onInput(ev) {
			ev.preventDefault();
			let val = UICommon$1.formatPhone(ev.currentTarget.value);
			let data = { field: fieldname, value: val };
			$$invalidate(0, value = val);
			$$invalidate(16, inputStarted = true);
			dispatch("change", data);
			return false;
		}

		function input_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(11, allErrors), $$invalidate(17, errors)), $$invalidate(18, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(10, showErrors), $$invalidate(7, validated)), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(8, validationClasses), $$invalidate(6, valid)), $$invalidate(16, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(16, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(7, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(17, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(18, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(19, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(12, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 393216) {
				$$invalidate(11, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 65728) {
				$$invalidate(10, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 524352) {
				$$invalidate(9, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 65600) {
				$$invalidate(8, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			required,
			readonly,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			onInput,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			input_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_telephone extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$G, create_fragment$G, safe_not_equal, {
				inputStarted: 16,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				required: 4,
				readonly: 5,
				valid: 6,
				validated: 7,
				errors: 17,
				formErrors: 18,
				formLevelError: 19
			});
		}
	}

	/* node_modules/not-bulma/src/elements/form/ui.textarea.svelte generated by Svelte v4.2.19 */

	function create_else_block$h(ctx) {
		let textarea;
		let textarea_id_value;
		let textarea_class_value;
		let textarea_placeholder_value;
		let textarea_aria_controls_value;
		let textarea_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4$7(ctx);
		let if_block1 = /*validated*/ ctx[9] === true && create_if_block_1$l(ctx);

		return {
			c() {
				textarea = element("textarea");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(textarea, "id", textarea_id_value = "form-field-textarea-" + /*fieldname*/ ctx[2]);
				attr(textarea, "invalid", /*invalid*/ ctx[11]);
				textarea.disabled = /*disabled*/ ctx[7];
				textarea.required = /*required*/ ctx[5];
				textarea.readOnly = /*readonly*/ ctx[6];
				attr(textarea, "class", textarea_class_value = "textarea " + /*validationClasses*/ ctx[10]);
				attr(textarea, "name", /*fieldname*/ ctx[2]);
				attr(textarea, "placeholder", textarea_placeholder_value = /*$LOCALE*/ ctx[15][/*placeholder*/ ctx[1]]);
				attr(textarea, "rows", /*rows*/ ctx[4]);
				attr(textarea, "aria-controls", textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(textarea, "aria-describedby", textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, textarea, anchor);
				set_input_value(textarea, /*value*/ ctx[0]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(textarea, "blur", /*onBlur*/ ctx[16]),
						listen(textarea, "input", /*textarea_input_handler*/ ctx[21])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 4 && textarea_id_value !== (textarea_id_value = "form-field-textarea-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "id", textarea_id_value);
				}

				if (dirty & /*invalid*/ 2048) {
					attr(textarea, "invalid", /*invalid*/ ctx[11]);
				}

				if (dirty & /*disabled*/ 128) {
					textarea.disabled = /*disabled*/ ctx[7];
				}

				if (dirty & /*required*/ 32) {
					textarea.required = /*required*/ ctx[5];
				}

				if (dirty & /*readonly*/ 64) {
					textarea.readOnly = /*readonly*/ ctx[6];
				}

				if (dirty & /*validationClasses*/ 1024 && textarea_class_value !== (textarea_class_value = "textarea " + /*validationClasses*/ ctx[10])) {
					attr(textarea, "class", textarea_class_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(textarea, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*$LOCALE, placeholder*/ 32770 && textarea_placeholder_value !== (textarea_placeholder_value = /*$LOCALE*/ ctx[15][/*placeholder*/ ctx[1]])) {
					attr(textarea, "placeholder", textarea_placeholder_value);
				}

				if (dirty & /*rows*/ 16) {
					attr(textarea, "rows", /*rows*/ ctx[4]);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_controls_value !== (textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-controls", textarea_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_describedby_value !== (textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-describedby", textarea_aria_describedby_value);
				}

				if (dirty & /*value*/ 1) {
					set_input_value(textarea, /*value*/ ctx[0]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$7(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[9] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$l(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(textarea);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (60:4) {#if readonly}
	function create_if_block$r(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*value*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (78:8) {#if icon}
	function create_if_block_4$7(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (83:8) {#if validated === true}
	function create_if_block_1$l(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[8] === true) return create_if_block_2$d;
			if (/*valid*/ ctx[8] === false) return create_if_block_3$b;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (87:42) 
	function create_if_block_3$b(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (85:16) {#if valid === true}
	function create_if_block_2$d(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment$F(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return create_if_block$r;
			return create_else_block$h;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[22](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[23](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[24](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[13] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[13];
		}

		if (/*showErrors*/ ctx[12] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[12];
		}

		if (/*validationClasses*/ ctx[10] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[10];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[14]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 16384 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[14])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 8192) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[13];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 4096) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[12];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 1024) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[10];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance$F($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(15, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "input some text here, please" } = $$props;
		let { fieldname = "textarea" } = $$props;
		let { icon = false } = $$props;
		let { rows = 10 } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			let data = {
				field: fieldname,
				value: ev.target.type === "checkbox"
				? ev.target.checked
				: ev.target.value
			};

			$$invalidate(17, inputStarted = true);
			dispatch("change", data);
			return true;
		}

		function textarea_input_handler() {
			value = this.value;
			$$invalidate(0, value);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(13, allErrors), $$invalidate(18, errors)), $$invalidate(19, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(12, showErrors), $$invalidate(9, validated)), $$invalidate(8, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(10, validationClasses), $$invalidate(8, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('rows' in $$props) $$invalidate(4, rows = $$props.rows);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(8, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(9, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(18, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(19, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(20, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(14, iconClasses = (icon ? " has-icons-left " : "") + " has-icons-right ");
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 786432) {
				$$invalidate(13, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131840) {
				$$invalidate(12, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 1048832) {
				$$invalidate(11, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131328) {
				$$invalidate(10, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}
		};

		return [
			value,
			placeholder,
			fieldname,
			icon,
			rows,
			required,
			readonly,
			disabled,
			valid,
			validated,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			$LOCALE,
			onBlur,
			inputStarted,
			errors,
			formErrors,
			formLevelError,
			textarea_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class Ui_textarea extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$F, create_fragment$F, safe_not_equal, {
				inputStarted: 17,
				value: 0,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				rows: 4,
				required: 5,
				readonly: 6,
				disabled: 7,
				valid: 8,
				validated: 9,
				errors: 18,
				formErrors: 19,
				formLevelError: 20
			});
		}
	}

	var index$7 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIAutocomplete: Ui_autocomplete,
		UICheckbox: Ui_checkbox,
		UICheckboxList: Ui_checkbox_list,
		UIColor: Ui_color,
		UIControl: Ui_control,
		UIDate: Ui_date,
		UIDatetimeInTZ: Ui_datetime_in_tz,
		UIEmail: Ui_email,
		UIHidden: Ui_hidden,
		UILabel: Ui_label,
		UIListOfModels: Ui_list_of_models,
		UINamedNumbersList: Ui_named_numbers_list,
		UINumber: Ui_number,
		UIPassword: Ui_password,
		UIRadioButtons: Ui_radio_buttons,
		UIRange: Ui_range,
		UIRangeLogarithmic: Ui_range_logarithmic,
		UISelect: Ui_select,
		UISelectFromModel: Ui_select_from_model,
		UISwitch: Ui_switch$1,
		UITagSelect: Ui_tag_select,
		UITelephone: Ui_telephone,
		UITextarea: Ui_textarea,
		UITextfield: Ui_textfield
	});

	/* node_modules/not-bulma/src/elements/icon/ui.icon.button.with.tag.svelte generated by Svelte v4.2.19 */

	function create_fragment$E(ctx) {
		let uibutton;
		let t;
		let uitag;
		let current;
		const uibutton_spread_levels = [/*button*/ ctx[0]];
		let uibutton_props = {};

		for (let i = 0; i < uibutton_spread_levels.length; i += 1) {
			uibutton_props = assign(uibutton_props, uibutton_spread_levels[i]);
		}

		uibutton = new Ui_button({ props: uibutton_props });
		const uitag_spread_levels = [/*tag*/ ctx[1], { classes: "is-top-right" }];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uibutton.$$.fragment);
				t = space();
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibutton, target, anchor);
				insert(target, t, anchor);
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibutton_changes = (dirty & /*button*/ 1)
				? get_spread_update(uibutton_spread_levels, [get_spread_object(/*button*/ ctx[0])])
				: {};

				uibutton.$set(uibutton_changes);

				const uitag_changes = (dirty & /*tag*/ 2)
				? get_spread_update(uitag_spread_levels, [get_spread_object(/*tag*/ ctx[1]), uitag_spread_levels[1]])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}

				destroy_component(uibutton, detaching);
				destroy_component(uitag, detaching);
			}
		};
	}

	function instance$E($$self, $$props, $$invalidate) {
		let { button = {} } = $$props;
		let { tag = {} } = $$props;

		$$self.$$set = $$props => {
			if ('button' in $$props) $$invalidate(0, button = $$props.button);
			if ('tag' in $$props) $$invalidate(1, tag = $$props.tag);
		};

		return [button, tag];
	}

	class Ui_icon_button_with_tag extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$E, create_fragment$E, safe_not_equal, { button: 0, tag: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/icon/ui.icon.floating.svelte generated by Svelte v4.2.19 */

	function create_fragment$D(ctx) {
		let div;
		let uibutton;
		let current;
		const uibutton_spread_levels = [{ action: toggle }, /*trigger*/ ctx[0]];
		let uibutton_props = {};

		for (let i = 0; i < uibutton_spread_levels.length; i += 1) {
			uibutton_props = assign(uibutton_props, uibutton_spread_levels[i]);
		}

		uibutton = new Ui_button({ props: uibutton_props });

		return {
			c() {
				div = element("div");
				create_component(uibutton.$$.fragment);
				attr(div, "class", "is-fab svelte-1haul9u");
				attr(div, "style", /*positionStyle*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uibutton, div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibutton_changes = (dirty & /*toggle, trigger*/ 1)
				? get_spread_update(uibutton_spread_levels, [
						dirty & /*toggle*/ 0 && { action: toggle },
						dirty & /*trigger*/ 1 && get_spread_object(/*trigger*/ ctx[0])
					])
				: {};

				uibutton.$set(uibutton_changes);

				if (!current || dirty & /*positionStyle*/ 2) {
					attr(div, "style", /*positionStyle*/ ctx[1]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uibutton.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibutton.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uibutton);
			}
		};
	}

	function toggle() {
		
	}

	function instance$D($$self, $$props, $$invalidate) {
		let { trigger = {
			title: 'Click me!',
			icon: 'plus',
			color: 'primary',
			size: 'medium'
		} } = $$props;

		let positionStyle = '';

		onMount(() => {
			$$invalidate(1, positionStyle = '');
		});

		$$self.$$set = $$props => {
			if ('trigger' in $$props) $$invalidate(0, trigger = $$props.trigger);
		};

		return [trigger, positionStyle];
	}

	class Ui_icon_floating extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$D, create_fragment$D, safe_not_equal, { trigger: 0 });
		}
	}

	/* node_modules/not-bulma/src/elements/icon/ui.icon.font.svelte generated by Svelte v4.2.19 */

	function create_else_block$g(ctx) {
		let span;
		let i;
		let i_class_value;
		let span_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*font*/ ctx[1]);
				attr(span, "class", span_class_value = "" + (/*pointable*/ ctx[3] ? 'is-clickable' : '') + " icon " + (/*size*/ ctx[2] ? `is-${/*size*/ ctx[2]}` : '') + " " + (/*size*/ ctx[2] == 'medium' ? 'fa-lg' : '') + " " + (/*size*/ ctx[2] == 'large' ? 'fa-2x' : ''));
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*font*/ 2 && i_class_value !== (i_class_value = "fas fa-" + /*font*/ ctx[1])) {
					attr(i, "class", i_class_value);
				}

				if (dirty & /*pointable, size*/ 12 && span_class_value !== (span_class_value = "" + (/*pointable*/ ctx[3] ? 'is-clickable' : '') + " icon " + (/*size*/ ctx[2] ? `is-${/*size*/ ctx[2]}` : '') + " " + (/*size*/ ctx[2] == 'medium' ? 'fa-lg' : '') + " " + (/*size*/ ctx[2] == 'large' ? 'fa-2x' : ''))) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (21:0) {#if title}
	function create_if_block$q(ctx) {
		let span2;
		let span1;
		let i;
		let i_class_value;
		let t0;
		let span0;
		let t1_value = /*$LOCALE*/ ctx[4][/*title*/ ctx[0]] + "";
		let t1;
		let span1_class_value;
		let span2_class_value;

		return {
			c() {
				span2 = element("span");
				span1 = element("span");
				i = element("i");
				t0 = space();
				span0 = element("span");
				t1 = text(t1_value);
				attr(i, "class", i_class_value = "is-title-icon fas fa-" + /*font*/ ctx[1] + " " + (/*size*/ ctx[2] == 'medium' ? 'fa-lg' : '') + " " + (/*size*/ ctx[2] == 'large' ? 'fa-2x' : '') + "");
				attr(span1, "class", span1_class_value = "icon " + (/*size*/ ctx[2] ? `is-${/*size*/ ctx[2]}` : ''));
				attr(span2, "class", span2_class_value = "icon-text " + (/*pointable*/ ctx[3] ? 'is-clickable' : ''));
			},
			m(target, anchor) {
				insert(target, span2, anchor);
				append(span2, span1);
				append(span1, i);
				append(span1, t0);
				append(span1, span0);
				append(span0, t1);
			},
			p(ctx, dirty) {
				if (dirty & /*font, size*/ 6 && i_class_value !== (i_class_value = "is-title-icon fas fa-" + /*font*/ ctx[1] + " " + (/*size*/ ctx[2] == 'medium' ? 'fa-lg' : '') + " " + (/*size*/ ctx[2] == 'large' ? 'fa-2x' : '') + "")) {
					attr(i, "class", i_class_value);
				}

				if (dirty & /*$LOCALE, title*/ 17 && t1_value !== (t1_value = /*$LOCALE*/ ctx[4][/*title*/ ctx[0]] + "")) set_data(t1, t1_value);

				if (dirty & /*size*/ 4 && span1_class_value !== (span1_class_value = "icon " + (/*size*/ ctx[2] ? `is-${/*size*/ ctx[2]}` : ''))) {
					attr(span1, "class", span1_class_value);
				}

				if (dirty & /*pointable*/ 8 && span2_class_value !== (span2_class_value = "icon-text " + (/*pointable*/ ctx[3] ? 'is-clickable' : ''))) {
					attr(span2, "class", span2_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span2);
				}
			}
		};
	}

	function create_fragment$C(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*title*/ ctx[0]) return create_if_block$q;
			return create_else_block$g;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function instance$C($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(4, $LOCALE = $$value));
		let { title = "" } = $$props;
		let { font = "" } = $$props;
		let { size = "" } = $$props;
		let { pointable = false } = $$props;

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('font' in $$props) $$invalidate(1, font = $$props.font);
			if ('size' in $$props) $$invalidate(2, size = $$props.size);
			if ('pointable' in $$props) $$invalidate(3, pointable = $$props.pointable);
		};

		return [title, font, size, pointable, $LOCALE];
	}

	class Ui_icon_font extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$C, create_fragment$C, safe_not_equal, { title: 0, font: 1, size: 2, pointable: 3 });
		}
	}

	/* node_modules/not-bulma/src/elements/icon/ui.icon.svelte generated by Svelte v4.2.19 */

	function create_if_block_2$c(ctx) {
		let figure;
		let img;
		let img_src_value;
		let figure_class_value;

		return {
			c() {
				figure = element("figure");
				img = element("img");
				if (!src_url_equal(img.src, img_src_value = /*src*/ ctx[4])) attr(img, "src", img_src_value);
				attr(img, "title", /*title*/ ctx[0]);
				attr(img, "alt", /*title*/ ctx[0]);
				attr(img, "width", /*width*/ ctx[5]);
				attr(img, "height", /*height*/ ctx[6]);

				attr(figure, "class", figure_class_value = "image " + (/*width*/ ctx[5] && /*height*/ ctx[6]
				? `is-${/*width*/ ctx[5]}x${/*height*/ ctx[6]}`
				: '') + "");
			},
			m(target, anchor) {
				insert(target, figure, anchor);
				append(figure, img);
			},
			p(ctx, dirty) {
				if (dirty & /*src*/ 16 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[4])) {
					attr(img, "src", img_src_value);
				}

				if (dirty & /*title*/ 1) {
					attr(img, "title", /*title*/ ctx[0]);
				}

				if (dirty & /*title*/ 1) {
					attr(img, "alt", /*title*/ ctx[0]);
				}

				if (dirty & /*width*/ 32) {
					attr(img, "width", /*width*/ ctx[5]);
				}

				if (dirty & /*height*/ 64) {
					attr(img, "height", /*height*/ ctx[6]);
				}

				if (dirty & /*width, height*/ 96 && figure_class_value !== (figure_class_value = "image " + (/*width*/ ctx[5] && /*height*/ ctx[6]
				? `is-${/*width*/ ctx[5]}x${/*height*/ ctx[6]}`
				: '') + "")) {
					attr(figure, "class", figure_class_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(figure);
				}
			}
		};
	}

	// (18:15) 
	function create_if_block_1$k(ctx) {
		let span;

		return {
			c() {
				span = element("span");
				attr(span, "class", "icon");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				span.innerHTML = /*svg*/ ctx[3];
			},
			p(ctx, dirty) {
				if (dirty & /*svg*/ 8) span.innerHTML = /*svg*/ ctx[3];		},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (16:0) {#if font }
	function create_if_block$p(ctx) {
		let uiiconfont;
		let current;

		uiiconfont = new Ui_icon_font({
				props: {
					font: /*font*/ ctx[2],
					size: /*size*/ ctx[1],
					title: /*title*/ ctx[0]
				}
			});

		return {
			c() {
				create_component(uiiconfont.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiiconfont, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiiconfont_changes = {};
				if (dirty & /*font*/ 4) uiiconfont_changes.font = /*font*/ ctx[2];
				if (dirty & /*size*/ 2) uiiconfont_changes.size = /*size*/ ctx[1];
				if (dirty & /*title*/ 1) uiiconfont_changes.title = /*title*/ ctx[0];
				uiiconfont.$set(uiiconfont_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiiconfont.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiiconfont.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiiconfont, detaching);
			}
		};
	}

	function create_fragment$B(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$p, create_if_block_1$k, create_if_block_2$c];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*font*/ ctx[2]) return 0;
			if (/*svg*/ ctx[3]) return 1;
			if (/*src*/ ctx[4]) return 2;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						} else {
							if_block.p(ctx, dirty);
						}

						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}
			}
		};
	}

	function instance$B($$self, $$props, $$invalidate) {
		let { title = '' } = $$props;
		let { size = '' } = $$props;
		let { font = '' } = $$props;
		let { svg = '' } = $$props;
		let { src = '' } = $$props;
		let { width } = $$props;
		let { height } = $$props;

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
			if ('font' in $$props) $$invalidate(2, font = $$props.font);
			if ('svg' in $$props) $$invalidate(3, svg = $$props.svg);
			if ('src' in $$props) $$invalidate(4, src = $$props.src);
			if ('width' in $$props) $$invalidate(5, width = $$props.width);
			if ('height' in $$props) $$invalidate(6, height = $$props.height);
		};

		return [title, size, font, svg, src, width, height];
	}

	class Ui_icon extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$B, create_fragment$B, safe_not_equal, {
				title: 0,
				size: 1,
				font: 2,
				svg: 3,
				src: 4,
				width: 5,
				height: 6
			});
		}
	}

	var index$6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIIcon: Ui_icon,
		UIIconButtonWithTag: Ui_icon_button_with_tag,
		UIIconFloating: Ui_icon_floating,
		UIIconFont: Ui_icon_font
	});

	/* node_modules/not-bulma/src/elements/image/ui.images.svelte generated by Svelte v4.2.19 */

	function get_each_context$b(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[2] = list[i];
		return child_ctx;
	}

	// (6:0) {#each values as item (item.url)}
	function create_each_block$b(key_1, ctx) {
		let first;
		let uiimage;
		let current;
		const uiimage_spread_levels = [/*item*/ ctx[2]];
		let uiimage_props = {};

		for (let i = 0; i < uiimage_spread_levels.length; i += 1) {
			uiimage_props = assign(uiimage_props, uiimage_spread_levels[i]);
		}

		uiimage = new Ui_image({ props: uiimage_props });
		uiimage.$on("click", /*click_handler*/ ctx[1]);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uiimage.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uiimage, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				const uiimage_changes = (dirty & /*values*/ 1)
				? get_spread_update(uiimage_spread_levels, [get_spread_object(/*item*/ ctx[2])])
				: {};

				uiimage.$set(uiimage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiimage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiimage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uiimage, detaching);
			}
		};
	}

	function create_fragment$A(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[2].url;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$b(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*values*/ 1) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$b, each_1_anchor, get_each_context$b);
					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	function instance$A($$self, $$props, $$invalidate) {
		let { values = [] } = $$props;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
		};

		return [values, click_handler];
	}

	class Ui_images extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$A, create_fragment$A, safe_not_equal, { values: 0 });
		}
	}

	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIImage: Ui_image,
		UIImages: Ui_images
	});

	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UILink: Ui_link,
		UILinks: Ui_links
	});

	/* node_modules/not-bulma/src/elements/list/endless/ui.endless.list.navigation.svelte generated by Svelte v4.2.19 */

	function create_if_block$o(ctx) {
		let div2;
		let div0;
		let t0;
		let t1;
		let div1;
		let current;
		let if_block0 = /*page*/ ctx[0] > 1 && create_if_block_3$a(ctx);
		let if_block1 = /*pages*/ ctx[1] > 1 && create_if_block_2$b(ctx);
		let if_block2 = /*page*/ ctx[0] < /*pages*/ ctx[1] && create_if_block_1$j(ctx);

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				div1 = element("div");
				if (if_block2) if_block2.c();
				attr(div0, "class", "column");
				attr(div1, "class", "column");
				attr(div2, "class", "columns");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				if (if_block0) if_block0.m(div0, null);
				append(div2, t0);
				if (if_block1) if_block1.m(div2, null);
				append(div2, t1);
				append(div2, div1);
				if (if_block2) if_block2.m(div1, null);
				current = true;
			},
			p(ctx, dirty) {
				if (/*page*/ ctx[0] > 1) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*page*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_3$a(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*pages*/ ctx[1] > 1) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$b(ctx);
						if_block1.c();
						if_block1.m(div2, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*page*/ ctx[0] < /*pages*/ ctx[1]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*page, pages*/ 3) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_1$j(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div1, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (21:8) {#if page > 1 }
	function create_if_block_3$a(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*buttonComponentProps*/ ctx[3], { action: /*func*/ ctx[6] }];
		var switch_value = /*buttonComponent*/ ctx[2];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*buttonComponentProps, dispatch*/ 40) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*buttonComponentProps*/ 8 && get_spread_object(/*buttonComponentProps*/ ctx[3]),
					dirty & /*dispatch*/ 32 && { action: /*func*/ ctx[6] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*buttonComponent*/ 4 && switch_value !== (switch_value = /*buttonComponent*/ ctx[2])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*buttonComponentProps, dispatch*/ 40)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*buttonComponentProps*/ 8 && get_spread_object(/*buttonComponentProps*/ ctx[3]),
							dirty & /*dispatch*/ 32 && { action: /*func*/ ctx[6] }
						])
					: {};

					if (dirty & /*$$scope, $LOCALE*/ 272) {
						switch_instance_changes.$$scope = { dirty, ctx };
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (22:8) <svelte:component             this={buttonComponent}                         {...buttonComponentProps}             action={() => dispatch('prev')}             >
	function create_default_slot_1$2(ctx) {
		let t_value = /*$LOCALE*/ ctx[4]['not-node:list_navigation_prev_button_label'] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE*/ 16 && t_value !== (t_value = /*$LOCALE*/ ctx[4]['not-node:list_navigation_prev_button_label'] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (29:4) {#if pages > 1 }
	function create_if_block_2$b(ctx) {
		let div;
		let t0;
		let t1;
		let t2;

		return {
			c() {
				div = element("div");
				t0 = text(/*page*/ ctx[0]);
				t1 = text(" / ");
				t2 = text(/*pages*/ ctx[1]);
				attr(div, "class", "column box");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, t2);
			},
			p(ctx, dirty) {
				if (dirty & /*page*/ 1) set_data(t0, /*page*/ ctx[0]);
				if (dirty & /*pages*/ 2) set_data(t2, /*pages*/ ctx[1]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (35:8) {#if page < pages }
	function create_if_block_1$j(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*buttonComponentProps*/ ctx[3], { action: /*func_1*/ ctx[7] }];
		var switch_value = /*buttonComponent*/ ctx[2];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*buttonComponentProps, dispatch*/ 40) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*buttonComponentProps*/ 8 && get_spread_object(/*buttonComponentProps*/ ctx[3]),
					dirty & /*dispatch*/ 32 && { action: /*func_1*/ ctx[7] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*buttonComponent*/ 4 && switch_value !== (switch_value = /*buttonComponent*/ ctx[2])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*buttonComponentProps, dispatch*/ 40)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*buttonComponentProps*/ 8 && get_spread_object(/*buttonComponentProps*/ ctx[3]),
							dirty & /*dispatch*/ 32 && { action: /*func_1*/ ctx[7] }
						])
					: {};

					if (dirty & /*$$scope, $LOCALE*/ 272) {
						switch_instance_changes.$$scope = { dirty, ctx };
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (36:8) <svelte:component             this={buttonComponent}                         {...buttonComponentProps}             action={() => dispatch('next')}             >
	function create_default_slot$4(ctx) {
		let t_value = /*$LOCALE*/ ctx[4]['not-node:list_navigation_next_button_label'] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE*/ 16 && t_value !== (t_value = /*$LOCALE*/ ctx[4]['not-node:list_navigation_next_button_label'] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	function create_fragment$z(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*pages*/ ctx[1] > 0 && create_if_block$o(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*pages*/ ctx[1] > 0) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*pages*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$o(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$z($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(4, $LOCALE = $$value));
		const dispatch = createEventDispatcher();
		let { page = 0 } = $$props;
		let { pages = 0 } = $$props;
		let { buttonComponent = Ui_button } = $$props;
		let { buttonComponentProps = {} } = $$props;
		const func = () => dispatch('prev');
		const func_1 = () => dispatch('next');

		$$self.$$set = $$props => {
			if ('page' in $$props) $$invalidate(0, page = $$props.page);
			if ('pages' in $$props) $$invalidate(1, pages = $$props.pages);
			if ('buttonComponent' in $$props) $$invalidate(2, buttonComponent = $$props.buttonComponent);
			if ('buttonComponentProps' in $$props) $$invalidate(3, buttonComponentProps = $$props.buttonComponentProps);
		};

		return [
			page,
			pages,
			buttonComponent,
			buttonComponentProps,
			$LOCALE,
			dispatch,
			func,
			func_1
		];
	}

	class Ui_endless_list_navigation extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$z, create_fragment$z, safe_not_equal, {
				page: 0,
				pages: 1,
				buttonComponent: 2,
				buttonComponentProps: 3
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/endless/ui.endless.list.simple.item.svelte generated by Svelte v4.2.19 */

	function create_fragment$y(ctx) {
		let div;
		let span;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				div = element("div");
				span = element("span");
				t = text(/*title*/ ctx[0]);
				attr(div, "class", "box list-item-selectable svelte-ialyiy");
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, t);

				if (!mounted) {
					dispose = [
						listen(div, "click", prevent_default(/*click*/ ctx[1])),
						listen(div, "keyup", /*click*/ ctx[1])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*title*/ 1) set_data(t, /*title*/ ctx[0]);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$y($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { title } = $$props;
		let { id } = $$props;
		let { _id } = $$props;

		function click() {
			dispatch("click", { _id, id, title });
		}

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('id' in $$props) $$invalidate(2, id = $$props.id);
			if ('_id' in $$props) $$invalidate(3, _id = $$props._id);
		};

		return [title, click, id, _id];
	}

	class Ui_endless_list_simple_item extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$y, create_fragment$y, safe_not_equal, { title: 0, id: 2, _id: 3 });
		}
	}

	/* node_modules/not-bulma/src/elements/list/endless/ui.endless.list.svelte generated by Svelte v4.2.19 */

	function get_each_context$a(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[15] = list[i];
		return child_ctx;
	}

	// (41:4) {:else}
	function create_else_block$f(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*emptyListPlaceholderComponentProps*/ ctx[4]];
		var switch_value = /*emptyListPlaceholderComponent*/ ctx[3];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*emptyListPlaceholderComponentProps*/ 16) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*emptyListPlaceholderComponentProps*/ ctx[4])]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*emptyListPlaceholderComponent*/ 8 && switch_value !== (switch_value = /*emptyListPlaceholderComponent*/ ctx[3])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*emptyListPlaceholderComponentProps*/ 16)
					? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*emptyListPlaceholderComponentProps*/ ctx[4])])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (32:4) {#if data.list.length}
	function create_if_block$n(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*data*/ ctx[0].list);
		const get_key = ctx => /*item*/ ctx[15].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$a(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*itemComponent, itemComponentProps, data, select*/ 135) {
					each_value = ensure_array_like(/*data*/ ctx[0].list);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$a, each_1_anchor, get_each_context$a);
					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	// (33:8) {#each data.list as item (item.id)}
	function create_each_block$a(key_1, ctx) {
		let first;
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*itemComponentProps*/ ctx[2], /*item*/ ctx[15]];
		var switch_value = /*itemComponent*/ ctx[1];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*itemComponentProps, data*/ 5) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*itemComponentProps*/ 4 && get_spread_object(/*itemComponentProps*/ ctx[2]),
					dirty & /*data*/ 1 && get_spread_object(/*item*/ ctx[15])
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("click", /*select*/ ctx[7]);
		}

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*itemComponent*/ 2 && switch_value !== (switch_value = /*itemComponent*/ ctx[1])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("click", /*select*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*itemComponentProps, data*/ 5)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*itemComponentProps*/ 4 && get_spread_object(/*itemComponentProps*/ ctx[2]),
							dirty & /*data*/ 1 && get_spread_object(/*item*/ ctx[15])
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$x(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let t;
		let switch_instance;
		let updating_page;
		let updating_pages;
		let updating_skip;
		let updating_count;
		let switch_instance_anchor;
		let current;
		const if_block_creators = [create_if_block$n, create_else_block$f];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*data*/ ctx[0].list.length) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		const switch_instance_spread_levels = [/*listNavigationComponentProps*/ ctx[6]];

		function switch_instance_page_binding(value) {
			/*switch_instance_page_binding*/ ctx[8](value);
		}

		function switch_instance_pages_binding(value) {
			/*switch_instance_pages_binding*/ ctx[9](value);
		}

		function switch_instance_skip_binding(value) {
			/*switch_instance_skip_binding*/ ctx[10](value);
		}

		function switch_instance_count_binding(value) {
			/*switch_instance_count_binding*/ ctx[11](value);
		}

		var switch_value = /*listNavigationComponent*/ ctx[5];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listNavigationComponentProps*/ 64) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*listNavigationComponentProps*/ ctx[6])]));
			}

			if (/*data*/ ctx[0].page !== void 0) {
				switch_instance_props.page = /*data*/ ctx[0].page;
			}

			if (/*data*/ ctx[0].pages !== void 0) {
				switch_instance_props.pages = /*data*/ ctx[0].pages;
			}

			if (/*data*/ ctx[0].skip !== void 0) {
				switch_instance_props.skip = /*data*/ ctx[0].skip;
			}

			if (/*data*/ ctx[0].count !== void 0) {
				switch_instance_props.count = /*data*/ ctx[0].count;
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'page', switch_instance_page_binding));
			binding_callbacks.push(() => bind(switch_instance, 'pages', switch_instance_pages_binding));
			binding_callbacks.push(() => bind(switch_instance, 'skip', switch_instance_skip_binding));
			binding_callbacks.push(() => bind(switch_instance, 'count', switch_instance_count_binding));
			switch_instance.$on("prev", /*prev_handler*/ ctx[12]);
			switch_instance.$on("next", /*next_handler*/ ctx[13]);
		}

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				insert(target, t, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}

				if (dirty & /*listNavigationComponent*/ 32 && switch_value !== (switch_value = /*listNavigationComponent*/ ctx[5])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'page', switch_instance_page_binding));
						binding_callbacks.push(() => bind(switch_instance, 'pages', switch_instance_pages_binding));
						binding_callbacks.push(() => bind(switch_instance, 'skip', switch_instance_skip_binding));
						binding_callbacks.push(() => bind(switch_instance, 'count', switch_instance_count_binding));
						switch_instance.$on("prev", /*prev_handler*/ ctx[12]);
						switch_instance.$on("next", /*next_handler*/ ctx[13]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listNavigationComponentProps*/ 64)
					? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*listNavigationComponentProps*/ ctx[6])])
					: {};

					if (!updating_page && dirty & /*data*/ 1) {
						updating_page = true;
						switch_instance_changes.page = /*data*/ ctx[0].page;
						add_flush_callback(() => updating_page = false);
					}

					if (!updating_pages && dirty & /*data*/ 1) {
						updating_pages = true;
						switch_instance_changes.pages = /*data*/ ctx[0].pages;
						add_flush_callback(() => updating_pages = false);
					}

					if (!updating_skip && dirty & /*data*/ 1) {
						updating_skip = true;
						switch_instance_changes.skip = /*data*/ ctx[0].skip;
						add_flush_callback(() => updating_skip = false);
					}

					if (!updating_count && dirty & /*data*/ 1) {
						updating_count = true;
						switch_instance_changes.count = /*data*/ ctx[0].count;
						add_flush_callback(() => updating_count = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
					detach(switch_instance_anchor);
				}

				if_blocks[current_block_type_index].d();
				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$x($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();

		let { data = {
			list: [],
			skip: 0,
			count: 0,
			page: 0,
			pages: 0
		} } = $$props;

		let { itemComponent = Ui_endless_list_simple_item } = $$props;
		let { itemComponentProps = {} } = $$props;
		let { emptyListPlaceholderComponent = Ui_list_empty_placeholder } = $$props;
		let { emptyListPlaceholderComponentProps = {} } = $$props;
		let { listNavigationComponent = Ui_endless_list_navigation } = $$props;
		let { listNavigationComponentProps = {} } = $$props;

		function select({ detail }) {
			dispatch("select", detail);
		}

		function switch_instance_page_binding(value) {
			if ($$self.$$.not_equal(data.page, value)) {
				data.page = value;
				$$invalidate(0, data);
			}
		}

		function switch_instance_pages_binding(value) {
			if ($$self.$$.not_equal(data.pages, value)) {
				data.pages = value;
				$$invalidate(0, data);
			}
		}

		function switch_instance_skip_binding(value) {
			if ($$self.$$.not_equal(data.skip, value)) {
				data.skip = value;
				$$invalidate(0, data);
			}
		}

		function switch_instance_count_binding(value) {
			if ($$self.$$.not_equal(data.count, value)) {
				data.count = value;
				$$invalidate(0, data);
			}
		}

		function prev_handler(event) {
			bubble.call(this, $$self, event);
		}

		function next_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('data' in $$props) $$invalidate(0, data = $$props.data);
			if ('itemComponent' in $$props) $$invalidate(1, itemComponent = $$props.itemComponent);
			if ('itemComponentProps' in $$props) $$invalidate(2, itemComponentProps = $$props.itemComponentProps);
			if ('emptyListPlaceholderComponent' in $$props) $$invalidate(3, emptyListPlaceholderComponent = $$props.emptyListPlaceholderComponent);
			if ('emptyListPlaceholderComponentProps' in $$props) $$invalidate(4, emptyListPlaceholderComponentProps = $$props.emptyListPlaceholderComponentProps);
			if ('listNavigationComponent' in $$props) $$invalidate(5, listNavigationComponent = $$props.listNavigationComponent);
			if ('listNavigationComponentProps' in $$props) $$invalidate(6, listNavigationComponentProps = $$props.listNavigationComponentProps);
		};

		return [
			data,
			itemComponent,
			itemComponentProps,
			emptyListPlaceholderComponent,
			emptyListPlaceholderComponentProps,
			listNavigationComponent,
			listNavigationComponentProps,
			select,
			switch_instance_page_binding,
			switch_instance_pages_binding,
			switch_instance_skip_binding,
			switch_instance_count_binding,
			prev_handler,
			next_handler
		];
	}

	class Ui_endless_list extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$x, create_fragment$x, safe_not_equal, {
				data: 0,
				itemComponent: 1,
				itemComponentProps: 2,
				emptyListPlaceholderComponent: 3,
				emptyListPlaceholderComponentProps: 4,
				listNavigationComponent: 5,
				listNavigationComponentProps: 6
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.select.svelte generated by Svelte v4.2.19 */

	function create_fragment$w(ctx) {
		let switch_instance;
		let updating_items;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*listComponentProps*/ ctx[8],
			{
				titleComponent: /*titleComponent*/ ctx[1]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[2]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[5]
			},
			{
				descriptionComponentProps: {
					.../*descriptionComponentProps*/ ctx[6],
					action: /*func*/ ctx[21]
				}
			},
			{
				imageComponent: /*imageComponent*/ ctx[3]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[4]
			}
		];

		function switch_instance_items_binding(value) {
			/*switch_instance_items_binding*/ ctx[22](value);
		}

		var switch_value = /*listComponent*/ ctx[7];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 894) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
					dirty & /*titleComponent*/ 2 && {
						titleComponent: /*titleComponent*/ ctx[1]
					},
					dirty & /*titleComponentProps*/ 4 && {
						titleComponentProps: /*titleComponentProps*/ ctx[2]
					},
					dirty & /*descriptionComponent*/ 32 && {
						descriptionComponent: /*descriptionComponent*/ ctx[5]
					},
					dirty & /*descriptionComponentProps, toggle*/ 576 && {
						descriptionComponentProps: {
							.../*descriptionComponentProps*/ ctx[6],
							action: /*func*/ ctx[21]
						}
					},
					dirty & /*imageComponent*/ 8 && {
						imageComponent: /*imageComponent*/ ctx[3]
					},
					dirty & /*imageComponentProps*/ 16 && {
						imageComponentProps: /*imageComponentProps*/ ctx[4]
					}
				]));
			}

			if (/*variants*/ ctx[0] !== void 0) {
				switch_instance_props.items = /*variants*/ ctx[0];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*listComponent*/ 128 && switch_value !== (switch_value = /*listComponent*/ ctx[7])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 894)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
							dirty & /*titleComponent*/ 2 && {
								titleComponent: /*titleComponent*/ ctx[1]
							},
							dirty & /*titleComponentProps*/ 4 && {
								titleComponentProps: /*titleComponentProps*/ ctx[2]
							},
							dirty & /*descriptionComponent*/ 32 && {
								descriptionComponent: /*descriptionComponent*/ ctx[5]
							},
							dirty & /*descriptionComponentProps, toggle*/ 576 && {
								descriptionComponentProps: {
									.../*descriptionComponentProps*/ ctx[6],
									action: /*func*/ ctx[21]
								}
							},
							dirty & /*imageComponent*/ 8 && {
								imageComponent: /*imageComponent*/ ctx[3]
							},
							dirty & /*imageComponentProps*/ 16 && {
								imageComponentProps: /*imageComponentProps*/ ctx[4]
							}
						])
					: {};

					if (!updating_items && dirty & /*variants*/ 1) {
						updating_items = true;
						switch_instance_changes.items = /*variants*/ ctx[0];
						add_flush_callback(() => updating_items = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$w($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { fieldname = "list-select" } = $$props;
		let { multiple = false } = $$props;
		let { atLeastOne = true } = $$props;
		let { variants = [] } = $$props;
		let { value } = $$props;
		let { selectedVariantsIds = [] } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 5 } } = $$props;
		let { imageComponent = Ui_image } = $$props;
		let { imageComponentProps = { covered: true } } = $$props;
		let { descriptionComponent = Ui_buttons } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { listComponent = Ui_list } = $$props;
		let { listComponentProps = {} } = $$props;
		let { sublimeValue = value => value.id } = $$props;

		let { getItem = ({ valueId }) => {
			return variants.find(btnVal => btnVal.value.id === valueId);
		} } = $$props;

		let { getItemValue = ({ valueId }) => {
			return getItem({ valueId }).value;
		} } = $$props;

		let { getDefaultItemSublime = () => {
			return variants[0].id;
		} } = $$props;

		let { uiOn = item => {
			item.color = "success";
			item.outlined = false;
		} } = $$props;

		let { uiOff = item => {
			item.color = false;
			item.outlined = true;
		} } = $$props;

		onMount(() => {
			if (value && Array.isArray(value)) {
				if (atLeastOne && value.length) {
					value.forEach(itemValue => {
						let ui = updateSelected(itemValue);
						updateUI(ui);
					});
				}

				return;
			}

			selectDefault();
		});

		//
		function countOfSelected() {
			return Array.isArray(value) ? selectedVariantsIds.length : 0;
		}

		const notLastOne = () => !(atLeastOne && countOfSelected() === 1);

		//
		function updateSelected(detail) {
			const valueId = sublimeValue(detail);
			let ui = { on: undefined, off: undefined };

			//
			if (!Array.isArray(selectedVariantsIds)) {
				$$invalidate(11, selectedVariantsIds = []);
			}

			if (multiple) {
				if (selectedVariantsIds.includes(valueId)) {
					if (notLastOne()) {
						selectedVariantsIds.splice(selectedVariantsIds.indexOf(valueId), 1);
						ui.off = { valueId };
					}
				} else {
					selectedVariantsIds.push(valueId);
					ui.on = { valueId };
				}
			} else {
				if (atLeastOne) {
					if (!selectedVariantsIds.includes(valueId)) {
						if (countOfSelected() > 0) {
							ui.off = { valueId: selectedVariantsIds.pop() };
						}

						ui.on = { valueId };
						$$invalidate(11, selectedVariantsIds = [valueId]);
					}
				} else {
					if (selectedVariantsIds.includes(valueId)) {
						ui.off = { valueId };
						selectedVariantsIds.splice(selectedVariantsIds.indexOf(valueId), 1);
					} else {
						ui.on = { valueId };
						selectedVariantsIds.push(valueId);
					}
				}
			}

			$$invalidate(11, selectedVariantsIds);
			return ui;
		}

		//
		function toggle(detail) {
			let ui = updateSelected(detail);
			updateUI(ui);

			//
			updateValue();

			//
			dispatch("change", { field: fieldname, value });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff(getItem(changes.off));
			}

			if (changes.on) {
				uiOn(getItem(changes.on));
			}

			$$invalidate(0, variants);
		}

		//
		function updateValue() {
			let newVal = [];

			if (typeof selectedVariantsIds !== "undefined" && Array.isArray(selectedVariantsIds)) {
				newVal = selectedVariantsIds.filter(val => typeof val !== "undefined").map(valueId => getItemValue({ valueId }));
			}

			$$invalidate(10, value = newVal);
		}

		//
		function selectDefault() {
			if (atLeastOne && variants.length > 0) {
				const defValueId = getDefaultItemSublime();
				toggle({ id: defValueId });
			}
		}

		const func = function (event, value) {
			toggle(value);
		};

		function switch_instance_items_binding(value) {
			variants = value;
			$$invalidate(0, variants);
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(12, fieldname = $$props.fieldname);
			if ('multiple' in $$props) $$invalidate(13, multiple = $$props.multiple);
			if ('atLeastOne' in $$props) $$invalidate(14, atLeastOne = $$props.atLeastOne);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('value' in $$props) $$invalidate(10, value = $$props.value);
			if ('selectedVariantsIds' in $$props) $$invalidate(11, selectedVariantsIds = $$props.selectedVariantsIds);
			if ('titleComponent' in $$props) $$invalidate(1, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(2, titleComponentProps = $$props.titleComponentProps);
			if ('imageComponent' in $$props) $$invalidate(3, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(4, imageComponentProps = $$props.imageComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(5, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(6, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('listComponent' in $$props) $$invalidate(7, listComponent = $$props.listComponent);
			if ('listComponentProps' in $$props) $$invalidate(8, listComponentProps = $$props.listComponentProps);
			if ('sublimeValue' in $$props) $$invalidate(15, sublimeValue = $$props.sublimeValue);
			if ('getItem' in $$props) $$invalidate(16, getItem = $$props.getItem);
			if ('getItemValue' in $$props) $$invalidate(17, getItemValue = $$props.getItemValue);
			if ('getDefaultItemSublime' in $$props) $$invalidate(18, getDefaultItemSublime = $$props.getDefaultItemSublime);
			if ('uiOn' in $$props) $$invalidate(19, uiOn = $$props.uiOn);
			if ('uiOff' in $$props) $$invalidate(20, uiOff = $$props.uiOff);
		};

		return [
			variants,
			titleComponent,
			titleComponentProps,
			imageComponent,
			imageComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			listComponent,
			listComponentProps,
			toggle,
			value,
			selectedVariantsIds,
			fieldname,
			multiple,
			atLeastOne,
			sublimeValue,
			getItem,
			getItemValue,
			getDefaultItemSublime,
			uiOn,
			uiOff,
			func,
			switch_instance_items_binding
		];
	}

	class Ui_list_select extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$w, create_fragment$w, safe_not_equal, {
				fieldname: 12,
				multiple: 13,
				atLeastOne: 14,
				variants: 0,
				value: 10,
				selectedVariantsIds: 11,
				titleComponent: 1,
				titleComponentProps: 2,
				imageComponent: 3,
				imageComponentProps: 4,
				descriptionComponent: 5,
				descriptionComponentProps: 6,
				listComponent: 7,
				listComponentProps: 8,
				sublimeValue: 15,
				getItem: 16,
				getItemValue: 17,
				getDefaultItemSublime: 18,
				uiOn: 19,
				uiOff: 20
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.select.with.groups.svelte generated by Svelte v4.2.19 */

	function create_fragment$v(ctx) {
		let switch_instance;
		let updating_items;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*listComponentProps*/ ctx[8],
			{
				titleComponent: /*titleComponent*/ ctx[1]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[2]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[5]
			},
			{
				descriptionComponentProps: {
					.../*descriptionComponentProps*/ ctx[6],
					action: /*func*/ ctx[22]
				}
			},
			{
				imageComponent: /*imageComponent*/ ctx[3]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[4]
			}
		];

		function switch_instance_items_binding(value) {
			/*switch_instance_items_binding*/ ctx[23](value);
		}

		var switch_value = /*listComponent*/ ctx[7];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 894) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
					dirty & /*titleComponent*/ 2 && {
						titleComponent: /*titleComponent*/ ctx[1]
					},
					dirty & /*titleComponentProps*/ 4 && {
						titleComponentProps: /*titleComponentProps*/ ctx[2]
					},
					dirty & /*descriptionComponent*/ 32 && {
						descriptionComponent: /*descriptionComponent*/ ctx[5]
					},
					dirty & /*descriptionComponentProps, toggle*/ 576 && {
						descriptionComponentProps: {
							.../*descriptionComponentProps*/ ctx[6],
							action: /*func*/ ctx[22]
						}
					},
					dirty & /*imageComponent*/ 8 && {
						imageComponent: /*imageComponent*/ ctx[3]
					},
					dirty & /*imageComponentProps*/ 16 && {
						imageComponentProps: /*imageComponentProps*/ ctx[4]
					}
				]));
			}

			if (/*variants*/ ctx[0] !== void 0) {
				switch_instance_props.items = /*variants*/ ctx[0];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*listComponent*/ 128 && switch_value !== (switch_value = /*listComponent*/ ctx[7])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, descriptionComponentProps, toggle, imageComponent, imageComponentProps*/ 894)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
							dirty & /*titleComponent*/ 2 && {
								titleComponent: /*titleComponent*/ ctx[1]
							},
							dirty & /*titleComponentProps*/ 4 && {
								titleComponentProps: /*titleComponentProps*/ ctx[2]
							},
							dirty & /*descriptionComponent*/ 32 && {
								descriptionComponent: /*descriptionComponent*/ ctx[5]
							},
							dirty & /*descriptionComponentProps, toggle*/ 576 && {
								descriptionComponentProps: {
									.../*descriptionComponentProps*/ ctx[6],
									action: /*func*/ ctx[22]
								}
							},
							dirty & /*imageComponent*/ 8 && {
								imageComponent: /*imageComponent*/ ctx[3]
							},
							dirty & /*imageComponentProps*/ 16 && {
								imageComponentProps: /*imageComponentProps*/ ctx[4]
							}
						])
					: {};

					if (!updating_items && dirty & /*variants*/ 1) {
						updating_items = true;
						switch_instance_changes.items = /*variants*/ ctx[0];
						add_flush_callback(() => updating_items = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$v($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { fieldname = "list-select-tags" } = $$props;
		let { multiple = false } = $$props;
		let { onlyOneInGroup = true } = $$props;
		let { atLeastOne = true } = $$props;
		let { variants = [] } = $$props;
		let { variantsSelected = {} } = $$props;
		let { value } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 5 } } = $$props;
		let { imageComponent = Ui_image } = $$props;
		let { imageComponentProps = { covered: true } } = $$props;
		let { descriptionComponent = Ui_buttons } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { listComponent = Ui_list } = $$props;
		let { listComponentProps = {} } = $$props;

		let { sublimeValue = value => {
			return { groupId: value.group, valueId: value.id };
		} } = $$props;

		let { getItem = ({ groupId, valueId }) => {
			return variants.find(group => group.id === groupId).description.values.find(btnVal => btnVal.value.id === valueId);
		} } = $$props;

		let { getItemValue = ({ groupId, valueId }) => {
			return getItem({ groupId, valueId }).value;
		} } = $$props;

		let { getDefaultItemSublime = () => {
			return {
				groupId: variants[0].id,
				valueId: variants[0].description.values[0].value.id
			};
		} } = $$props;

		let { uiOn = item => {
			item.color = "success";
			item.outlined = false;
		} } = $$props;

		let { uiOff = item => {
			item.color = false;
			item.outlined = false;
		} } = $$props;

		onMount(() => {
			if (value) {
				if (multiple) {
					if (onlyOneInGroup) {
						for (let t of Object.keys(value)) {
							const itemValue = value[t];
							let ui = updateSelected(itemValue);
							updateUI(ui);
						}
					} else {
						for (let t of Object.keys(value)) {
							value[t].forEach(itemValue => {
								let ui = updateSelected(itemValue);
								updateUI(ui);
							});
						}
					}
				} else {
					let ui = updateSelected(value);
					updateUI(ui);
				}
			} else {
				selectDefault();
			}
		});

		//
		function countOfSelected() {
			let c = 0;

			if (multiple) {
				for (let groupValue of Object.values(variantsSelected)) {
					if (onlyOneInGroup) {
						if (typeof groupValue !== "undefined") {
							c++;
						}
					} else {
						if (typeof groupValue !== "undefined" && Array.isArray(groupValue)) {
							c += groupValue.length;
						}
					}
				}
			} else {
				if (typeof variantsSelected !== "undefined" && typeof variantsSelected.value !== "undefined" && typeof variantsSelected.group !== "undefined") {
					c++;
				}
			}

			return c;
		}

		//
		function updateSelected(detail) {
			const { valueId, groupId } = sublimeValue(detail);
			let ui = { on: undefined, off: undefined };

			//
			if (multiple) {
				if (onlyOneInGroup) {
					if (typeof variantsSelected[groupId] !== "undefined") {
						ui.off = {
							groupId,
							valueId: variantsSelected[groupId]
						};
					}

					$$invalidate(10, variantsSelected[groupId] = valueId, variantsSelected);
					ui.on = { groupId, valueId };
				} else {
					if (!Array.isArray(variantsSelected[groupId])) {
						$$invalidate(10, variantsSelected[groupId] = [], variantsSelected);
					}

					if (variantsSelected[groupId].includes(valueId)) {
						if (countOfSelected() > 1) {
							variantsSelected[groupId].splice(variantsSelected[groupId].indexOf(valueId), 1);
							ui.off = { groupId, valueId };
						}
					} else {
						variantsSelected[groupId].push(valueId);
						ui.on = { groupId, valueId };
					}

					$$invalidate(10, variantsSelected);
				}

				$$invalidate(10, variantsSelected);
			} else {
				if (variantsSelected && variantsSelected.groupId === groupId && variantsSelected.valueId === valueId) {
					if (!atLeastOne) {
						$$invalidate(10, variantsSelected = undefined);
						ui.off = { groupId, valueId };
					}
				} else {
					if (variantsSelected) {
						if (typeof variantsSelected.groupId !== "undefined") {
							ui.off = {
								groupId: variantsSelected.groupId,
								valueId: variantsSelected.valueId
							};
						}
					}

					ui.on = { groupId, valueId };
					$$invalidate(10, variantsSelected = { groupId, valueId });
				}
			}

			return ui;
		}

		//
		function toggle(detail) {
			let ui = updateSelected(detail);
			console.log("image value", value, ui);
			updateUI(ui);

			//
			updateValue();

			//
			dispatch("change", { field: fieldname, value });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff(getItem(changes.off));
			}

			if (changes.on) {
				uiOn(getItem(changes.on));
			}

			$$invalidate(0, variants);
		}

		//
		function updateValue() {
			if (multiple) {
				let newVal = {};

				if (onlyOneInGroup) {
					for (let groupId in variantsSelected) {
						if (typeof variantsSelected[groupId] !== "undefined") {
							newVal[groupId] = getItemValue({
								groupId,
								valueId: variantsSelected[groupId]
							});
						}
					}
				} else {
					for (let groupId in variantsSelected) {
						if (typeof variantsSelected[groupId] !== "undefined" && Array.isArray(variantsSelected[groupId])) {
							newVal[groupId] = variantsSelected[groupId].filter(val => typeof val !== "undefined").map(itemValueId => {
								return getItemValue({ groupId, valueId: itemValueId });
							});
						}
					}
				}

				if (Object.keys(newVal).length == 0) {
					$$invalidate(11, value = undefined);
				} else {
					$$invalidate(11, value = newVal);
				}
			} else {
				if (variantsSelected) {
					$$invalidate(11, value = getItemValue(variantsSelected));
				} else {
					$$invalidate(11, value = undefined);
				}
			}
		}

		//
		function selectDefault() {
			if (atLeastOne && variants.length > 0) {
				const defValue = getDefaultItemSublime();

				toggle({
					id: defValue.valueId,
					group: defValue.groupId
				});
			}
		}

		const func = function (event, value) {
			toggle(value);
		};

		function switch_instance_items_binding(value) {
			variants = value;
			$$invalidate(0, variants);
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(12, fieldname = $$props.fieldname);
			if ('multiple' in $$props) $$invalidate(13, multiple = $$props.multiple);
			if ('onlyOneInGroup' in $$props) $$invalidate(14, onlyOneInGroup = $$props.onlyOneInGroup);
			if ('atLeastOne' in $$props) $$invalidate(15, atLeastOne = $$props.atLeastOne);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('variantsSelected' in $$props) $$invalidate(10, variantsSelected = $$props.variantsSelected);
			if ('value' in $$props) $$invalidate(11, value = $$props.value);
			if ('titleComponent' in $$props) $$invalidate(1, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(2, titleComponentProps = $$props.titleComponentProps);
			if ('imageComponent' in $$props) $$invalidate(3, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(4, imageComponentProps = $$props.imageComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(5, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(6, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('listComponent' in $$props) $$invalidate(7, listComponent = $$props.listComponent);
			if ('listComponentProps' in $$props) $$invalidate(8, listComponentProps = $$props.listComponentProps);
			if ('sublimeValue' in $$props) $$invalidate(16, sublimeValue = $$props.sublimeValue);
			if ('getItem' in $$props) $$invalidate(17, getItem = $$props.getItem);
			if ('getItemValue' in $$props) $$invalidate(18, getItemValue = $$props.getItemValue);
			if ('getDefaultItemSublime' in $$props) $$invalidate(19, getDefaultItemSublime = $$props.getDefaultItemSublime);
			if ('uiOn' in $$props) $$invalidate(20, uiOn = $$props.uiOn);
			if ('uiOff' in $$props) $$invalidate(21, uiOff = $$props.uiOff);
		};

		return [
			variants,
			titleComponent,
			titleComponentProps,
			imageComponent,
			imageComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			listComponent,
			listComponentProps,
			toggle,
			variantsSelected,
			value,
			fieldname,
			multiple,
			onlyOneInGroup,
			atLeastOne,
			sublimeValue,
			getItem,
			getItemValue,
			getDefaultItemSublime,
			uiOn,
			uiOff,
			func,
			switch_instance_items_binding
		];
	}

	class Ui_list_select_with_groups extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$v, create_fragment$v, safe_not_equal, {
				fieldname: 12,
				multiple: 13,
				onlyOneInGroup: 14,
				atLeastOne: 15,
				variants: 0,
				variantsSelected: 10,
				value: 11,
				titleComponent: 1,
				titleComponentProps: 2,
				imageComponent: 3,
				imageComponentProps: 4,
				descriptionComponent: 5,
				descriptionComponentProps: 6,
				listComponent: 7,
				listComponentProps: 8,
				sublimeValue: 16,
				getItem: 17,
				getItemValue: 18,
				getDefaultItemSublime: 19,
				uiOn: 20,
				uiOff: 21
			});
		}
	}

	/* node_modules/not-bulma/src/elements/list/ui.list.select.buttons.with.groups.svelte generated by Svelte v4.2.19 */

	function create_fragment$u(ctx) {
		let uibuttons;
		let t;
		let switch_instance;
		let updating_items;
		let switch_instance_anchor;
		let current;

		uibuttons = new Ui_buttons({
				props: {
					values: /*ACTIONS*/ ctx[9],
					centered: true
				}
			});

		const switch_instance_spread_levels = [
			/*listComponentProps*/ ctx[8],
			{
				titleComponent: /*titleComponent*/ ctx[1]
			},
			{
				titleComponentProps: /*titleComponentProps*/ ctx[2]
			},
			{
				descriptionComponent: /*descriptionComponent*/ ctx[5]
			},
			{
				descriptionComponentProps: {
					action: /*func*/ ctx[23],
					.../*descriptionComponentProps*/ ctx[6]
				}
			},
			{
				imageComponent: /*imageComponent*/ ctx[3]
			},
			{
				imageComponentProps: /*imageComponentProps*/ ctx[4]
			}
		];

		function switch_instance_items_binding(value) {
			/*switch_instance_items_binding*/ ctx[24](value);
		}

		var switch_value = /*listComponent*/ ctx[7];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, setTimeout, triggerChange, descriptionComponentProps, imageComponent, imageComponentProps*/ 1406) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
					dirty & /*titleComponent*/ 2 && {
						titleComponent: /*titleComponent*/ ctx[1]
					},
					dirty & /*titleComponentProps*/ 4 && {
						titleComponentProps: /*titleComponentProps*/ ctx[2]
					},
					dirty & /*descriptionComponent*/ 32 && {
						descriptionComponent: /*descriptionComponent*/ ctx[5]
					},
					dirty & /*setTimeout, triggerChange, descriptionComponentProps*/ 1088 && {
						descriptionComponentProps: {
							action: /*func*/ ctx[23],
							.../*descriptionComponentProps*/ ctx[6]
						}
					},
					dirty & /*imageComponent*/ 8 && {
						imageComponent: /*imageComponent*/ ctx[3]
					},
					dirty & /*imageComponentProps*/ 16 && {
						imageComponentProps: /*imageComponentProps*/ ctx[4]
					}
				]));
			}

			if (/*variants*/ ctx[0] !== void 0) {
				switch_instance_props.items = /*variants*/ ctx[0];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
		}

		return {
			c() {
				create_component(uibuttons.$$.fragment);
				t = space();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				mount_component(uibuttons, target, anchor);
				insert(target, t, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uibuttons_changes = {};
				if (dirty & /*ACTIONS*/ 512) uibuttons_changes.values = /*ACTIONS*/ ctx[9];
				uibuttons.$set(uibuttons_changes);

				if (dirty & /*listComponent*/ 128 && switch_value !== (switch_value = /*listComponent*/ ctx[7])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance, 'items', switch_instance_items_binding));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*listComponentProps, titleComponent, titleComponentProps, descriptionComponent, setTimeout, triggerChange, descriptionComponentProps, imageComponent, imageComponentProps*/ 1406)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*listComponentProps*/ 256 && get_spread_object(/*listComponentProps*/ ctx[8]),
							dirty & /*titleComponent*/ 2 && {
								titleComponent: /*titleComponent*/ ctx[1]
							},
							dirty & /*titleComponentProps*/ 4 && {
								titleComponentProps: /*titleComponentProps*/ ctx[2]
							},
							dirty & /*descriptionComponent*/ 32 && {
								descriptionComponent: /*descriptionComponent*/ ctx[5]
							},
							dirty & /*setTimeout, triggerChange, descriptionComponentProps*/ 1088 && {
								descriptionComponentProps: {
									action: /*func*/ ctx[23],
									.../*descriptionComponentProps*/ ctx[6]
								}
							},
							dirty & /*imageComponent*/ 8 && {
								imageComponent: /*imageComponent*/ ctx[3]
							},
							dirty & /*imageComponentProps*/ 16 && {
								imageComponentProps: /*imageComponentProps*/ ctx[4]
							}
						])
					: {};

					if (!updating_items && dirty & /*variants*/ 1) {
						updating_items = true;
						switch_instance_changes.items = /*variants*/ ctx[0];
						add_flush_callback(() => updating_items = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(switch_instance_anchor);
				}

				destroy_component(uibuttons, detaching);
				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function instance$u($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { fieldname = "list-select-tags" } = $$props;
		let { variants = [] } = $$props;
		let { variantsSelected = {} } = $$props;
		let { value } = $$props;
		let { titleComponent = Ui_title } = $$props;
		let { titleComponentProps = { size: 5 } } = $$props;
		let { imageComponent = Ui_image } = $$props;
		let { imageComponentProps = { covered: true } } = $$props;
		let { descriptionComponent = Ui_buttons_switchers } = $$props;
		let { descriptionComponentProps = {} } = $$props;
		let { listComponent = Ui_list } = $$props;
		let { listComponentProps = {} } = $$props;
		let { actionsList = ["selectAll", "deselectAll"] } = $$props;

		let { sublimeValue = value => {
			return { groupId: value.group, valueId: value.id };
		} } = $$props;

		//
		const AVAILABLE_ACTIONS = {
			selectAll: {
				title: "Выбрать все",
				color: "success",
				action() {
					selectAll();
				}
			},
			deselectAll: {
				title: "Снять выделение со всех",
				color: "",
				action() {
					deselectAll();
				}
			}
		};

		let ACTIONS = [];

		onMount(() => {
			actionsList.forEach(name => {
				Object.hasOwn(AVAILABLE_ACTIONS, name)
				? ACTIONS.push(AVAILABLE_ACTIONS[name])
				: false;
			});

			$$invalidate(9, ACTIONS);
		});

		const selectAll = () => {
			setSelectionOfAll(true);
		};

		const deselectAll = () => {
			setSelectionOfAll(false);
		};

		const selectGroup = groupId => {
			setSelectionOfGroup(groupId, true);
		};

		const deselectGroup = groupId => {
			setSelectionOfGroup(groupId, false);
		};

		const setSelectionOfGroup = (groupId, selection) => {
			variants.forEach(group => {
				if (groupId === group.id) {
					group.description.values.forEach(itm => {
						itm.selected = selection;
					});
				}
			});

			$$invalidate(0, variants);
			triggerChange();
		};

		const setSelectionOfAll = selection => {
			variants.forEach(group => {
				group.description.values.forEach(itm => {
					itm.selected = selection;
				});
			});

			$$invalidate(0, variants);
			triggerChange();
		};

		function getSelectedItems() {
			let result = {};

			variants.forEach(group => {
				if (!Object.hasOwn(result, group.id)) {
					result[group.id] = [];
				}

				group.description.values.forEach(itm => {
					if (itm.selected) {
						result[group.id].push(sublimeValue(itm.value));
					}
				});
			});

			return result;
		}

		function triggerChange() {
			$$invalidate(11, value = getSelectedItems());
			dispatch("change", { fieldname, value });
		}

		const func = function (event, value, selected) {
			setTimeout(triggerChange, 0);
			return !selected;
		};

		function switch_instance_items_binding(value) {
			variants = value;
			$$invalidate(0, variants);
		}

		$$self.$$set = $$props => {
			if ('fieldname' in $$props) $$invalidate(12, fieldname = $$props.fieldname);
			if ('variants' in $$props) $$invalidate(0, variants = $$props.variants);
			if ('variantsSelected' in $$props) $$invalidate(13, variantsSelected = $$props.variantsSelected);
			if ('value' in $$props) $$invalidate(11, value = $$props.value);
			if ('titleComponent' in $$props) $$invalidate(1, titleComponent = $$props.titleComponent);
			if ('titleComponentProps' in $$props) $$invalidate(2, titleComponentProps = $$props.titleComponentProps);
			if ('imageComponent' in $$props) $$invalidate(3, imageComponent = $$props.imageComponent);
			if ('imageComponentProps' in $$props) $$invalidate(4, imageComponentProps = $$props.imageComponentProps);
			if ('descriptionComponent' in $$props) $$invalidate(5, descriptionComponent = $$props.descriptionComponent);
			if ('descriptionComponentProps' in $$props) $$invalidate(6, descriptionComponentProps = $$props.descriptionComponentProps);
			if ('listComponent' in $$props) $$invalidate(7, listComponent = $$props.listComponent);
			if ('listComponentProps' in $$props) $$invalidate(8, listComponentProps = $$props.listComponentProps);
			if ('actionsList' in $$props) $$invalidate(14, actionsList = $$props.actionsList);
			if ('sublimeValue' in $$props) $$invalidate(15, sublimeValue = $$props.sublimeValue);
		};

		return [
			variants,
			titleComponent,
			titleComponentProps,
			imageComponent,
			imageComponentProps,
			descriptionComponent,
			descriptionComponentProps,
			listComponent,
			listComponentProps,
			ACTIONS,
			triggerChange,
			value,
			fieldname,
			variantsSelected,
			actionsList,
			sublimeValue,
			selectAll,
			deselectAll,
			selectGroup,
			deselectGroup,
			setSelectionOfGroup,
			setSelectionOfAll,
			getSelectedItems,
			func,
			switch_instance_items_binding
		];
	}

	class Ui_list_select_buttons_with_groups extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$u, create_fragment$u, safe_not_equal, {
				fieldname: 12,
				variants: 0,
				variantsSelected: 13,
				value: 11,
				titleComponent: 1,
				titleComponentProps: 2,
				imageComponent: 3,
				imageComponentProps: 4,
				descriptionComponent: 5,
				descriptionComponentProps: 6,
				listComponent: 7,
				listComponentProps: 8,
				actionsList: 14,
				sublimeValue: 15,
				selectAll: 16,
				deselectAll: 17,
				selectGroup: 18,
				deselectGroup: 19,
				setSelectionOfGroup: 20,
				setSelectionOfAll: 21,
				getSelectedItems: 22
			});
		}

		get selectAll() {
			return this.$$.ctx[16];
		}

		get deselectAll() {
			return this.$$.ctx[17];
		}

		get selectGroup() {
			return this.$$.ctx[18];
		}

		get deselectGroup() {
			return this.$$.ctx[19];
		}

		get setSelectionOfGroup() {
			return this.$$.ctx[20];
		}

		get setSelectionOfAll() {
			return this.$$.ctx[21];
		}

		get getSelectedItems() {
			return this.$$.ctx[22];
		}
	}

	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIEndlessList: Ui_endless_list,
		UIEndlessListNavigation: Ui_endless_list_navigation,
		UIEndlessListSimpleItem: Ui_endless_list_simple_item,
		UIList: Ui_list,
		UIListEmptyPlaceholder: Ui_list_empty_placeholder,
		UIListItem: Ui_list_item,
		UIListSelect: Ui_list_select,
		UIListSelectButtonsWithGroups: Ui_list_select_buttons_with_groups,
		UIListSelectWithGroups: Ui_list_select_with_groups
	});

	/* node_modules/not-bulma/src/elements/modal/ui.overlay.svelte generated by Svelte v4.2.19 */

	function create_if_block$m(ctx) {
		let div;
		let t;
		let div_class_value;
		let div_transition;
		let current;
		let mounted;
		let dispose;
		let if_block = /*closeButton*/ ctx[0] && create_if_block_1$i(ctx);
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

		return {
			c() {
				div = element("div");
				if (if_block) if_block.c();
				t = space();
				if (default_slot) default_slot.c();
				attr(div, "class", div_class_value = "is-overlay not-overlay " + /*classes*/ ctx[4]);
				attr(div, "role", "button");
				attr(div, "tabindex", "0");
				set_style(div, "z-index", zIndexStep * /*layer*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
				append(div, t);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*overlayClick*/ ctx[5]),
						listen(div, "keyup", /*overlayClick*/ ctx[5])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (/*closeButton*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$i(ctx);
						if_block.c();
						if_block.m(div, t);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[9],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*classes*/ 16 && div_class_value !== (div_class_value = "is-overlay not-overlay " + /*classes*/ ctx[4])) {
					attr(div, "class", div_class_value);
				}

				if (!current || dirty & /*layer*/ 8) {
					set_style(div, "z-index", zIndexStep * /*layer*/ ctx[3]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
						div_transition.run(1);
					});
				}

				current = true;
			},
			o(local) {
				transition_out(default_slot, local);

				if (local) {
					if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
					div_transition.run(0);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block) if_block.d();
				if (default_slot) default_slot.d(detaching);
				if (detaching && div_transition) div_transition.end();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (76:8) {#if closeButton}
	function create_if_block_1$i(ctx) {
		let button;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				attr(button, "class", button_class_value = "delete is-" + /*closeSize*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, button, anchor);

				if (!mounted) {
					dispose = listen(button, "click", /*closeButtonClick*/ ctx[6]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*closeSize*/ 4 && button_class_value !== (button_class_value = "delete is-" + /*closeSize*/ ctx[2])) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$t(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*show*/ ctx[1] && create_if_block$m(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*show*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*show*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$m(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	const zIndexStep = 1000;

	function instance$t($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let overflowSave = "";
		const dispatch = createEventDispatcher();
		let { closeButton = false } = $$props;
		let { show = true } = $$props;
		let { closeOnClick = true } = $$props;
		let { closeSize = "normal" } = $$props;
		let { layer = 1 } = $$props;
		let { classes = "" } = $$props;

		function overlayClick(e) {
			if (closeOnClick) {
				closeOverlay(e);
			}
		}

		function closeButtonClick() {
			rejectOverlay();
		}

		function closeOverlay(e) {
			try {
				if (e && e.originalTarget) {
					const target = e.originalTarget;

					if (target.classList && target.classList.contains("is-overlay")) {
						rejectOverlay();
					}
				}
			} catch(_) {
				
			}
		}

		function rejectOverlay(data = {}) {
			dispatch("reject", data);
		}

		/*
		function resolveOverlay(data = {}) {
		  dispatch('resolve', data);
		}
	*/
		onMount(() => {
			$$invalidate(8, overflowSave = document.body.style.overflow);
		});

		onDestroy(() => {
			document.body.style.overflow = overflowSave;
		});

		$$self.$$set = $$props => {
			if ('closeButton' in $$props) $$invalidate(0, closeButton = $$props.closeButton);
			if ('show' in $$props) $$invalidate(1, show = $$props.show);
			if ('closeOnClick' in $$props) $$invalidate(7, closeOnClick = $$props.closeOnClick);
			if ('closeSize' in $$props) $$invalidate(2, closeSize = $$props.closeSize);
			if ('layer' in $$props) $$invalidate(3, layer = $$props.layer);
			if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
			if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*show, overflowSave*/ 258) {
				if (show) {
					document.body.style.overflow = "hidden";
				} else {
					document.body.style.overflow = overflowSave;
				}
			}
		};

		return [
			closeButton,
			show,
			closeSize,
			layer,
			classes,
			overlayClick,
			closeButtonClick,
			closeOnClick,
			overflowSave,
			$$scope,
			slots
		];
	}

	class Ui_overlay extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$t, create_fragment$t, safe_not_equal, {
				closeButton: 0,
				show: 1,
				closeOnClick: 7,
				closeSize: 2,
				layer: 3,
				classes: 4
			});
		}
	}

	/* node_modules/not-bulma/src/elements/modal/ui.modal.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$h(ctx) {
		let uibuttonsrow;
		let current;

		uibuttonsrow = new Ui_buttons_row({
				props: {
					left: /*closeButton*/ ctx[1] ? [/*closeButton*/ ctx[1]] : [],
					right: /*applyButton*/ ctx[2] ? [/*applyButton*/ ctx[2]] : []
				}
			});

		return {
			c() {
				create_component(uibuttonsrow.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttonsrow, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttonsrow_changes = {};
				if (dirty & /*closeButton*/ 2) uibuttonsrow_changes.left = /*closeButton*/ ctx[1] ? [/*closeButton*/ ctx[1]] : [];
				if (dirty & /*applyButton*/ 4) uibuttonsrow_changes.right = /*applyButton*/ ctx[2] ? [/*applyButton*/ ctx[2]] : [];
				uibuttonsrow.$set(uibuttonsrow_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttonsrow.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttonsrow.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttonsrow, detaching);
			}
		};
	}

	// (48:12) {#if buttonsPosition === "bottom"}
	function create_if_block$l(ctx) {
		let uibuttonsrow;
		let current;

		uibuttonsrow = new Ui_buttons_row({
				props: {
					left: /*closeButton*/ ctx[1] ? [/*closeButton*/ ctx[1]] : [],
					right: /*applyButton*/ ctx[2] ? [/*applyButton*/ ctx[2]] : []
				}
			});

		return {
			c() {
				create_component(uibuttonsrow.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttonsrow, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttonsrow_changes = {};
				if (dirty & /*closeButton*/ 2) uibuttonsrow_changes.left = /*closeButton*/ ctx[1] ? [/*closeButton*/ ctx[1]] : [];
				if (dirty & /*applyButton*/ 4) uibuttonsrow_changes.right = /*applyButton*/ ctx[2] ? [/*applyButton*/ ctx[2]] : [];
				uibuttonsrow.$set(uibuttonsrow_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttonsrow.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttonsrow.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttonsrow, detaching);
			}
		};
	}

	// (34:8) <UIContent>
	function create_default_slot_2(ctx) {
		let div;
		let span;
		let t0_value = /*$LOCALE*/ ctx[10][/*WAITING_TEXT*/ ctx[9]] + "";
		let t0;
		let div_class_value;
		let t1;
		let t2;
		let t3;
		let if_block1_anchor;
		let current;
		let if_block0 = /*buttonsPosition*/ ctx[0] === "top" && create_if_block_1$h(ctx);
		const default_slot_template = /*#slots*/ ctx[11].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
		let if_block1 = /*buttonsPosition*/ ctx[0] === "bottom" && create_if_block$l(ctx);

		return {
			c() {
				div = element("div");
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (default_slot) default_slot.c();
				t3 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(span, "class", "title");
				attr(div, "class", div_class_value = "pageloader " + (/*loading*/ ctx[4] ? 'is-active' : ''));
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, t0);
				insert(target, t1, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t2, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				insert(target, t3, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if ((!current || dirty & /*$LOCALE, WAITING_TEXT*/ 1536) && t0_value !== (t0_value = /*$LOCALE*/ ctx[10][/*WAITING_TEXT*/ ctx[9]] + "")) set_data(t0, t0_value);

				if (!current || dirty & /*loading*/ 16 && div_class_value !== (div_class_value = "pageloader " + (/*loading*/ ctx[4] ? 'is-active' : ''))) {
					attr(div, "class", div_class_value);
				}

				if (/*buttonsPosition*/ ctx[0] === "top") {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*buttonsPosition*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$h(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t2.parentNode, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[12],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
							null
						);
					}
				}

				if (/*buttonsPosition*/ ctx[0] === "bottom") {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*buttonsPosition*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$l(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(default_slot, local);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(default_slot, local);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t1);
					detach(t2);
					detach(t3);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (default_slot) default_slot.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	// (32:4) <UIBox {classes}>
	function create_default_slot_1$1(ctx) {
		let uititle;
		let t;
		let uicontent;
		let current;

		uititle = new Ui_title({
				props: {
					size: "2",
					title: /*$LOCALE*/ ctx[10][/*title*/ ctx[5]],
					subtitle: /*$LOCALE*/ ctx[10][/*subtitle*/ ctx[6]]
				}
			});

		uicontent = new Ui_content({
				props: {
					$$slots: { default: [create_default_slot_2] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uititle.$$.fragment);
				t = space();
				create_component(uicontent.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uititle, target, anchor);
				insert(target, t, anchor);
				mount_component(uicontent, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uititle_changes = {};
				if (dirty & /*$LOCALE, title*/ 1056) uititle_changes.title = /*$LOCALE*/ ctx[10][/*title*/ ctx[5]];
				if (dirty & /*$LOCALE, subtitle*/ 1088) uititle_changes.subtitle = /*$LOCALE*/ ctx[10][/*subtitle*/ ctx[6]];
				uititle.$set(uititle_changes);
				const uicontent_changes = {};

				if (dirty & /*$$scope, closeButton, applyButton, buttonsPosition, loading, $LOCALE, WAITING_TEXT*/ 5655) {
					uicontent_changes.$$scope = { dirty, ctx };
				}

				uicontent.$set(uicontent_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uititle.$$.fragment, local);
				transition_in(uicontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uititle.$$.fragment, local);
				transition_out(uicontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}

				destroy_component(uititle, detaching);
				destroy_component(uicontent, detaching);
			}
		};
	}

	// (26:0) <UIOverlay     {show}     closeOnClick={false}     closeButton={false}     classes={overlayClasses} >
	function create_default_slot$3(ctx) {
		let uibox;
		let current;

		uibox = new Ui_box({
				props: {
					classes: /*classes*/ ctx[7],
					$$slots: { default: [create_default_slot_1$1] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uibox.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibox, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibox_changes = {};
				if (dirty & /*classes*/ 128) uibox_changes.classes = /*classes*/ ctx[7];

				if (dirty & /*$$scope, closeButton, applyButton, buttonsPosition, loading, $LOCALE, WAITING_TEXT, title, subtitle*/ 5751) {
					uibox_changes.$$scope = { dirty, ctx };
				}

				uibox.$set(uibox_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibox.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibox.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibox, detaching);
			}
		};
	}

	function create_fragment$s(ctx) {
		let uioverlay;
		let current;

		uioverlay = new Ui_overlay({
				props: {
					show: /*show*/ ctx[3],
					closeOnClick: false,
					closeButton: false,
					classes: /*overlayClasses*/ ctx[8],
					$$slots: { default: [create_default_slot$3] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uioverlay.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uioverlay, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uioverlay_changes = {};
				if (dirty & /*show*/ 8) uioverlay_changes.show = /*show*/ ctx[3];
				if (dirty & /*overlayClasses*/ 256) uioverlay_changes.classes = /*overlayClasses*/ ctx[8];

				if (dirty & /*$$scope, classes, closeButton, applyButton, buttonsPosition, loading, $LOCALE, WAITING_TEXT, title, subtitle*/ 5879) {
					uioverlay_changes.$$scope = { dirty, ctx };
				}

				uioverlay.$set(uioverlay_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uioverlay.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uioverlay.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uioverlay, detaching);
			}
		};
	}

	function instance$s($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(10, $LOCALE = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		let { buttonsPosition = "bottom" } = $$props;
		let { closeButton = false } = $$props;
		let { applyButton = false } = $$props;
		let { show = false } = $$props;
		let { loading = false } = $$props;
		let { title = "Modal window" } = $$props;
		let { subtitle = "" } = $$props;
		let { classes = "" } = $$props;
		let { overlayClasses = "" } = $$props;
		let { WAITING_TEXT = "Обработка" } = $$props;

		$$self.$$set = $$props => {
			if ('buttonsPosition' in $$props) $$invalidate(0, buttonsPosition = $$props.buttonsPosition);
			if ('closeButton' in $$props) $$invalidate(1, closeButton = $$props.closeButton);
			if ('applyButton' in $$props) $$invalidate(2, applyButton = $$props.applyButton);
			if ('show' in $$props) $$invalidate(3, show = $$props.show);
			if ('loading' in $$props) $$invalidate(4, loading = $$props.loading);
			if ('title' in $$props) $$invalidate(5, title = $$props.title);
			if ('subtitle' in $$props) $$invalidate(6, subtitle = $$props.subtitle);
			if ('classes' in $$props) $$invalidate(7, classes = $$props.classes);
			if ('overlayClasses' in $$props) $$invalidate(8, overlayClasses = $$props.overlayClasses);
			if ('WAITING_TEXT' in $$props) $$invalidate(9, WAITING_TEXT = $$props.WAITING_TEXT);
			if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
		};

		return [
			buttonsPosition,
			closeButton,
			applyButton,
			show,
			loading,
			title,
			subtitle,
			classes,
			overlayClasses,
			WAITING_TEXT,
			$LOCALE,
			slots,
			$$scope
		];
	}

	class Ui_modal extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$s, create_fragment$s, safe_not_equal, {
				buttonsPosition: 0,
				closeButton: 1,
				applyButton: 2,
				show: 3,
				loading: 4,
				title: 5,
				subtitle: 6,
				classes: 7,
				overlayClasses: 8,
				WAITING_TEXT: 9
			});
		}
	}

	/* node_modules/not-bulma/src/elements/modal/ui.generic.selector.svelte generated by Svelte v4.2.19 */

	function create_default_slot$2(ctx) {
		let div;
		let switch_instance0;
		let updating_term;
		let t0;
		let switch_instance1;
		let updating_data;
		let t1;
		let uibuttons;
		let div_class_value;
		let current;
		const switch_instance0_spread_levels = [/*inputComponentProps*/ ctx[5]];

		function switch_instance0_term_binding(value) {
			/*switch_instance0_term_binding*/ ctx[11](value);
		}

		var switch_value = /*inputComponent*/ ctx[4];

		function switch_props(ctx, dirty) {
			let switch_instance0_props = {};

			for (let i = 0; i < switch_instance0_spread_levels.length; i += 1) {
				switch_instance0_props = assign(switch_instance0_props, switch_instance0_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*inputComponentProps*/ 32) {
				switch_instance0_props = assign(switch_instance0_props, get_spread_update(switch_instance0_spread_levels, [get_spread_object(/*inputComponentProps*/ ctx[5])]));
			}

			if (/*term*/ ctx[0] !== void 0) {
				switch_instance0_props.term = /*term*/ ctx[0];
			}

			return { props: switch_instance0_props };
		}

		if (switch_value) {
			switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance0, 'term', switch_instance0_term_binding));
			switch_instance0.$on("termChange", /*termChange_handler*/ ctx[12]);
		}

		const switch_instance1_spread_levels = [/*outputComponentProps*/ ctx[7]];

		function switch_instance1_data_binding(value) {
			/*switch_instance1_data_binding*/ ctx[13](value);
		}

		var switch_value_1 = /*outputComponent*/ ctx[6];

		function switch_props_1(ctx, dirty) {
			let switch_instance1_props = {};

			for (let i = 0; i < switch_instance1_spread_levels.length; i += 1) {
				switch_instance1_props = assign(switch_instance1_props, switch_instance1_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*outputComponentProps*/ 128) {
				switch_instance1_props = assign(switch_instance1_props, get_spread_update(switch_instance1_spread_levels, [get_spread_object(/*outputComponentProps*/ ctx[7])]));
			}

			if (/*results*/ ctx[1] !== void 0) {
				switch_instance1_props.data = /*results*/ ctx[1];
			}

			return { props: switch_instance1_props };
		}

		if (switch_value_1) {
			switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
			binding_callbacks.push(() => bind(switch_instance1, 'data', switch_instance1_data_binding));
			switch_instance1.$on("prev", /*prev_handler*/ ctx[14]);
			switch_instance1.$on("next", /*next_handler*/ ctx[15]);
			switch_instance1.$on("select", /*select*/ ctx[10]);
		}

		uibuttons = new Ui_buttons({
				props: {
					values: /*buttons*/ ctx[8],
					centered: true,
					classes: "mt-5"
				}
			});

		return {
			c() {
				div = element("div");
				if (switch_instance0) create_component(switch_instance0.$$.fragment);
				t0 = space();
				if (switch_instance1) create_component(switch_instance1.$$.fragment);
				t1 = space();
				create_component(uibuttons.$$.fragment);
				attr(div, "class", div_class_value = "paper box block " + /*size*/ ctx[3] + " svelte-1gllhdk");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (switch_instance0) mount_component(switch_instance0, div, null);
				append(div, t0);
				if (switch_instance1) mount_component(switch_instance1, div, null);
				append(div, t1);
				mount_component(uibuttons, div, null);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*inputComponent*/ 16 && switch_value !== (switch_value = /*inputComponent*/ ctx[4])) {
					if (switch_instance0) {
						group_outros();
						const old_component = switch_instance0;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance0, 'term', switch_instance0_term_binding));
						switch_instance0.$on("termChange", /*termChange_handler*/ ctx[12]);
						create_component(switch_instance0.$$.fragment);
						transition_in(switch_instance0.$$.fragment, 1);
						mount_component(switch_instance0, div, t0);
					} else {
						switch_instance0 = null;
					}
				} else if (switch_value) {
					const switch_instance0_changes = (dirty & /*inputComponentProps*/ 32)
					? get_spread_update(switch_instance0_spread_levels, [get_spread_object(/*inputComponentProps*/ ctx[5])])
					: {};

					if (!updating_term && dirty & /*term*/ 1) {
						updating_term = true;
						switch_instance0_changes.term = /*term*/ ctx[0];
						add_flush_callback(() => updating_term = false);
					}

					switch_instance0.$set(switch_instance0_changes);
				}

				if (dirty & /*outputComponent*/ 64 && switch_value_1 !== (switch_value_1 = /*outputComponent*/ ctx[6])) {
					if (switch_instance1) {
						group_outros();
						const old_component = switch_instance1;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value_1) {
						switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx, dirty));
						binding_callbacks.push(() => bind(switch_instance1, 'data', switch_instance1_data_binding));
						switch_instance1.$on("prev", /*prev_handler*/ ctx[14]);
						switch_instance1.$on("next", /*next_handler*/ ctx[15]);
						switch_instance1.$on("select", /*select*/ ctx[10]);
						create_component(switch_instance1.$$.fragment);
						transition_in(switch_instance1.$$.fragment, 1);
						mount_component(switch_instance1, div, t1);
					} else {
						switch_instance1 = null;
					}
				} else if (switch_value_1) {
					const switch_instance1_changes = (dirty & /*outputComponentProps*/ 128)
					? get_spread_update(switch_instance1_spread_levels, [get_spread_object(/*outputComponentProps*/ ctx[7])])
					: {};

					if (!updating_data && dirty & /*results*/ 2) {
						updating_data = true;
						switch_instance1_changes.data = /*results*/ ctx[1];
						add_flush_callback(() => updating_data = false);
					}

					switch_instance1.$set(switch_instance1_changes);
				}

				if (!current || dirty & /*size*/ 8 && div_class_value !== (div_class_value = "paper box block " + /*size*/ ctx[3] + " svelte-1gllhdk")) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
				if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
				if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (switch_instance0) destroy_component(switch_instance0);
				if (switch_instance1) destroy_component(switch_instance1);
				destroy_component(uibuttons);
			}
		};
	}

	function create_fragment$r(ctx) {
		let uioverlay;
		let current;

		uioverlay = new Ui_overlay({
				props: {
					show: /*show*/ ctx[2],
					closeOnClick: true,
					closeButton: false,
					$$slots: { default: [create_default_slot$2] },
					$$scope: { ctx }
				}
			});

		uioverlay.$on("reject", /*overlayClosed*/ ctx[9]);

		return {
			c() {
				create_component(uioverlay.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uioverlay, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uioverlay_changes = {};
				if (dirty & /*show*/ 4) uioverlay_changes.show = /*show*/ ctx[2];

				if (dirty & /*$$scope, size, outputComponent, outputComponentProps, results, inputComponent, inputComponentProps, term*/ 524539) {
					uioverlay_changes.$$scope = { dirty, ctx };
				}

				uioverlay.$set(uioverlay_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uioverlay.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uioverlay.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uioverlay, detaching);
			}
		};
	}

	function instance$r($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(16, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { show = true } = $$props;
		let { term = '' } = $$props;
		let { size = 'narrow' } = $$props;
		let { inputComponent = Ui_simple_search_input } = $$props;
		let { inputComponentProps = {} } = $$props;
		let { outputComponent = Ui_endless_list } = $$props;
		let { outputComponentProps = {} } = $$props;

		let { results = {
			list: [],
			page: 0,
			pages: 0,
			skip: 0,
			count: 0
		} } = $$props;

		onMount(() => {
			
		});

		const buttons = [
			{
				title: $LOCALE['not-node:button_cancel_label'],
				action: () => reject()
			}
		];

		function overlayClosed() {
			dispatch('reject');
		}

		function select({ detail }) {
			console.log('selected user', detail);
			dispatch('resolve', detail);
		}

		function reject() {
			dispatch('reject');
		}

		function switch_instance0_term_binding(value) {
			term = value;
			$$invalidate(0, term);
		}

		function termChange_handler(event) {
			bubble.call(this, $$self, event);
		}

		function switch_instance1_data_binding(value) {
			results = value;
			$$invalidate(1, results);
		}

		function prev_handler(event) {
			bubble.call(this, $$self, event);
		}

		function next_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('show' in $$props) $$invalidate(2, show = $$props.show);
			if ('term' in $$props) $$invalidate(0, term = $$props.term);
			if ('size' in $$props) $$invalidate(3, size = $$props.size);
			if ('inputComponent' in $$props) $$invalidate(4, inputComponent = $$props.inputComponent);
			if ('inputComponentProps' in $$props) $$invalidate(5, inputComponentProps = $$props.inputComponentProps);
			if ('outputComponent' in $$props) $$invalidate(6, outputComponent = $$props.outputComponent);
			if ('outputComponentProps' in $$props) $$invalidate(7, outputComponentProps = $$props.outputComponentProps);
			if ('results' in $$props) $$invalidate(1, results = $$props.results);
		};

		return [
			term,
			results,
			show,
			size,
			inputComponent,
			inputComponentProps,
			outputComponent,
			outputComponentProps,
			buttons,
			overlayClosed,
			select,
			switch_instance0_term_binding,
			termChange_handler,
			switch_instance1_data_binding,
			prev_handler,
			next_handler
		];
	}

	class Ui_generic_selector extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$r, create_fragment$r, safe_not_equal, {
				show: 2,
				term: 0,
				size: 3,
				inputComponent: 4,
				inputComponentProps: 5,
				outputComponent: 6,
				outputComponentProps: 7,
				results: 1
			});
		}
	}

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIGenericSelector: Ui_generic_selector,
		UIModal: Ui_modal,
		UIOverlay: Ui_overlay
	});

	/* node_modules/not-bulma/src/elements/notification/ui.error.svelte generated by Svelte v4.2.19 */

	function create_fragment$q(ctx) {
		let article;
		let div0;
		let p;
		let t0_value = /*$LOCALE*/ ctx[2][/*title*/ ctx[1]] + "";
		let t0;
		let t1;
		let div1;
		let t2_value = /*$LOCALE*/ ctx[2][/*message*/ ctx[0]] + "";
		let t2;

		return {
			c() {
				article = element("article");
				div0 = element("div");
				p = element("p");
				t0 = text(t0_value);
				t1 = space();
				div1 = element("div");
				t2 = text(t2_value);
				attr(div0, "class", "message-header");
				attr(div1, "class", "message-body");
				attr(article, "class", "message is-danger");
			},
			m(target, anchor) {
				insert(target, article, anchor);
				append(article, div0);
				append(div0, p);
				append(p, t0);
				append(article, t1);
				append(article, div1);
				append(div1, t2);
			},
			p(ctx, [dirty]) {
				if (dirty & /*$LOCALE, title*/ 6 && t0_value !== (t0_value = /*$LOCALE*/ ctx[2][/*title*/ ctx[1]] + "")) set_data(t0, t0_value);
				if (dirty & /*$LOCALE, message*/ 5 && t2_value !== (t2_value = /*$LOCALE*/ ctx[2][/*message*/ ctx[0]] + "")) set_data(t2, t2_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(article);
				}
			}
		};
	}

	function instance$q($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		let { message } = $$props;
		let { title } = $$props;

		$$self.$$set = $$props => {
			if ('message' in $$props) $$invalidate(0, message = $$props.message);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
		};

		return [message, title, $LOCALE];
	}

	class Ui_error extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$q, create_fragment$q, safe_not_equal, { message: 0, title: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/notification/ui.success.svelte generated by Svelte v4.2.19 */

	function create_fragment$p(ctx) {
		let article;
		let div0;
		let p;
		let t0_value = /*$LOCALE*/ ctx[2][/*title*/ ctx[1]] + "";
		let t0;
		let t1;
		let div1;
		let t2_value = /*$LOCALE*/ ctx[2][/*message*/ ctx[0]] + "";
		let t2;

		return {
			c() {
				article = element("article");
				div0 = element("div");
				p = element("p");
				t0 = text(t0_value);
				t1 = space();
				div1 = element("div");
				t2 = text(t2_value);
				attr(div0, "class", "message-header");
				attr(div1, "class", "message-body");
				attr(article, "class", "message is-success");
			},
			m(target, anchor) {
				insert(target, article, anchor);
				append(article, div0);
				append(div0, p);
				append(p, t0);
				append(article, t1);
				append(article, div1);
				append(div1, t2);
			},
			p(ctx, [dirty]) {
				if (dirty & /*$LOCALE, title*/ 6 && t0_value !== (t0_value = /*$LOCALE*/ ctx[2][/*title*/ ctx[1]] + "")) set_data(t0, t0_value);
				if (dirty & /*$LOCALE, message*/ 5 && t2_value !== (t2_value = /*$LOCALE*/ ctx[2][/*message*/ ctx[0]] + "")) set_data(t2, t2_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(article);
				}
			}
		};
	}

	function instance$p($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		let { message } = $$props;
		let { title } = $$props;

		$$self.$$set = $$props => {
			if ('message' in $$props) $$invalidate(0, message = $$props.message);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
		};

		return [message, title, $LOCALE];
	}

	class Ui_success extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$p, create_fragment$p, safe_not_equal, { message: 0, title: 1 });
		}
	}

	/* node_modules/not-bulma/src/elements/notification/ui.cookie.notification.svelte generated by Svelte v4.2.19 */

	function create_if_block$k(ctx) {
		let div;
		let p;
		let t0_value = /*$LOCALE*/ ctx[3][/*message*/ ctx[1]] + "";
		let t0;
		let t1;
		let button;
		let t2_value = /*$LOCALE*/ ctx[3][/*agree*/ ctx[2]] + "";
		let t2;
		let mounted;
		let dispose;

		return {
			c() {
				div = element("div");
				p = element("p");
				t0 = text(t0_value);
				t1 = space();
				button = element("button");
				t2 = text(t2_value);
				attr(p, "class", "svelte-19d5xat");
				attr(button, "class", "button is-success cookie_accept svelte-19d5xat");
				attr(div, "id", "cookie_notification");
				attr(div, "class", "svelte-19d5xat");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, p);
				append(p, t0);
				append(div, t1);
				append(div, button);
				append(button, t2);

				if (!mounted) {
					dispose = listen(button, "click", /*accept*/ ctx[4]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, message*/ 10 && t0_value !== (t0_value = /*$LOCALE*/ ctx[3][/*message*/ ctx[1]] + "")) set_data(t0, t0_value);
				if (dirty & /*$LOCALE, agree*/ 12 && t2_value !== (t2_value = /*$LOCALE*/ ctx[3][/*agree*/ ctx[2]] + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$o(ctx) {
		let if_block_anchor;
		let if_block = /*show*/ ctx[0] && create_if_block$k(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*show*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$k(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$o($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { show = false } = $$props;
		let { message = 'Для улучшения работы сайта и его взаимодействия с пользователями мы используем файлы cookie. Продолжая работу с сайтом, Вы разрешаете использование cookie-файлов. Вы всегда можете отключить файлы cookie в настройках Вашего браузера.' } = $$props;
		let { agree = 'Хорошо' } = $$props;

		onMount(() => {
			let cookieDate = localStorage.getItem('cookie_date');

			if (!cookieDate || +cookieDate + 31536000000 < Date.now()) {
				$$invalidate(0, show = true);
			}
		});

		function accept() {
			localStorage.setItem('cookie_date', Date.now());
			$$invalidate(0, show = false);
		}

		$$self.$$set = $$props => {
			if ('show' in $$props) $$invalidate(0, show = $$props.show);
			if ('message' in $$props) $$invalidate(1, message = $$props.message);
			if ('agree' in $$props) $$invalidate(2, agree = $$props.agree);
		};

		return [show, message, agree, $LOCALE, accept];
	}

	class Ui_cookie_notification extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$o, create_fragment$o, safe_not_equal, { show: 0, message: 1, agree: 2 });
		}
	}

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UICookieNotification: Ui_cookie_notification,
		UIError: Ui_error,
		UISuccess: Ui_success
	});

	//block elements

	var Elements = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Blocks: index$b,
		Buttons: index$a,
		Forms: index$7,
		Icons: index$6,
		Images: index$5,
		Layouts: index$8,
		Links: index$4,
		Lists: index$3,
		Modals: index$2,
		Notifications: index$1,
		UICommon: UICommon$1,
		Various: index$9
	});

	const META_METHOD_INIT = Symbol("init"),
	    META_DATA = Symbol("data"),
	    META_WORKING = Symbol("working"),
	    META_OPTIONS = Symbol("options");

	let notBase$1 = class notBase extends EventEmitter {
	    constructor(input) {
	        super();
	        this[META_DATA] = {};
	        this[META_WORKING] = {};
	        this[META_OPTIONS] = {};
	        this[META_METHOD_INIT](input);
	        return this;
	    }

	    [META_METHOD_INIT](input) {
	        if (!input) {
	            input = {};
	        }

	        if (Object.hasOwn(input, "data")) {
	            this.setData(input.data);
	        }

	        if (Object.hasOwn(input, "working")) {
	            this.setWorking(input.working);
	        }

	        if (Object.hasOwn(input, "options")) {
	            this.setOptions(input.options);
	        }

	        this.log = notCommon$3.genLogMsg(this.getWorking("name"));
	        this.info = this.log;
	        this.debug = notCommon$3.genLogDebug(this.getWorking("name"));
	        this.error = notCommon$3.genLogError(this.getWorking("name"));
	    }

	    setCommon(what, args) {
	        switch (args.length) {
	            case 1: {
	                /* set collection */
	                what = args[0];
	                break;
	            }
	            case 2: {
	                /* set collection element */
	                notPath$1.set(
	                    args[0] /* path */,
	                    what /* collection */,
	                    undefined /* helpers */,
	                    args[1] /* value */
	                );
	                break;
	            }
	        }
	        return this;
	    }
	    getCommon(what, args) {
	        switch (args.length) {
	            /* if we want get data by path */
	            case 1: {
	                return notPath$1.get(args[0], what);
	            }
	            /* if we want get data by path with default value */
	            case 2: {
	                let res = notPath$1.get(args[0], what);
	                if (res === undefined) {
	                    /* no data, return default value */
	                    return args[1];
	                } else {
	                    /* data, return it */
	                    return res;
	                }
	            }
	            /* return full collection */
	            default: {
	                return what;
	            }
	        }
	    }

	    /*
	    CORE OBJECT
	      DATA - information
	      OPTIONS - how to work
	      WORKING - temporarily generated in proccess
	  */

	    setData() {
	        if (arguments.length === 1) {
	            this[META_DATA] = arguments[0];
	        } else {
	            this.setCommon(this.getData(), arguments);
	        }
	        this.emit("change");
	        return this;
	    }

	    getData() {
	        return this.getCommon(this[META_DATA], arguments);
	    }

	    setOptions() {
	        if (arguments.length === 1) {
	            this[META_OPTIONS] = arguments[0];
	        } else {
	            this.setCommon(this.getOptions(), arguments);
	        }
	        return this;
	    }

	    getOptions() {
	        return this.getCommon(this[META_OPTIONS], arguments);
	    }

	    setWorking() {
	        if (arguments.length === 1) {
	            this[META_WORKING] = arguments[0];
	        } else {
	            this.setCommon(this.getWorking(), arguments);
	        }
	        return this;
	    }

	    getWorking() {
	        return this.getCommon(this[META_WORKING], arguments);
	    }

	    report(e) {
	        if (notCommon$3.report) {
	            notCommon$3.report(e);
	        }
	    }

	    getApp() {
	        return notCommon$3.getApp();
	    }

	    destroy() {
	        this.removeEvent();
	        this.setOptions(null);
	        this.setWorking(null);
	        this.setData(null);
	        this.emit("destroy");
	    }
	};

	const OPT_MODE_HISTORY = Symbol("history"),
	    OPT_MODE_HASH = Symbol("hash"),
	    OPT_DEFAULT_CHECK_INTERVAL = 50;

	class notRouter extends notBase$1 {
	    host = "";
	    constructor() {
	        super({
	            working: {
	                routes: [],
	                mode: OPT_MODE_HISTORY,
	                root: "/", //always in slashes /user/, /, /input/. and no /user or input/level
	                initialized: false,
	                delays: NAVIGATION_DELAYS,
	                delay_default: NAVIGATION_DELAY_DEFAULT,
	            },
	        });
	        return this;
	    }

	    /**
	     * Set object with named delays
	     * @param {Object.<string, number>} delays
	     * @returns {notRouter}
	     */
	    setDelays(delays) {
	        this.setWorking("delays", delays);
	        return this;
	    }

	    /**
	     * Set default navigation delay, provided as name of one of `delays` or in number form
	     * @param {string|number} delay
	     * @returns {notRouter}
	     */
	    setDefaultNavigationDelay(delay) {
	        this.setWorking("delay_default", this.delayAsMs(delay));
	        return this;
	    }

	    /**
	     * Returns number of ms, if not set returns NAVIGATION_DELAY_DEFAULT
	     * @returns {number}
	     */
	    getDefaultNavigationDelay() {
	        return this.getWorking(`delay_default`, NAVIGATION_DELAY_DEFAULT);
	    }

	    /**
	     *  Ensures that delay is in ms, if its provided as name of alias, searches for it and returns, if not found - returns working default_delay
	     * @param {string|number} delay    name of delay alias or number of ms
	     * @returns {number}               delay in ms
	     */
	    delayAsMs(delay) {
	        if (typeof delay === "number") {
	            return delay;
	        } else {
	            if (typeof delay === "string" && delay.length > 0) {
	                return this.getWorking(
	                    `delays.${delay}`,
	                    this.getDefaultNavigationDelay()
	                );
	            } else {
	                return this.getDefaultNavigationDelay();
	            }
	        }
	    }

	    /**
	     *
	     *  @param {string}              url     we go to url
	     *  @param {string|number}       delay   name of delay alias or number of ms
	     *  @returns {NodeJS.Timeout}            timeout identificator
	     */
	    navigateWithDelay(url, delay, doBefore) {
	        return setTimeout(() => {
	            typeof doBefore === "function" && doBefore();
	            this.navigate(url);
	        }, this.delayAsMs(delay));
	    }

	    /**
	     * Use browser History API
	     */
	    history() {
	        this.setWorking("mode", OPT_MODE_HISTORY);
	    }

	    /**
	     * Use hash part as container for location information
	     */
	    hash() {
	        this.setWorking("mode", OPT_MODE_HASH);
	    }

	    /**
	     * root should start and end with
	     * @param {string} root
	     * @returns {notRouter}
	     */
	    setRoot(root) {
	        this.setWorking(
	            "root",
	            root && root !== "/" ? "/" + this.clearSlashes(root) + "/" : "/"
	        );
	        return this;
	    }

	    /**
	     * clear first and last slashes from string
	     * @param {string} path
	     * @returns {string}
	     */
	    clearSlashes(path) {
	        return path.toString().replace(/\/$/, "").replace(/^\//, "");
	    }

	    add(re, handler) {
	        if (typeof re == "function") {
	            handler = re;
	            re = "";
	        }
	        let rule = {
	            re: re,
	            handler: handler,
	        };
	        this.getWorking("routes").push(rule);
	        return this;
	    }

	    addList(list) {
	        for (let t in list) {
	            this.add(t, list[t]);
	        }
	        return this;
	    }

	    remove(param) {
	        for (
	            var i = 0, r;
	            i < this.getWorking("routes").length,
	                (r = this.getWorking("routes")[i]);
	            i++
	        ) {
	            if (r.handler === param || r.re === param) {
	                this.getWorking("routes").splice(i, 1);
	                return this;
	            }
	        }
	        return this;
	    }

	    flush() {
	        this.setWorking({
	            routes: [],
	            mode: OPT_MODE_HISTORY,
	            root: "/",
	        });
	        return this;
	    }

	    isInitialized() {
	        return this.getWorking("initialized");
	    }

	    setInitialized(val = true) {
	        return this.setWorking("initialized", val);
	    }

	    getFragment() {
	        var fragment = "";
	        if (this.getWorking("mode") === OPT_MODE_HISTORY) {
	            if (!location) return "";
	            fragment = this.clearSlashes(
	                decodeURI(location.pathname + location.search)
	            );
	            fragment = fragment.replace(/\?(.*)$/, "");
	            fragment =
	                this.getWorking("root") != "/"
	                    ? fragment.replace(this.getWorking("root"), "")
	                    : fragment;
	        } else {
	            if (!window) return "";
	            var match = window.location.href.match(/#(.*)$/);
	            fragment = match ? match[1] : "";
	        }
	        return this.clearSlashes(fragment);
	    }

	    checkLocation() {
	        let current = this.getWorking("current"),
	            fragment = this.getFragment(),
	            init = this.isInitialized();
	        if (current !== fragment || !init) {
	            this.setWorking("current", fragment);
	            this.check(fragment);
	            this.setInitialized(true);
	        }
	    }

	    hrefClick() {
	        //console.log(...arguments);
	    }

	    getRoot() {
	        return this.getWorking("root");
	    }

	    listen(loopInterval = OPT_DEFAULT_CHECK_INTERVAL) {
	        this.setWorking("current", "notInitialized");
	        clearInterval(this.getWorking("interval"));
	        this.setWorking(
	            "interval",
	            setInterval(this.checkLocation.bind(this), loopInterval)
	        );
	        window.addEventListener("popstate", this.hrefClick.bind(this));
	        return this;
	    }

	    check(f) {
	        let fragment = f || this.getFragment(),
	            failBack = null;
	        for (let i = 0; i < this.getWorking("routes").length; i++) {
	            let path =
	                    this.getWorking("root") + this.getWorking("routes")[i].re,
	                fullRE = this.clearSlashes(decodeURI(path)),
	                match = fragment.match(fullRE);
	            if (match && match.length) {
	                if (fullRE === "") {
	                    match.shift();
	                    failBack = {
	                        route: this.getWorking("routes")[i],
	                        match,
	                    };
	                } else {
	                    match.shift();
	                    this.getWorking("routes")[i].handler.apply(
	                        this.host || {},
	                        match
	                    );
	                    this.emit("afterRoute", this.getWorking("routes")[i]);
	                    return this;
	                }
	            }
	        }
	        if (failBack) {
	            failBack.route.handler.apply(this.host || {}, failBack.match);
	            this.emit("afterRoute", failBack.route);
	        }
	        return this;
	    }

	    /**
	     *  Refreshes page
	     * @param {number} timeout time to wait in ms
	     */
	    refresh(timeout = 0) {
	        if (timeout > 0) {
	            setTimeout(() => this.refresh(), timeout);
	        } else {
	            this.check(this.getWorking("current"));
	        }
	    }

	    /**
	     * Changes locations
	     * @param {string} path
	     * @returns
	     */
	    navigate(path) {
	        path = path ? path : "";
	        switch (this.getWorking("mode")) {
	            case OPT_MODE_HISTORY: {
	                const newRoute = this.getFullRoute(path);
	                if (newRoute === this.lastRoute) {
	                    this.refresh();
	                } else {
	                    this.lastRoute = newRoute;
	                    history.pushState(null, "", this.lastRoute);
	                }
	                break;
	            }
	            case OPT_MODE_HASH: {
	                window.location.href.match(/#(.*)$/);
	                window.location.href =
	                    window.location.href.replace(/#(.*)$/, "") + "#" + path;
	                break;
	            }
	        }
	        return this;
	    }

	    /**
	     *  returns app root + path
	     * @param {string} path
	     * @returns {string}
	     */
	    getFullRoute(path = "") {
	        path = this.clearSlashes(path);
	        const root = this.getWorking("root");
	        if (root !== "/") {
	            if (path.indexOf(root.substring(1)) === 0) {
	                return "/" + path;
	            }
	        }
	        return this.getWorking("root") + this.clearSlashes(path);
	    }

	    /**
	     * Returns all links with n-href attribute
	     * @returns {Array<HTMLAnchorElement>}
	     */
	    getAllLinks() {
	        const allElements = document.body.querySelectorAll("a");
	        let list = [];
	        for (let j = 0; j < allElements.length; j++) {
	            for (
	                let i = 0, atts = allElements[j].attributes, n = atts.length;
	                i < n;
	                i++
	            ) {
	                if (atts[i].nodeName.indexOf("n-href") === 0) {
	                    list.push(allElements[j]);
	                    break;
	                }
	            }
	        }
	        return list;
	    }

	    /**
	     * Reroute all links(anchor tags) with n-href attribute.
	     * Disable navigation to href.
	     * @returns {notRouter}
	     */
	    reRouteExisted() {
	        const list = this.getAllLinks();
	        for (let t = 0; t < list.length; t++) {
	            this.initRerouting(list[t], list[t].getAttribute("n-href"));
	        }
	        return this;
	    }

	    /**
	     * If `el` is not initialized, adds onclick listener to navigate to `link` location.
	     * Disables default navigation to href.
	     * @param {HTMLAnchorElement}   el
	     * @param {string}              link
	     * @returns
	     */
	    initRerouting(el, link) {
	        // @ts-ignore
	        if (!el.notRouterInitialized) {
	            let fullLink = this.getFullRoute(link);
	            el.setAttribute("href", fullLink);
	            el.addEventListener("click", (e) => {
	                e.preventDefault();
	                this.navigate(link);
	                return false;
	            });
	            // @ts-ignore
	            el.notRouterInitialized = true;
	        }
	        return this;
	    }
	}

	var notRouter$1 = new notRouter();

	const LOG_PREFIX$1 = 'APIQuee';

	class notAPIQueue extends notBase$1{
	  static QUEUE_CHECK_INTERVAL    = 100;

	  static MAX_BUSY_TIME = 300;

	  constructor(options = {}){
	    super({
	      working:{
	        name: options.name?options.name:LOG_PREFIX$1
	      },
	      options
	    });
	    this.busy = false;
	    this.queue = [];
	    this.busySince = false;
	    this.afterEmpty = null;
	    this.start();
	    return this;
	  }

	  stop(){
	    if(this.interval){
	      clearInterval(this.interval);
	      this.interval = undefined;
	      this.busy = false;
	      this.busySince = false;
	    }
	  }

	  start(){
	    this.stop();
	    this.interval = setInterval(this.checkQueue.bind(this), this.QUEUE_CHECK_INTERVAL);
	  }

	  checkQueue(){
	    if(!this.isEmpty() && !this.isBusy()){
	      this.setBusy()
	        .runNext()
	        .then(this.setFree.bind(this))
	        .catch((e)=>{
	          this.error(e);
	          this.setFree();
	        });
	    }else {
	      if(!this.isBusy()){
	        if(this.afterEmpty){
	          let t = this.afterEmpty;
	          this.afterEmpty = null;
	          t();
	        }
	      }
	    }
	  }

	  addToQueue(task){
	    this.queue.push(task);
	  }

	  runNext(){
	    let list = this.queue.map(action=>action.title).join(', ');
	    this.debug(`tasks [${list}]` );
	    let task = this.queue.shift();
	    if (!notCommon$3.isFunc(task.action)){
	      this.error('В задании нет исполнимой части, action не функция', task.title);
	      return Promise.resolve();
	    }

	    if (!notCommon$3.isFunc(task.resolve)){
	      this.error('В задании нет возвратной части, resolve не функция', task.title);
	      return task.action();
	    }
	    return task.action().then(task.resolve);
	  }

	  isBusy(){
	    let busy = !!this.busy,
	      now = Date.now() / 1000;
	    if(busy){
	      if(now - this.busySince > this.MAX_BUSY_TIME){
	        this.setFree();
	        return false;
	      }else {
	        return true;
	      }
	    }else {
	      return false;
	    }
	  }

	  setBusy(){
	    this.busy = true;
	    this.busySince = Date.now() / 1000;
	    return this;
	  }

	  setFree(){
	    this.busy = false;
	    this.busySince = false;
	    return this;
	  }

	  isEmpty(){
	    return this.queue.length === 0;
	  }

	  /**
	  * Исполнитель запросов
	  * @param      {function}   action      должна возвращать Promise
	  * @param      {function}   afterEmpty  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	  * @returns    {Promise}  результат функции
	  **/
	  run(action, afterEmpty = null, title = ''){
	    if(afterEmpty && this.afterEmpty === null){
	      this.afterEmpty = afterEmpty;
	    }
	    return new Promise((resolve, reject)=>{
	      try{
	        this.addToQueue({action, resolve, title});
	      }catch(e){
	        this.error(e);
	        reject(e);
	      }
	    });
	  }

	  actionIsQueued(title){
	    return this.queue.some(queued => queued.title == title);
	  }

	  runIfNotQueued(action, afterEmpty = null, title = ''){
	    if(this.actionIsQueued(title)){
	      return Promise.resolve();
	    }else {
	      this.run(action, afterEmpty, title);
	    }
	  }
	}

	let notAPIOptions = {
	  rps: 50,
	  protocol: 'http',
	  host: 'localhost',
	  port: 9000
	};

	const LOG_PREFIX = 'APIConnection';

	class notAPIConnection extends notBase$1{
	  static int;
	  static online;

	  constructor(options) {
	    super({
	      options,
	      working: {
	        name: options.name?options.name:LOG_PREFIX
	      }
	    });
	    this.online = null;
	    this.run();
	    return this;
	  }

	  run() {
	    this.int = window.setInterval(this.check.bind(this), 1000);
	  }

	  pause() {
	    window.clearInterval(this.int);
	  }

	  resume() {
	    this.run();
	  }

	  isOnline(){
	    return window.navigator.onLine;
	  }

	  check() {
	    let t = this.isOnline();
	    if (this.online !== null) {
	      if (this.online !== t) {
	        this.changeState(t);
	      }
	    }
	    this.online = t;
	  }

	  changeState(online = false) {
	    if (online) {
	      this.emit('online');
	    } else {
	      this.emit('offline');
	    }
	  }
	}

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		notAPIConnection: notAPIConnection,
		notAPIOptions: notAPIOptions,
		notAPIQueue: notAPIQueue
	});

	const ALL$1 = {};

	function exist$1(key) {
	    return notCommon$3.objHas(ALL$1, key);
	}

	function get$1(key) {
	    if (exist$1(key)) {
	        return ALL$1[key];
	    } else {
	        return false;
	    }
	}

	function create$1(
	    key,
	    props = {
	        raw: [],
	        filtered: [],
	        selected: {},
	    }
	) {
	    if (!exist$1(key)) {
	        if (Object.keys(props).length > 0) {
	            ALL$1[key] = {};
	            Object.keys(props).forEach((name) => {
	                ALL$1[key][name] = writable(props[name]);
	            });
	        } else {
	            throw new Error("store's props wasn't specified");
	        }
	    }
	    return ALL$1[key];
	}

	/**
	 * Creates object that is fake Store
	 * Some time this is useful when you need to initialize local var,
	 * before you could get actual Stores from central storage by its ID
	 *	@params {mixed} val 	data of type that is actual storage will contain
	 * @returns {Object}
	 */

	function fake(val) {
	    return {
	        subscribe(f) {
	            f(val);
	            return () => {};
	        },
	        set() {},
	    };
	}

	var stores = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$1,
		fake: fake,
		get: get$1
	});

	const //record
	  META_INTERFACE = Symbol('interface'),
	  META_MAP_TO_INTERFACE = [
	    'getActionsCount',
	    'getActions',
	    'setFindBy',
	    'resetFilter',
	    'setFilter',
	    'getFilter',
	    'setSorter',
	    'getSorter',
	    'resetSorter',
	    'setPageNumber',
	    'setPageSize',
	    'setPager',
	    'setReturn',
	    'setSearch',
	    'getSearch',
	    'resetSearch',
	    'resetPager',
	    'getPager',
	    'addFormFieldType',
	    'addFormField',
	    'getFieldTypes',
	    'getActionFormFields'
	  ],
	  DEFAULT_ACTION_PREFIX$1 = '$';

	const OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY = ["_id", "id", "ID"],
	    DEFAULT_FILTER = {},
	    DEFAULT_SEARCH = "",
	    DEFAULT_RETURN = {},
	    DEFAULT_PAGE_NUMBER = 0,
	    DEFAULT_PAGE_SIZE = 10,
	    DEFAULT_ACTION_PREFIX = "$",
	    DEFAULT_WS_ROUTE_ACTION_SPLITTER = "//";

	class notInterface extends notBase$1 {
	    constructor(manifest, options) {
	        super({
	            working: {
	                name:
	                    "network interface for: " +
	                    (manifest.model ? manifest.model : "unknown"),
	                filter: DEFAULT_FILTER,
	                search: DEFAULT_SEARCH,
	                return: DEFAULT_RETURN,
	                pager: {
	                    size: DEFAULT_PAGE_SIZE,
	                    page: DEFAULT_PAGE_NUMBER,
	                },
	            },
	            options,
	        });
	        this.manifest = manifest;
	        this.initActions();
	        return this;
	    }

	    initActions() {
	        if (this.getActionsCount() > 0) {
	            let actions = this.getActions();
	            for (let actionName in actions) {
	                this.initAction(actionName);
	            }
	        }
	    }

	    initAction(actionName) {
	        if (!notCommon$3.objHas(this, DEFAULT_ACTION_PREFIX + actionName)) {
	            this[DEFAULT_ACTION_PREFIX + actionName] = (
	                opts,
	                headers,
	                fileUpload = false,
	                files
	            ) =>
	                this.request(
	                    this,
	                    actionName,
	                    opts,
	                    headers,
	                    fileUpload,
	                    files
	                );
	        }
	    }

	    requestHTTP(
	        record,
	        actionName,
	        params,
	        headers = {},
	        fileUpload = false,
	        files
	    ) {
	        try {
	            let compositeData = Object.assign(
	                {},
	                record.getData && typeof record.getData === "function"
	                    ? record.getData()
	                    : record,
	                params
	            );
	            let actionData = this.getActionData(actionName),
	                requestParams = this.collectRequestData(actionData),
	                requestParamsEncoded = this.encodeRequest(requestParams),
	                //id = this.getID(compositeData, actionData, actionName),
	                apiServerURL = this.getServerURL(),
	                url = this.getURL(compositeData, actionData, actionName),
	                opts = {};
	            if (fileUpload) {
	                url = this.getURL(params, actionData, actionName);
	                const fd = new FormData();
	                fd.append("file", files);
	                opts.body = fd;
	            } else {
	                if (
	                    ["OPTIONS", "GET"].indexOf(
	                        actionData.method.toUpperCase()
	                    ) === -1
	                ) {
	                    opts = {
	                        method: actionData.method,
	                        body: JSON.stringify(
	                            record.getData &&
	                                typeof record.getData === "function"
	                                ? record.getData()
	                                : record
	                        ),
	                        headers: {
	                            Accept: "application/json",
	                            "Content-Type": "application/json",
	                        },
	                    };
	                }
	            }
	            opts.method = actionData.method.toUpperCase();
	            if (headers && Object.keys(headers).length) {
	                opts.headers = headers;
	            }
	            return fetch(apiServerURL + url + requestParamsEncoded, opts).then(
	                (response) => response.json()
	            );
	        } catch (e) {
	            notCommon$3.error(e);
	            notCommon$3.report(e);
	        }
	    }

	    requestWS(record, actionName) {
	        try {
	            let actionData = this.getActionData(actionName),
	                requestParams = this.collectRequestData(actionData);
	            const WS = notCommon$3.getApp().getWSClient();
	            const messageName = this.getWSRequestName(actionName);
	            const payload = Object.assign({}, requestParams, record.getData());
	            if (
	                notCommon$3.objHas(actionData, "type") &&
	                typeof actionData.type === "string" &&
	                actionData.type.length &&
	                actionData.type !== "request"
	            ) {
	                return WS.message(actionData.type, messageName, payload).then(
	                    (response) => response.payload
	                );
	            } else {
	                return WS.request(messageName, payload).then(
	                    (response) => response.payload
	                );
	            }
	        } catch (e) {
	            notCommon$3.error(e);
	            notCommon$3.report(e);
	        }
	    }

	    request() {
	        let actionData = this.getActionData(arguments[1]);
	        switch (this.selectTransport(actionData)) {
	            case "ws":
	                return this.requestWS(...arguments);
	            case "http":
	                return this.requestHTTP(...arguments);
	            default:
	                throw new Error("Offline");
	        }
	    }

	    wsIsUp(actionData) {
	        if (actionData.ws === true) {
	            let client;
	            if (
	                notCommon$3.objHas(actionData, "wsClient") &&
	                actionData.wsClient
	            ) {
	                client = notCommon$3.getApp().getWSClient(actionData.wsClient);
	            } else {
	                client = notCommon$3.getApp().getWSClient();
	            }
	            if (client) {
	                return true;
	            }
	        }
	        return false;
	    }

	    selectTransport(actionData) {
	        if (this.wsIsUp(actionData)) {
	            return "ws"; //for ws/wss
	        }
	        if (notCommon$3.objHas(actionData, "method")) {
	            return "http"; //for http/https
	        }
	        return false; //for offline
	    }

	    getModelName() {
	        return this && this.manifest ? this.manifest.model : null;
	    }

	    getActionData(actionName) {
	        return this.getActions() && this.getActions()[actionName]
	            ? this.getActions()[actionName]
	            : null;
	    }

	    getActionsCount() {
	        return this.getActions() ? Object.keys(this.getActions()).length : 0;
	    }

	    getActions() {
	        return this.manifest && this.manifest.actions
	            ? this.manifest.actions
	            : {};
	    }

	    parseParams(start, end, line, record) {
	        let fieldName = "";
	        let len = start.length;
	        while (line.indexOf(start) > -1) {
	            let ind = line.indexOf(start);
	            let startSlice = ind + len;
	            let endSlice = line.indexOf(end);
	            if (ind > endSlice) {
	                break;
	            }
	            fieldName = line.slice(startSlice, endSlice);
	            if (fieldName == "") break;
	            this.log &&
	                this.log(
	                    start + fieldName + end,
	                    notPath$1.get(fieldName, record)
	                );
	            line = line.replace(
	                start + fieldName + end,
	                notPath$1.get(fieldName, record)
	            );
	        }
	        return line;
	    }

	    parseLine(line, record, actionName) {
	        line = line.replace(":modelName", this.manifest.model);
	        line = line.replace(":actionName", actionName);
	        line = this.parseParams(":record[", "]", line, record);
	        line = this.parseParams(":", "?", line, record);
	        return line;
	    }

	    getURL(record, actionData, actionName) {
	        var line =
	            this.parseLine(this.manifest.url, record, actionName) +
	            (notCommon$3.objHas(actionData, "postFix")
	                ? this.parseLine(actionData.postFix, record, actionName)
	                : "");
	        return line;
	    }

	    getServerURL() {
	        return notCommon$3.getApp()
	            ? notCommon$3.getApp().getOptions("api.server.url", "")
	            : "";
	    }

	    getWSRequestName(actionName) {
	        const modelName = this.manifest.model;
	        return `${modelName}${DEFAULT_WS_ROUTE_ACTION_SPLITTER}${actionName}`;
	    }

	    encodeRequest(data) {
	        let p = "?";
	        for (let t in data) {
	            if (typeof data[t] !== "undefined" && data[t] !== null) {
	                p +=
	                    encodeURIComponent(t) +
	                    "=" +
	                    encodeURIComponent(
	                        data[t].constructor === Object
	                            ? JSON.stringify(data[t])
	                            : data[t]
	                    ) +
	                    "&";
	            }
	        }
	        //for test purpose only, special test server needed
	        if (this.getOptions("test")) {
	            p += "&test=1";
	            if (this.getOptions("test.session")) {
	                p += "&session=" + this.getOptions("test.session");
	            }
	            if (this.getOptions("test.session")) {
	                p += "&role=" + this.getOptions("test.role");
	            }
	        }
	        return p;
	    }

	    collectRequestData(actionData) {
	        let requestData = {};
	        if (
	            notCommon$3.objHas(actionData, "data") &&
	            Array.isArray(actionData.data)
	        ) {
	            for (let i = 0; i < actionData.data.length; i++) {
	                let dataProviderName =
	                    "get" + notCommon$3.capitalizeFirstLetter(actionData.data[i]);
	                if (
	                    this[dataProviderName] &&
	                    typeof this[dataProviderName] === "function"
	                ) {
	                    let data = this[dataProviderName](),
	                        res = {};
	                    if (
	                        [
	                            "pager",
	                            "sorter",
	                            "filter",
	                            "search",
	                            "return",
	                        ].indexOf(actionData.data[i]) > -1
	                    ) {
	                        res[actionData.data[i]] = data;
	                    } else {
	                        res = data;
	                    }
	                    requestData = Object.assign(requestData, res);
	                }
	            }
	        }
	        return requestData;
	    }

	    getID(record, actionData) {
	        let resultId,
	            list = OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY,
	            prefixes = ["", this.manifest.model];
	        if (notCommon$3.objHas(actionData, "index") && actionData.index) {
	            list = [actionData.index].concat(
	                OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY
	            );
	        }
	        for (let pre of prefixes) {
	            for (let t of list) {
	                if (notCommon$3.objHas(record, pre + t)) {
	                    resultId = record[pre + t];
	                    break;
	                }
	            }
	        }
	        return resultId;
	    }

	    setFindBy(key, value) {
	        var obj = {};
	        obj[key] = value;
	        return this.setFilter(obj);
	    }

	    setFilter(filterData = DEFAULT_FILTER) {
	        this.setWorking("filter", filterData);
	        return this;
	    }

	    resetFilter() {
	        return this.setFilter();
	    }

	    getFilter() {
	        return this.getWorking("filter");
	    }

	    setSearch(searchData = DEFAULT_SEARCH) {
	        this.setWorking("search", searchData);
	        return this;
	    }

	    resetSearch() {
	        return this.setSearch();
	    }

	    getSearch() {
	        return this.getWorking("search");
	    }

	    setSorter(sorterData) {
	        this.setWorking("sorter", sorterData);
	        return this;
	    }

	    resetSorter() {
	        return this.setSorter({});
	    }

	    getSorter() {
	        return this.getWorking("sorter");
	    }

	    setReturn(returnData = DEFAULT_RETURN) {
	        this.setWorking("return", returnData);
	        return this;
	    }

	    resetReturn() {
	        return this.setReturn({});
	    }

	    getReturn() {
	        return this.getWorking("return");
	    }

	    setPageNumber(pageNumber) {
	        this.setWorking("pager.page", pageNumber);
	        return this;
	    }

	    setPageSize(pageSize) {
	        this.setWorking("pager.size", pageSize);
	        return this;
	    }

	    //pageSize = DEFAULT_PAGE_SIZE, pageNumber = DEFAULT_PAGE_NUMBER
	    setPager() {
	        if (
	            (arguments.length < 2 ||
	                isNaN(arguments[0]) ||
	                isNaN(arguments[1])) &&
	            arguments[0].constructor === Object &&
	            notCommon$3.objHas(arguments[0], "page") &&
	            notCommon$3.objHas(arguments[0], "size")
	        ) {
	            const pager = arguments[0];
	            this.setWorking("pager", {
	                size: pager.size || DEFAULT_PAGE_SIZE,
	                page: pager.page || DEFAULT_PAGE_NUMBER,
	            });
	        }
	        return this;
	    }

	    resetPager() {
	        return this.setPager();
	    }

	    getPager() {
	        return this.getWorking("pager");
	    }

	    getRecord() {
	        this.getData();
	    }

	    getDefaultAsPlainObject() {
	        if (!this.manifest || !this.manifest.fields) {
	            return {};
	        }
	        const result = {};
	        for (const fieldName of Object.keys(this.manifest.fields)) {
	            if (Object.hasOwn(this.manifest.fields[fieldName], "default")) {
	                result[fieldName] = this.manifest.fields[fieldName].default;
	            }
	        }
	        return result;
	    }
	}

	class notRecord extends notBase$1 {
	    constructor(manifest, item) {
	        super();
	        if (
	            typeof item === "undefined" ||
	            item === null ||
	            typeof item !== "object"
	        ) {
	            return item;
	        }
	        if (item && item.isProxy) {
	            notCommon$3.error("this is Proxy item");
	            return item;
	        }
	        if (item && (item.isRecord || item.isProperty)) {
	            return item;
	        } else {
	            if (Array.isArray(item)) {
	                return this.createCollection(manifest, item);
	            }
	        }
	        this.setOptions({});
	        this[META_INTERFACE] = new notInterface(manifest, {});
	        this.setData(item);
	        this.interfaceUp();
	        this.mapToInterface();
	        this.mapToMethods();
	        return this;
	    }

	    toDefault() {
	        return this.setData(this[META_INTERFACE].getDefaultAsPlainObject());
	    }

	    mapToInterface() {
	        let rec = this;
	        for (let t of META_MAP_TO_INTERFACE) {
	            if (
	                this[META_INTERFACE][t] &&
	                typeof this[META_INTERFACE][t] === "function"
	            ) {
	                this[t] = function () {
	                    let res = rec[META_INTERFACE][t](...arguments);
	                    return res == rec[META_INTERFACE] ? rec : res;
	                };
	            }
	        }
	    }

	    mapToMethods() {
	        let manifest = this[META_INTERFACE].manifest,
	            app = notCommon$3.getApp(),
	            methods = {};
	        if (manifest.methods) {
	            methods = manifest.methods;
	        } else if (app) {
	            methods = app.getOptions(
	                ["models", this[META_INTERFACE].manifest.model].join("."),
	                {}
	            );
	        }
	        if (methods) {
	            for (let t in methods) {
	                if (Object.hasOwn(methods, t)) {
	                    this[t] = methods[t];
	                }
	            }
	        }
	    }

	    createCollection(manifest, items) {
	        var collection = [];
	        for (var i = 0; i < items.length; i++) {
	            collection.push(new notRecord(manifest, items[i]));
	        }
	        return collection;
	    }

	    interfaceUp() {
	        if (this[META_INTERFACE].getActionsCount() > 0) {
	            let actions = this[META_INTERFACE].getActions();
	            for (let i in actions) {
	                this.actionUp(i, actions[i]);
	            }
	        }
	    }

	    actionUp(index) {
	        if (!Object.hasOwn(this, [DEFAULT_ACTION_PREFIX$1 + index])) {
	            this[DEFAULT_ACTION_PREFIX$1 + index] = (...params) =>
	                this[META_INTERFACE].request(this, index, ...params);
	        }
	    }
	    /*
	  -> 'path.to.key', valueOfKey
	  <- ok, with one onChange event triggered
	  */

	    setAttr(key, value) {
	        return this.setData(key, value);
	    }

	    /*
	  ->
	  {
	    'keyPath': value,
	    'key.subPath': value2,
	    'keyPath.0.title': value3
	  }
	  <- ok, with bunch of onChange events triggered
	  */
	    setAttrs(objectPart) {
	        //notCommon.log('setAttrs', objectPart, Object.keys(objectPart));
	        if (
	            objectPart &&
	            typeof objectPart === "object" &&
	            Object.keys(objectPart).length > 0
	        ) {
	            for (let path in objectPart) {
	                //notCommon.log('setAttrs one to go', path);
	                this.setAttr(path, objectPart[path]);
	            }
	        }
	    }

	    /*
	  -> 'pathToKey'
	  <- value1
	  */
	    getAttr(what, plain = false) {
	        let prx = this.getData(what, {});
	        if (plain) {
	            return notCommon$3.stripProxy(prx);
	        } else {
	            return prx;
	        }
	    }

	    /*
	  -> ['pathToKey', 'path.to.key', 'simpleKey',...]
	  <- [value1, value2, value3,...]
	  */
	    getAttrs(what) {
	        let result = [];
	        if (what && what.length > 0) {
	            for (let path of what) {
	                result.push(this.getAttr(path));
	            }
	        }
	        return result;
	    }

	    getManifest() {
	        if (this[META_INTERFACE]) {
	            return this[META_INTERFACE].manifest;
	        } else {
	            return {};
	        }
	    }

	    setItem(item) {
	        this.setData(item);
	        return this;
	    }
	}

	/**
	 * @const {string} [OPT_CONTROLLER_PREFIX = "nc"] controller names prefix nc aka NotController
	 */
	const OPT_CONTROLLER_PREFIX = "nc";
	/**
	 * @const {string} [OPT_RECORD_PREFIX = "nr"] record names prefix nr aka NotRecord
	 */
	const OPT_RECORD_PREFIX = "nr";
	/**
	 * @const {string} [DEFAULT_WS_CLIENT_NAME = "main"] default name of WS client
	 */
	const DEFAULT_WS_CLIENT_NAME = "main";

	/**
	 * Class of application
	 * @class
	 */
	let notApp$1 = class notApp extends notBase$1 {
	    /**
	     *  @static {function} DEFAULT_WS_CLIENT_NAME  function to perform deep merges of objects
	     */
	    static DEFAULT_WS_CLIENT_NAME = DEFAULT_WS_CLIENT_NAME;
	    /**
	     * @class
	     * @param {object} options              application options
	     * @param {string} options.name         name
	     * @param {object} options.controllers  controllers
	     * @param {string}  options.manifestURL URL of network manifest with all available models/actions/fields requests options
	     */
	    constructor(options) {
	        super({
	            working: {
	                name: options.name,
	                interfaces: {},
	                controllers: notCommon$3.objHas(options, "controllers")
	                    ? options.controllers
	                    : {},
	                initController: null,
	                currentController: null,
	                uis: {},
	                wsc: {},
	                wss: {},
	                services: {},
	            },
	            options,
	        });
	        this?.log && this.log("start app");
	        notCommon$3.register("app", this);
	        this.initManifest();
	        return this;
	    }

	    /**
	     * Initializes application according to network manifest, which is retrieved from server
	     */
	    initManifest() {
	        notCommon$3
	            .getJSON(this.getOptions("manifestURL"))
	            .then(this.setInterfaceManifest.bind(this))
	            .catch(notCommon$3.report.bind(this));
	    }

	    /**
	     * One page routing initialization
	     */
	    initRouter() {
	        this.setWorking("router", notRouter$1);
	        this.getWorking("router").setRoot(this.getOptions("router.root"));
	        notRouter$1.reRouteExisted();
	    }

	    /**
	     * Creates all the routes handlers and pushes them into router
	     */
	    execRouter() {
	        var routieInput = {};
	        for (let t = 0; t < this.getOptions("router.manifest").length; t++) {
	            let routeBlock = this.getOptions("router.manifest")[t],
	                paths = routeBlock.paths,
	                schemes = routeBlock.schemes,
	                controller = routeBlock.controller;
	            for (let i = 0; i < paths.length; i++) {
	                let pathScheme =
	                    schemes && Array.isArray(schemes) && schemes.length > i
	                        ? schemes[i]
	                        : false;
	                routieInput[paths[i]] = this.bindController(
	                    controller,
	                    pathScheme
	                );
	            }
	        }
	        this.getWorking("router").addList(routieInput).listen(); //.navigate(this.getOptions('router.index'));
	    }

	    /**
	     * Sets interface manifest option
	     * @param {object}  manifest    interface manifest
	     */
	    setInterfaceManifest(manifest) {
	        this.setOptions("interfaceManifest", manifest);
	        this.initRouter();
	        this.update();
	    }

	    /**
	     * returns constructor of interface model
	     * @param {string}  modelName   model name
	     * @returns {object}    interface model constructor
	     */
	    getInterfaceManifest(modelName) {
	        if (modelName) {
	            return this.getOptions("interfaceManifest")[modelName];
	        } else {
	            return this.getOptions("interfaceManifest");
	        }
	    }

	    /**
	     * Updating Application, reloads interfaces, init controller launched, start again
	     */
	    update() {
	        //нужно инициализировать
	        //модели полученными интерфейсами
	        this.updateInterfaces();
	        //иницилицировать и запустить контроллер инициализации
	        this.initController();
	        this.startApp();
	    }

	    /**
	     * Initialization of services, startup of routing
	     */
	    startApp() {
	        this.initServices();
	        //создать контроллеры
	        //роутер и привязать к нему контроллеры
	        this.execRouter();
	        this.emit("afterStarted", this);
	    }

	    /**
	     *
	     * @param {object} controllerName controller constructor
	     * @param {string[]} controllerPathScheme
	     * @returns {function} function creates new controller instance and pass in notApp instance, arguments from router parser and pathScheme
	     */
	    bindController(controllerName, controllerPathScheme) {
	        let app = this;
	        return function () {
	            new controllerName(app, arguments, controllerPathScheme);
	        };
	    }

	    /**
	     * Initializes 'initialization' controller which is runs once,
	     * to perform custom initializations routines by application code
	     */
	    initController() {
	        if (typeof this.getOptions("initController") !== "undefined") {
	            let initController = this.getOptions("initController");
	            this.setWorking("initController", new initController(this));
	        }
	    }

	    /**
	     * Returns working controller
	     * @returns {object} working controller
	     */
	    getCurrentController() {
	        return this.getWorking("currentController");
	    }

	    /**
	     * Destroyes working controller then sets provided as working
	     * @param {object} ctrl controller instance
	     * @returns {object} notApp instance
	     */
	    setCurrentController(ctrl) {
	        let oldCtrl = this.getCurrentController();
	        if (oldCtrl && oldCtrl.destroy) {
	            oldCtrl.destroy();
	        }
	        this.setWorking("currentController", ctrl);
	        return this;
	    }

	    /**
	     * Clears interfaces, recreates all according to Options.interafaceManifest
	     */
	    updateInterfaces() {
	        this.clearInterfaces();
	        let manifests = this.getOptions("interfaceManifest");
	        if (manifests) {
	            for (let name in manifests) {
	                let recordManifest = manifests[name],
	                    recordMethods = this.getOptions(
	                        ["models", name].join("."),
	                        {}
	                    );
	                recordManifest.methods = recordMethods;
	                this.getWorking("interfaces")[name] = (recordData) =>
	                    new notRecord(recordManifest, recordData);
	                window["nr" + notCommon$3.capitalizeFirstLetter(name)] =
	                    this.getWorking("interfaces")[name];
	            }
	        }
	    }

	    /**
	     * Converts interface name (modelName) to standartizied prefixModelName
	     * @param {string} name interface model name
	     * @returns {string}    not record name
	     */
	    getRecordName(name) {
	        return OPT_RECORD_PREFIX + notCommon$3.capitalizeFirstLetter(name);
	    }

	    /**
	     * Converts controller name (controllerName) to standartizied prefixControllerName
	     * @param {string} name controller name
	     * @returns {string}    not controller name
	     */
	    getControllerName(name) {
	        return OPT_CONTROLLER_PREFIX + notCommon$3.capitalizeFirstLetter(name);
	    }

	    /**
	     * Returns all network interfaces
	     * @returns {object} all network insterfaces
	     */
	    getInterfaces() {
	        return this.getWorking("interfaces");
	    }

	    /**
	     * Sets interfaces list clear
	     * @returns {object} notApp instance
	     */
	    clearInterfaces() {
	        this.setWorking("interfaces", {});
	        return this;
	    }

	    /**
	     * Sets WebSockets client
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME] name of client
	     * @param {object} wsc  notWSClient instance
	     * @returns {object} notApp instance
	     */
	    // @ts-ignore
	    setWSClient(name = DEFAULT_WS_CLIENT_NAME, wsc) {
	        return this.setWorking(`wsc.${name}`, wsc);
	    }

	    /**
	     * Returns web sockets client instance by name
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME]
	     * @returns {object} instance of notWSClient
	     */
	    getWSClient(name = DEFAULT_WS_CLIENT_NAME) {
	        return this.getWorking(`wsc.${name}`);
	    }

	    /**
	     * returns network interface class initializator
	     * @param {string} name name of network interface
	     * @returns {function} interface class initializator
	     */
	    getInterface(name) {
	        return this.getInterfaces()[name];
	    }

	    /**
	     * Returns network interface (model) initialized with provided data
	     * @param {string} name interface(modelName)
	     * @param {object} [data={}]    model data
	     * @returns network interface initializes with provided data
	     */
	    getModel(name, data = {}) {
	        return this.getInterface(name)(data);
	    }

	    /**
	     * Sets service
	     * @param {string} name name of the service
	     * @param {object|function} val service
	     */
	    setService(name, val) {
	        return this.setWorking(`services.${name}`, val);
	    }

	    /**
	     * Returns service
	     * @param {string} name name of the service
	     * @returns {object|function} service
	     */
	    getService(name) {
	        return this.getWorking(`services.${name}`);
	    }

	    /**
	     * Initializes all provided services
	     */
	    initServices() {
	        if (this.getOptions("services")) {
	            for (let servName in this.getOptions("services")) {
	                try {
	                    let serv = this.getOptions(`services.${servName}`);
	                    const servType = notCommon$3.detectType(serv);
	                    switch (servType) {
	                        case "function":
	                        case "class":
	                            this.setService(servName, new serv(this));
	                            break;
	                        default:
	                            this.setService(servName, serv);
	                    }
	                } catch (e) {
	                    this?.error &&
	                        this.error(`Service (${servName}) init error`, e);
	                }
	            }
	        }
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} moduleName   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	    getConfigReaderForModule(moduleName = "") {
	        const modConfPath = ["modules", moduleName].join(".");
	        return {
	            get: (subPath, fallback) => {
	                if (subPath && typeof subPath == "string" && subPath.length) {
	                    return this.getOptions(
	                        [modConfPath, subPath].join("."),
	                        fallback
	                    );
	                } else {
	                    return this.getOptions(modConfPath, fallback);
	                }
	            },
	        };
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} [moduleName='']   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	    moduleConfig(moduleName = "") {
	        return this.getConfigReaderForModule(moduleName);
	    }
	};

	/**
	 * @const {string}  [OPT_DEFAULT_ACTION_NAME = "default"]      default action name
	 */
	const OPT_DEFAULT_ACTION_NAME = "default";

	/**
	 * @const {string}  [OPT_DEFAULT_CONTAINER_SELECTOR = "main.content"]  selector of container HTML
	 *                          element
	 */
	const OPT_DEFAULT_CONTAINER_SELECTOR = "main.content";

	/**
	 * @const {string}  [OPT_DEFAULT_PLURAL_NAME = "Models"]  default plural name of entities
	 */
	const OPT_DEFAULT_PLURAL_NAME = "Models";

	/**
	 * @const {string}  [OPT_DEFAULT_SINGLE_NAME = "Model"]  default single name of entities
	 */
	const OPT_DEFAULT_SINGLE_NAME = "Model";

	/**
	 * @const {string}  [OPT_DEFAULT_MODULE_NAME="main"]  default module name
	 */
	const OPT_DEFAULT_MODULE_NAME = "main";

	/**
	 * @const {boolean}  [OPT_DEFAULT_AUTO_NAME = true]  if shoould be used auto name generator
	 */
	const OPT_DEFAULT_AUTO_NAME = true;

	/*
	 *  Basic class for user controller
	 */
	let notController$1 = class notController extends notBase$1 {
	    /**
	     *  @static {number} PARAMS_LENGTH  number of params in URL path
	     */
	    static PARAMS_LENGTH = 2;
	    /**
	     *  @static {string} MODULE_NAME  name of module
	     */
	    static get MODULE_NAME() {
	        return OPT_DEFAULT_MODULE_NAME;
	    }
	    /**
	     *  @static {string} MODEL_NAME  name of model
	     */
	    static get MODEL_NAME() {
	        return "ModelName";
	    }

	    static get LABELS() {
	        return {
	            plural: `${OPT_DEFAULT_MODULE_NAME}:model_label_plural`,
	            single: `${OPT_DEFAULT_MODULE_NAME}:model_label_single`,
	        };
	    }

	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    els;
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    make;
	    /**
	     *
	     * @type    {null|import('./app.js').default}
	     * @memberof notController
	     */
	    app;
	    /**
	     *  @class
	     *  @param {import('./app.js').default} app
	     *  @param  {string}    name
	     */
	    constructor(app, name) {
	        super({});
	        this.app = app;
	        this.app.setCurrentController(this);
	        this.setWorking({
	            name,
	            ready: false,
	            views: {},
	            libs: {},
	            helpers: {},
	        });
	        this.ui = {};
	        this.els = {};
	        this.setData({});
	        this.setOptions({
	            moduleName: OPT_DEFAULT_MODULE_NAME,
	            containerSelector: OPT_DEFAULT_CONTAINER_SELECTOR,
	            prefix: app.getOptions("paths.module"),
	            names: {
	                plural: OPT_DEFAULT_PLURAL_NAME,
	                single: OPT_DEFAULT_SINGLE_NAME,
	            },
	        });
	        this.setURLPrefix(app.getOptions("router.root"));
	        /*
	      сразу делаем доступными модели notRecord из nc`ControllerName` будут доступны как this.nr`ModelName`
	    */
	        let interfaces = app.getInterfaces();
	        this.make = {};
	        for (let t in interfaces) {
	            if (Object.hasOwn(interfaces, t)) {
	                this.make[t] = interfaces[t];
	            }
	        }
	        this.on("destroy", () => {
	            this.app = null;
	            for (let uiName in this.ui) {
	                this.ui[uiName].destroy && this.ui[uiName].destroy();
	                this.ui[uiName].$destroy && this.ui[uiName].$destroy();
	                this.ui[uiName] = null;
	            }
	            this.els = null;
	            this.make = null;
	        });
	        return this;
	    }

	    /**
	     *  Returns current notApp
	     *  @return {import('./app.js').default}
	     */
	    getApp() {
	        return notCommon$3.getApp();
	    }

	    /**
	     *  Sets default controller model
	     *  @param {import('./record.js')}  model  notRecord interface object
	     *  @return {notController}
	     */
	    setModel(model) {
	        this.setWorking("model", model);
	        return this;
	    }

	    /**
	     *  If zero or one argument provided this modelName instance will be returned
	     *  If two provided and first is a string than instance of name will be returned initialized with second object param or empty object
	     *  @param {string|object}      name    modelName of instance to return or initial data for instance
	     *  @param {object}             data    model data
	     *  @return {import('./record.js')}
	     */
	    getModel(name, data = undefined) {
	        if (typeof name === "string") {
	            const int = this.getInterface(name);
	            return int && int(data || {});
	        } else {
	            const int = this.getInterface();
	            return int && int(name || {});
	        }
	    }

	    getInterface(name = "") {
	        return this.app?.getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	    getModelName() {
	        return this.getWorking("modelName");
	    }
	    /**
	     *  Sets default controller model name
	     *  @param {string}  modelName  notRecord interface object
	     *  @return {notController}
	     */
	    setModelName(modelName) {
	        this.setWorking("modelName", notCommon$3.lowerFirstLetter(modelName));
	        return this;
	    }

	    /**
	     *  Returns current model primary ID field name
	     *  @return {import('./record.js')}
	     */
	    getModelIDFieldName() {
	        return this.getWorking("modelIDFieldName", "_id");
	    }

	    /**
	     *  Sets current model primary ID field name
	     *  @return {notController}
	     */
	    setModelIDFieldName(val = "_id") {
	        return this.setWorking("modelIDFieldName", val);
	    }

	    /**
	     *  Marks this controller as ready
	     *  emits "ready"/"busy" events
	     *  @param {Boolean}  val  true/false
	     */
	    setReady(val = true) {
	        this.setWorking("ready", val);
	        val ? this.emit("ready") : this.emit("busy");
	    }

	    /**
	     *  Sets module URL prefix
	     *  @param {string} val URL prefix
	     *  @return {notController} this
	     */
	    setURLPrefix(val) {
	        this.setOptions("urlPrefix", val);
	        this.updateAutoName();
	        return this;
	    }

	    /**
	     *  Returns module url prefix
	     *  @return  {string} prefix
	     */
	    getURLPrefix() {
	        return this.getOptions("urlPrefix");
	    }

	    /**
	     *  Sets module name
	     *  @param {string} val name of the module
	     *  @return {notController} this
	     */
	    setModuleName(val) {
	        this.setOptions("moduleName", notCommon$3.lowerFirstLetter(val));
	        this.updateAutoName();
	        return this;
	    }
	    /**
	     *  Returns module name
	     *  @return  {string} module name
	     */
	    getModuleName() {
	        return this.getOptions("moduleName");
	    }

	    /**
	     *  Returns this module path prefix
	     *  @return {string}  path to module dir
	     */
	    getModulePrefix() {
	        return [
	            notCommon$3.getApp().getOptions("paths.modules"),
	            this.getModuleName(),
	        ].join("/");
	    }

	    /**
	     *  Returns this model URL with URL prefix
	     *  @return {string}  url path
	     */
	    getModelURL() {
	        return notCommon$3.buildURL({
	            prefix: this.getURLPrefix(),
	            module: this.getModuleName(),
	            model: this.getModelName(),
	        });
	    }

	    /**
	     *  Returns this model action URL with URL prefix
	     * @param  {string}   id       some identificator of model
	     * @param  {string}   action   action name
	     *  @return {string}  url path
	     */
	    getModelActionURL(id, action = "") {
	        return notCommon$3.buildURL({
	            prefix: this.getURLPrefix(),
	            module: this.getModuleName(),
	            model: this.getModelName(),
	            id,
	            action,
	        });
	    }

	    /**
	     * Creates url from value content
	     * @param {object}  val
	     **/
	    buildURL(val) {
	        return notCommon$3.buildURL(val);
	    }

	    /**
	     *  Updates working name
	     *  @return {notController} this
	     */
	    updateAutoName() {
	        if (this.getOptions("autoName", OPT_DEFAULT_AUTO_NAME)) ;
	        return this;
	    }

	    /**
	     *  Sets object name
	     *  @param {string} val name of the object
	     *  @return {notController} this
	     */
	    setName(val) {
	        this.setWorking("name", val);
	        this.setOptions("autoName", false);
	        return this;
	    }

	    /**
	     *  Gets object name
	     *  @return {string}
	     */
	    getName(val) {
	        return this.getWorking("name");
	    }

	    /**
	     *  Preload records from server, using listAll method,
	     *  returns Promise
	     *  @param {object}  list  map of preloaded records
	     *  @return {Promise}
	     */
	    preloadLib(list = {}) {
	        return new Promise((resolve, reject) => {
	            if (typeof list !== "object") {
	                resolve(undefined);
	            } else {
	                this.setWorking("loading", []);
	                for (let t in list) {
	                    this.getWorking("loading").push(list[t]);
	                    this.make[list[t]]({})
	                        .$listAll()
	                        .then((data) => {
	                            if (!this.getOptions("libs")) {
	                                this.setOptions("libs", {});
	                            }
	                            this.getOptions("libs")[t] = data;
	                            if (
	                                this.getWorking("loading").indexOf(list[t]) > -1
	                            ) {
	                                this.getWorking("loading").splice(
	                                    this.getWorking("loading").indexOf(list[t]),
	                                    1
	                                );
	                            }
	                            if (this.getWorking("loading").length === 0) {
	                                resolve(undefined);
	                            }
	                        })
	                        .catch((err) => {
	                            this.report(err);
	                            reject();
	                        });
	                }
	                if (this.getWorking("loading").length === 0) {
	                    resolve(undefined);
	                }
	            }
	        });
	    }

	    /**
	     * emits afterRender event
	     */
	    onAfterRender() {
	        this.emit("afterRender");
	    }

	    /**
	     *  Transform route name in action name
	     *  @param {String}   name tranform action name
	     *  @return {String}
	     */
	    getActionName(name = OPT_DEFAULT_ACTION_NAME) {
	        return "run" + notCommon$3.capitalizeFirstLetter(name);
	    }

	    /**
	     *  Get default controller action name
	     *  @return {String} default action from options
	     */
	    getDefaultActionName() {
	        return this.getActionName(
	            this.getOptions("defaultAction", OPT_DEFAULT_ACTION_NAME)
	        );
	    }

	    /**
	     *  Route params into specific run[Route_name] function
	     *  @param {array}   params   controller input params
	     *  @return {undefined}
	     */
	    route(params) {
	        let [routerName, ...subParams] = params,
	            actionName = this.getActionName(
	                routerName ? routerName : OPT_DEFAULT_ACTION_NAME
	            );
	        if (typeof this[actionName] === "function") {
	            this.setCurrentAction(actionName);
	            this[actionName](subParams);
	        } else if (this[this.getDefaultActionName()]) {
	            this.setCurrentAction(this.getDefaultActionName());
	            this[this.getDefaultActionName()](subParams);
	        } else {
	            this.setCurrentAction(undefined);
	            this.error && this.error("No action in router", params);
	        }
	    }

	    /**
	     * Sets working action
	     * @params {string} actionName current action name
	     */
	    setCurrentAction(actionName) {
	        this.setWorking("action", actionName);
	    }

	    /**
	     * Gets working action
	     * @returns {string} current action name
	     */
	    getCurrentAction() {
	        return this.getWorking("action");
	    }

	    /**
	     *  Return application options
	     *  @return {object}
	     */
	    getAppOptions() {
	        try {
	            return this.getApp().getOptions();
	        } catch (e) {
	            this.error && this.error(e);
	        }
	    }

	    /**
	     *  Returns module options
	     *  @param  {string}   [moduleName]    name of the module which options requested
	     *  @return {object}
	     */

	    getModuleOptions(moduleName) {
	        try {
	            return this.getApp().getOptions(
	                ["modules", moduleName || this.getModuleName()].join(".")
	            );
	        } catch (e) {
	            this.error && this.error(e);
	        }
	    }

	    /**
	     *  Returns module services
	     *  @param  {string}   moduleName    name of the module which services requested
	     *  @return {object}
	     */

	    getServices(moduleName) {
	        try {
	            return this.getApp().getOptions(
	                ["services", moduleName || this.getModuleName()].join(".")
	            );
	        } catch (e) {
	            this.error && this.error(e);
	        }
	    }

	    /**
	     *  Returns module components
	     *  @param  {string}   moduleName    name of the module which components requested
	     *  @return {object}
	     */

	    getComponents(moduleName) {
	        try {
	            return this.getApp().getOptions(
	                ["components", moduleName || this.getModuleName()].join(".")
	            );
	        } catch (e) {
	            this.error && this.error(e);
	        }
	    }

	    /**
	     *  Refreshes current URL, re-run all action
	     *  @param {number} timeout time to wait in ms
	     */
	    refresh(timeout = 0) {
	        this.app?.getWorking("router").refresh(timeout);
	    }

	    /**
	     * Returns path pattern for router
	     * @params {number} [0] paramsCount   number of params
	     * @return {string}  pattern for controller supported url
	     */
	    static getControllerRoute(paramsCount = 0) {
	        let path = [];
	        if (this.MODULE_NAME && this.MODULE_NAME.length > 0) {
	            path.push(notCommon$3.lowerFirstLetter(this.MODULE_NAME));
	        }
	        if (this.MODEL_NAME && this.MODEL_NAME.length > 0) {
	            path.push(notCommon$3.lowerFirstLetter(this.MODEL_NAME));
	        }
	        path = [path.join("/")];
	        for (let i = 0; i < paramsCount; i++) {
	            path.push("/([^/]+)");
	        }
	        return path.join("");
	    }

	    /**
	     * Returns path patterns for router
	     * @params {number} [0] paramsDeep   how many paths with params in the end
	     * @return {string[]}  patterns for controller supported url in order of simplification
	     */
	    static getControllerRoutes(paramsDeep = 0) {
	        let routes = [this.getControllerRoute(0)];
	        for (let i = 0; i < paramsDeep; i++) {
	            routes.unshift(this.getControllerRoute(i + 1));
	        }
	        return routes;
	    }

	    /**
	     * Returns router rule.
	     * @returns {Object} router rule {paths:String[], controller:notController}
	     */
	    static getRoutes() {
	        return {
	            paths: this.getControllerRoutes(this.PARAMS_LENGTH),
	            controller: this,
	        };
	    }

	    /**
	     * Returns Application router
	     * @returns {import('./router.js')}
	     */
	    getRouter() {
	        return this.app?.getWorking("router");
	    }

	    /**
	     * Changes location to `url` after `delay` ms
	     * @param {string} url
	     * @param {number|string}   delay   number in ms or name of delay
	     */
	    navigateWithDelay(
	        url,
	        delay = NAVIGATION_DELAY_DEFAULT,
	        doBefore = () => {}
	    ) {
	        return this.getRouter().navigateWithDelay(url, delay, doBefore);
	    }

	    /**
	     * Changes location to `url`
	     * @param {string} url
	     */
	    navigate(url) {
	        return this.getRouter().navigate(url);
	    }

	    /**
	     *  Navigating to this controller main model `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	    navigateAction(id, action = "", delay = 0, doBefore = () => {}) {
	        return this.navigateModuleAction(
	            this.getModuleName(),
	            this.getModelName(),
	            id,
	            action,
	            delay,
	            doBefore
	        );
	    }

	    /**
	     *  Navigating to this controller module model of `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	    navigateModelAction(
	        modelName,
	        id,
	        action = "",
	        delay = 0,
	        doBefore = () => {}
	    ) {
	        return this.navigateModuleAction(
	            this.getModuleName(),
	            modelName,
	            id,
	            action,
	            delay,
	            doBefore
	        );
	    }

	    /**
	     *  Navigating to `moduleName` `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} moduleName
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	    navigateModuleAction(
	        moduleName,
	        modelName,
	        id,
	        action = "",
	        delay = 0,
	        doBefore = () => {}
	    ) {
	        if (delay) {
	            return this.getRouter().navigateWithDelay(
	                notCommon$3.buildURL({
	                    prefix: this.getURLPrefix(),
	                    module: moduleName,
	                    model: modelName,
	                    id,
	                    action,
	                }),
	                delay,
	                doBefore
	            );
	        } else {
	            return this.getRouter().navigate(
	                notCommon$3.buildURL({
	                    prefix: this.getURLPrefix(),
	                    module: moduleName,
	                    model: modelName,
	                    id,
	                    action,
	                })
	            );
	        }
	    }

	    static getCommonMenu(childConstructor) {
	        return [
	            {
	                section: childConstructor.MODULE_NAME,
	                title: childConstructor.LABELS.plural,
	                url: `/${notCommon$3.lowerFirstLetter(
                    childConstructor.MODULE_NAME
                )}/${notCommon$3.lowerFirstLetter(childConstructor.MODEL_NAME)}`,
	            },
	        ];
	    }

	    static getMenu() {}
	};

	const ALL = {};

	function exist(key) {
	    return Object.hasOwn(ALL, key);
	}

	function get(key) {
	    if (exist(key)) {
	        return ALL[key];
	    } else {
	        return false;
	    }
	}

	function create(
	    key,
	    props = {
	        raw: [],
	        filtered: [],
	        selected: {},
	    }
	) {
	    if (!exist(key)) {
	        if (Object.keys(props).length > 0) {
	            ALL[key] = {};
	            Object.keys(props).forEach((name) => {
	                ALL[key][name] = writable(props[name]);
	            });
	        } else {
	            throw new Error("store's props wasn't specified");
	        }
	    }
	    return ALL[key];
	}

	/* node_modules/not-bulma/src/frame/components/table/controls/ui.switch.svelte generated by Svelte v4.2.19 */

	function create_fragment$n(ctx) {
		let input;
		let input_class_value;
		let input_id_value;
		let t;
		let label;
		let label_for_value;
		let mounted;
		let dispose;

		return {
			c() {
				input = element("input");
				t = space();
				label = element("label");
				attr(input, "type", "checkbox");
				attr(input, "class", input_class_value = "switch " + /*styling*/ ctx[5]);
				attr(input, "id", input_id_value = "edit-table-row-cell-inline-switch-" + /*fieldname*/ ctx[2] + "-" + /*id*/ ctx[1]);
				attr(input, "name", /*fieldname*/ ctx[2]);
				input.readOnly = /*readonly*/ ctx[4];
				input.disabled = /*disabled*/ ctx[3];
				attr(label, "class", "label");
				attr(label, "for", label_for_value = "edit-table-row-cell-inline-switch-" + /*fieldname*/ ctx[2] + "-" + /*id*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				input.checked = /*value*/ ctx[0];
				insert(target, t, anchor);
				insert(target, label, anchor);

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[7]),
						listen(input, "input", /*onInput*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*styling*/ 32 && input_class_value !== (input_class_value = "switch " + /*styling*/ ctx[5])) {
					attr(input, "class", input_class_value);
				}

				if (dirty & /*fieldname, id*/ 6 && input_id_value !== (input_id_value = "edit-table-row-cell-inline-switch-" + /*fieldname*/ ctx[2] + "-" + /*id*/ ctx[1])) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(input, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*readonly*/ 16) {
					input.readOnly = /*readonly*/ ctx[4];
				}

				if (dirty & /*disabled*/ 8) {
					input.disabled = /*disabled*/ ctx[3];
				}

				if (dirty & /*value*/ 1) {
					input.checked = /*value*/ ctx[0];
				}

				if (dirty & /*fieldname, id*/ 6 && label_for_value !== (label_for_value = "edit-table-row-cell-inline-switch-" + /*fieldname*/ ctx[2] + "-" + /*id*/ ctx[1])) {
					attr(label, "for", label_for_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t);
					detach(label);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$n($$self, $$props, $$invalidate) {
		let dispatch = createEventDispatcher();
		let { id = '' } = $$props;
		let { value = false } = $$props;
		let { fieldname = 'switch' } = $$props;
		let { disabled = false } = $$props;
		let { readonly = false } = $$props;
		let { styling = " is-rounded is-success " } = $$props;

		function onInput(ev) {
			let data = {
				id,
				field: fieldname,
				value: ev.target.type === 'checkbox'
				? ev.target.checked
				: ev.target.value
			};

			dispatch('change', data);
			return true;
		}

		function input_change_handler() {
			value = this.checked;
			$$invalidate(0, value);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(1, id = $$props.id);
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
			if ('readonly' in $$props) $$invalidate(4, readonly = $$props.readonly);
			if ('styling' in $$props) $$invalidate(5, styling = $$props.styling);
		};

		return [
			value,
			id,
			fieldname,
			disabled,
			readonly,
			styling,
			onInput,
			input_change_handler
		];
	}

	class Ui_switch extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$n, create_fragment$n, safe_not_equal, {
				id: 1,
				value: 0,
				fieldname: 2,
				disabled: 3,
				readonly: 4,
				styling: 5
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/table/controls/ui.tags.svelte generated by Svelte v4.2.19 */

	function get_each_context$9(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[1] = list[i];
		return child_ctx;
	}

	// (32:4) {:else}
	function create_else_block_1$3(ctx) {
		let span;
		let t;
		let span_class_value;

		function select_block_type_2(ctx, dirty) {
			if (/*item*/ ctx[1].url) return create_if_block_2$a;
			return create_else_block_2$2;
		}

		let current_block_type = select_block_type_2(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if_block.c();
				t = space();
				attr(span, "class", span_class_value = "mx-1 tag is-" + /*item*/ ctx[1].color + " " + /*item*/ ctx[1].customClasses + " svelte-38rpfk");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if_block.m(span, null);
				append(span, t);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, t);
					}
				}

				if (dirty & /*values*/ 1 && span_class_value !== (span_class_value = "mx-1 tag is-" + /*item*/ ctx[1].color + " " + /*item*/ ctx[1].customClasses + " svelte-38rpfk")) {
					attr(span, "class", span_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if_block.d();
			}
		};
	}

	// (19:4) {#if Object.hasOwn(item, "value")}
	function create_if_block$j(ctx) {
		let div;
		let span0;
		let t0_value = /*item*/ ctx[1].title + "";
		let t0;
		let t1;
		let span1;
		let span1_class_value;
		let t2;

		function select_block_type_1(ctx, dirty) {
			if (/*item*/ ctx[1].url) return create_if_block_1$g;
			return create_else_block$e;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				div = element("div");
				span0 = element("span");
				t0 = text(t0_value);
				t1 = space();
				span1 = element("span");
				if_block.c();
				t2 = space();
				attr(span0, "class", "tag");
				attr(span1, "class", span1_class_value = "tag is-" + /*item*/ ctx[1].color + " " + /*item*/ ctx[1].customClasses + " svelte-38rpfk");
				attr(div, "class", "mx-1 tags has-addons svelte-38rpfk");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span0);
				append(span0, t0);
				append(div, t1);
				append(div, span1);
				if_block.m(span1, null);
				append(div, t2);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t0_value !== (t0_value = /*item*/ ctx[1].title + "")) set_data(t0, t0_value);

				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span1, null);
					}
				}

				if (dirty & /*values*/ 1 && span1_class_value !== (span1_class_value = "tag is-" + /*item*/ ctx[1].color + " " + /*item*/ ctx[1].customClasses + " svelte-38rpfk")) {
					attr(span1, "class", span1_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_block.d();
			}
		};
	}

	// (37:12) {:else}
	function create_else_block_2$2(ctx) {
		let t_value = /*item*/ ctx[1].title + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t_value !== (t_value = /*item*/ ctx[1].title + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (34:12) {#if item.url}
	function create_if_block_2$a(ctx) {
		let a;
		let t_value = /*item*/ ctx[1].title + "";
		let t;
		let a_href_value;
		let a_class_value;

		return {
			c() {
				a = element("a");
				t = text(t_value);
				attr(a, "href", a_href_value = /*item*/ ctx[1].url);
				attr(a, "class", a_class_value = "" + (null_to_empty(/*item*/ ctx[1].urlCustomClasses) + " svelte-38rpfk"));
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, t);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t_value !== (t_value = /*item*/ ctx[1].title + "")) set_data(t, t_value);

				if (dirty & /*values*/ 1 && a_href_value !== (a_href_value = /*item*/ ctx[1].url)) {
					attr(a, "href", a_href_value);
				}

				if (dirty & /*values*/ 1 && a_class_value !== (a_class_value = "" + (null_to_empty(/*item*/ ctx[1].urlCustomClasses) + " svelte-38rpfk"))) {
					attr(a, "class", a_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}
			}
		};
	}

	// (27:16) {:else}
	function create_else_block$e(ctx) {
		let t_value = /*item*/ ctx[1].value + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t_value !== (t_value = /*item*/ ctx[1].value + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (23:16) {#if item.url}
	function create_if_block_1$g(ctx) {
		let a;
		let t_value = /*item*/ ctx[1].value + "";
		let t;
		let a_href_value;
		let a_class_value;

		return {
			c() {
				a = element("a");
				t = text(t_value);
				attr(a, "href", a_href_value = /*item*/ ctx[1].url);
				attr(a, "class", a_class_value = "" + (null_to_empty(/*item*/ ctx[1].urlCustomClasses) + " svelte-38rpfk"));
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, t);
			},
			p(ctx, dirty) {
				if (dirty & /*values*/ 1 && t_value !== (t_value = /*item*/ ctx[1].value + "")) set_data(t, t_value);

				if (dirty & /*values*/ 1 && a_href_value !== (a_href_value = /*item*/ ctx[1].url)) {
					attr(a, "href", a_href_value);
				}

				if (dirty & /*values*/ 1 && a_class_value !== (a_class_value = "" + (null_to_empty(/*item*/ ctx[1].urlCustomClasses) + " svelte-38rpfk"))) {
					attr(a, "class", a_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}
			}
		};
	}

	// (18:0) {#each values as item (item.id)}
	function create_each_block$9(key_1, ctx) {
		let first;
		let show_if;
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (dirty & /*values*/ 1) show_if = null;
			if (show_if == null) show_if = !!Object.hasOwn(/*item*/ ctx[1], "value");
			if (show_if) return create_if_block$j;
			return create_else_block_1$3;
		}

		let current_block_type = select_block_type(ctx, -1);
		let if_block = current_block_type(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if_block.c();
				if_block_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function create_fragment$m(ctx) {
		let each_blocks = [];
		let each_1_lookup = new Map();
		let each_1_anchor;
		let each_value = ensure_array_like(/*values*/ ctx[0]);
		const get_key = ctx => /*item*/ ctx[1].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$9(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (dirty & /*values, Object*/ 1) {
					each_value = ensure_array_like(/*values*/ ctx[0]);
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$9, each_1_anchor, get_each_context$9);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d(detaching);
				}
			}
		};
	}

	function instance$m($$self, $$props, $$invalidate) {
		let { values = [] } = $$props;

		$$self.$$set = $$props => {
			if ('values' in $$props) $$invalidate(0, values = $$props.values);
		};

		return [values];
	}

	class Ui_tags extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$m, create_fragment$m, safe_not_equal, { values: 0 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/table/notTableCell.svelte generated by Svelte v4.2.19 */

	function create_else_block$d(ctx) {
		let t_value = /*$LOCALE*/ ctx[5][notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, field, item, helpers*/ 46 && t_value !== (t_value = /*$LOCALE*/ ctx[5][notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (71:98) 
	function create_if_block_7$2(ctx) {
		let t_value = notCommon$3.strLengthCap(notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]), /*field*/ ctx[1].maxLength) + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*field, item, helpers*/ 14 && t_value !== (t_value = notCommon$3.strLengthCap(notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]), /*field*/ ctx[1].maxLength) + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (60:30) 
	function create_if_block_6$2(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;

		const switch_instance_spread_levels = [
			{
				id: /*getItemId*/ ctx[0](/*item*/ ctx[2])
			},
			{ fieldname: /*field*/ ctx[1].path },
			{ disabled: /*field*/ ctx[1].disabled },
			{ readonly: /*field*/ ctx[1].readonly },
			{
				value: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
			},
			/*field*/ ctx[1].options
		];

		var switch_value = /*field*/ ctx[1].component;

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*getItemId, item, field, helpers*/ 15) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*getItemId, item*/ 5 && {
						id: /*getItemId*/ ctx[0](/*item*/ ctx[2])
					},
					dirty & /*field*/ 2 && { fieldname: /*field*/ ctx[1].path },
					dirty & /*field*/ 2 && { disabled: /*field*/ ctx[1].disabled },
					dirty & /*field*/ 2 && { readonly: /*field*/ ctx[1].readonly },
					dirty & /*field, item, helpers*/ 14 && {
						value: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
					},
					dirty & /*field*/ 2 && get_spread_object(/*field*/ ctx[1].options)
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));

			switch_instance.$on("change", function () {
				if (is_function(/*field*/ ctx[1].onChange)) /*field*/ ctx[1].onChange.apply(this, arguments);
			});
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*field*/ 2 && switch_value !== (switch_value = /*field*/ ctx[1].component)) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));

						switch_instance.$on("change", function () {
							if (is_function(/*field*/ ctx[1].onChange)) /*field*/ ctx[1].onChange.apply(this, arguments);
						});

						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*getItemId, item, field, helpers*/ 15)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*getItemId, item*/ 5 && {
								id: /*getItemId*/ ctx[0](/*item*/ ctx[2])
							},
							dirty & /*field*/ 2 && { fieldname: /*field*/ ctx[1].path },
							dirty & /*field*/ 2 && { disabled: /*field*/ ctx[1].disabled },
							dirty & /*field*/ 2 && { readonly: /*field*/ ctx[1].readonly },
							dirty & /*field, item, helpers*/ 14 && {
								value: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
							},
							dirty & /*field*/ 2 && get_spread_object(/*field*/ ctx[1].options)
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (51:38) 
	function create_if_block_5$4(ctx) {
		let tableswitch;
		let current;

		tableswitch = new Ui_switch({
				props: {
					id: /*getItemId*/ ctx[0](/*item*/ ctx[2]),
					fieldname: /*field*/ ctx[1].path,
					value: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]),
					disabled: /*field*/ ctx[1].disabled,
					readonly: /*field*/ ctx[1].readonly
				}
			});

		tableswitch.$on("change", function () {
			if (is_function(/*field*/ ctx[1].onChange)) /*field*/ ctx[1].onChange.apply(this, arguments);
		});

		return {
			c() {
				create_component(tableswitch.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tableswitch, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const tableswitch_changes = {};
				if (dirty & /*getItemId, item*/ 5) tableswitch_changes.id = /*getItemId*/ ctx[0](/*item*/ ctx[2]);
				if (dirty & /*field*/ 2) tableswitch_changes.fieldname = /*field*/ ctx[1].path;
				if (dirty & /*field, item, helpers*/ 14) tableswitch_changes.value = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				if (dirty & /*field*/ 2) tableswitch_changes.disabled = /*field*/ ctx[1].disabled;
				if (dirty & /*field*/ 2) tableswitch_changes.readonly = /*field*/ ctx[1].readonly;
				tableswitch.$set(tableswitch_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tableswitch.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tableswitch.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tableswitch, detaching);
			}
		};
	}

	// (49:35) 
	function create_if_block_4$6(ctx) {
		let tabletags;
		let current;

		tabletags = new Ui_tags({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(tabletags.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tabletags, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tabletags_changes = {};
				if (dirty & /*field, item, helpers*/ 14) tabletags_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				tabletags.$set(tabletags_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tabletags.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tabletags.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tabletags, detaching);
			}
		};
	}

	// (47:39) 
	function create_if_block_3$9(ctx) {
		let uibooleans;
		let current;

		uibooleans = new Ui_booleans({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(uibooleans.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibooleans, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibooleans_changes = {};
				if (dirty & /*field, item, helpers*/ 14) uibooleans_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				uibooleans.$set(uibooleans_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibooleans.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibooleans.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibooleans, detaching);
			}
		};
	}

	// (45:37) 
	function create_if_block_2$9(ctx) {
		let uiimages;
		let current;

		uiimages = new Ui_images({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(uiimages.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiimages, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiimages_changes = {};
				if (dirty & /*field, item, helpers*/ 14) uiimages_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				uiimages.$set(uiimages_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiimages.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiimages.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiimages, detaching);
			}
		};
	}

	// (43:38) 
	function create_if_block_1$f(ctx) {
		let uibuttons;
		let current;

		uibuttons = new Ui_buttons({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(uibuttons.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttons, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttons_changes = {};
				if (dirty & /*field, item, helpers*/ 14) uibuttons_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttons, detaching);
			}
		};
	}

	// (41:4) {#if field.type === "link"}
	function create_if_block$i(ctx) {
		let uilinks;
		let current;

		uilinks = new Ui_links({
				props: {
					values: notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3])
				}
			});

		return {
			c() {
				create_component(uilinks.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uilinks, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uilinks_changes = {};
				if (dirty & /*field, item, helpers*/ 14) uilinks_changes.values = notPath$1.get(/*field*/ ctx[1].path, /*item*/ ctx[2], /*helpers*/ ctx[3]);
				uilinks.$set(uilinks_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilinks.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilinks.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uilinks, detaching);
			}
		};
	}

	function create_fragment$l(ctx) {
		let td;
		let show_if;
		let current_block_type_index;
		let if_block;
		let td_class_value;
		let current;

		const if_block_creators = [
			create_if_block$i,
			create_if_block_1$f,
			create_if_block_2$9,
			create_if_block_3$9,
			create_if_block_4$6,
			create_if_block_5$4,
			create_if_block_6$2,
			create_if_block_7$2,
			create_else_block$d
		];

		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (dirty & /*field*/ 2) show_if = null;
			if (/*field*/ ctx[1].type === "link") return 0;
			if (/*field*/ ctx[1].type === "button") return 1;
			if (/*field*/ ctx[1].type === "image") return 2;
			if (/*field*/ ctx[1].type === "boolean") return 3;
			if (/*field*/ ctx[1].type === "tag") return 4;
			if (/*field*/ ctx[1].type === "switch") return 5;
			if (/*field*/ ctx[1].component) return 6;
			if (show_if == null) show_if = !!(/*field*/ ctx[1] && typeof /*field*/ ctx[1] !== "undefined" && !isNaN(/*field*/ ctx[1].maxLength) && /*field*/ ctx[1].maxLength);
			if (show_if) return 7;
			return 8;
		}

		current_block_type_index = select_block_type(ctx, -1);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				td = element("td");
				if_block.c();
				attr(td, "class", td_class_value = /*field*/ ctx[1].hideOnMobile ? "is-hidden-touch" : "");
				attr(td, "title", /*title*/ ctx[4]);
			},
			m(target, anchor) {
				insert(target, td, anchor);
				if_blocks[current_block_type_index].m(td, null);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(td, null);
				}

				if (!current || dirty & /*field*/ 2 && td_class_value !== (td_class_value = /*field*/ ctx[1].hideOnMobile ? "is-hidden-touch" : "")) {
					attr(td, "class", td_class_value);
				}

				if (!current || dirty & /*title*/ 16) {
					attr(td, "title", /*title*/ ctx[4]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(td);
				}

				if_blocks[current_block_type_index].d();
			}
		};
	}

	function instance$l($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(5, $LOCALE = $$value));
		let title = "";

		onMount(() => {
			if (typeof field.type === "undefined") {
				if (Object.hasOwn(field, "titlePath")) {
					$$invalidate(4, title = notPath$1.get(field.titlePath, item, helpers));
				} else if (Object.hasOwn(field, "titleComposer") && typeof field.titleComposer === "function") {
					$$invalidate(4, title = field.titleComposer(item, helpers));
				} else {
					$$invalidate(4, title = notPath$1.get(field.path, item, helpers));
				}
			}
		});

		let { getItemId = item => item._id } = $$props;
		let { field = {} } = $$props;
		let { item = {} } = $$props;
		let { helpers = {} } = $$props;

		$$self.$$set = $$props => {
			if ('getItemId' in $$props) $$invalidate(0, getItemId = $$props.getItemId);
			if ('field' in $$props) $$invalidate(1, field = $$props.field);
			if ('item' in $$props) $$invalidate(2, item = $$props.item);
			if ('helpers' in $$props) $$invalidate(3, helpers = $$props.helpers);
		};

		return [getItemId, field, item, helpers, title, $LOCALE];
	}

	class NotTableCell extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$l, create_fragment$l, safe_not_equal, {
				getItemId: 0,
				field: 1,
				item: 2,
				helpers: 3
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/table/notTableRow.svelte generated by Svelte v4.2.19 */

	function get_each_context$8(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[12] = list[i];
		return child_ctx;
	}

	// (36:2) {#if showSelect && $selectedList }
	function create_if_block$h(ctx) {
		let td;
		let input;
		let input_id_value;
		let input_data_id_value;
		let input_name_value;
		let mounted;
		let dispose;

		return {
			c() {
				td = element("td");
				input = element("input");
				attr(input, "id", input_id_value = "table-row-select-" + /*getItemId*/ ctx[4](/*item*/ ctx[0]));
				attr(input, "type", "checkbox");
				attr(input, "data-id", input_data_id_value = /*getItemId*/ ctx[4](/*item*/ ctx[0]));
				attr(input, "placeholder", "");
				attr(input, "name", input_name_value = "row_selected_" + /*getItemId*/ ctx[4](/*item*/ ctx[0]));
			},
			m(target, anchor) {
				insert(target, td, anchor);
				append(td, input);
				input.checked = /*$selectedList*/ ctx[7][/*itemId*/ ctx[5]];

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[10]),
						listen(input, "change", /*onRowSelect*/ ctx[8])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*getItemId, item*/ 17 && input_id_value !== (input_id_value = "table-row-select-" + /*getItemId*/ ctx[4](/*item*/ ctx[0]))) {
					attr(input, "id", input_id_value);
				}

				if (dirty & /*getItemId, item*/ 17 && input_data_id_value !== (input_data_id_value = /*getItemId*/ ctx[4](/*item*/ ctx[0]))) {
					attr(input, "data-id", input_data_id_value);
				}

				if (dirty & /*getItemId, item*/ 17 && input_name_value !== (input_name_value = "row_selected_" + /*getItemId*/ ctx[4](/*item*/ ctx[0]))) {
					attr(input, "name", input_name_value);
				}

				if (dirty & /*$selectedList, itemId*/ 160) {
					input.checked = /*$selectedList*/ ctx[7][/*itemId*/ ctx[5]];
				}
			},
			d(detaching) {
				if (detaching) {
					detach(td);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (41:2) {#each fields as field }
	function create_each_block$8(ctx) {
		let uitablecell;
		let current;

		uitablecell = new NotTableCell({
				props: {
					field: /*field*/ ctx[12],
					helpers: /*helpers*/ ctx[1],
					item: /*item*/ ctx[0],
					getItemId: /*getItemId*/ ctx[4]
				}
			});

		return {
			c() {
				create_component(uitablecell.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitablecell, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitablecell_changes = {};
				if (dirty & /*fields*/ 4) uitablecell_changes.field = /*field*/ ctx[12];
				if (dirty & /*helpers*/ 2) uitablecell_changes.helpers = /*helpers*/ ctx[1];
				if (dirty & /*item*/ 1) uitablecell_changes.item = /*item*/ ctx[0];
				if (dirty & /*getItemId*/ 16) uitablecell_changes.getItemId = /*getItemId*/ ctx[4];
				uitablecell.$set(uitablecell_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitablecell.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitablecell.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitablecell, detaching);
			}
		};
	}

	function create_fragment$k(ctx) {
		let tr;
		let t;
		let current;
		let if_block = /*showSelect*/ ctx[3] && /*$selectedList*/ ctx[7] && create_if_block$h(ctx);
		let each_value = ensure_array_like(/*fields*/ ctx[2]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				tr = element("tr");
				if (if_block) if_block.c();
				t = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
			},
			m(target, anchor) {
				insert(target, tr, anchor);
				if (if_block) if_block.m(tr, null);
				append(tr, t);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(tr, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (/*showSelect*/ ctx[3] && /*$selectedList*/ ctx[7]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$h(ctx);
						if_block.c();
						if_block.m(tr, t);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty & /*fields, helpers, item, getItemId*/ 23) {
					each_value = ensure_array_like(/*fields*/ ctx[2]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$8(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$8(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(tr, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(tr);
				}

				if (if_block) if_block.d();
				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$k($$self, $$props, $$invalidate) {
		let $selectedList,
			$$unsubscribe_selectedList = noop$1,
			$$subscribe_selectedList = () => ($$unsubscribe_selectedList(), $$unsubscribe_selectedList = subscribe(selectedList, $$value => $$invalidate(7, $selectedList = $$value)), selectedList);

		$$self.$$.on_destroy.push(() => $$unsubscribe_selectedList());
		let dispatch = createEventDispatcher();
		let itemId, selectedList;

		onMount(() => {
			$$invalidate(5, itemId = getItemId(item));
			$$subscribe_selectedList($$invalidate(6, selectedList = get(id).selected));
		});

		let { id } = $$props;
		let { item = {} } = $$props;
		let { helpers = {} } = $$props;
		let { fields = [] } = $$props;
		let { showSelect = false } = $$props;

		let { getItemId = () => {
			
		} } = $$props;

		function onRowSelect(e) {
			e.preventDefault();

			dispatch('rowSelectChange', {
				id: itemId,
				selected: $selectedList[itemId]
			});

			return false;
		}

		function input_change_handler() {
			$selectedList[itemId] = this.checked;
			selectedList.set($selectedList);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(9, id = $$props.id);
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
			if ('helpers' in $$props) $$invalidate(1, helpers = $$props.helpers);
			if ('fields' in $$props) $$invalidate(2, fields = $$props.fields);
			if ('showSelect' in $$props) $$invalidate(3, showSelect = $$props.showSelect);
			if ('getItemId' in $$props) $$invalidate(4, getItemId = $$props.getItemId);
		};

		return [
			item,
			helpers,
			fields,
			showSelect,
			getItemId,
			itemId,
			selectedList,
			$selectedList,
			onRowSelect,
			id,
			input_change_handler
		];
	}

	class NotTableRow extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$k, create_fragment$k, safe_not_equal, {
				id: 9,
				item: 0,
				helpers: 1,
				fields: 2,
				showSelect: 3,
				getItemId: 4
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/table/notTable.svelte generated by Svelte v4.2.19 */

	function get_each_context$7(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		return child_ctx;
	}

	function get_each_context_1$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[33] = list[i];
		return child_ctx;
	}

	function get_each_context_2$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[36] = list[i];
		const constants_0 = /*field*/ child_ctx[36].path.substring(1);
		child_ctx[37] = constants_0;
		return child_ctx;
	}

	// (123:0) {#if links.length}
	function create_if_block_7$1(ctx) {
		let div;
		let uilinks;
		let current;
		uilinks = new Ui_links({ props: { values: /*links*/ ctx[11] } });

		return {
			c() {
				div = element("div");
				create_component(uilinks.$$.fragment);
				attr(div, "class", "field is-grouped");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uilinks, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const uilinks_changes = {};
				if (dirty[0] & /*links*/ 2048) uilinks_changes.values = /*links*/ ctx[11];
				uilinks.$set(uilinks_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uilinks.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilinks.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uilinks);
			}
		};
	}

	// (128:0) {#if actions.length}
	function create_if_block_6$1(ctx) {
		let div;
		let uibuttons;
		let current;
		uibuttons = new Ui_buttons({ props: { values: /*actions*/ ctx[10] } });

		return {
			c() {
				div = element("div");
				create_component(uibuttons.$$.fragment);
				attr(div, "class", "field is-grouped");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uibuttons, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttons_changes = {};
				if (dirty[0] & /*actions*/ 1024) uibuttons_changes.values = /*actions*/ ctx[10];
				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uibuttons);
			}
		};
	}

	// (133:0) {#if showSearch}
	function create_if_block_4$5(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_5$3, create_else_block_2$1];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*filterUI*/ ctx[7]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (141:4) {:else}
	function create_else_block_2$1(ctx) {
		let div1;
		let div0;
		let input;
		let mounted;
		let dispose;

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				input = element("input");
				attr(input, "class", "input");
				attr(input, "type", "text");
				attr(input, "placeholder", "Поиск");
				attr(div0, "class", "control");
				attr(div1, "class", "field");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div0, input);
				set_input_value(input, /*search*/ ctx[4]);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[26]),
						listen(input, "input", /*onSearchInput*/ ctx[16])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*search*/ 16 && input.value !== /*search*/ ctx[4]) {
					set_input_value(input, /*search*/ ctx[4]);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (134:4) {#if filterUI}
	function create_if_block_5$3(ctx) {
		let switch_instance;
		let updating_filter;
		let switch_instance_anchor;
		let current;

		function switch_instance_filter_binding(value) {
			/*switch_instance_filter_binding*/ ctx[25](value);
		}

		var switch_value = /*filterUI*/ ctx[7];

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			if (/*filter*/ ctx[1] !== void 0) {
				switch_instance_props.filter = /*filter*/ ctx[1];
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			binding_callbacks.push(() => bind(switch_instance, 'filter', switch_instance_filter_binding));
			switch_instance.$on("change", /*onFilterChange*/ ctx[18]);
			switch_instance.$on("searchChange", /*onSearchChange*/ ctx[17]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*filterUI*/ 128 && switch_value !== (switch_value = /*filterUI*/ ctx[7])) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
						binding_callbacks.push(() => bind(switch_instance, 'filter', switch_instance_filter_binding));
						switch_instance.$on("change", /*onFilterChange*/ ctx[18]);
						switch_instance.$on("searchChange", /*onSearchChange*/ ctx[17]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = {};

					if (!updating_filter && dirty[0] & /*filter*/ 2) {
						updating_filter = true;
						switch_instance_changes.filter = /*filter*/ ctx[1];
						add_flush_callback(() => updating_filter = false);
					}

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (157:8) {#if showSelect}
	function create_if_block_3$8(ctx) {
		let th;
		let input;
		let mounted;
		let dispose;

		return {
			c() {
				th = element("th");
				input = element("input");
				attr(input, "type", "checkbox");
				attr(input, "id", "table-row-select-page");
				attr(input, "placeholder", "");
				attr(input, "name", "row_selected_all");
			},
			m(target, anchor) {
				insert(target, th, anchor);
				append(th, input);
				input.checked = /*selectAll*/ ctx[5];

				if (!mounted) {
					dispose = [
						listen(input, "change", /*input_change_handler*/ ctx[27]),
						listen(input, "change", /*onSelectAll*/ ctx[22])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectAll*/ 32) {
					input.checked = /*selectAll*/ ctx[5];
				}
			},
			d(detaching) {
				if (detaching) {
					detach(th);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (182:16) {:else}
	function create_else_block_1$2(ctx) {
		let t_value = /*$LOCALE*/ ctx[15][/*field*/ ctx[36].title] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, fields*/ 33280 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*field*/ ctx[36].title] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (176:16) {#if field.sortable && Object.hasOwn(sorter, propPath)}
	function create_if_block_2$8(ctx) {
		let uiicon;
		let current;

		uiicon = new Ui_icon_font({
				props: {
					font: /*sorter*/ ctx[2][/*propPath*/ ctx[37]] > 0
					? "sort-up"
					: "sort-down",
					title: /*field*/ ctx[36].title,
					pointable: true
				}
			});

		return {
			c() {
				create_component(uiicon.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiicon, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiicon_changes = {};

				if (dirty[0] & /*sorter, fields*/ 516) uiicon_changes.font = /*sorter*/ ctx[2][/*propPath*/ ctx[37]] > 0
				? "sort-up"
				: "sort-down";

				if (dirty[0] & /*fields*/ 512) uiicon_changes.title = /*field*/ ctx[36].title;
				uiicon.$set(uiicon_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiicon.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiicon.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiicon, detaching);
			}
		};
	}

	// (169:8) {#each fields as field}
	function create_each_block_2$3(ctx) {
		let th;
		let show_if;
		let current_block_type_index;
		let if_block;
		let t;
		let th_class_value;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_2$8, create_else_block_1$2];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (dirty[0] & /*fields, sorter*/ 516) show_if = null;
			if (show_if == null) show_if = !!(/*field*/ ctx[36].sortable && Object.hasOwn(/*sorter*/ ctx[2], /*propPath*/ ctx[37]));
			if (show_if) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx, [-1, -1]);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				th = element("th");
				if_block.c();
				t = space();
				attr(th, "class", th_class_value = (/*field*/ ctx[36].hideOnMobile ? " is-hidden-touch" : "") + (/*field*/ ctx[36].sortable ? " is-clickable" : ""));
			},
			m(target, anchor) {
				insert(target, th, anchor);
				if_blocks[current_block_type_index].m(th, null);
				append(th, t);
				current = true;

				if (!mounted) {
					dispose = listen(th, "click", function () {
						if (is_function(/*onFieldHeadClick*/ ctx[23](/*field*/ ctx[36]))) /*onFieldHeadClick*/ ctx[23](/*field*/ ctx[36]).apply(this, arguments);
					});

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(th, t);
				}

				if (!current || dirty[0] & /*fields*/ 512 && th_class_value !== (th_class_value = (/*field*/ ctx[36].hideOnMobile ? " is-hidden-touch" : "") + (/*field*/ ctx[36].sortable ? " is-clickable" : ""))) {
					attr(th, "class", th_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(th);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};
	}

	// (189:8) {#each items as item (item._id)}
	function create_each_block_1$3(key_1, ctx) {
		let first;
		let uitablerow;
		let current;

		uitablerow = new NotTableRow({
				props: {
					id: /*id*/ ctx[6],
					item: /*item*/ ctx[33],
					fields: /*fields*/ ctx[9],
					helpers: /*helpers*/ ctx[8],
					showSelect: /*showSelect*/ ctx[13],
					getItemId: /*getItemId*/ ctx[14]
				}
			});

		uitablerow.$on("rowSelectChange", /*rowSelectChange_handler*/ ctx[28]);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uitablerow.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uitablerow, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const uitablerow_changes = {};
				if (dirty[0] & /*id*/ 64) uitablerow_changes.id = /*id*/ ctx[6];
				if (dirty[0] & /*items*/ 8) uitablerow_changes.item = /*item*/ ctx[33];
				if (dirty[0] & /*fields*/ 512) uitablerow_changes.fields = /*fields*/ ctx[9];
				if (dirty[0] & /*helpers*/ 256) uitablerow_changes.helpers = /*helpers*/ ctx[8];
				if (dirty[0] & /*showSelect*/ 8192) uitablerow_changes.showSelect = /*showSelect*/ ctx[13];
				if (dirty[0] & /*getItemId*/ 16384) uitablerow_changes.getItemId = /*getItemId*/ ctx[14];
				uitablerow.$set(uitablerow_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitablerow.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitablerow.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uitablerow, detaching);
			}
		};
	}

	// (206:8) {#if state.pagination && state.pagination.pages && state.pagination.pages.list}
	function create_if_block$g(ctx) {
		let each_1_anchor;
		let each_value = ensure_array_like(/*state*/ ctx[0].pagination.pages.list);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*state, goTo*/ 2097153) {
					each_value = ensure_array_like(/*state*/ ctx[0].pagination.pages.list);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$7(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$7(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (216:20) {:else}
	function create_else_block$c(ctx) {
		let a;
		let t_value = /*page*/ ctx[30].index + 1 + "";
		let t;
		let a_aria_label_value;
		let a_data_page_value;
		let mounted;
		let dispose;

		return {
			c() {
				a = element("a");
				t = text(t_value);
				attr(a, "href", "");
				attr(a, "class", "pagination-link");
				attr(a, "aria-label", a_aria_label_value = "Страница " + /*page*/ ctx[30].index);
				attr(a, "data-page", a_data_page_value = /*page*/ ctx[30].index);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, t);

				if (!mounted) {
					dispose = listen(a, "click", /*goTo*/ ctx[21]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*state*/ 1 && t_value !== (t_value = /*page*/ ctx[30].index + 1 + "")) set_data(t, t_value);

				if (dirty[0] & /*state*/ 1 && a_aria_label_value !== (a_aria_label_value = "Страница " + /*page*/ ctx[30].index)) {
					attr(a, "aria-label", a_aria_label_value);
				}

				if (dirty[0] & /*state*/ 1 && a_data_page_value !== (a_data_page_value = /*page*/ ctx[30].index)) {
					attr(a, "data-page", a_data_page_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (209:20) {#if page.active}
	function create_if_block_1$e(ctx) {
		let a;
		let t_value = /*page*/ ctx[30].index + 1 + "";
		let t;
		let a_aria_label_value;

		return {
			c() {
				a = element("a");
				t = text(t_value);
				attr(a, "href", "");
				attr(a, "class", "pagination-link is-current");
				attr(a, "aria-label", a_aria_label_value = "Страница " + /*page*/ ctx[30].index);
				attr(a, "aria-current", "page");
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*state*/ 1 && t_value !== (t_value = /*page*/ ctx[30].index + 1 + "")) set_data(t, t_value);

				if (dirty[0] & /*state*/ 1 && a_aria_label_value !== (a_aria_label_value = "Страница " + /*page*/ ctx[30].index)) {
					attr(a, "aria-label", a_aria_label_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}
			}
		};
	}

	// (207:12) {#each state.pagination.pages.list as page}
	function create_each_block$7(ctx) {
		let li;
		let t;

		function select_block_type_2(ctx, dirty) {
			if (/*page*/ ctx[30].active) return create_if_block_1$e;
			return create_else_block$c;
		}

		let current_block_type = select_block_type_2(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				li = element("li");
				if_block.c();
				t = space();
			},
			m(target, anchor) {
				insert(target, li, anchor);
				if_block.m(li, null);
				append(li, t);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(li, t);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				if_block.d();
			}
		};
	}

	function create_fragment$j(ctx) {
		let t0;
		let t1;
		let t2;
		let table;
		let thead;
		let t3;
		let t4;
		let tbody;
		let each_blocks = [];
		let each1_lookup = new Map();
		let t5;
		let nav;
		let a0;
		let t7;
		let a1;
		let t9;
		let ul;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*links*/ ctx[11].length && create_if_block_7$1(ctx);
		let if_block1 = /*actions*/ ctx[10].length && create_if_block_6$1(ctx);
		let if_block2 = /*showSearch*/ ctx[12] && create_if_block_4$5(ctx);
		let if_block3 = /*showSelect*/ ctx[13] && create_if_block_3$8(ctx);
		let each_value_2 = ensure_array_like(/*fields*/ ctx[9]);
		let each_blocks_1 = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks_1[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
		}

		const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
			each_blocks_1[i] = null;
		});

		let each_value_1 = ensure_array_like(/*items*/ ctx[3]);
		const get_key = ctx => /*item*/ ctx[33]._id;

		for (let i = 0; i < each_value_1.length; i += 1) {
			let child_ctx = get_each_context_1$3(ctx, each_value_1, i);
			let key = get_key(child_ctx);
			each1_lookup.set(key, each_blocks[i] = create_each_block_1$3(key, child_ctx));
		}

		let if_block4 = /*state*/ ctx[0].pagination && /*state*/ ctx[0].pagination.pages && /*state*/ ctx[0].pagination.pages.list && create_if_block$g(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				table = element("table");
				thead = element("thead");
				if (if_block3) if_block3.c();
				t3 = space();

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].c();
				}

				t4 = space();
				tbody = element("tbody");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t5 = space();
				nav = element("nav");
				a0 = element("a");
				a0.textContent = "Назад";
				t7 = space();
				a1 = element("a");
				a1.textContent = "Вперед";
				t9 = space();
				ul = element("ul");
				if (if_block4) if_block4.c();
				attr(table, "class", "table");
				attr(a0, "href", "");
				attr(a0, "class", "pagination-previous");
				attr(a1, "href", "");
				attr(a1, "class", "pagination-next");
				attr(ul, "class", "pagination-list");
				attr(nav, "class", "pagination is-centered");
				attr(nav, "aria-label", "pagination");
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t2, anchor);
				insert(target, table, anchor);
				append(table, thead);
				if (if_block3) if_block3.m(thead, null);
				append(thead, t3);

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					if (each_blocks_1[i]) {
						each_blocks_1[i].m(thead, null);
					}
				}

				append(table, t4);
				append(table, tbody);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(tbody, null);
					}
				}

				insert(target, t5, anchor);
				insert(target, nav, anchor);
				append(nav, a0);
				append(nav, t7);
				append(nav, a1);
				append(nav, t9);
				append(nav, ul);
				if (if_block4) if_block4.m(ul, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(a0, "click", /*goPrev*/ ctx[19]),
						listen(a1, "click", /*goNext*/ ctx[20])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (/*links*/ ctx[11].length) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*links*/ 2048) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_7$1(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*actions*/ ctx[10].length) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*actions*/ 1024) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_6$1(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*showSearch*/ ctx[12]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*showSearch*/ 4096) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_4$5(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(t2.parentNode, t2);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*showSelect*/ ctx[13]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block_3$8(ctx);
						if_block3.c();
						if_block3.m(thead, t3);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}

				if (dirty[0] & /*fields, onFieldHeadClick, sorter, $LOCALE*/ 8421892) {
					each_value_2 = ensure_array_like(/*fields*/ ctx[9]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

						if (each_blocks_1[i]) {
							each_blocks_1[i].p(child_ctx, dirty);
							transition_in(each_blocks_1[i], 1);
						} else {
							each_blocks_1[i] = create_each_block_2$3(child_ctx);
							each_blocks_1[i].c();
							transition_in(each_blocks_1[i], 1);
							each_blocks_1[i].m(thead, null);
						}
					}

					group_outros();

					for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (dirty[0] & /*id, items, fields, helpers, showSelect, getItemId*/ 25416) {
					each_value_1 = ensure_array_like(/*items*/ ctx[3]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each1_lookup, tbody, outro_and_destroy_block, create_each_block_1$3, null, get_each_context_1$3);
					check_outros();
				}

				if (/*state*/ ctx[0].pagination && /*state*/ ctx[0].pagination.pages && /*state*/ ctx[0].pagination.pages.list) {
					if (if_block4) {
						if_block4.p(ctx, dirty);
					} else {
						if_block4 = create_if_block$g(ctx);
						if_block4.c();
						if_block4.m(ul, null);
					}
				} else if (if_block4) {
					if_block4.d(1);
					if_block4 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks_1[i]);
				}

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				each_blocks_1 = each_blocks_1.filter(Boolean);

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					transition_out(each_blocks_1[i]);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(table);
					detach(t5);
					detach(nav);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				if (if_block3) if_block3.d();
				destroy_each(each_blocks_1, detaching);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}

				if (if_block4) if_block4.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$j($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(15, $LOCALE = $$value));
		let dispatch = createEventDispatcher();
		let { id } = $$props;
		let { filterUI } = $$props;
		let { helpers = {} } = $$props;
		let { state = {} } = $$props;
		let { filter = {} } = $$props;
		let { sorter = {} } = $$props;
		let { fields = [] } = $$props;
		let { selected = {} } = $$props;
		let { items = [] } = $$props;
		let { actions = [] } = $$props;
		let { links = [] } = $$props;
		let { search = "" } = $$props;
		let { showSearch = true } = $$props;
		let { showSelect = true } = $$props;
		let { selectAll = false } = $$props;
		let { getItemId = item => item._id } = $$props;

		onMount(() => {
			if (showSelect) {
				get(id).selected.subscribe(value => {
					$$invalidate(24, selected = value);
				});
			}

			get(id).refined.subscribe(value => {
				$$invalidate(3, items = value);

				if (showSelect) {
					for (let itemId in selected) {
						if (!items.some(item => getItemId(item) === itemId)) {
							delete selected[itemId];
						} else {
							if (!Object.hasOwn(selected, itemId)) {
								$$invalidate(24, selected[itemId] = false, selected);
							}
						}
					}

					$$invalidate(24, selected);
				}
			});

			get(id).state.subscribe(value => {
				$$invalidate(0, state = value);
			});
		});

		function onSearchInput(ev) {
			try {
				let data = ev.currentTarget.value.trim();
				dispatch("searchChange", data);
			} catch(e) {
				return;
			}
		}

		function onSearchChange({ detail }) {
			try {
				dispatch("searchChange", detail);
			} catch(e) {
				return;
			}
		}

		function onFilterChange({ detail }) {
			try {
				dispatch("filterChange", detail);
			} catch(e) {
				return;
			}
		}

		function goPrev() {
			dispatch("goToPrevPage");
		}

		function goNext() {
			dispatch("goToNextPage");
		}

		function goTo(e) {
			e.preventDefault();
			let el = e.target;
			dispatch("goToPage", parseInt(el.dataset.page));
			return false;
		}

		function onSelectAll() {
			get(id).selected.update(value => {
				items.forEach(item => {
					value[getItemId(item)] = selectAll;
				});

				return value;
			});
		}

		function onFieldHeadClick(field) {
			const propPath = field.path.substring(1);

			if (Object.hasOwn(sorter, propPath)) {
				$$invalidate(2, sorter[propPath] = parseInt(sorter[propPath]) * -1, sorter);
			} else {
				$$invalidate(2, sorter = { [propPath]: 1 });
			}

			dispatch("sorterChange", sorter);
		}

		function switch_instance_filter_binding(value) {
			filter = value;
			$$invalidate(1, filter);
		}

		function input_input_handler() {
			search = this.value;
			$$invalidate(4, search);
		}

		function input_change_handler() {
			selectAll = this.checked;
			$$invalidate(5, selectAll);
		}

		function rowSelectChange_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(6, id = $$props.id);
			if ('filterUI' in $$props) $$invalidate(7, filterUI = $$props.filterUI);
			if ('helpers' in $$props) $$invalidate(8, helpers = $$props.helpers);
			if ('state' in $$props) $$invalidate(0, state = $$props.state);
			if ('filter' in $$props) $$invalidate(1, filter = $$props.filter);
			if ('sorter' in $$props) $$invalidate(2, sorter = $$props.sorter);
			if ('fields' in $$props) $$invalidate(9, fields = $$props.fields);
			if ('selected' in $$props) $$invalidate(24, selected = $$props.selected);
			if ('items' in $$props) $$invalidate(3, items = $$props.items);
			if ('actions' in $$props) $$invalidate(10, actions = $$props.actions);
			if ('links' in $$props) $$invalidate(11, links = $$props.links);
			if ('search' in $$props) $$invalidate(4, search = $$props.search);
			if ('showSearch' in $$props) $$invalidate(12, showSearch = $$props.showSearch);
			if ('showSelect' in $$props) $$invalidate(13, showSelect = $$props.showSelect);
			if ('selectAll' in $$props) $$invalidate(5, selectAll = $$props.selectAll);
			if ('getItemId' in $$props) $$invalidate(14, getItemId = $$props.getItemId);
		};

		return [
			state,
			filter,
			sorter,
			items,
			search,
			selectAll,
			id,
			filterUI,
			helpers,
			fields,
			actions,
			links,
			showSearch,
			showSelect,
			getItemId,
			$LOCALE,
			onSearchInput,
			onSearchChange,
			onFilterChange,
			goPrev,
			goNext,
			goTo,
			onSelectAll,
			onFieldHeadClick,
			selected,
			switch_instance_filter_binding,
			input_input_handler,
			input_change_handler,
			rowSelectChange_handler
		];
	}

	class NotTable extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$j,
				create_fragment$j,
				safe_not_equal,
				{
					id: 6,
					filterUI: 7,
					helpers: 8,
					state: 0,
					filter: 1,
					sorter: 2,
					fields: 9,
					selected: 24,
					items: 3,
					actions: 10,
					links: 11,
					search: 4,
					showSearch: 12,
					showSelect: 13,
					selectAll: 5,
					getItemId: 14
				},
				null,
				[-1, -1]
			);
		}
	}

	const CONST_ID_DUBLICATE_POSTFIX = "__dublicate__";

	const OPT_DEFAULT_PAGE_SIZE$1 = 20,
	    OPT_DEFAULT_PAGE_NUMBER$1 = 0,
	    OPT_DEFAULT_PAGE_RANGE$1 = 6,
	    OPT_DEFAULT_SORT_DIRECTION$1 = 1,
	    OPT_DEFAULT_SEARCH$1 = "",
	    OPT_DEFAULT_RETURN$1 = {},
	    OPT_DEFAULT_COMBINED = false,
	    OPT_DEFAULT_COMBINED_ACTION$1 = "listAndCount",
	    OPT_DEFAULT_COUNT_ACTION = "count",
	    OPT_DEFAULT_LIST_ACTION = "list",
	    OPT_DEFAULT_SORT_FIELD$1 = "_id",
	    OPT_FIELD_NAME_PRE_PROC = "preprocessor";

	const DEFAULT_OPTIONS$3 = {
	    ui: NotTable,
	    links: [],
	    actions: [],
	    endless: false,
	    idField: "_id",
	    getItemId: (item) => {
	        return item._id;
	    },
	};

	class notTable extends EventEmitter {
	    constructor(input = {}) {
	        super();
	        this.id = "table-" + Math.random();
	        this.options = {
	            ...DEFAULT_OPTIONS$3,
	            ...(input.options ? input.options : {}),
	        };
	        this.ui = {};
	        this.data = {
	            raw: [],
	            filtered: [],
	            refined: [],
	            selected: {},
	        };
	        this.state = {
	            pagination: {
	                items: {
	                    count: 0,
	                    from: 0,
	                    to: 0,
	                },
	                pages: {
	                    count: 0,
	                    from: 0,
	                    to: 0,
	                    current: 0,
	                    list: [],
	                },
	            },
	        };
	        this.working = {};

	        this.stores = create(this.id, {
	            raw: [],
	            filtered: [],
	            refined: [],
	            selected: {},
	            state: this.state,
	            working: this.working,
	        });

	        this.stores.working.subscribe(this.onWorkingUpdate.bind(this));
	        //полученные из сети
	        this.stores.raw.subscribe(this.onRawUpdate.bind(this));
	        //применены фильтры, сортировки и т.д.
	        this.stores.filtered.subscribe(this.onFilteredUpdate.bind(this));
	        //урезаны до минимального набора, точно соотвествующего табличному формату
	        this.stores.refined.subscribe(this.onRefinedUpdate.bind(this));
	        //словарь с идентификаторами выбранных строк
	        this.stores.selected.subscribe(this.onSelectedUpdate.bind(this));
	        //pagination, items information
	        this.stores.state.subscribe(this.onStateUpdate.bind(this));

	        if (notCommon$3.objHas(input, "data") && Array.isArray(input.data)) {
	            this.stores.raw.update((val) => {
	                val = input.data;
	                return val;
	            });
	        }
	        if (notCommon$3.objHas(this.options, "filter")) {
	            this.setFilter(this.options.filter, true);
	        } else {
	            this.resetFilter();
	        }
	        if (notCommon$3.objHas(this.options, "pager")) {
	            this.setPager(this.options.pager, true);
	        } else {
	            this.resetPager();
	        }
	        if (notCommon$3.objHas(this.options, "sorter")) {
	            this.setSorter(this.options.sorter, true);
	        } else {
	            this.resetSorter(true);
	        }
	        if (notCommon$3.objHas(this.options, "return")) {
	            this.setReturn(this.options.return);
	        } else {
	            this.setReturn();
	        }
	        if (notCommon$3.objHas(this.options, "search")) {
	            this.setSearch(this.options.search, true);
	        } else {
	            this.setSearch();
	        }
	        this.render();
	        this.updateData();
	        return this;
	    }

	    onWorkingUpdate(val) {
	        this.working = val;
	        return val;
	    }

	    onRawUpdate(val) {
	        this.data.raw = val;
	        return val;
	    }

	    onFilteredUpdate(val) {
	        this.data.filtered = val;
	        this.refineFiltered();
	        return val;
	    }

	    onRefinedUpdate(val) {
	        this.data.refined = val;
	        this.clearSelected();
	        return val;
	    }

	    onStateUpdate(val) {
	        this.state = val;
	        return val;
	    }

	    onSearchChange(line) {
	        if (line.length > 3) {
	            this.setSearch(line);
	        } else {
	            this.setSearch();
	        }
	    }

	    onSorterChange(sorter) {
	        if (sorter) {
	            this.setSorter(sorter);
	        } else {
	            this.resetSorter();
	        }
	    }

	    onFilterChange(filter) {
	        if (filter) {
	            this.setFilter(filter);
	        } else {
	            this.resetFilter();
	        }
	    }

	    onSelectedUpdate(val) {
	        this.data.selected = val;
	    }

	    clearSelected() {
	        this.data.selected = {};
	    }

	    getSelected(object = false, store = "refined") {
	        let res = [];
	        for (let id in this.data.selected) {
	            if (this.data.selected[id]) {
	                if (object) {
	                    let indx = this.data[store].findIndex(
	                        (item) => item._id === id
	                    );
	                    if (indx > -1) {
	                        res.push(this.data[store][indx]);
	                    }
	                } else {
	                    res.push(id);
	                }
	            }
	        }
	        return res;
	    }

	    getItemId(item) {
	        return this.getOptions("getItemId", DEFAULT_OPTIONS$3.getItemId)(item);
	    }

	    selectAll() {
	        this.stores.selected.update(() => {
	            let value = {};
	            this.data.filtered.forEach((item) => {
	                value[this.getItemId(item)] = true;
	            });
	            return value;
	        });
	    }

	    selectNone() {
	        this.stores.selected.update(() => {
	            let value = {};
	            this.data.filtered.forEach((item) => {
	                value[this.getItemId(item)] = false;
	            });
	            return value;
	        });
	    }

	    render() {
	        if (!this.ui.table) {
	            this.ui.table = new this.options.ui({
	                target: this.options.targetEl,
	                props: {
	                    filterUI: this.getOptions("filterUI", undefined),
	                    id: this.id,
	                    helpers: Object.assign({}, this.getHelpers()),
	                    fields: this.getOptions("fields"),
	                    actions: this.getActions(),
	                    links: this.getLinks(),
	                    search: "",
	                    showSelect: this.getOptions("showSelect"),
	                    showSearch: this.getOptions("showSearch"),
	                    showSort: this.getOptions("showSort"),
	                    idField: this.getOptions("idField"),
	                    getItemId: this.getOptions("getItemId"),
	                    filter: this.getFilter(),
	                },
	            });
	        }
	        this.ui.table.$on("searchChange", (e) => this.onSearchChange(e.detail));
	        this.ui.table.$on("sorterChange", (e) => this.onSorterChange(e.detail));
	        this.ui.table.$on("filterChange", (e) => this.onFilterChange(e.detail));
	        this.ui.table.$on("goToPage", (e) => this.goToPage(e.detail));
	        this.ui.table.$on("goToNextPage", () => this.goToNext());
	        this.ui.table.$on("goToPrevPage", () => this.goToPrev());
	    }

	    getActions() {
	        return this.getOptions("actions", []);
	    }

	    getLinks() {
	        return this.getOptions("links", []);
	    }

	    getHelpers() {
	        return this.options.helpers || {};
	    }

	    setWorking(key, value) {
	        this.stores.working.update((val) => {
	            notPath$1.set(key, val, this.getHelpers(), value);
	            return val;
	        });
	        return this;
	    }

	    getWorking(key, def) {
	        let res = notPath$1.get(key, this.working, this.getHelpers());
	        if (res === undefined) {
	            return def;
	        } else {
	            return res;
	        }
	    }

	    setState(key, value) {
	        this.stores.state.update((val) => {
	            notPath$1.set(key, val, this.getHelpers(), value);
	            return val;
	        });
	        return this;
	    }

	    getState(key, def) {
	        let res = notPath$1.get(key, this.state, this.getHelpers());
	        if (res === undefined) {
	            return def;
	        } else {
	            return res;
	        }
	    }

	    setOptions(key, value) {
	        notPath$1.set(key, this.options, this.getHelpers(), value);
	        return this;
	    }

	    getOptions(key, def) {
	        let res = notPath$1.get(key, this.options, this.getHelpers());
	        if (res === undefined) {
	            return def;
	        } else {
	            return res;
	        }
	    }

	    setFilter(hash, withoutInvalidation = false) {
	        this.setState("filter", hash);
	        if (withoutInvalidation) {
	            return this;
	        }
	        this.invalidateData();
	        this.updateData();
	        return this;
	    }

	    resetFilter() {
	        this.setState("filter", {});
	        return this;
	    }

	    getFilter() {
	        return this.getState("filter");
	    }

	    setPager(hash, withoutInvalidation = false) {
	        this.setState("pager", hash);
	        if (withoutInvalidation) {
	            return this;
	        }
	        this.updateData();
	        return this;
	    }

	    getDefaultPageNumber() {
	        return isNaN(this.getOptions("pager.page"))
	            ? OPT_DEFAULT_PAGE_NUMBER$1
	            : this.getOptions("pager.page");
	    }

	    getDefaultPageSize() {
	        return isNaN(this.getOptions("pager.size"))
	            ? OPT_DEFAULT_PAGE_SIZE$1
	            : this.getOptions("pager.size");
	    }

	    resetPager() {
	        this.setState("pager", {
	            size: this.getDefaultPageSize(),
	            page: this.getDefaultPageNumber(),
	        });
	    }

	    getPager() {
	        return this.getState("pager");
	    }

	    setSorter(hash, withoutInvalidation = false) {
	        this.setWorking("sorter", hash);
	        if (withoutInvalidation) {
	            return this;
	        }
	        this.invalidateData();
	        this.updateData();
	        return this;
	    }

	    resetSorter(withoutInvalidation = false) {
	        let t = {};
	        t[OPT_DEFAULT_SORT_FIELD$1] = OPT_DEFAULT_SORT_DIRECTION$1;
	        return this.setSorter(t, withoutInvalidation);
	    }

	    getSorter() {
	        return this.getWorking("sorter");
	    }

	    getSorterDirection() {
	        try {
	            let names = Object.keys(this.getSorter());
	            return this.getSorter()[names[0]];
	        } catch (e) {
	            return OPT_DEFAULT_SORT_DIRECTION$1;
	        }
	    }

	    getSearch() {
	        let search =
	            typeof this.getWorking("search") !== "undefined" &&
	            this.getWorking("search") !== null;
	        return search ? this.getWorking("search") : "";
	    }

	    setSearch(line = OPT_DEFAULT_SEARCH$1, withoutInvalidation = false) {
	        this.setWorking("search", line);
	        if (withoutInvalidation) {
	            return this;
	        }
	        this.invalidateData();
	        this.updateData();
	        return this;
	    }

	    getReturn() {
	        return this.getWorking("return");
	    }

	    setReturn(ret = OPT_DEFAULT_RETURN$1) {
	        this.setWorking("return", ret);
	        return this;
	    }

	    clearFilteredData() {
	        this.stores.filtered.update((val) => {
	            val.splice(0, val.length);
	            return val;
	        });
	    }

	    clearRawData() {
	        this.stores.raw.update((val) => {
	            val.splice(0, val.length);
	            return val;
	        });
	    }

	    clearRefinedData() {
	        this.stores.refined.update((val) => {
	            val.splice(0, val.length);
	            return val;
	        });
	    }

	    invalidateData() {
	        //clearing filtered and sorted
	        this.clearFilteredData();
	        //in case live loading from server
	        if (this.isLive()) {
	            //clearing loaded data
	            this.clearRawData();
	        }
	        //resset pager anyway
	        this.resetPager();
	    }

	    isLive() {
	        return (
	            this.getOptions("interface") && this.getOptions("interface.factory")
	        );
	    }

	    setUpdating() {
	        this.setState("updating", true);
	    }

	    setUpdated() {
	        this.setState("updating", false);
	    }

	    ifUpdating() {
	        return this.getState("updating");
	    }

	    getDataInterface() {
	        let factory = this.getOptions("interface.factory");
	        if (typeof factory === "function") {
	            return factory({});
	        } else {
	            return factory;
	        }
	    }

	    getLoadDataActionName() {
	        return this.getOptions("interface.listAction")
	            ? this.getOptions("interface.listAction")
	            : OPT_DEFAULT_LIST_ACTION;
	    }

	    getCombinedActionName() {
	        return this.getOptions("interface.combinedAction")
	            ? this.getOptions("interface.combinedAction")
	            : OPT_DEFAULT_COMBINED_ACTION$1;
	    }

	    getCountActionName() {
	        return this.getOptions("interface.countAction")
	            ? this.getOptions("interface.countAction")
	            : OPT_DEFAULT_COUNT_ACTION;
	    }

	    loadData() {
	        //load from server
	        let query = this.getDataInterface()
	                .setFilter(this.getFilter())
	                .setSorter(this.getSorter())
	                .setReturn(this.getReturn())
	                .setSearch(this.getSearch())
	                .setPager(this.getPager()),
	            actionName;
	        if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	            actionName = this.getCombinedActionName();
	        } else {
	            actionName = this.getLoadDataActionName();
	        }
	        return query["$" + actionName]();
	    }

	    goToNext() {
	        let next = isNaN(this.getState("pager.page"))
	            ? this.getDefaultPageNumber()
	            : this.getState("pager.page") + 1;
	        this.setState(
	            "pager.page",
	            Math.min(next, this.getState("pagination.pages.to"))
	        );
	        this.updateData();
	    }

	    goToPrev() {
	        let prev = isNaN(this.getState("pager.page"))
	            ? this.getDefaultPageNumber()
	            : this.getState("pager.page") - 1;
	        this.setState(
	            "pager.page",
	            Math.max(prev, this.getState("pagination.pages.from"))
	        );
	        this.updateData();
	    }

	    goToFirst() {
	        this.setState("pager.page", this.getState("pagination.pages.from"));
	        this.updateData();
	    }

	    goToLast() {
	        this.setState("pager.page", this.getState("pagination.pages.to"));
	        this.updateData();
	    }

	    goToPage(pageNumber) {
	        this.setState("pager.page", pageNumber);
	        this.updateData();
	    }

	    testDataItem(item) {
	        var strValue = this.getSearch().toLowerCase();
	        for (var k in item) {
	            var toComp = item[k].toString().toLowerCase();
	            if (toComp.indexOf(strValue) > -1) {
	                return true;
	            }
	        }
	        return false;
	    }

	    getRowsCount() {
	        let query = this.getDataInterface().setFilter(this.getFilter());
	        return query["$" + this.getCountActionName()]()
	            .then((data) => {
	                this.updatePagination(data.count);
	            })
	            .catch((e) => {
	                this.error(e);
	            });
	    }

	    updatePagination(itemsCount) {
	        this.log("update pagination", itemsCount);
	        this.state.pagination.pages.list.splice(
	            0,
	            this.state.pagination.pages.list.length
	        );
	        let itemsFrom =
	                (this.getPager().page - OPT_DEFAULT_PAGE_NUMBER$1) *
	                    this.getPager().size +
	                1,
	            pagesCount =
	                itemsCount % this.getPager().size
	                    ? Math.floor(itemsCount / this.getPager().size) + 1
	                    : Math.round(itemsCount / this.getPager().size),
	            pagesFrom = Math.max(
	                OPT_DEFAULT_PAGE_NUMBER$1,
	                this.getPager().page - OPT_DEFAULT_PAGE_RANGE$1
	            ),
	            pagesTo = Math.min(
	                pagesCount - (1 - OPT_DEFAULT_PAGE_NUMBER$1),
	                this.getPager().page + OPT_DEFAULT_PAGE_RANGE$1
	            ),
	            list = [],
	            itemsTo = Math.min(
	                itemsFrom + this.getPager().size - 1,
	                itemsCount
	            );
	        for (let t = pagesFrom; t <= pagesTo; t++) {
	            list.push({
	                index: t,
	                active: t === this.getPager().page,
	            });
	        }

	        this.stores.state.update((val) => {
	            this.log("update pagination", val);
	            val.pagination.items.count = itemsCount;
	            val.pagination.items.from = itemsFrom;
	            val.pagination.items.to = itemsTo;
	            val.pagination.pages.count = pagesCount;
	            val.pagination.pages.from = pagesFrom;
	            val.pagination.pages.to = pagesTo;
	            val.pagination.pages.current = this.getPager().page;
	            val.pagination.pages.list.splice(
	                0,
	                val.pagination.pages.list.length,
	                ...list
	            );
	            return val;
	        });
	    }

	    updateData() {
	        if (this.isLive()) {
	            if (this.ifUpdating()) {
	                return;
	            }
	            if (!this.getOptions("endless", false)) {
	                this.clearRawData();
	            }
	            this.setUpdating();
	            if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	                this.loadData()
	                    .then((data) => {
	                        let full =
	                            notCommon$3.objHas(data, "status") &&
	                            notCommon$3.objHas(data, "result");
	                        this.stores.filtered.update((val) => {
	                            if (!this.getOptions("endless", false)) {
	                                this.clearFilteredData();
	                            }
	                            if (full) {
	                                val.push(...data.result.list);
	                            } else {
	                                if (
	                                    notCommon$3.objHas(data, "list") &&
	                                    Array.isArray(data.list)
	                                ) {
	                                    val.push(...data.list);
	                                } else if (Array.isArray(data)) {
	                                    val.push(...data);
	                                }
	                            }
	                            return val;
	                        });
	                        this.setWorking(
	                            "lastCount",
	                            full ? data.result.count : data.count
	                        );
	                    })
	                    .then(() => {
	                        this.updatePagination(this.getWorking("lastCount"));
	                    })
	                    .catch(this.error.bind(this))
	                    .then(this.setUpdated.bind(this));
	            } else {
	                this.loadData()
	                    .then((data) => {
	                        this.stores.filtered.update((val) => {
	                            val.push(...data);
	                            return val;
	                        });
	                    })
	                    .then(this.getRowsCount.bind(this))
	                    .catch(this.error.bind(this))
	                    .then(this.setUpdated.bind(this));
	            }
	        } else {
	            //local magic
	            this.setUpdating();
	            this.processData();
	            this.setUpdated();
	        }
	    }

	    getData() {
	        return this.data;
	    }

	    processData() {
	        let thatFilter = this.getFilter();
	        //this.getData('rows').__setPassive;
	        this.log(this.getData());
	        if (
	            typeof thatFilter !== "undefined" &&
	            thatFilter !== null &&
	            typeof thatFilter.filterSearch !== "undefined" &&
	            thatFilter.filterSearch !== null &&
	            thatFilter.filterSearch.length > 0
	        ) {
	            this.stores.filtered.update((val) => {
	                val.splice(
	                    0,
	                    val.length,
	                    ...this.data.raw.filter(this.testDataItem.bind(this))
	                );
	                return val;
	            });
	        } else {
	            this.stores.filtered.update((val) => {
	                val.splice(0, val.length, ...this.data.raw);
	                return val;
	            });
	        }
	        ////sorter
	        let thatSorter = this.getSorter();
	        if (typeof thatSorter !== "undefined" && thatSorter !== null) {
	            this.stores.filtered.update((val) => {
	                val.sort((item1, item2) => {
	                    let t1 = notPath$1.get(thatSorter.sortByField, item1, {}),
	                        t2 = notPath$1.get(thatSorter.sortByField, item2, {});
	                    if (isNaN(t1)) {
	                        if (
	                            typeof t1 !== "undefined" &&
	                            typeof t2 !== "undefined" &&
	                            t1.localeCompare
	                        ) {
	                            return (
	                                t1.localeCompare() * -thatSorter.sortDirection
	                            );
	                        } else {
	                            return 0;
	                        }
	                    } else {
	                        return (t1 < t2 ? 1 : -1) * thatSorter.sortDirection;
	                    }
	                });
	                return val;
	            });
	        }
	    }

	    error() {
	        if (this.options.logger) {
	            this.options.logger.error(...arguments);
	        }
	    }

	    log() {
	        if (this.options.logger) {
	            this.options.logger.log(...arguments);
	        }
	    }

	    checkFieldsNames() {
	        const fieldId = this.getOptions("idField");
	        const pathId = ":" + fieldId;
	        let fields = this.getOptions("fields", []);
	        fields.forEach((field) => {
	            if (pathId === field.path) {
	                field.path = field.path + CONST_ID_DUBLICATE_POSTFIX;
	            }
	        });
	    }

	    readFieldValue(path, item, helpers) {
	        if (path.indexOf(CONST_ID_DUBLICATE_POSTFIX) > -1) {
	            const fieldId = this.getOptions("idField");
	            const pathId = ":" + fieldId;
	            return notPath$1.get(pathId, item, helpers);
	        } else {
	            return notPath$1.get(path, item, helpers);
	        }
	    }

	    refineFiltered() {
	        let result = [];
	        this.checkFieldsNames();
	        this.data.filtered.forEach((item, index) => {
	            let refined = {};
	            if (this.getOptions("idField")) {
	                refined[this.getOptions("idField")] =
	                    item[this.getOptions("idField")];
	            }
	            this.getOptions("fields", []).forEach((field) => {
	                let preprocessed = null,
	                    val = this.readFieldValue(
	                        field.path,
	                        item,
	                        this.getOptions("helpers")
	                    );
	                if (notCommon$3.objHas(field, OPT_FIELD_NAME_PRE_PROC)) {
	                    try {
	                        preprocessed = field[OPT_FIELD_NAME_PRE_PROC](
	                            val,
	                            item,
	                            index
	                        );
	                    } catch (e) {
	                        this.error(
	                            "Error while preprocessing cell value",
	                            val,
	                            item,
	                            index
	                        );
	                        this.error(e);
	                    }
	                    notPath$1.set(field.path, refined, preprocessed);
	                } else {
	                    notPath$1.set(field.path, refined, val);
	                }
	            });
	            result.push(refined);
	        });
	        this.stores.refined.update((val) => {
	            val.splice(0, val.length, ...result);
	            return val;
	        });
	    }

	    $destroy() {
	        for (let name in this.ui) {
	            this.ui[name].$destroy && this.ui[name].$destroy();
	            delete this.ui[name];
	        }
	    }
	}

	/* node_modules/not-bulma/src/frame/components/action/ui.action.container.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$d(ctx) {
		let uinotificationerror;
		let updating_title;
		let updating_message;
		let current;

		function uinotificationerror_title_binding(value) {
			/*uinotificationerror_title_binding*/ ctx[18](value);
		}

		function uinotificationerror_message_binding(value) {
			/*uinotificationerror_message_binding*/ ctx[19](value);
		}

		let uinotificationerror_props = {};

		if (/*errorTitle*/ ctx[5] !== void 0) {
			uinotificationerror_props.title = /*errorTitle*/ ctx[5];
		}

		if (/*errorMessage*/ ctx[6] !== void 0) {
			uinotificationerror_props.message = /*errorMessage*/ ctx[6];
		}

		uinotificationerror = new Ui_error({ props: uinotificationerror_props });
		binding_callbacks.push(() => bind(uinotificationerror, 'title', uinotificationerror_title_binding));
		binding_callbacks.push(() => bind(uinotificationerror, 'message', uinotificationerror_message_binding));

		return {
			c() {
				create_component(uinotificationerror.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinotificationerror, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinotificationerror_changes = {};

				if (!updating_title && dirty & /*errorTitle*/ 32) {
					updating_title = true;
					uinotificationerror_changes.title = /*errorTitle*/ ctx[5];
					add_flush_callback(() => updating_title = false);
				}

				if (!updating_message && dirty & /*errorMessage*/ 64) {
					updating_message = true;
					uinotificationerror_changes.message = /*errorMessage*/ ctx[6];
					add_flush_callback(() => updating_message = false);
				}

				uinotificationerror.$set(uinotificationerror_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinotificationerror.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinotificationerror.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinotificationerror, detaching);
			}
		};
	}

	// (81:2) {#if success}
	function create_if_block$f(ctx) {
		let uinotificationsuccess;
		let updating_title;
		let updating_message;
		let current;

		function uinotificationsuccess_title_binding(value) {
			/*uinotificationsuccess_title_binding*/ ctx[20](value);
		}

		function uinotificationsuccess_message_binding(value) {
			/*uinotificationsuccess_message_binding*/ ctx[21](value);
		}

		let uinotificationsuccess_props = {};

		if (/*successTitle*/ ctx[3] !== void 0) {
			uinotificationsuccess_props.title = /*successTitle*/ ctx[3];
		}

		if (/*successMessage*/ ctx[4] !== void 0) {
			uinotificationsuccess_props.message = /*successMessage*/ ctx[4];
		}

		uinotificationsuccess = new Ui_success({ props: uinotificationsuccess_props });
		binding_callbacks.push(() => bind(uinotificationsuccess, 'title', uinotificationsuccess_title_binding));
		binding_callbacks.push(() => bind(uinotificationsuccess, 'message', uinotificationsuccess_message_binding));

		return {
			c() {
				create_component(uinotificationsuccess.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinotificationsuccess, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinotificationsuccess_changes = {};

				if (!updating_title && dirty & /*successTitle*/ 8) {
					updating_title = true;
					uinotificationsuccess_changes.title = /*successTitle*/ ctx[3];
					add_flush_callback(() => updating_title = false);
				}

				if (!updating_message && dirty & /*successMessage*/ 16) {
					updating_message = true;
					uinotificationsuccess_changes.message = /*successMessage*/ ctx[4];
					add_flush_callback(() => updating_message = false);
				}

				uinotificationsuccess.$set(uinotificationsuccess_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinotificationsuccess.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinotificationsuccess.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinotificationsuccess, detaching);
			}
		};
	}

	// (77:0) <UIContainer {...container} >
	function create_default_slot$1(ctx) {
		let t;
		let if_block1_anchor;
		let current;
		let if_block0 = /*error*/ ctx[9] && create_if_block_1$d(ctx);
		let if_block1 = /*success*/ ctx[8] && create_if_block$f(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*error*/ ctx[9]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*error*/ 512) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$d(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*success*/ ctx[8]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*success*/ 256) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$f(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	function create_fragment$i(ctx) {
		let uiloader;
		let updating_loading;
		let updating_title;
		let updating_size;
		let t;
		let uicontainer;
		let current;

		function uiloader_loading_binding(value) {
			/*uiloader_loading_binding*/ ctx[15](value);
		}

		function uiloader_title_binding(value) {
			/*uiloader_title_binding*/ ctx[16](value);
		}

		function uiloader_size_binding(value) {
			/*uiloader_size_binding*/ ctx[17](value);
		}

		let uiloader_props = {};

		if (/*loaderActive*/ ctx[1] !== void 0) {
			uiloader_props.loading = /*loaderActive*/ ctx[1];
		}

		if (/*loaderTitle*/ ctx[0] !== void 0) {
			uiloader_props.title = /*loaderTitle*/ ctx[0];
		}

		if (/*loaderSize*/ ctx[2] !== void 0) {
			uiloader_props.size = /*loaderSize*/ ctx[2];
		}

		uiloader = new Ui_loader({ props: uiloader_props });
		binding_callbacks.push(() => bind(uiloader, 'loading', uiloader_loading_binding));
		binding_callbacks.push(() => bind(uiloader, 'title', uiloader_title_binding));
		binding_callbacks.push(() => bind(uiloader, 'size', uiloader_size_binding));
		const uicontainer_spread_levels = [/*container*/ ctx[7]];

		let uicontainer_props = {
			$$slots: { default: [create_default_slot$1] },
			$$scope: { ctx }
		};

		for (let i = 0; i < uicontainer_spread_levels.length; i += 1) {
			uicontainer_props = assign(uicontainer_props, uicontainer_spread_levels[i]);
		}

		uicontainer = new Ui_container({ props: uicontainer_props });

		return {
			c() {
				create_component(uiloader.$$.fragment);
				t = space();
				create_component(uicontainer.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiloader, target, anchor);
				insert(target, t, anchor);
				mount_component(uicontainer, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const uiloader_changes = {};

				if (!updating_loading && dirty & /*loaderActive*/ 2) {
					updating_loading = true;
					uiloader_changes.loading = /*loaderActive*/ ctx[1];
					add_flush_callback(() => updating_loading = false);
				}

				if (!updating_title && dirty & /*loaderTitle*/ 1) {
					updating_title = true;
					uiloader_changes.title = /*loaderTitle*/ ctx[0];
					add_flush_callback(() => updating_title = false);
				}

				if (!updating_size && dirty & /*loaderSize*/ 4) {
					updating_size = true;
					uiloader_changes.size = /*loaderSize*/ ctx[2];
					add_flush_callback(() => updating_size = false);
				}

				uiloader.$set(uiloader_changes);

				const uicontainer_changes = (dirty & /*container*/ 128)
				? get_spread_update(uicontainer_spread_levels, [get_spread_object(/*container*/ ctx[7])])
				: {};

				if (dirty & /*$$scope, successTitle, successMessage, success, errorTitle, errorMessage, error*/ 4195192) {
					uicontainer_changes.$$scope = { dirty, ctx };
				}

				uicontainer.$set(uicontainer_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiloader.$$.fragment, local);
				transition_in(uicontainer.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiloader.$$.fragment, local);
				transition_out(uicontainer.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}

				destroy_component(uiloader, detaching);
				destroy_component(uicontainer, detaching);
			}
		};
	}

	function instance$i($$self, $$props, $$invalidate) {
		let { container = {} } = $$props;
		let { loaderTitle = 'Отправка данных на сервер' } = $$props;
		let { loaderActive = false } = $$props;
		let { loaderSize = 'container' } = $$props;
		let success = false;
		let { successTitle = 'OK' } = $$props;
		let { successMessage = '' } = $$props;
		let error = false;
		let { errorTitle = 'Error' } = $$props;
		let { errorMessage = '' } = $$props;

		function showSuccess(title, message) {
			$$invalidate(9, error = false);
			$$invalidate(8, success = true);

			if (message != undefined) {
				$$invalidate(4, successMessage = message);
			}

			if (title != undefined) {
				$$invalidate(3, successTitle = title);
			}
		}

		function showError(title, message) {
			$$invalidate(8, success = false);
			$$invalidate(9, error = true);

			if (message != undefined) {
				messageTitle = message;
			}

			if (title != undefined) {
				$$invalidate(3, successTitle = title);
			}
		}

		function setLoading() {
			$$invalidate(1, loaderActive = true);
			$$invalidate(8, success = false);
			$$invalidate(9, error = false);
		}

		function resetLoading() {
			$$invalidate(1, loaderActive = false);
		}

		function hideAll() {
			$$invalidate(1, loaderActive = false);
			$$invalidate(8, success = false);
			$$invalidate(9, error = false);
		}

		function uiloader_loading_binding(value) {
			loaderActive = value;
			$$invalidate(1, loaderActive);
		}

		function uiloader_title_binding(value) {
			loaderTitle = value;
			$$invalidate(0, loaderTitle);
		}

		function uiloader_size_binding(value) {
			loaderSize = value;
			$$invalidate(2, loaderSize);
		}

		function uinotificationerror_title_binding(value) {
			errorTitle = value;
			$$invalidate(5, errorTitle);
		}

		function uinotificationerror_message_binding(value) {
			errorMessage = value;
			$$invalidate(6, errorMessage);
		}

		function uinotificationsuccess_title_binding(value) {
			successTitle = value;
			$$invalidate(3, successTitle);
		}

		function uinotificationsuccess_message_binding(value) {
			successMessage = value;
			$$invalidate(4, successMessage);
		}

		$$self.$$set = $$props => {
			if ('container' in $$props) $$invalidate(7, container = $$props.container);
			if ('loaderTitle' in $$props) $$invalidate(0, loaderTitle = $$props.loaderTitle);
			if ('loaderActive' in $$props) $$invalidate(1, loaderActive = $$props.loaderActive);
			if ('loaderSize' in $$props) $$invalidate(2, loaderSize = $$props.loaderSize);
			if ('successTitle' in $$props) $$invalidate(3, successTitle = $$props.successTitle);
			if ('successMessage' in $$props) $$invalidate(4, successMessage = $$props.successMessage);
			if ('errorTitle' in $$props) $$invalidate(5, errorTitle = $$props.errorTitle);
			if ('errorMessage' in $$props) $$invalidate(6, errorMessage = $$props.errorMessage);
		};

		return [
			loaderTitle,
			loaderActive,
			loaderSize,
			successTitle,
			successMessage,
			errorTitle,
			errorMessage,
			container,
			success,
			error,
			showSuccess,
			showError,
			setLoading,
			resetLoading,
			hideAll,
			uiloader_loading_binding,
			uiloader_title_binding,
			uiloader_size_binding,
			uinotificationerror_title_binding,
			uinotificationerror_message_binding,
			uinotificationsuccess_title_binding,
			uinotificationsuccess_message_binding
		];
	}

	class Ui_action_container extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$i, create_fragment$i, safe_not_equal, {
				container: 7,
				loaderTitle: 0,
				loaderActive: 1,
				loaderSize: 2,
				successTitle: 3,
				successMessage: 4,
				errorTitle: 5,
				errorMessage: 6,
				showSuccess: 10,
				showError: 11,
				setLoading: 12,
				resetLoading: 13,
				hideAll: 14
			});
		}

		get showSuccess() {
			return this.$$.ctx[10];
		}

		get showError() {
			return this.$$.ctx[11];
		}

		get setLoading() {
			return this.$$.ctx[12];
		}

		get resetLoading() {
			return this.$$.ctx[13];
		}

		get hideAll() {
			return this.$$.ctx[14];
		}
	}

	const DEFAULT_CONTAINER_SELECTOR$2 = '.container';

	class notActionUI extends notBase$1 {
	  //UI renderer component class constructor
	  #uiComponent = null;
	  #ui = null;

	  constructor({
	    target = null,
	    name = 'Default',
	    options = {},
	    working = {},
	    data = {},
	    ui = Ui_action_container, //default UI
	  }) {
	    super({
	      working: {
	        name: `${name}ActionUI`,
	        ...working,
	      },
	      options,
	      data
	    });
	    if(target){
	      this.setOptions('target', target);
	    }
	    this.#uiComponent = ui;
	    this.initUI();
	  }

	  initUI() {
	    try {
	      const target = this.getTargetEl();
	      while(target.children.length) target.removeChild(target.firstChild);
	      this.#ui = new this.#uiComponent({
	        target,
	        props: this.getOptions()
	      });
	    } catch (e) {
	      this.error(e);
	    }
	  }

	  setLoading() {
	    this.emit('loading');
	    this.#ui.setLoading();
	  }

	  resetLoading() {
	    this.emit('loaded');
	    this.#ui.resetLoading();
	  }

	  destroy() {
	    this.emit('destroy');
	    if (this.#ui){
	      this.#ui.$destroy && this.#ui.$destroy();
	      this.#ui.destroy && this.#ui.destroy();
	      this.#ui = null;
	    }
	    this.setOptions(null);
	    this.setWorking(null);
	    this.setData(null);
	  }

	  processResult(result) {
	    if (result.status === DEFAULT_STATUS_SUCCESS) {
	      this.setFormSuccess();
	      return true;
	    } else {
	      this.setFormErrors(result);
	      return false;
	    }
	  }

	  /**
	   *   Form validation result
	   **/
	  setFormSuccess() {
	    this.#ui.showSuccess();
	    this.emit('success');
	  }

	  setFormErrors(result) {
	    const status = {
	      form: [],
	      fields: {}
	    };
	    if (result.message) {
	      status.form.push(result.message);
	    }
	    if (result.errors && Object.keys(result.errors).length > 0) {
	      status.fields = { ...result.errors
	      };
	    }
	    this.#ui.showError(status);
	    this.emit('error', status);
	  }

	  /***
	   * Redefinable getters
	   **/
	  getTargetEl() {
	    const targetEl = this.getOptions(
	      'target',
	      DEFAULT_CONTAINER_SELECTOR$2
	    );
	    if (targetEl instanceof HTMLElement) {
	      return targetEl;
	    } else if (typeof targetEl === 'string') {
	      return document.querySelector(targetEl);
	    } else {
	      throw new Error('ActionUI parent element is not defined');
	    }
	  }

	}

	let notFormUtils$1 = class notFormUtils {
	    static validator = null;

	    static addComponent(name, value) {
	        COMPONENTS$2.add(name, value);
	    }

	    static addVariants(name, value) {
	        VARIANTS$1.add(name, value);
	    }

	    static addField(name, field) {
	        FIELDS$2.add(name, field);
	    }

	    static actionFieldsInit(fieldName, options, data) {
	        if (Array.isArray(fieldName)) {
	            fieldName.forEach((subFieldName) => {
	                this.actionFieldsInit(subFieldName, options, data);
	            });
	        } else {
	            if (!notCommon$3.objHas(options, "fields")) {
	                options.fields = {};
	            }
	            if (!notCommon$3.objHas(options.fields, fieldName)) {
	                options.fields[fieldName] = {};
	            }
	            //copying initial data
	            if (
	                typeof data !== "undefined" &&
	                data !== null &&
	                typeof data[fieldName] !== "undefined" &&
	                data[fieldName] !== null
	            ) {
	                options.fields[fieldName].value = data[fieldName];
	            }
	        }
	    }
	};

	const DEFAULT_FIELD = {
	  label: '',
	  placeholder: '',
	  enabled: true,
	  visible: true,
	  required: true,
	  validated: false,
	  valid: false,
	  errors: false
	};

	/**
	* Creates field manifest
	* @param {string} type      name/type of the field
	* @param {Object} mutation  mutation to manifest from library
	* @param {Object} VARIANTS  store which contains named lists of field value variants
	* @param {Object} FIELDS    store which contains named lists of field manifests
	* @return {Object}          field manifest
	**/
	function fieldInit(type, mutation = {}, VARIANTS, FIELDS) {
	  let field = { ...DEFAULT_FIELD };
	  //getting field core manifest
	  if (FIELDS.contains(type)) {
	    field = {
	      ...field,
	      ...FIELDS.get(type)
	    };
	  }
	  //adding mutations
	  if (mutation) {
	    field = {
	      ...field,
	      ...mutation
	    };
	  }
	  //adding variants list to field from VARIANTS store
	  if (
	    notCommon$3.objHas(field, 'variantsSource') &&
	    VARIANTS.contains(field.variantsSource)
	  ) {
	    field.variants = VARIANTS.get(field.variantsSource);
	  }else {
	    if(!field.variants || field.variants.length === 0 ){
	      field.variants = [];
	    }
	  }
	  return field;
	}

	/**
	* Initialization of form structure object
	* @param {object}               form          form structure object
	* @param {string|Array<string>} fieldName     name of the field type if string, array of strings = subform
	* @param {Object}               VARIANTS      store which contains named lists of field value variants
	* @param {Object}               FIELDS        store which contains named lists of field manifests
	* @param {Object}               formFieldsOptions   form wide options
	* @returns {Object}                           form structure object
	**/
	function initFormByField(form = {}, fieldName = [], VARIANTS, FIELDS, formFieldsOptions, data) {
	  if (Array.isArray(fieldName)) {
	    fieldName.forEach(subFormFieldName => initFormByField(form, subFormFieldName, VARIANTS, FIELDS, formFieldsOptions, data));
	  } else {
	    let opts = {};
	    if (formFieldsOptions && notCommon$3.objHas(formFieldsOptions, 'mutations') && notCommon$3.objHas(formFieldsOptions.mutations, fieldName)) {
	      opts = formFieldsOptions.mutations[fieldName]; //option mutation for field
	    }
	    if (data && notCommon$3.objHas(data, fieldName)) {
	      opts.value = data[fieldName];
	    }
	    form[fieldName] = fieldInit(fieldName, opts, VARIANTS, FIELDS);
	    //if form readonly, marking every field as readonly
	    if (formFieldsOptions && formFieldsOptions.readonly) {
	      form[fieldName].readonly = true;
	    }
	  }
	  return form;
	}

	/**
	*  Marking field as invalid by own validator
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @param {any}              value         value of field
	* @param  {Array<string>}   errors        list of errors
	* @return {Object}                        form structure object
	**/
	function setFieldInvalid(form, fieldName, value, errors) {
	  form[fieldName].errors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].valid = false;
	  form[fieldName].value = value;
	  return form;
	}

	/**
	*  Marking field as valid by own validator
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @param {any}              value         value of field
	* @return {Object}                        form structure object
	**/
	function setFieldValid(form, fieldName, value) {
	  form[fieldName].errors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].value = value;
	  for (let fname in form) {
	    if (fname !== fieldName) {
	      if (Array.isArray(form[fname].errors) && form[fname].errors.length === 0) {
	        form[fname].errors = false;
	      }
	      if (form[fname].errors !== false) {
	        break;
	      }
	    }
	  }
	  return form;
	}

	/**
	* Checks if field has errors
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @returns {boolean}                      true - valid, false -invalid
	**/
	function isFieldValid(form, fieldName) {
	  return !Array.isArray(form[fieldName].errors);
	}

	/**
	* Form level validator error in this field
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @param  {Array<string>}   errors        list of errors
	* @return {Object}                        form structure object
	**/
	function setFormFieldInvalid(form, fieldName, errors) {
	  form[fieldName].formErrors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].inputStarted = true;
	  form[fieldName].valid = false;
	  form[fieldName].formLevelError = true;
	  return form;
	}
	/**
	* Form level validator success in this field
	* @param {Object}           form          form structure object
	* @param {string}           fieldName     name of the field
	* @return {Object}                        form structure object
	**/
	function setFormFieldValid(form, fieldName) {
	  form[fieldName].formErrors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].formLevelError = false;
	  return form;
	}

	/**
	* Updates fields and form error labels
	* @param {Object}           form                  form structure object
	* @param {Object}           validationStatus      results of validation
	**/
	function updateFormValidationStatus(
	  {
	    form,
	    formErrors,
	    formHasErrors,
	    fieldsHasErrors,
	    validationStatus
	  }  /* FormValidationSession.getCompleteResult() */
	) {
	  formHasErrors = false;
	  fieldsHasErrors = false;
	  if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
	    formErrors.splice(0, formErrors.length, ...validationStatus.form);
	    formHasErrors = true;
	  } else {
	    formErrors.splice(0, formErrors.length);
	  }
	  formErrors = formErrors;
	  if (validationStatus.fields) {
	    for (let fieldName in validationStatus.fields) {
	      if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
	        setFormFieldInvalid(form, fieldName, validationStatus.fields[fieldName]);
	        fieldsHasErrors = true;
	      } else {
	        setFormFieldValid(form, fieldName);
	      }
	    }
	  }
	}

	function setFieldsVisibility(form, fieldsList, val) {
	  if (Array.isArray(fieldsList)) {
	    Object.keys(form).forEach(fieldName => {
	      form[fieldName].visible = fieldsList.includes(fieldName) ? val : !val;
	    });
	    return true;
	  }
	  return false;
	}

	function setFieldValue(form, fieldName, value) {
	  if (notCommon$3.objHas(form, fieldName)) {
	    form[fieldName].value = value;
	    return true;
	  }
	  return false;
	}

	function fieldIsVisibleAndFilled(form, fieldName){
	  return notCommon$3.objHas(form, fieldName) &&
	    form[fieldName].enabled &&
	    form[fieldName].visible &&
	    typeof form[fieldName].value !== 'undefined';
	}

	function collectData(fields, form) {
	  let result = {};
	  fields.flat().forEach((fieldName) => {
	    if (fieldIsVisibleAndFilled(form, fieldName)) {
	      result[fieldName] = form[fieldName].value;
	    }
	  });
	  return result;
	}

	var FormHelpers = {
	  fieldInit,
	  initFormByField,
	  setFieldInvalid,
	  setFieldValid,
	  isFieldValid,
	  setFormFieldInvalid,
	  setFormFieldValid,
	  updateFormValidationStatus,
	  fieldIsVisibleAndFilled,
	  setFieldsVisibility,
	  setFieldValue,
	  collectData
	};

	const emptyFieldsResults = (data) => {
	    return Object.keys(data).reduce((acc, curr) => {
	        acc[curr] = [];
	        return acc;
	    }, {});
	};

	const FIELDS$1 = ["fields", "form"];

	var result$1 = class ValidationResult {
	    #clean = true;
	    #result;

	    constructor(result) {
	        this.#result = JSON.parse(JSON.stringify(result));
	        Object.keys(this.#result).forEach((fieldName) => {
	            if (!FIELDS$1.includes(fieldName)) {
	                delete this.#result[fieldName];
	            }
	        });
	        this.#clean = this.#result.form.errors.length === 0;
	        const list = this.#getFieldsList();
	        for (let fieldName of list) {
	            if (this.isFieldDirty(fieldName)) {
	                this.#clean = false;
	            }
	        }
	    }

	    destroy() {
	        this.#result = undefined;
	    }

	    get clean() {
	        return this.#clean;
	    }

	    static getDefaultResult(data) {
	        return {
	            fields: emptyFieldsResults(data),
	            form: {
	                fields: emptyFieldsResults(data),
	                errors: [],
	                exceptions: [],
	            },
	        };
	    }

	    getReport() {
	        return JSON.parse(JSON.stringify(this.#getCompleteResult()));
	    }

	    getDetailedReport() {
	        if (typeof this.#result === "object") {
	            return JSON.parse(JSON.stringify(this.#result));
	        } else {
	            return undefined;
	        }
	    }

	    isFieldDirty(fieldName) {
	        if (
	            Array.isArray(this.#result.fields[fieldName]) &&
	            this.#result.fields[fieldName].length
	        ) {
	            return true;
	        }
	        if (
	            Array.isArray(this.#result.form.fields[fieldName]) &&
	            this.#result.form.fields[fieldName].length
	        ) {
	            return true;
	        }
	        return false;
	    }

	    getCompleteResultForField(fieldName) {
	        const fieldResult = [];
	        if (Array.isArray(this.#result.fields[fieldName])) {
	            fieldResult.push(...this.#result.fields[fieldName]);
	        }
	        if (Array.isArray(this.#result.form.fields[fieldName])) {
	            fieldResult.push(...this.#result.form.fields[fieldName]);
	        }
	        return fieldResult;
	    }

	    #getCompleteResult() {
	        const resultComplete = {
	            clean: this.#clean,
	            fields: {},
	            form: [],
	        };
	        const list = this.#getFieldsList();
	        for (let fieldName of list) {
	            const errors = this.getCompleteResultForField(fieldName);
	            if (errors.length) {
	                resultComplete.fields[fieldName] = errors;
	            }
	        }
	        resultComplete.form = [...this.#result.form.errors];
	        if (resultComplete.form.length === 0) {
	            delete resultComplete.form;
	        }
	        return resultComplete;
	    }

	    #getFieldsList() {
	        const fields = Object.keys(this.#result.fields);
	        const fieldsInForm = Object.keys(this.#result.form.fields);
	        return [...new Set([...fieldsInForm, ...fields])];
	    }
	};

	/**
	 * Test argument type to be 'function'
	 * @param {any}  func    possible function
	 * @return {boolean}     if this is a function
	 **/

	const isFunc$1 = (func) => {
	    return typeof func === "function";
	};

	/**
	 * Returns true if argument is Async function
	 * @param {function} func  to test
	 * @return {boolean}       if this function is constructed as AsyncFunction
	 **/
	const isAsync$1 = (func) => {
	    return func.constructor.name === "AsyncFunction";
	};

	var common = async (proc, params) => {
	    if (isFunc$1(proc)) {
	        if (isAsync$1(proc)) {
	            return await proc(...params);
	        } else {
	            return proc(...params);
	        }
	    }
	};

	const ValidationResult = result$1;

	const executeObjectFunction = common;

	const ValidationSession$1 = async (validators, data) => {
	    const result = ValidationResult.getDefaultResult(data);
	    await validateFields({ validators, data, result });
	    await validateForm({ validators, data, result });
	    return new ValidationResult(result);
	};

	var session = ValidationSession$1;

	const validateFields = async ({ validators, data, result }) => {
	    for (let t in data) {
	        await validateField(t, data[t], validators, result);
	    }
	};

	const validateField = async (fieldName, value, validators, result) => {
	    const fieldValidators = getFieldValidators(fieldName, validators);
	    return await runFieldValidators(fieldName, value, fieldValidators, result);
	};

	const getFieldValidators = (name, validators) => {
	    return validators && validators.fields && validators.fields[name]
	        ? validators.fields[name]
	        : [];
	};

	const runFieldValidators = async (fieldName, value, validators, result) => {
	    for (let validatorRule of validators) {
	        try {
	            const valid = await executeObjectFunction(
	                validatorRule["validator"],
	                [value]
	            );
	            if (!valid) {
	                setFieldError(fieldName, validatorRule.message, result);
	            }
	        } catch (e) {
	            setFieldError(fieldName, validatorRule.message, result);
	        }
	    }
	};

	const setFieldError = (fieldName, errorMessage, result) => {
	    if (!result.fields[fieldName].includes(errorMessage)) {
	        result.fields[fieldName].push(errorMessage);
	    }
	};

	const validateForm = async ({ validators, data, result }) => {
	    const formValidators = getFormValidators(validators);
	    await runFormValidators(data, formValidators, result);
	};

	const getFormValidators = (validators) => {
	    return validators && validators.form ? validators.form : [];
	};

	const runFormValidators = async (data, formValidators, result) => {
	    for (let validator of formValidators) {
	        try {
	            await validator(data);
	        } catch (e) {
	            if (e && typeof e.getFieldsErrors === "function") {
	                const formErrors = e.getFieldsErrors();
	                Array.isArray(formErrors.form) &&
	                    addFormErrors(formErrors.form, result);
	                formErrors.fields &&
	                    addFormFieldsErrors(formErrors.fields, result);
	            } else {
	                throw e;
	            }
	        }
	    }
	};

	const addFormErrors = (errors, result) => {
	    errors.forEach((error) => {
	        addFormError(error, result);
	    });
	};

	const addFormError = (errorMessage, result) => {
	    if (!result.form.errors.includes(errorMessage)) {
	        result.form.errors.push(errorMessage);
	    }
	};

	const addFormFieldsErrors = (fieldsErrors, result) => {
	    for (let fieldName in fieldsErrors) {
	        addFormFieldErrors(fieldName, fieldsErrors[fieldName], result);
	    }
	};

	const addFormFieldErrors = (fieldName, errorMessages, result) => {
	    errorMessages.forEach((error) => {
	        addFormFieldError(fieldName, error, result);
	    });
	};

	const addFormFieldError = (fieldName, errorMessage, result) => {
	    if (!Array.isArray(result.form.fields[fieldName])) {
	        result.form.fields[fieldName] = [];
	    }
	    if (!result.form.fields[fieldName].includes(errorMessage)) {
	        result.form.fields[fieldName].push(errorMessage);
	    }
	};

	const composeFieldsValidators$1 = (data, validatorsLib) => {
	    if (validatorsLib && validatorsLib.fields) {
	        const list = Object.keys(data);
	        const result = {};
	        list.forEach((fieldName) => {
	            if (Array.isArray(validatorsLib.fields[fieldName])) {
	                result[fieldName] = validatorsLib.fields[fieldName];
	            }
	        });
	        return result;
	    } else {
	        return {};
	    }
	};

	const composeFormValidators$1 = (name, validatorsLib) => {
	    if (!validatorsLib) return [];
	    if (validatorsLib.forms && Array.isArray(validatorsLib.forms[name])) {
	        return validatorsLib.forms[name];
	    }
	    if (Array.isArray(validatorsLib.form)) {
	        return validatorsLib.form;
	    }
	    return [];
	};

	var runner_utils = {
	    composeFieldsValidators: composeFieldsValidators$1,
	    composeFormValidators: composeFormValidators$1,
	};

	const {
	    composeFieldsValidators,
	    composeFormValidators,
	} = runner_utils;

	const ValidationSession = session;

	/**
	 * Creates validation runner function from provided validation rules lib
	 * @param {object}     validationLib object containing fields validation rules and form specific rules
	 * @returns {function} (data: object, formName: string)=>Promise<ValidationResult>
	 **/
	const ValidationRunner = (validatorsLib) => {
	    /**
	     * Validation session runner
	     * @param {object} data      object to validate
	     * @param {string} formName
	     * @returns {Promise}
	     **/
	    return (data, formName) => {
	        const validators = {
	            //fields specific validators
	            fields: composeFieldsValidators(data, validatorsLib),
	            //form specific validators
	            form: composeFormValidators(formName, validatorsLib),
	        };
	        return ValidationSession(validators, data);
	    };
	};

	var runner = ValidationRunner;

	const augmentFieldsValidators$1 = (fieldValidators, getValidatorEnv) => {
	    return fieldValidators.map((fieldRule) =>
	        augmentFieldValidator(fieldRule, getValidatorEnv)
	    );
	};

	const augmentFieldValidator = (rule, getValidatorEnv) => {
	    if (rule.validator && typeof rule.validator === "function") {
	        const ruleValidator = rule.validator;
	        const result = {
	            ...rule,
	        };
	        delete result.validator;
	        result.validator = (val) => ruleValidator(val, getValidatorEnv());
	        return result;
	    }
	    return rule;
	};

	const augmentFormValidators$1 = (rules, getValidatorEnv) => {
	    return rules.map((rule) => augmentFormValidator(rule, getValidatorEnv));
	};

	const augmentFormValidator = (rule, getValidatorEnv) => {
	    return (val) => rule(val, getValidatorEnv());
	};

	var builder_utils = {
	    augmentFieldsValidators: augmentFieldsValidators$1,
	    augmentFieldValidator,
	    augmentFormValidators: augmentFormValidators$1,
	    augmentFormValidator,
	};

	const objHas = (obj, name) => {
	    return Object.prototype.hasOwnProperty.call(obj, name);
	};
	const {
	    augmentFieldsValidators,
	    augmentFormValidators,
	} = builder_utils;

	/**
	 * @typedef   {object}    notValidationSchema
	 * @property  {object}    [fields]
	 * @property  {array}     [form]
	 * @property  {object}    [forms]
	 */

	/**
	 * returns valid empty validation scheme
	 *
	 * @return {notValidationSchema}
	 */
	const emptyScheme = () => {
	    return {
	        fields: {},
	        forms: {},
	    };
	};
	/**
	 *
	 *
	 * @param {object} validators
	 * @param {function} getValidatorEnv
	 * @return {notValidationSchema}
	 */
	const validationBuilder = (validators, getValidatorEnv) => {
	    if (typeof validators === "undefined" || validators === null) {
	        return emptyScheme();
	    }
	    const augmented = {};
	    if (objHas(validators, "fields")) {
	        augmented.fields = transformFieldsValidators(
	            validators.fields,
	            getValidatorEnv
	        );
	    }
	    if (objHas(validators, "forms")) {
	        augmented.forms = transformFormsValidators(
	            validators.forms,
	            getValidatorEnv
	        );
	    } else {
	        if (objHas(validators, "form")) {
	            augmented.form = augmentFormValidators(
	                validators.form,
	                getValidatorEnv
	            );
	        }
	    }
	    return augmented;
	};

	var builder = validationBuilder;

	const transformFieldsValidators = (fields, getValidatorEnv) => {
	    const augmented = {};
	    for (let fieldName in fields) {
	        if (Array.isArray(fields[fieldName])) {
	            augmented[fieldName] = augmentFieldsValidators(
	                fields[fieldName],
	                getValidatorEnv
	            );
	        }
	    }
	    return augmented;
	};

	const transformFormsValidators = (formsValidators, getValidatorEnv) => {
	    const augmented = {};
	    for (let formName in formsValidators) {
	        if (Array.isArray(formsValidators[formName])) {
	            augmented[formName] = augmentFormValidators(
	                formsValidators[formName],
	                getValidatorEnv
	            );
	        }
	    }
	    return augmented;
	};

	const Session = session;
	const Runner = runner;
	const Builder = builder;
	const Result = result$1;

	var src = {
	    name: "not-validation",
	    Session,
	    Runner,
	    Builder,
	    Result,
	};

	/* node_modules/not-bulma/src/frame/components/form/field.svelte generated by Svelte v4.2.19 */

	function get_each_context_2$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[18] = list[i];
		return child_ctx;
	}

	function get_each_context_1$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[18] = list[i];
		return child_ctx;
	}

	function get_each_context$6(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[18] = list[i];
		return child_ctx;
	}

	// (84:0) {:else}
	function create_else_block$b(ctx) {
		let div;
		let div_class_value;
		let current;
		let each_value_2 = ensure_array_like(/*controls*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", div_class_value = "field " + /*fieldClasses*/ ctx[4] + " " + /*fieldId*/ ctx[6]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*controls, name, onControlChange*/ 138) {
					each_value_2 = ensure_array_like(/*controls*/ ctx[3]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_2$2(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value_2.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty & /*fieldClasses, fieldId*/ 80 && div_class_value !== (div_class_value = "field " + /*fieldClasses*/ ctx[4] + " " + /*fieldId*/ ctx[6])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (68:21) 
	function create_if_block_1$c(ctx) {
		let div2;
		let div0;
		let uilabel;
		let t;
		let div1;
		let div2_class_value;
		let current;

		uilabel = new Ui_label({
				props: {
					id: /*fieldId*/ ctx[6],
					label: /*label*/ ctx[0] || /*controls*/ ctx[3][0].label
				}
			});

		let each_value_1 = ensure_array_like(/*controls*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				create_component(uilabel.$$.fragment);
				t = space();
				div1 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div0, "class", "field-label is-normal");
				attr(div1, "class", "field-body");
				attr(div1, "id", /*fieldId*/ ctx[6]);
				attr(div2, "class", div2_class_value = "field is-horizontal " + /*fieldClasses*/ ctx[4] + " " + /*fieldId*/ ctx[6]);
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				mount_component(uilabel, div0, null);
				append(div2, t);
				append(div2, div1);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div1, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				const uilabel_changes = {};
				if (dirty & /*fieldId*/ 64) uilabel_changes.id = /*fieldId*/ ctx[6];
				if (dirty & /*label, controls*/ 9) uilabel_changes.label = /*label*/ ctx[0] || /*controls*/ ctx[3][0].label;
				uilabel.$set(uilabel_changes);

				if (dirty & /*controls, name, onControlChange*/ 138) {
					each_value_1 = ensure_array_like(/*controls*/ ctx[3]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$2(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div1, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty & /*fieldId*/ 64) {
					attr(div1, "id", /*fieldId*/ ctx[6]);
				}

				if (!current || dirty & /*fieldClasses, fieldId*/ 80 && div2_class_value !== (div2_class_value = "field is-horizontal " + /*fieldClasses*/ ctx[4] + " " + /*fieldId*/ ctx[6])) {
					attr(div2, "class", div2_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uilabel.$$.fragment, local);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(uilabel.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				destroy_component(uilabel);
				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (59:0) {#if hidden}
	function create_if_block$e(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*controls*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*controls, name, onControlChange*/ 138) {
					each_value = ensure_array_like(/*controls*/ ctx[3]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$6(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$6(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (86:8) {#each controls as control}
	function create_each_block_2$2(ctx) {
		let uilabel;
		let t;
		let switch_instance;
		let switch_instance_anchor;
		let current;

		uilabel = new Ui_label({
				props: {
					id: "form-field-" + /*control*/ ctx[18].component + "-" + /*name*/ ctx[1],
					label: /*control*/ ctx[18].label
				}
			});

		const switch_instance_spread_levels = [/*control*/ ctx[18], { fieldname: /*name*/ ctx[1] }];
		var switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*controls, name*/ 10) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
					dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*onControlChange*/ ctx[7]);
		}

		return {
			c() {
				create_component(uilabel.$$.fragment);
				t = space();
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				mount_component(uilabel, target, anchor);
				insert(target, t, anchor);
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uilabel_changes = {};
				if (dirty & /*controls, name*/ 10) uilabel_changes.id = "form-field-" + /*control*/ ctx[18].component + "-" + /*name*/ ctx[1];
				if (dirty & /*controls*/ 8) uilabel_changes.label = /*control*/ ctx[18].label;
				uilabel.$set(uilabel_changes);

				if (dirty & /*controls*/ 8 && switch_value !== (switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*onControlChange*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*controls, name*/ 10)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
							dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uilabel.$$.fragment, local);
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uilabel.$$.fragment, local);
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(switch_instance_anchor);
				}

				destroy_component(uilabel, detaching);
				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (74:12) {#each controls as control}
	function create_each_block_1$2(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*control*/ ctx[18], { fieldname: /*name*/ ctx[1] }];
		var switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*controls, name*/ 10) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
					dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*onControlChange*/ ctx[7]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*controls*/ 8 && switch_value !== (switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*onControlChange*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*controls, name*/ 10)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
							dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (60:4) {#each controls as control}
	function create_each_block$6(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [/*control*/ ctx[18], { fieldname: /*name*/ ctx[1] }];
		var switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*controls, name*/ 10) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
					dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
			switch_instance.$on("change", /*onControlChange*/ ctx[7]);
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*controls*/ 8 && switch_value !== (switch_value = COMPONENTS$2.get(/*control*/ ctx[18].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						switch_instance.$on("change", /*onControlChange*/ ctx[7]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*controls, name*/ 10)
					? get_spread_update(switch_instance_spread_levels, [
							dirty & /*controls*/ 8 && get_spread_object(/*control*/ ctx[18]),
							dirty & /*name*/ 2 && { fieldname: /*name*/ ctx[1] }
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	function create_fragment$h(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$e, create_if_block_1$c, create_else_block$b];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*hidden*/ ctx[5]) return 0;
			if (/*horizontal*/ ctx[2]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$h($$self, $$props, $$invalidate) {
		let dispatch = createEventDispatcher();
		let { label = "" } = $$props;
		let { name = "generic field" } = $$props;
		let { readonly = false } = $$props;
		let { horizontal = false } = $$props;
		let { controls = [] } = $$props;
		let { classes = "" } = $$props;
		let { addons = false } = $$props;
		let { addonsCentered = false } = $$props;
		let { addonsRight = false } = $$props;
		let { grouped = false } = $$props;
		let { groupedMultiline = false } = $$props;
		let { groupedRight = false } = $$props;
		let { groupedCentered = false } = $$props;
		let fieldClasses = "";
		let hidden = false;
		let fieldId;

		onMount(() => {
			$$invalidate(4, fieldClasses += " " + classes);
			$$invalidate(4, fieldClasses += addons ? " has-addons " : "");
			$$invalidate(4, fieldClasses += addonsCentered ? " has-addons-centered " : "");
			$$invalidate(4, fieldClasses += addonsRight ? " has-addons-right " : "");
			$$invalidate(4, fieldClasses += grouped ? " is-grouped " : "");
			$$invalidate(4, fieldClasses += groupedMultiline ? " is-grouped-multiline " : "");
			$$invalidate(4, fieldClasses += groupedRight ? " is-grouped-right " : "");
			$$invalidate(4, fieldClasses += groupedCentered ? " is-grouped-centered " : "");

			if (readonly) {
				controls.forEach(control => {
					control.readonly = true;
				});
			}

			let notHidden = controls.filter(control => control.component !== "UIHidden");
			$$invalidate(5, hidden = notHidden.length === 0);
			let tmp = controls.map(itm => itm.component).join("_");
			$$invalidate(6, fieldId = `form-field-${tmp}-${name}`);
		});

		function onControlChange(ev) {
			let data = ev.detail;
			dispatch("change", data);
		}

		$$self.$$set = $$props => {
			if ('label' in $$props) $$invalidate(0, label = $$props.label);
			if ('name' in $$props) $$invalidate(1, name = $$props.name);
			if ('readonly' in $$props) $$invalidate(8, readonly = $$props.readonly);
			if ('horizontal' in $$props) $$invalidate(2, horizontal = $$props.horizontal);
			if ('controls' in $$props) $$invalidate(3, controls = $$props.controls);
			if ('classes' in $$props) $$invalidate(9, classes = $$props.classes);
			if ('addons' in $$props) $$invalidate(10, addons = $$props.addons);
			if ('addonsCentered' in $$props) $$invalidate(11, addonsCentered = $$props.addonsCentered);
			if ('addonsRight' in $$props) $$invalidate(12, addonsRight = $$props.addonsRight);
			if ('grouped' in $$props) $$invalidate(13, grouped = $$props.grouped);
			if ('groupedMultiline' in $$props) $$invalidate(14, groupedMultiline = $$props.groupedMultiline);
			if ('groupedRight' in $$props) $$invalidate(15, groupedRight = $$props.groupedRight);
			if ('groupedCentered' in $$props) $$invalidate(16, groupedCentered = $$props.groupedCentered);
		};

		return [
			label,
			name,
			horizontal,
			controls,
			fieldClasses,
			hidden,
			fieldId,
			onControlChange,
			readonly,
			classes,
			addons,
			addonsCentered,
			addonsRight,
			grouped,
			groupedMultiline,
			groupedRight,
			groupedCentered
		];
	}

	class Field extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$h, create_fragment$h, safe_not_equal, {
				label: 0,
				name: 1,
				readonly: 8,
				horizontal: 2,
				controls: 3,
				classes: 9,
				addons: 10,
				addonsCentered: 11,
				addonsRight: 12,
				grouped: 13,
				groupedMultiline: 14,
				groupedRight: 15,
				groupedCentered: 16
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/form/form.svelte generated by Svelte v4.2.19 */

	function get_each_context$5(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[37] = list[i];
		return child_ctx;
	}

	function get_each_context_1$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[40] = list[i];
		return child_ctx;
	}

	function get_each_context_2$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[43] = list[i];
		return child_ctx;
	}

	// (201:4) {#if loader !== "hidden"}
	function create_if_block_16(ctx) {
		let div;
		let span;
		let t_value = /*$LOCALE*/ ctx[15][/*WAITING_TEXT*/ ctx[5]] + "";
		let t;
		let div_class_value;

		return {
			c() {
				div = element("div");
				span = element("span");
				t = text(t_value);
				attr(span, "class", "title");

				attr(div, "class", div_class_value = "" + ((/*loader*/ ctx[2] === 'page'
				? 'pageloader'
				: 'containerloader') + " " + (/*loading*/ ctx[1] ? 'is-active' : '')));
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, WAITING_TEXT*/ 32800 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*WAITING_TEXT*/ ctx[5]] + "")) set_data(t, t_value);

				if (dirty[0] & /*loader, loading*/ 6 && div_class_value !== (div_class_value = "" + ((/*loader*/ ctx[2] === 'page'
				? 'pageloader'
				: 'containerloader') + " " + (/*loading*/ ctx[1] ? 'is-active' : '')))) {
					attr(div, "class", div_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (215:4) {:else}
	function create_else_block$a(ctx) {
		let t0;
		let t1;
		let t2;
		let t3;
		let if_block3_anchor;
		let current;
		let if_block0 = /*title*/ ctx[6] && create_if_block_15(ctx);
		let if_block1 = /*description*/ ctx[7] && create_if_block_14(ctx);
		let if_block2 = /*buttonsFirst*/ ctx[8] && create_if_block_10(ctx);
		let each_value_1 = ensure_array_like(/*fields*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block3 = !/*buttonsFirst*/ ctx[8] && create_if_block_1$b(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t3 = space();
				if (if_block3) if_block3.c();
				if_block3_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t2, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, t3, anchor);
				if (if_block3) if_block3.m(target, anchor);
				insert(target, if_block3_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*title*/ ctx[6]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_15(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*description*/ ctx[7]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_14(ctx);
						if_block1.c();
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*buttonsFirst*/ ctx[8]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_10(ctx);
						if_block2.c();
						if_block2.m(t2.parentNode, t2);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (dirty[0] & /*fields, form, horizontal, onFieldChange*/ 66057) {
					each_value_1 = ensure_array_like(/*fields*/ ctx[3]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$1(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(t3.parentNode, t3);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!/*buttonsFirst*/ ctx[8]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block_1$b(ctx);
						if_block3.c();
						if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(t3);
					detach(if_block3_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				destroy_each(each_blocks, detaching);
				if (if_block3) if_block3.d(detaching);
			}
		};
	}

	// (211:4) {#if success}
	function create_if_block$d(ctx) {
		let div;
		let h3;
		let t_value = /*$LOCALE*/ ctx[15][/*SUCCESS_TEXT*/ ctx[4]] + "";
		let t;

		return {
			c() {
				div = element("div");
				h3 = element("h3");
				t = text(t_value);
				attr(h3, "class", "form-success-message");
				attr(div, "class", "notification is-success");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, h3);
				append(h3, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, SUCCESS_TEXT*/ 32784 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*SUCCESS_TEXT*/ ctx[4]] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (216:8) {#if title}
	function create_if_block_15(ctx) {
		let h5;
		let t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[6]] + "";
		let t;

		return {
			c() {
				h5 = element("h5");
				t = text(t_value);
				attr(h5, "class", "title is-5");
			},
			m(target, anchor) {
				insert(target, h5, anchor);
				append(h5, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, title*/ 32832 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*title*/ ctx[6]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(h5);
				}
			}
		};
	}

	// (219:8) {#if description}
	function create_if_block_14(ctx) {
		let h6;
		let t_value = /*$LOCALE*/ ctx[15][/*description*/ ctx[7]] + "";
		let t;

		return {
			c() {
				h6 = element("h6");
				t = text(t_value);
				attr(h6, "class", "subtitle is-6");
			},
			m(target, anchor) {
				insert(target, h6, anchor);
				append(h6, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, description*/ 32896 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*description*/ ctx[7]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(h6);
				}
			}
		};
	}

	// (223:8) {#if buttonsFirst}
	function create_if_block_10(ctx) {
		let div;
		let t0;
		let t1;
		let if_block2_anchor;
		let if_block0 = /*cancel*/ ctx[11].enabled && create_if_block_13(ctx);
		let if_block1 = /*submit*/ ctx[10].enabled && create_if_block_12(ctx);
		let if_block2 = /*formErrors*/ ctx[12].length > 0 && create_if_block_11(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
				attr(div, "class", "buttons is-grouped is-centered");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				if (if_block1) if_block1.m(div, null);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*cancel*/ ctx[11].enabled) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_13(ctx);
						if_block0.c();
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*submit*/ ctx[10].enabled) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_12(ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*formErrors*/ ctx[12].length > 0) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_11(ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t1);
					detach(if_block2_anchor);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d(detaching);
			}
		};
	}

	// (225:16) {#if cancel.enabled}
	function create_if_block_13(ctx) {
		let button;
		let t_value = /*$LOCALE*/ ctx[15][/*cancel*/ ctx[11].caption] + "";
		let t;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(t_value);
				attr(button, "class", button_class_value = "button is-outlined " + /*cancel*/ ctx[11].classes);
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*rejectForm*/ ctx[18]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, cancel*/ 34816 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*cancel*/ ctx[11].caption] + "")) set_data(t, t_value);

				if (dirty[0] & /*cancel*/ 2048 && button_class_value !== (button_class_value = "button is-outlined " + /*cancel*/ ctx[11].classes)) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (231:16) {#if submit.enabled}
	function create_if_block_12(ctx) {
		let button;
		let t_value = /*$LOCALE*/ ctx[15][/*submit*/ ctx[10].caption] + "";
		let t;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(t_value);
				button.disabled = /*formInvalid*/ ctx[14];
				attr(button, "class", button_class_value = "button is-primary is-hovered " + /*submit*/ ctx[10].classes);
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*submitForm*/ ctx[17]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, submit*/ 33792 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*submit*/ ctx[10].caption] + "")) set_data(t, t_value);

				if (dirty[0] & /*formInvalid*/ 16384) {
					button.disabled = /*formInvalid*/ ctx[14];
				}

				if (dirty[0] & /*submit*/ 1024 && button_class_value !== (button_class_value = "button is-primary is-hovered " + /*submit*/ ctx[10].classes)) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (241:12) {#if formErrors.length > 0}
	function create_if_block_11(ctx) {
		let div;
		let t_value = /*formErrors*/ ctx[12].join(", ") + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "edit-form-error notification is-danger");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*formErrors*/ 4096 && t_value !== (t_value = /*formErrors*/ ctx[12].join(", ") + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (285:12) {:else}
	function create_else_block_2(ctx) {
		let div;
		let t0;
		let t1_value = /*field*/ ctx[40] + "";
		let t1;
		let t2;

		return {
			c() {
				div = element("div");
				t0 = text("Field '");
				t1 = text(t1_value);
				t2 = text("' is not registered");
				attr(div, "class", "notification is-danger");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fields*/ 8 && t1_value !== (t1_value = /*field*/ ctx[40] + "")) set_data(t1, t1_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (275:59) 
	function create_if_block_8(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*form*/ ctx[0][/*field*/ ctx[40]].visible && create_if_block_9(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*form*/ ctx[0][/*field*/ ctx[40]].visible) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*form, fields*/ 9) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_9(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (249:12) {#if Array.isArray(field)}
	function create_if_block_5$2(ctx) {
		let div;
		let current;
		let each_value_2 = ensure_array_like(/*field*/ ctx[40]);
		let each_blocks = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", "columns");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*form, fields, horizontal, onFieldChange*/ 66057) {
					each_value_2 = ensure_array_like(/*field*/ ctx[40]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_2$1(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value_2.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (276:16) {#if form[field].visible}
	function create_if_block_9(ctx) {
		let uifield;
		let current;

		uifield = new Field({
				props: {
					controls: [/*form*/ ctx[0][/*field*/ ctx[40]]],
					name: /*field*/ ctx[40],
					horizontal: /*horizontal*/ ctx[9],
					label: /*form*/ ctx[0][/*field*/ ctx[40]].label
				}
			});

		uifield.$on("change", /*onFieldChange*/ ctx[16]);

		return {
			c() {
				create_component(uifield.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uifield, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uifield_changes = {};
				if (dirty[0] & /*form, fields*/ 9) uifield_changes.controls = [/*form*/ ctx[0][/*field*/ ctx[40]]];
				if (dirty[0] & /*fields*/ 8) uifield_changes.name = /*field*/ ctx[40];
				if (dirty[0] & /*horizontal*/ 512) uifield_changes.horizontal = /*horizontal*/ ctx[9];
				if (dirty[0] & /*form, fields*/ 9) uifield_changes.label = /*form*/ ctx[0][/*field*/ ctx[40]].label;
				uifield.$set(uifield_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uifield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uifield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uifield, detaching);
			}
		};
	}

	// (268:24) {:else}
	function create_else_block_1$1(ctx) {
		let div;
		let t0;
		let t1_value = /*subfield*/ ctx[43] + "";
		let t1;
		let t2;

		return {
			c() {
				div = element("div");
				t0 = text("Subfield '");
				t1 = text(t1_value);
				t2 = text("' is not registered");
				attr(div, "class", "column notification is-danger");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*fields*/ 8 && t1_value !== (t1_value = /*subfield*/ ctx[43] + "")) set_data(t1, t1_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (252:24) {#if form[subfield] && form[subfield].component}
	function create_if_block_6(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*form*/ ctx[0][/*subfield*/ ctx[43]].visible && create_if_block_7(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*form*/ ctx[0][/*subfield*/ ctx[43]].visible) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*form, fields*/ 9) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_7(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (253:28) {#if form[subfield].visible}
	function create_if_block_7(ctx) {
		let div;
		let uifield;
		let div_class_value;
		let current;

		uifield = new Field({
				props: {
					controls: [/*form*/ ctx[0][/*subfield*/ ctx[43]]],
					name: /*subfield*/ ctx[43],
					horizontal: /*horizontal*/ ctx[9],
					label: /*form*/ ctx[0][/*subfield*/ ctx[43]].label
				}
			});

		uifield.$on("change", /*onFieldChange*/ ctx[16]);

		return {
			c() {
				div = element("div");
				create_component(uifield.$$.fragment);

				attr(div, "class", div_class_value = "column " + (/*form*/ ctx[0][/*subfield*/ ctx[43]].fieldSize
				? 'is-' + /*form*/ ctx[0][/*subfield*/ ctx[43]].fieldSize
				: '') + "");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uifield, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const uifield_changes = {};
				if (dirty[0] & /*form, fields*/ 9) uifield_changes.controls = [/*form*/ ctx[0][/*subfield*/ ctx[43]]];
				if (dirty[0] & /*fields*/ 8) uifield_changes.name = /*subfield*/ ctx[43];
				if (dirty[0] & /*horizontal*/ 512) uifield_changes.horizontal = /*horizontal*/ ctx[9];
				if (dirty[0] & /*form, fields*/ 9) uifield_changes.label = /*form*/ ctx[0][/*subfield*/ ctx[43]].label;
				uifield.$set(uifield_changes);

				if (!current || dirty[0] & /*form, fields*/ 9 && div_class_value !== (div_class_value = "column " + (/*form*/ ctx[0][/*subfield*/ ctx[43]].fieldSize
				? 'is-' + /*form*/ ctx[0][/*subfield*/ ctx[43]].fieldSize
				: '') + "")) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uifield.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uifield.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uifield);
			}
		};
	}

	// (251:20) {#each field as subfield}
	function create_each_block_2$1(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_6, create_else_block_1$1];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*form*/ ctx[0][/*subfield*/ ctx[43]] && /*form*/ ctx[0][/*subfield*/ ctx[43]].component) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (248:8) {#each fields as field}
	function create_each_block_1$1(ctx) {
		let show_if;
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_5$2, create_if_block_8, create_else_block_2];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (dirty[0] & /*fields*/ 8) show_if = null;
			if (show_if == null) show_if = !!Array.isArray(/*field*/ ctx[40]);
			if (show_if) return 0;
			if (/*form*/ ctx[0][/*field*/ ctx[40]] && /*form*/ ctx[0][/*field*/ ctx[40]].component) return 1;
			return 2;
		}

		current_block_type_index = select_block_type_1(ctx, [-1, -1]);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (292:8) {#if !buttonsFirst}
	function create_if_block_1$b(ctx) {
		let t0;
		let div;
		let t1;
		let if_block0 = /*formErrors*/ ctx[12].length > 0 && create_if_block_4$4(ctx);
		let if_block1 = /*cancel*/ ctx[11].enabled && create_if_block_3$7(ctx);
		let if_block2 = /*submit*/ ctx[10].enabled && create_if_block_2$7(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				div = element("div");
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(div, "class", "buttons is-grouped is-centered");
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				insert(target, div, anchor);
				if (if_block1) if_block1.m(div, null);
				append(div, t1);
				if (if_block2) if_block2.m(div, null);
			},
			p(ctx, dirty) {
				if (/*formErrors*/ ctx[12].length > 0) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$4(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*cancel*/ ctx[11].enabled) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_3$7(ctx);
						if_block1.c();
						if_block1.m(div, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*submit*/ ctx[10].enabled) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_2$7(ctx);
						if_block2.c();
						if_block2.m(div, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(div);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (293:12) {#if formErrors.length > 0}
	function create_if_block_4$4(ctx) {
		let div;
		let each_value = ensure_array_like(/*formErrors*/ ctx[12]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", "edit-form-error notification is-danger");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, formErrors*/ 36864) {
					each_value = ensure_array_like(/*formErrors*/ ctx[12]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$5(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$5(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (295:20) {#each formErrors as formError}
	function create_each_block$5(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[15][/*formError*/ ctx[37]] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, formErrors*/ 36864 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*formError*/ ctx[37]] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (301:16) {#if cancel.enabled}
	function create_if_block_3$7(ctx) {
		let button;
		let t_value = /*$LOCALE*/ ctx[15][/*cancel*/ ctx[11].caption] + "";
		let t;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(t_value);

				attr(button, "class", button_class_value = "button " + (/*cancel*/ ctx[11].classes
				? /*cancel*/ ctx[11].classes
				: ''));
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*rejectForm*/ ctx[18]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, cancel*/ 34816 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*cancel*/ ctx[11].caption] + "")) set_data(t, t_value);

				if (dirty[0] & /*cancel*/ 2048 && button_class_value !== (button_class_value = "button " + (/*cancel*/ ctx[11].classes
				? /*cancel*/ ctx[11].classes
				: ''))) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (307:16) {#if submit.enabled}
	function create_if_block_2$7(ctx) {
		let button;
		let t_value = /*$LOCALE*/ ctx[15][/*submit*/ ctx[10].caption] + "";
		let t;
		let button_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(t_value);
				button.disabled = /*formInvalid*/ ctx[14];

				attr(button, "class", button_class_value = "button is-primary is-hovered " + (/*submit*/ ctx[10].classes
				? /*submit*/ ctx[10].classes
				: ''));
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*submitForm*/ ctx[17]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*$LOCALE, submit*/ 33792 && t_value !== (t_value = /*$LOCALE*/ ctx[15][/*submit*/ ctx[10].caption] + "")) set_data(t, t_value);

				if (dirty[0] & /*formInvalid*/ 16384) {
					button.disabled = /*formInvalid*/ ctx[14];
				}

				if (dirty[0] & /*submit*/ 1024 && button_class_value !== (button_class_value = "button is-primary is-hovered " + (/*submit*/ ctx[10].classes
				? /*submit*/ ctx[10].classes
				: ''))) {
					attr(button, "class", button_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$g(ctx) {
		let div;
		let t;
		let current_block_type_index;
		let if_block1;
		let current;
		let if_block0 = /*loader*/ ctx[2] !== "hidden" && create_if_block_16(ctx);
		const if_block_creators = [create_if_block$d, create_else_block$a];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*success*/ ctx[13]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t = space();
				if_block1.c();
				attr(div, "class", "form-container");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t);
				if_blocks[current_block_type_index].m(div, null);
				current = true;
			},
			p(ctx, dirty) {
				if (/*loader*/ ctx[2] !== "hidden") {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_16(ctx);
						if_block0.c();
						if_block0.m(div, t);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if_blocks[current_block_type_index].d();
			}
		};
	}

	function instance$g($$self, $$props, $$invalidate) {
		let formInvalid;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(15, $LOCALE = $$value));
		let dispatch = createEventDispatcher();

		//validation status
		let formErrors = [];

		let formHasErrors = false;
		let fieldsHasErrors = false;
		let success = false;
		let { form = {} } = $$props;
		let { loading = false } = $$props;
		let { loader = "container" } = $$props;
		let { fields = [] } = $$props;
		let { SUCCESS_TEXT = "Операция завершена" } = $$props;
		let { WAITING_TEXT = "Отправка данных на сервер" } = $$props;
		let { title = "Форма" } = $$props;
		let { description = "" } = $$props;
		let { buttonsFirst = false } = $$props;
		let { horizontal = false } = $$props;
		let { submit = { caption: "Отправить", enabled: true } } = $$props;
		let { cancel = { caption: "Назад", enabled: true } } = $$props;

		function collectData() {
			return FormHelpers.collectData(fields, form);
		}

		function setFieldInvalid(fieldName, value, errors) {
			$$invalidate(0, form = FormHelpers.setFieldInvalid(form, fieldName, value, errors));
			$$invalidate(35, fieldsHasErrors = true);
		}

		function setFieldValid(fieldName, value) {
			$$invalidate(0, form = FormHelpers.setFieldValid(form, fieldName, value));

			if (fieldsHasErrors !== some) {
				$$invalidate(35, fieldsHasErrors = some);
			}
		}

		function isFieldValid(fieldName) {
			return FormHelpers.isFieldValid(form, fieldName);
		}

		function setFormFieldInvalid(fieldName, errors) {
			$$invalidate(0, form = FormHelpers.setFormFieldInvalid(form, fieldName, errors));
			dispatch(`field.invalid`, { fieldName });
		}

		function setFormFieldValid(fieldName) {
			$$invalidate(0, form = FormHelpers.setFormFieldValid(form, fieldName));
			dispatch(`field.valid`, { fieldName });
		}

		function updateFormValidationStatus(validationStatus) {
			$$invalidate(/* FormValidationSession.getCompleteResult() */ 34, formHasErrors = false);
			$$invalidate(35, fieldsHasErrors = false);

			if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
				formErrors.splice(0, formErrors.length, ...validationStatus.form);
				$$invalidate(34, formHasErrors = true);
			} else {
				formErrors.splice(0, formErrors.length);
			}

			$$invalidate(12, formErrors);

			if (validationStatus.fields) {
				for (let fieldName of Object.keys(form)) {
					if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
						FormHelpers.setFormFieldInvalid(form, fieldName, validationStatus.fields[fieldName]);
						$$invalidate(35, fieldsHasErrors = true);
					} else {
						FormHelpers.setFormFieldValid(form, fieldName);
					}
				}
			}
		}

		function showSuccess() {
			$$invalidate(13, success = true);
		}

		function setLoading() {
			$$invalidate(1, loading = true);
		}

		function resetLoading() {
			$$invalidate(1, loading = false);
		}

		function setFieldsVisibility(fieldsList, val) {
			if (FormHelpers.setFieldsVisibility(form, fieldsList, val)) {
				$$invalidate(0, form);
			}
		}

		function setVisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, true);
		}

		function setInvisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, false);
		}

		function setFieldValue(fieldName, value) {
			if (FormHelpers.setFieldValue(form, fieldName, value)) {
				onFieldChange({ detail: { field: fieldName, value } });
			}
		}

		function updateField(fieldName, props) {
			$$invalidate(0, form[fieldName] = { ...form[fieldName], ...props }, form);
			$$invalidate(0, form);
		}

		function onFieldChange(ev) {
			let data = ev.detail;
			$$invalidate(0, form[data.field].value = data.value, form);
			$$invalidate(0, form);
			dispatch("change", data);
		}

		function submitForm(e) {
			e && e.preventDefault();
			dispatch("submit", collectData());
			return false;
		}

		function rejectForm() {
			dispatch("reject");
		}

		$$self.$$set = $$props => {
			if ('form' in $$props) $$invalidate(0, form = $$props.form);
			if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
			if ('loader' in $$props) $$invalidate(2, loader = $$props.loader);
			if ('fields' in $$props) $$invalidate(3, fields = $$props.fields);
			if ('SUCCESS_TEXT' in $$props) $$invalidate(4, SUCCESS_TEXT = $$props.SUCCESS_TEXT);
			if ('WAITING_TEXT' in $$props) $$invalidate(5, WAITING_TEXT = $$props.WAITING_TEXT);
			if ('title' in $$props) $$invalidate(6, title = $$props.title);
			if ('description' in $$props) $$invalidate(7, description = $$props.description);
			if ('buttonsFirst' in $$props) $$invalidate(8, buttonsFirst = $$props.buttonsFirst);
			if ('horizontal' in $$props) $$invalidate(9, horizontal = $$props.horizontal);
			if ('submit' in $$props) $$invalidate(10, submit = $$props.submit);
			if ('cancel' in $$props) $$invalidate(11, cancel = $$props.cancel);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[1] & /*formHasErrors, fieldsHasErrors*/ 24) {
				$$invalidate(14, formInvalid = formHasErrors || fieldsHasErrors);
			}
		};

		return [
			form,
			loading,
			loader,
			fields,
			SUCCESS_TEXT,
			WAITING_TEXT,
			title,
			description,
			buttonsFirst,
			horizontal,
			submit,
			cancel,
			formErrors,
			success,
			formInvalid,
			$LOCALE,
			onFieldChange,
			submitForm,
			rejectForm,
			collectData,
			setFieldInvalid,
			setFieldValid,
			isFieldValid,
			setFormFieldInvalid,
			setFormFieldValid,
			updateFormValidationStatus,
			showSuccess,
			setLoading,
			resetLoading,
			setFieldsVisibility,
			setVisibleFields,
			setInvisibleFields,
			setFieldValue,
			updateField,
			formHasErrors,
			fieldsHasErrors
		];
	}

	class Form extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$g,
				create_fragment$g,
				safe_not_equal,
				{
					form: 0,
					loading: 1,
					loader: 2,
					fields: 3,
					SUCCESS_TEXT: 4,
					WAITING_TEXT: 5,
					title: 6,
					description: 7,
					buttonsFirst: 8,
					horizontal: 9,
					submit: 10,
					cancel: 11,
					collectData: 19,
					setFieldInvalid: 20,
					setFieldValid: 21,
					isFieldValid: 22,
					setFormFieldInvalid: 23,
					setFormFieldValid: 24,
					updateFormValidationStatus: 25,
					showSuccess: 26,
					setLoading: 27,
					resetLoading: 28,
					setFieldsVisibility: 29,
					setVisibleFields: 30,
					setInvisibleFields: 31,
					setFieldValue: 32,
					updateField: 33
				},
				null,
				[-1, -1]
			);
		}

		get collectData() {
			return this.$$.ctx[19];
		}

		get setFieldInvalid() {
			return this.$$.ctx[20];
		}

		get setFieldValid() {
			return this.$$.ctx[21];
		}

		get isFieldValid() {
			return this.$$.ctx[22];
		}

		get setFormFieldInvalid() {
			return this.$$.ctx[23];
		}

		get setFormFieldValid() {
			return this.$$.ctx[24];
		}

		get updateFormValidationStatus() {
			return this.$$.ctx[25];
		}

		get showSuccess() {
			return this.$$.ctx[26];
		}

		get setLoading() {
			return this.$$.ctx[27];
		}

		get resetLoading() {
			return this.$$.ctx[28];
		}

		get setFieldsVisibility() {
			return this.$$.ctx[29];
		}

		get setVisibleFields() {
			return this.$$.ctx[30];
		}

		get setInvisibleFields() {
			return this.$$.ctx[31];
		}

		get setFieldValue() {
			return this.$$.ctx[32];
		}

		get updateField() {
			return this.$$.ctx[33];
		}
	}

	const DEFAULT_RULES = {
	    notReadonly(v) {
	        return {
	            readonly: !v,
	        };
	    },
	    readonly(v) {
	        return {
	            readonly: v,
	        };
	    },
	    enable(v) {
	        return {
	            disabled: !v,
	        };
	    },
	    disable(v) {
	        return {
	            disabled: v,
	        };
	    },
	};

	class notFormRules {
	    static #RULES = { ...DEFAULT_RULES };

	    static add(name, func) {
	        if (!notCommon$3.objHas(this.#RULES, name)) {
	            this.#RULES[name] = func;
	        }
	    }

	    static remove(name) {
	        if (
	            notCommon$3.objHas(this.#RULES, name) &&
	            !Object.keys(DEFAULT_RULES).includes(name)
	        ) {
	            delete this.#RULES[name];
	        }
	    }

	    static exec(rule, master, slaves, value, form) {
	        return this.#RULES[rule](value, master, slaves, form);
	    }
	}

	const DEFAULT_CONTAINER_SELECTOR$1 = ".form";
	const DEFAULT_ACTION_NAME = "default";

	class notForm extends notBase$1 {
	    //UI renderer component class constructor
	    #uiComponent = null;
	    //form validation
	    #validationRunner = null;
	    //ui component
	    #form = null;
	    //model.action
	    #action = DEFAULT_ACTION_NAME;
	    //fields schemas
	    #fields = new Lib(); //fields of UI
	    //variants sets for select menus and so on
	    #variants = null; //variants for UI

	    constructor({
	        target = null,
	        name = "Default",
	        options = {},
	        working = {},
	        data = {},
	        ui = Form, //default UI
	    }) {
	        super({
	            working: {
	                name: `${name}Form`,
	                ...working,
	            },
	            options,
	            data,
	        });
	        this.#variants = new Lib(VARIANTS$1.getContent());
	        if (target) {
	            this.setOptions("target", target);
	        }
	        this.#uiComponent = ui;
	        if (notCommon$3.objHas(options, "action")) {
	            this.#action = options.action;
	        }
	        this.initForm();
	    }

	    initForm() {
	        if (this.getOptions("autoInit", true)) {
	            this.initLibs();
	        }
	        if (this.getOptions("autoRender", true)) {
	            this.initUI();
	        }
	    }

	    initLibs() {
	        this.initFields();
	        this.initVariants();
	        this.initValidator();
	    }

	    reInit() {
	        this.initLibs();
	        this.updateUI();
	        this.resetLoading();
	    }

	    initFields() {
	        const manifest = this.getFormManifest();
	        if (notCommon$3.objHas(manifest, "fields") && this.#fields.isEmpty()) {
	            this.#fields.import(manifest.fields); //all fields available in model manifest
	        }
	    }

	    initVariants() {
	        if (this.getOptions("variants")) {
	            this.#variants.import(this.getOptions("variants"));
	        }
	    }

	    //creating validators runner for this specific form
	    initValidator() {
	        this.#validationRunner = src.Runner(this.getFormValidators());
	    }

	    initUI() {
	        try {
	            const props = this.#getFormProps({
	                manifest: this.getFormManifest(),
	                formOptions: this.getFormOptions(),
	                data: this.getFormData(),
	                injectedProps: this.getFormInjectedProps(),
	            });
	            const target = this.getFormTargetEl();
	            while (target.children.length)
	                target.removeChild(target.firstChild);
	            this.#form = new this.#uiComponent({
	                target,
	                props,
	            });
	            this.#bindUIEvents();
	            this.validateForm();
	        } catch (e) {
	            this.error(e);
	        }
	    }

	    updateUI() {
	        try {
	            const props = this.#getFormProps({
	                manifest: this.getFormManifest(),
	                formOptions: this.getFormOptions(),
	                data: this.getFormData(),
	                injectedProps: this.getFormInjectedProps(),
	            });
	            this.#form.$set(props);
	            this.validateForm();
	        } catch (e) {
	            this.error(e);
	        }
	    }

	    #bindUIEvents() {
	        this.#form.$on("change", () => this.validateForm());
	        this.#form.$on("change", (ev) => {
	            this.emit("change", ev.detail);
	            this.emit(`change.${ev.detail.field}`, ev.detail.value);
	        });
	        this.#form.$on("submit", (ev) => this.submit(ev.detail));
	        this.#form.$on("reject", () => this.reject());
	        this.#form.$on("error", ({ detail }) => this.emit("error", detail));
	        this.#bindMasterSlaveEvents();
	    }

	    #bindMasterSlaveEvents() {
	        const masters = this.getOptions("masters", false);
	        if (!masters) {
	            return;
	        }
	        for (let master in masters) {
	            const rules = masters[master];
	            for (let ruleName in rules) {
	                const ruleSlaves = rules[ruleName];
	                this.#addMasterSlaveEvents(ruleName, master, ruleSlaves);
	            }
	        }
	    }

	    #addMasterSlaveEvents(rule, master, slaves = []) {
	        this.on(`change.${master}`, (value) => {
	            this.#execSlaveRule(rule, master, slaves, value);
	        });
	        this.emit(`change.${master}`, this.getFormData()[master]);
	    }

	    #execSlaveRule(rule, master, slaves, value) {
	        const cmd = notFormRules.exec(rule, master, slaves, value, this);
	        slaves.forEach((slaveField) => {
	            this.updateField(slaveField, cmd);
	        });
	    }

	    async validateForm() {
	        if (this.getOptions("readonly", false)) {
	            return;
	        }
	        try {
	            const validationResult = await this.#validationRunner(
	                this.#form.collectData(),
	                this.getFormAction()
	            );
	            this.#form.updateFormValidationStatus(validationResult.getReport());
	            if (!validationResult.clean) {
	                this.emit("error", validationResult.getReport());
	            }
	        } catch (e) {
	            const report = {
	                form: [UICommon$1.ERROR_DEFAULT, e.message],
	            };
	            this.#form && this.#form.updateFormValidationStatus(report);
	            this.emit("error", report);
	            notCommon$3.report(e);
	        }
	    }

	    submit(data) {
	        this.emit("submit", data);
	    }

	    reject() {
	        this.emit("reject");
	    }

	    //binding event to actual UI
	    $on() {
	        if (this.#form) {
	            this.#form.$on(...arguments);
	        }
	    }

	    setLoading() {
	        this.emit("loading");
	        this.#form.setLoading();
	    }

	    resetLoading() {
	        this.emit("loaded");
	        this.#form.resetLoading();
	    }

	    destroy() {
	        this.emit("destroy");
	        if (this.#form) {
	            this.#form.$destroy && this.#form.$destroy();
	            this.#form.destroy && this.#form.destroy();
	            this.#form = null;
	        }
	        this.#validationRunner = null;
	        this.#action = null;
	        this.#fields = null;
	        this.#variants = null;
	        this.setOptions(null);
	        this.setWorking(null);
	        this.setData(null);
	    }

	    #getFormProps({
	        manifest, //model manifest
	        formOptions = {
	            ui: {},
	            fields: {},
	        }, //some options
	        data = null, //initial data for form
	        injectedProps = {},
	    }) {
	        const action = this.#action;
	        if (typeof formOptions === "undefined" || formOptions === null) {
	            formOptions = {
	                ui: {},
	                fields: {},
	            };
	        }

	        const form = FormHelpers.initFormByField(
	            //form seed object
	            {},
	            /*
	      Form structure
	      [
	        //each item is line of form
	        //field - field takes whole line of form
	        //[field1, field2] - few fields in one line
	        nameFirst, nameLast
	        [age, country, language],
	        [email, telephone]
	      ]
	      */
	            manifest.actions[action].fields, //form fields structure
	            this.#variants, //variants library
	            this.#fields, //fields library
	            formOptions.fields, //form wide fields options
	            data
	        );

	        return {
	            //if no auto init of form structure, set to loading state
	            loading: !this.getOptions("autoInit", true),
	            title: manifest.actions[action].title,
	            description: manifest.actions[action].description,
	            fields: manifest.actions[action].fields,
	            form,
	            //injecting options to UI from top level input
	            ...formOptions.ui, //form UI options
	            ...injectedProps,
	        };
	    }

	    getName() {
	        return this.getWorking("name");
	    }

	    getFormAction() {
	        return this.#action;
	    }

	    setFormAction(val) {
	        if (val && val !== this.#action) {
	            this.#action = val;
	            this.#form && this.#form.$destroy();
	            this.initForm();
	        }
	    }

	    processResult(result) {
	        if (result.status === DEFAULT_STATUS_SUCCESS) {
	            this.setFormSuccess();
	            return true;
	        } else {
	            this.setFormErrors(result);
	            return false;
	        }
	    }

	    /**
	     *   Form validation result
	     **/
	    setFormSuccess() {
	        this.#form.showSuccess();
	        this.emit("success");
	    }

	    setFormErrors(result) {
	        if (this.getOptions("readonly", false)) {
	            return;
	        }
	        const status = {
	            form: [],
	            fields: {},
	        };
	        if (result.message) {
	            status.form.push(result.message);
	        }
	        if (result.errors && Object.keys(result.errors).length > 0) {
	            status.fields = { ...result.errors };
	        }
	        this.#form.updateFormValidationStatus(status);
	        this.emit("error", status);
	    }

	    /**
	     * Returns variant by collection name and item id
	     * @param {string}         name  name of the variants collection
	     * @param {string|number}  id    item identificator
	     * @returns {object}             item
	     **/
	    getVariant(name, id) {
	        let lib = this.#variants.get(name);
	        let result = lib.find((item) => item.id === id);
	        if (result) {
	            return result;
	        }
	        return null;
	    }

	    /***
	     * Redefinable getters
	     **/

	    getFormTargetEl() {
	        const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$1);
	        if (targetEl instanceof HTMLElement) {
	            return targetEl;
	        } else if (typeof targetEl === "string") {
	            return document.querySelector(targetEl);
	        } else {
	            throw new Error("Form parent element is not defined");
	        }
	    }

	    getFormValidators() {
	        if (this.getOptions("validators")) {
	            return this.getOptions("validators", {});
	        } else {
	            this.#missingOverrideWarning("validators");
	            return {};
	        }
	    }

	    getFormManifest() {
	        const modelName = this.getModelName();
	        if (modelName && notCommon$3.getApp()) {
	            return notCommon$3.getApp().getInterfaceManifest(modelName);
	        }
	        if (this.getOptions("manifest", undefined)) {
	            return this.getOptions("manifest", {});
	        } else {
	            this.#missingOverrideWarning("manifest");
	            return {};
	        }
	    }

	    getFormData() {
	        if (this.getData()) {
	            return this.getData();
	        } else {
	            this.#missingOverrideWarning("data");
	            return {};
	        }
	    }

	    getFormOptions() {
	        if (
	            this.getOptions("ui", undefined) ||
	            this.getOptions("fields", undefined)
	        ) {
	            return {
	                ui: this.getOptions("ui", {}),
	                fields: this.getOptions("fields", {}),
	            };
	        } else {
	            this.#missingOverrideWarning("options");
	            return {
	                ui: {},
	                fields: {},
	            };
	        }
	    }

	    getFormInjectedProps() {
	        return this.getOptions("injected", {});
	    }

	    /**
	     * Override empty message
	     **/
	    #missingOverrideWarning(missing) {
	        this.error(
	            `${missing} for ${this.getWorking("name")} form is not defined`
	        );
	    }

	    /**
	     * Form operations
	     **/
	    collectData() {
	        if (this.getOptions("readonly", false)) {
	            return this.getData();
	        }
	        const data = this.#form.collectData();
	        this.setData({ ...data }); //update in inner store
	        return data;
	    }

	    updateField(fieldName, props) {
	        this.#form.updateField(fieldName, props);
	    }

	    getModel(name, data) {
	        if (typeof name === "string") {
	            return this.getInterface(name)(data || {});
	        } else {
	            return this.getInterface()(name || {});
	        }
	    }

	    getInterface(name = false) {
	        return notCommon$3.getApp().getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	    getModelName() {
	        return this.getOptions("model");
	    }
	}

	/* node_modules/not-bulma/src/frame/components/form/form.set.svelte generated by Svelte v4.2.19 */

	function create_if_block$c(ctx) {
		let uibuttons;
		let updating_values;
		let current;

		function uibuttons_values_binding(value) {
			/*uibuttons_values_binding*/ ctx[5](value);
		}

		let uibuttons_props = { centered: true, classes: "mt-4" };

		if (/*FORMS_BUTTONS*/ ctx[2] !== void 0) {
			uibuttons_props.values = /*FORMS_BUTTONS*/ ctx[2];
		}

		uibuttons = new Ui_buttons({ props: uibuttons_props });
		binding_callbacks.push(() => bind(uibuttons, 'values', uibuttons_values_binding));

		return {
			c() {
				create_component(uibuttons.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibuttons, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibuttons_changes = {};

				if (!updating_values && dirty & /*FORMS_BUTTONS*/ 4) {
					updating_values = true;
					uibuttons_changes.values = /*FORMS_BUTTONS*/ ctx[2];
					add_flush_callback(() => updating_values = false);
				}

				uibuttons.$set(uibuttons_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibuttons.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibuttons.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibuttons, detaching);
			}
		};
	}

	function create_fragment$f(ctx) {
		let div1;
		let div0;
		let div0_id_value;
		let t;
		let div1_id_value;
		let current;
		let if_block = /*showModes*/ ctx[1] && create_if_block$c(ctx);

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				t = space();
				if (if_block) if_block.c();
				attr(div0, "class", "form-paper");
				attr(div0, "id", div0_id_value = "" + (/*name*/ ctx[0] + "-form-set-container"));
				attr(div1, "class", "block-container");
				attr(div1, "id", div1_id_value = "" + (/*name*/ ctx[0] + "-form-set"));
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div1, t);
				if (if_block) if_block.m(div1, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*name*/ 1 && div0_id_value !== (div0_id_value = "" + (/*name*/ ctx[0] + "-form-set-container"))) {
					attr(div0, "id", div0_id_value);
				}

				if (/*showModes*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*showModes*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$c(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div1, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}

				if (!current || dirty & /*name*/ 1 && div1_id_value !== (div1_id_value = "" + (/*name*/ ctx[0] + "-form-set"))) {
					attr(div1, "id", div1_id_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				if (if_block) if_block.d();
			}
		};
	}

	function instance$f($$self, $$props, $$invalidate) {
		let dispatch = createEventDispatcher();
		let { name = 'default-form' } = $$props;
		let { showModes = false } = $$props;
		let { mode = 'default' } = $$props;
		let { forms = [] } = $$props;

		function setMode(val) {
			$$invalidate(3, mode = val);
			dispatch('mode', val);
			updateModesButtons();
		}

		let FORMS_BUTTONS = [];

		function updateModesButtons() {
			$$invalidate(2, FORMS_BUTTONS = forms.filter(form => {
				return mode !== form.mode;
			}).map(form => {
				return {
					title: form.title,
					outlined: true,
					type: 'link',
					action() {
						setMode(form.mode);
					}
				};
			}));
		}

		onMount(() => {
			updateModesButtons();
		});

		function uibuttons_values_binding(value) {
			FORMS_BUTTONS = value;
			$$invalidate(2, FORMS_BUTTONS);
		}

		$$self.$$set = $$props => {
			if ('name' in $$props) $$invalidate(0, name = $$props.name);
			if ('showModes' in $$props) $$invalidate(1, showModes = $$props.showModes);
			if ('mode' in $$props) $$invalidate(3, mode = $$props.mode);
			if ('forms' in $$props) $$invalidate(4, forms = $$props.forms);
		};

		return [name, showModes, FORMS_BUTTONS, mode, forms, uibuttons_values_binding];
	}

	class Form_set extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$f, create_fragment$f, safe_not_equal, { name: 0, showModes: 1, mode: 3, forms: 4 });
		}
	}

	const DEFAULT_CONTAINER_SELECTOR = ".form-set";
	const DEFAULT_FORM_SET_NAME = "form-set";

	class notFormSet extends notBase$1 {
	    #formSetComponent = null;
	    #formComponent = null;

	    #form = null;
	    #frame = null;

	    /*
	  new notFormSet({
	    options:{
	      target: el,
	      forms: [{
	        mode: 'form1',
	        title: 'Form 1',
	        form: formConstructor1 //custom constructors
	      },{
	        mode: 'form2',
	        title: 'Form 2',
	        props: {}             //params to create notForm instance
	      },{
	        mode: 'form3',
	        title: 'Form 3',
	        form: formConstructor3 //custom constructors
	      }]
	    }
	  });
	  */

	    constructor({
	        options = {},
	        formComponent = Form,
	        formSetComponent = Form_set,
	    }) {
	        super({
	            options: {
	                name: DEFAULT_FORM_SET_NAME,
	                mode: "default",
	                showModes: true,
	                ...options,
	            },
	        });
	        this.#formComponent = Form;
	        this.#formSetComponent = Form_set;
	        this.setFormMode(this.getOptions("mode"));
	        this.initUI();
	    }

	    /**
	     * Initalizing form frame mode, with switchers between modes
	     **/
	    initUI() {
	        const target = this.getFrameTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        this.#frame = new this.#formSetComponent({
	            target,
	            props: this.#getFrameProps(),
	        });
	        this.#frame.$on("mode", (ev) => {
	            this.setFormMode(ev.detail);
	            this.updateForm();
	        });
	        this.updateForm();
	    }

	    setFormMode(name) {
	        if (this.isModeExists(name)) {
	            this.setWorking("mode", name);
	        } else {
	            this.setWorking("mode", this.getFirstMode());
	            this.updateFormModeInUI();
	        }
	    }

	    updateFormModeInUI() {
	        if (this.#frame && this.getWorking("mode") !== null) {
	            this.#frame.$set({ mode: this.getWorking("mode") });
	        }
	    }

	    getFormMode() {
	        return this.getWorking("mode");
	    }

	    updateForm() {
	        this.destroyForm();
	        if (this.getWorking("mode") !== null) {
	            this.renderForm();
	        }
	    }

	    renderForm() {
	        const targetEl = this.getFormTargetEl();
	        const formConfig = this.getFormConfig();
	        if (!(targetEl instanceof HTMLElement && formConfig)) {
	            throw new Error("error while form rendering");
	        }
	        const changeMode = (mode) => {
	            this.setFormMode(mode);
	            this.updateForm();
	        };
	        if (formConfig.form) {
	            while (targetEl.children.length)
	                targetEl.removeChild(targetEl.firstChild);
	            this.#form = new formConfig.form({
	                options: { target: targetEl, changeMode },
	            });
	        } else if (formConfig.props) {
	            this.#form = new this.#formComponent({
	                target: targetEl,
	                ...formConfig.props,
	                changeMode,
	            });
	        }
	    }

	    getFormConfig() {
	        return this.getOptions("forms").find(
	            (form) => form.mode === this.getFormMode()
	        );
	    }

	    destroyForm() {
	        const containerEl = this.getFormTargetEl();
	        if (containerEl) {
	            while (containerEl.firstChild) {
	                containerEl.removeChild(containerEl.lastChild);
	            }
	        }
	        if (this.#form && this.#form.$destroy) {
	            this.#form.$destroy();
	        }
	        this.#form = null;
	    }

	    destroyFrame() {
	        if (this.#frame && this.#frame.$destroy) {
	            this.#frame.$destroy();
	        }
	        this.#frame = null;
	    }

	    isModeExists(mode) {
	        const forms = this.getOptions("forms", []);
	        return forms.some((item) => item.mode === mode);
	    }

	    getFirstMode() {
	        const forms = this.getOptions("forms", []);
	        if (forms.length > 0) {
	            return forms[0].mode;
	        }
	        return null;
	    }

	    destroy() {
	        this.#formSetComponent = null;
	        this.#formComponent = null;
	        this.destroyForm();
	        this.destroyFrame();
	        thi.setData(null);
	        thi.setOptions(null);
	        thi.setWorking(null);
	    }

	    getFrameTargetEl() {
	        const target = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR);
	        if (target instanceof HTMLElement) {
	            return target;
	        } else if (typeof target === "string") {
	            return document.querySelector(target);
	        } else {
	            throw new Error("form set target is not HTMLElement or string");
	        }
	    }

	    getFormTargetEl() {
	        const name = this.getOptions("name", DEFAULT_FORM_SET_NAME);
	        return document.querySelector(`#${name}-form-set-container`);
	    }

	    #getFrameProps() {
	        return {
	            showModes: this.getOptions("showModes", true),
	            mode: this.getFormMode(),
	            forms: this.getOptions("forms", []),
	            name: this.getOptions("name", DEFAULT_FORM_SET_NAME),
	        };
	    }
	}

	/* node_modules/not-bulma/src/frame/components/breadcrumbs/ui.breadcrumbs.svelte generated by Svelte v4.2.19 */

	function get_each_context$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		child_ctx[7] = i;
		return child_ctx;
	}

	// (29:4) {:else}
	function create_else_block$9(ctx) {
		let li;
		let a;
		let t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "";
		let t;
		let a_href_value;
		let a_data_href_value;
		let mounted;
		let dispose;

		return {
			c() {
				li = element("li");
				a = element("a");
				t = text(t_value);
				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*link*/ ctx[5].url));
				attr(a, "data-href", a_data_href_value = /*link*/ ctx[5].url);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, a);
				append(a, t);

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[3]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, items*/ 6 && t_value !== (t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "")) set_data(t, t_value);

				if (dirty & /*root, items*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*link*/ ctx[5].url))) {
					attr(a, "href", a_href_value);
				}

				if (dirty & /*items*/ 2 && a_data_href_value !== (a_data_href_value = /*link*/ ctx[5].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (27:4) {#if link.url === false }
	function create_if_block_1$a(ctx) {
		let li;
		let t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "";
		let t;

		return {
			c() {
				li = element("li");
				t = text(t_value);
				attr(li, "class", "is-plain-crumb");
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, items*/ 6 && t_value !== (t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}
			}
		};
	}

	// (24:4) {#if (items.length === (index + 1)) }
	function create_if_block$b(ctx) {
		let li;
		let a;
		let t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "";
		let t;
		let a_href_value;
		let a_data_href_value;

		return {
			c() {
				li = element("li");
				a = element("a");
				t = text(t_value);
				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*link*/ ctx[5].url));
				attr(a, "data-href", a_data_href_value = /*link*/ ctx[5].url);
				attr(a, "aria-current", "page");
				attr(li, "class", "is-active");
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, a);
				append(a, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, items*/ 6 && t_value !== (t_value = /*$LOCALE*/ ctx[2][/*link*/ ctx[5].title] + "")) set_data(t, t_value);

				if (dirty & /*root, items*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*link*/ ctx[5].url))) {
					attr(a, "href", a_href_value);
				}

				if (dirty & /*items*/ 2 && a_data_href_value !== (a_data_href_value = /*link*/ ctx[5].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}
			}
		};
	}

	// (23:4) {#each items as link, index}
	function create_each_block$4(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*items*/ ctx[1].length === /*index*/ ctx[7] + 1) return create_if_block$b;
			if (/*link*/ ctx[5].url === false) return create_if_block_1$a;
			return create_else_block$9;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function create_fragment$e(ctx) {
		let nav;
		let ul;
		let each_value = ensure_array_like(/*items*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
		}

		return {
			c() {
				nav = element("nav");
				ul = element("ul");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(nav, "class", "breadcrumb");
				attr(nav, "aria-label", "breadcrumbs");
			},
			m(target, anchor) {
				insert(target, nav, anchor);
				append(nav, ul);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*root, items, $LOCALE, onClick*/ 15) {
					each_value = ensure_array_like(/*items*/ ctx[1]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$4(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$4(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(nav);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$e($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		let { root = '' } = $$props;
		let { items = [] } = $$props;
		let { go = null } = $$props;

		function onClick(ev) {
			if (typeof go === 'function') {
				ev.preventDefault();
				go(ev.currentTarget.dataset.href);
				return false;
			} else {
				return true;
			}
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('items' in $$props) $$invalidate(1, items = $$props.items);
			if ('go' in $$props) $$invalidate(4, go = $$props.go);
		};

		return [root, items, $LOCALE, onClick, go];
	}

	class Ui_breadcrumbs extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$e, create_fragment$e, safe_not_equal, { root: 0, items: 1, go: 4 });
		}
	}

	class notBreadcrumbs{

	  static UIConstructor = null;
	  static ui = null;
	  static head = [];
	  static tail = [];

	  static render({target, root = '', navigate}){
	    this.remove();
	    if(notBreadcrumbs.UIConstructor){
	      this.ui = new notBreadcrumbs.UIConstructor({
	        target,
	        props:{
	          items:  this.getBreadcrumbs(),
	          root:   root,
	          go:      navigate
	        }
	      });
	    }
	  }

	  static setHead(head){
	    this.head.splice(0,this.head.length,...head);
	    return this;
	  }

	  static setTail(tail){
	    this.tail.splice(0, this.tail.length,...tail);
	    return this;
	  }

	  static getBreadcrumbs(){
	    let crumbs = [];
	    crumbs.push(...this.head);
	    crumbs.push(...this.tail);
	    return crumbs;
	  }

	  static update(){
	    if(this.ui){
	      this.ui.$set({ items: this.getBreadcrumbs() });
	    }
	  }

	  static remove(){
	    if (this.ui) {
	      this.ui.$destroy();
	      this.ui = null;
	    }
	    return this;
	  }

	}

	notBreadcrumbs.UIConstructor = Ui_breadcrumbs;

	class Menu {
	    static MAX_TOUCH_WIDTH = 1023;
	    static DEFAULT = {
	        section: "any",
	        sectionTitle: "Меню",
	        priority: 0,
	        //link, button, dropdown, component
	        type: "link",
	    };
	    static app = false;
	    static directNavigation = false;
	    static menu;
	    static options = {
	        directNavigation: false,
	        navigate: (urls) => {
	            this.hide();
	            if (!this.isDirectNavigation() && this.app) {
	                let func = this.app.getWorking("router");
	                if (func) {
	                    return func.navigate(urls.short);
	                }
	            }
	            document.location.assign(urls.full);
	        },
	    };

	    static items = [];
	    static sections = [];
	    static location;
	    static interval;

	    static setApp(app) {
	        if (!this.app) {
	            this.app = app;
	        }
	        return this;
	    }

	    static setOptions(options) {
	        this.options = { ...this.options, ...options };
	        return this;
	    }

	    static getOptionsPathTo(what) {
	        return `menu.${this.options.type}.${what}`;
	    }

	    static isDirectNavigation() {
	        return this.app
	            ? this.app.getOptions(
	                  this.getOptionsPathTo("directNavigation"),
	                  this.options.directNavigation
	              )
	            : this.options.directNavigation;
	    }

	    static getOptions() {
	        if (this.app) {
	            return {
	                brand: this.app.getOptions("brand", this.options.brand),
	                items: this.app.getOptions(
	                    this.getOptionsPathTo("items"),
	                    this.options.items
	                ),
	                sections: this.app.getOptions(
	                    this.getOptionsPathTo("sections"),
	                    this.options.sections
	                ),
	                targetSelector: this.app.getOptions(
	                    this.getOptionsPathTo("targetSelector"),
	                    this.options.targetSelector
	                ),
	                toggleSelector: this.app.getOptions(
	                    this.getOptionsPathTo("toggleSelector"),
	                    this.options.toggleSelector
	                ),
	                open: this.app.getOptions(
	                    this.getOptionsPathTo("open"),
	                    this.options.open
	                ),
	                directNavigation: this.app.getOptions(
	                    this.getOptionsPathTo("directNavigation"),
	                    this.options.directNavigation
	                ),
	                root: this.app.getOptions("router.root", this.options.root),
	                navigate: this.options.navigate.bind(this),
	                getComponent: this.getComponent.bind(this),
	            };
	        } else {
	            return this.options;
	        }
	    }

	    static getComponent(name) {
	        if (COMPONENTS$2.contains(name)) {
	            return COMPONENTS$2.get(name);
	        } else {
	            return false;
	        }
	    }

	    static initField(list, fields = []) {
	        list.forEach((item) => {
	            fields.forEach((field) => {
	                if (!Object.hasOwn(item, field)) {
	                    item[field] = this.DEFAULT[field];
	                }
	            });
	            if (Object.hasOwn(item, "items")) {
	                this.initField(item.items, fields);
	            }
	        });
	    }

	    static sortList(list) {
	        list.sort((item1, item2) => {
	            if (Object.hasOwn(item1, "items")) {
	                this.sortList(item1.items);
	            }
	            if (Object.hasOwn(item2, "items")) {
	                this.sortList(item2.items);
	            }
	            if (item1.priority === item2.priority) {
	                return item1.title > item2.title ? 1 : -1;
	            } else {
	                return item1.priority < item2.priority ? 1 : -1;
	            }
	        });
	    }

	    static removeDublicates(sections) {
	        for (let i = 0; i < sections.length; i++) {
	            let priority = sections[i].priority;
	            sections
	                .filter((section) => {
	                    return section.id === sections[i].id;
	                })
	                .forEach((item, indx) => {
	                    if (indx === 0) {
	                        return;
	                    }
	                    if (item.priority < priority) {
	                        priority = item.priority;
	                    }
	                    sections.splice(sections.indexOf(item), 1);
	                });
	            sections[i].priority = priority;
	        }
	        return sections;
	    }

	    static prepareData() {
	        let items = [];
	        items.push(...this.getOptions().items);
	        let sections = [];
	        sections.push(...this.getOptions().sections);

	        this.initField(sections, ["priority"]);
	        this.removeDublicates(sections);
	        this.initField(items, ["priority", "section", "type"]);
	        this.sortList(sections);

	        sections.push({
	            id: this.DEFAULT.section,
	            title: this.DEFAULT.sectionTitle,
	        });
	        this.sortList(items);

	        this.sections = sections;
	        this.items = items;
	    }

	    static remove() {
	        if (this.menu) {
	            this.menu.$destroy();
	            this.menu = null;
	            clearInterval(this.interval);
	        }
	    }

	    static updateIndicator(sectionId, itemId, state) {
	        this.updateSection(sectionId, (section) => {
	            section.indicator.state = state;
	        });
	        this.updateItem(itemId, (item) => {
	            item.indicator.state = state;
	        });
	    }

	    static updateTag(sectionId, itemId, tag) {
	        this.updateSection(sectionId, (section) => {
	            section.tag = tag;
	        });
	        this.updateItem(itemId, (item) => {
	            item.tag = tag;
	        });
	    }

	    static updateSectionTag(sectionId, tag) {
	        this.updateSection(sectionId, (section) => {
	            section.tag = { ...section.tag, ...tag };
	        });
	    }

	    static updateItemTag(itemId, tag) {
	        this.updateItem(itemId, (item) => {
	            item.tag = { ...item.tag, ...tag };
	        });
	    }

	    static updateSection(sectionId, proc) {
	        if (this.sections && sectionId) {
	            for (let section in this.sections) {
	                if (this.sections[section].id !== sectionId) continue;
	                proc(this.sections[section]);
	            }
	            if (this.menu) {
	                this.menu.$set({ sections: this.sections });
	            }
	        }
	    }

	    static updateSectionItems(sectionId, proc) {
	        if (this.sections && sectionId) {
	            let oldList = this.items.filter(
	                (item) => item.section === sectionId
	            );
	            for (let i of oldList) {
	                this.items.splice(this.items.indexOf(i), 1);
	            }
	            this.items.push(...proc(oldList));
	            if (this.menu) {
	                this.menu.$set({ items: this.items });
	            }
	        }
	    }

	    static updateItem(itemId, proc) {
	        if (itemId && this.items) {
	            this.items.forEach((item) => {
	                if (item.id !== itemId) return;
	                proc(item);
	            });
	            if (this.menu) {
	                this.menu.$set({ items: this.items });
	            }
	        }
	    }

	    static isTouch() {
	        return window.innerWidth <= this.MAX_TOUCH_WIDTH;
	    }

	    static getSectionComponent() {}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.item.without.children.svelte generated by Svelte v4.2.19 */

	function create_else_block$8(ctx) {
		let li;
		let t0_value = /*$LOCALE*/ ctx[2][/*item*/ ctx[1].title] + "";
		let t0;
		let t1;
		let t2;
		let li_class_value;
		let current;
		let if_block0 = /*item*/ ctx[1].tag && create_if_block_4$3(ctx);
		let if_block1 = /*item*/ ctx[1].indicator && create_if_block_3$6(ctx);

		return {
			c() {
				li = element("li");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				attr(li, "class", li_class_value = "is-no-follow-subtitle " + /*item*/ ctx[1].classes);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, t0);
				append(li, t1);
				if (if_block0) if_block0.m(li, null);
				append(li, t2);
				if (if_block1) if_block1.m(li, null);
				current = true;
			},
			p(ctx, dirty) {
				if ((!current || dirty & /*$LOCALE, item*/ 6) && t0_value !== (t0_value = /*$LOCALE*/ ctx[2][/*item*/ ctx[1].title] + "")) set_data(t0, t0_value);

				if (/*item*/ ctx[1].tag) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*item*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_4$3(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(li, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*item*/ ctx[1].indicator) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*item*/ 2) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_3$6(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(li, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*item*/ 2 && li_class_value !== (li_class_value = "is-no-follow-subtitle " + /*item*/ ctx[1].classes)) {
					attr(li, "class", li_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (22:0) {#if (typeof item.url !== 'undefined' && item.url!==false) }
	function create_if_block$a(ctx) {
		let li;
		let a;
		let t0_value = /*$LOCALE*/ ctx[2][/*item*/ ctx[1].title] + "";
		let t0;
		let t1;
		let t2;
		let a_href_value;
		let a_data_href_value;
		let li_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*item*/ ctx[1].tag && create_if_block_2$6(ctx);
		let if_block1 = /*item*/ ctx[1].indicator && create_if_block_1$9(ctx);

		return {
			c() {
				li = element("li");
				a = element("a");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[1].url));
				attr(a, "data-href", a_data_href_value = /*item*/ ctx[1].url);
				attr(li, "class", li_class_value = /*item*/ ctx[1].classes);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, a);
				append(a, t0);
				append(a, t1);
				if (if_block0) if_block0.m(a, null);
				append(a, t2);
				if (if_block1) if_block1.m(a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[3]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if ((!current || dirty & /*$LOCALE, item*/ 6) && t0_value !== (t0_value = /*$LOCALE*/ ctx[2][/*item*/ ctx[1].title] + "")) set_data(t0, t0_value);

				if (/*item*/ ctx[1].tag) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*item*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$6(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(a, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*item*/ ctx[1].indicator) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*item*/ 2) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$9(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(a, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*root, item*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[1].url))) {
					attr(a, "href", a_href_value);
				}

				if (!current || dirty & /*item*/ 2 && a_data_href_value !== (a_data_href_value = /*item*/ ctx[1].url)) {
					attr(a, "data-href", a_data_href_value);
				}

				if (!current || dirty & /*item*/ 2 && li_class_value !== (li_class_value = /*item*/ ctx[1].classes)) {
					attr(li, "class", li_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				mounted = false;
				dispose();
			}
		};
	}

	// (36:2) {#if item.tag }
	function create_if_block_4$3(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[1].id }, /*item*/ ctx[1].tag];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 2)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[1].id }, get_spread_object(/*item*/ ctx[1].tag)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (39:2) {#if item.indicator }
	function create_if_block_3$6(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[1].id }, /*item*/ ctx[1].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 2)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[1].id }, get_spread_object(/*item*/ ctx[1].indicator)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (26:2) {#if item.tag }
	function create_if_block_2$6(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[1].id }, /*item*/ ctx[1].tag];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 2)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[1].id }, get_spread_object(/*item*/ ctx[1].tag)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (29:2) {#if item.indicator }
	function create_if_block_1$9(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[1].id }, /*item*/ ctx[1].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 2)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[1].id }, get_spread_object(/*item*/ ctx[1].indicator)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	function create_fragment$d(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$a, create_else_block$8];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (typeof /*item*/ ctx[1].url !== 'undefined' && /*item*/ ctx[1].url !== false) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$d($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(2, $LOCALE = $$value));
		const dispatch = createEventDispatcher();
		let { root = '' } = $$props;
		let { item = {} } = $$props;

		function onClick(ev) {
			ev.preventDefault();

			dispatch('navigate', {
				full: ev.target.getAttribute('href'),
				short: ev.target.dataset.href
			});

			return false;
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('item' in $$props) $$invalidate(1, item = $$props.item);
		};

		return [root, item, $LOCALE, onClick];
	}

	class Ui_item_without_children extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$d, create_fragment$d, safe_not_equal, { root: 0, item: 1 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.trigger.svelte generated by Svelte v4.2.19 */

	function create_fragment$c(ctx) {
		let span;
		let i;
		let i_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				span = element("span");
				i = element("i");

				attr(i, "class", i_class_value = "fas " + (/*closed*/ ctx[0]
				? /*icon_closed*/ ctx[2]
				: /*icon_opened*/ ctx[1]));

				attr(i, "aria-hidden", "true");
				attr(span, "class", "icon is-small is-toggle-submenu is-pulled-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);

				if (!mounted) {
					dispose = [
						listen(span, "click", /*onClick*/ ctx[3]),
						listen(span, "keyup", /*onClick*/ ctx[3])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*closed, icon_closed, icon_opened*/ 7 && i_class_value !== (i_class_value = "fas " + (/*closed*/ ctx[0]
				? /*icon_closed*/ ctx[2]
				: /*icon_opened*/ ctx[1]))) {
					attr(i, "class", i_class_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$c($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();

		const CLASS_ICON = {
			OPENED: "fa-angle-down",
			CLOSED: "fa-angle-up"
		};

		let { icon_opened = CLASS_ICON.OPENED } = $$props;
		let { icon_closed = CLASS_ICON.CLOSED } = $$props;
		let { closed = false } = $$props;

		function onClick(e) {
			e && e.preventDefault() && e.stopPropagation();
			$$invalidate(0, closed = !closed);
			dispatch("toggle", { closed });
			return false;
		}

		$$self.$$set = $$props => {
			if ('icon_opened' in $$props) $$invalidate(1, icon_opened = $$props.icon_opened);
			if ('icon_closed' in $$props) $$invalidate(2, icon_closed = $$props.icon_closed);
			if ('closed' in $$props) $$invalidate(0, closed = $$props.closed);
		};

		return [closed, icon_opened, icon_closed, onClick];
	}

	class Ui_trigger extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$c, create_fragment$c, safe_not_equal, {
				icon_opened: 1,
				icon_closed: 2,
				closed: 0
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.item.label.svelte generated by Svelte v4.2.19 */

	function create_else_block$7(ctx) {
		let span;
		let t_value = /*$LOCALE*/ ctx[1][/*item*/ ctx[0].title] + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "class", "is-no-link");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, item*/ 3 && t_value !== (t_value = /*$LOCALE*/ ctx[1][/*item*/ ctx[0].title] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (14:94) 
	function create_if_block_3$5(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].props];
		var switch_value = COMPONENTS$2.get(/*item*/ ctx[0].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*item*/ 1) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].props)]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*item*/ 1 && switch_value !== (switch_value = COMPONENTS$2.get(/*item*/ ctx[0].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*item*/ 1)
					? get_spread_update(switch_instance_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].props)])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (12:0) {#if item.icon }
	function create_if_block_2$5(ctx) {
		let uiicon;
		let current;
		const uiicon_spread_levels = [/*item*/ ctx[0].icon];
		let uiicon_props = {};

		for (let i = 0; i < uiicon_spread_levels.length; i += 1) {
			uiicon_props = assign(uiicon_props, uiicon_spread_levels[i]);
		}

		uiicon = new Ui_icon_font({ props: uiicon_props });

		return {
			c() {
				create_component(uiicon.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiicon, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiicon_changes = (dirty & /*item*/ 1)
				? get_spread_update(uiicon_spread_levels, [get_spread_object(/*item*/ ctx[0].icon)])
				: {};

				uiicon.$set(uiicon_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiicon.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiicon.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiicon, detaching);
			}
		};
	}

	// (23:0) {#if item.tag }
	function create_if_block_1$8(ctx) {
		let uitag;
		let current;
		const uitag_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].tag];
		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitag_changes = (dirty & /*item*/ 1)
				? get_spread_update(uitag_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].tag)])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	// (26:0) {#if item.indicator }
	function create_if_block$9(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 1)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].indicator)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	function create_fragment$b(ctx) {
		let show_if;
		let current_block_type_index;
		let if_block0;
		let t0;
		let t1;
		let t2;
		let current;
		const if_block_creators = [create_if_block_2$5, create_if_block_3$5, create_else_block$7];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (dirty & /*item*/ 1) show_if = null;
			if (/*item*/ ctx[0].icon) return 0;
			if (show_if == null) show_if = !!(/*item*/ ctx[0].type === 'component' && /*item*/ ctx[0].component && COMPONENTS$2.contains(/*item*/ ctx[0].component));
			if (show_if) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx, -1);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*item*/ ctx[0].tag && create_if_block_1$8(ctx);
		let if_block2 = /*item*/ ctx[0].indicator && create_if_block$9(ctx);
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		return {
			c() {
				if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				if (default_slot) default_slot.c();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t2, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}

				if (/*item*/ ctx[0].tag) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*item*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$8(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*item*/ ctx[0].indicator) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*item*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block$9(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(t2.parentNode, t2);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
				}

				if_blocks[current_block_type_index].d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$b($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(1, $LOCALE = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		let { item = {} } = $$props;

		$$self.$$set = $$props => {
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
			if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
		};

		return [item, $LOCALE, $$scope, slots];
	}

	class Ui_item_label extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$b, create_fragment$b, safe_not_equal, { item: 0 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.items.svelte generated by Svelte v4.2.19 */

	function get_each_context$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[11] = list[i];
		child_ctx[12] = list;
		child_ctx[13] = i;
		return child_ctx;
	}

	// (48:1) {:else}
	function create_else_block_1(ctx) {
		let uisidemenuitemwithoutchildren;
		let current;

		uisidemenuitemwithoutchildren = new Ui_item_without_children({
				props: {
					root: /*root*/ ctx[0],
					item: /*item*/ ctx[11]
				}
			});

		uisidemenuitemwithoutchildren.$on("navigate", /*navigate_handler_1*/ ctx[9]);

		return {
			c() {
				create_component(uisidemenuitemwithoutchildren.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenuitemwithoutchildren, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uisidemenuitemwithoutchildren_changes = {};
				if (dirty & /*root*/ 1) uisidemenuitemwithoutchildren_changes.root = /*root*/ ctx[0];
				if (dirty & /*items*/ 2) uisidemenuitemwithoutchildren_changes.item = /*item*/ ctx[11];
				uisidemenuitemwithoutchildren.$set(uisidemenuitemwithoutchildren_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenuitemwithoutchildren.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenuitemwithoutchildren.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenuitemwithoutchildren, detaching);
			}
		};
	}

	// (33:1) {#if item.items && item.items.length }
	function create_if_block$8(ctx) {
		let li;
		let current_block_type_index;
		let if_block;
		let t0;
		let ui_items;
		let updating_closed;
		let t1;
		let li_class_value;
		let current;
		const if_block_creators = [create_if_block_1$7, create_else_block$6];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (typeof /*item*/ ctx[11].url !== 'undefined' && /*item*/ ctx[11].url !== false) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function ui_items_closed_binding(value) {
			/*ui_items_closed_binding*/ ctx[7](value, /*index*/ ctx[13]);
		}

		let ui_items_props = {
			root: /*root*/ ctx[0],
			items: /*item*/ ctx[11].items
		};

		if (/*closedChildren*/ ctx[3][/*index*/ ctx[13]] !== void 0) {
			ui_items_props.closed = /*closedChildren*/ ctx[3][/*index*/ ctx[13]];
		}

		ui_items = new Ui_items({ props: ui_items_props });
		binding_callbacks.push(() => bind(ui_items, 'closed', ui_items_closed_binding));
		ui_items.$on("navigate", /*navigate_handler*/ ctx[8]);

		return {
			c() {
				li = element("li");
				if_block.c();
				t0 = space();
				create_component(ui_items.$$.fragment);
				t1 = space();
				attr(li, "class", li_class_value = "is-no-follow-subtitle " + /*item*/ ctx[11].classes);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				if_blocks[current_block_type_index].m(li, null);
				append(li, t0);
				mount_component(ui_items, li, null);
				append(li, t1);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(li, t0);
				}

				const ui_items_changes = {};
				if (dirty & /*root*/ 1) ui_items_changes.root = /*root*/ ctx[0];
				if (dirty & /*items*/ 2) ui_items_changes.items = /*item*/ ctx[11].items;

				if (!updating_closed && dirty & /*closedChildren*/ 8) {
					updating_closed = true;
					ui_items_changes.closed = /*closedChildren*/ ctx[3][/*index*/ ctx[13]];
					add_flush_callback(() => updating_closed = false);
				}

				ui_items.$set(ui_items_changes);

				if (!current || dirty & /*items*/ 2 && li_class_value !== (li_class_value = "is-no-follow-subtitle " + /*item*/ ctx[11].classes)) {
					attr(li, "class", li_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(ui_items.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				transition_out(ui_items.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(ui_items);
			}
		};
	}

	// (41:2) {:else}
	function create_else_block$6(ctx) {
		let uisidemenuitemlabel;
		let current;

		uisidemenuitemlabel = new Ui_item_label({
				props: {
					item: /*item*/ ctx[11],
					$$slots: { default: [create_default_slot_1] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(uisidemenuitemlabel.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenuitemlabel, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uisidemenuitemlabel_changes = {};
				if (dirty & /*items*/ 2) uisidemenuitemlabel_changes.item = /*item*/ ctx[11];

				if (dirty & /*$$scope, closedChildren*/ 16392) {
					uisidemenuitemlabel_changes.$$scope = { dirty, ctx };
				}

				uisidemenuitemlabel.$set(uisidemenuitemlabel_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenuitemlabel.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenuitemlabel.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenuitemlabel, detaching);
			}
		};
	}

	// (35:2) {#if (typeof item.url !== 'undefined' && item.url!==false) }
	function create_if_block_1$7(ctx) {
		let a;
		let uisidemenuitemlabel;
		let a_href_value;
		let a_data_href_value;
		let current;
		let mounted;
		let dispose;

		uisidemenuitemlabel = new Ui_item_label({
				props: {
					item: /*item*/ ctx[11],
					$$slots: { default: [create_default_slot] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				a = element("a");
				create_component(uisidemenuitemlabel.$$.fragment);
				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[11].url));
				attr(a, "data-href", a_data_href_value = /*item*/ ctx[11].url);
				attr(a, "class", "has-subitems");
			},
			m(target, anchor) {
				insert(target, a, anchor);
				mount_component(uisidemenuitemlabel, a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[4]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uisidemenuitemlabel_changes = {};
				if (dirty & /*items*/ 2) uisidemenuitemlabel_changes.item = /*item*/ ctx[11];

				if (dirty & /*$$scope, closedChildren*/ 16392) {
					uisidemenuitemlabel_changes.$$scope = { dirty, ctx };
				}

				uisidemenuitemlabel.$set(uisidemenuitemlabel_changes);

				if (!current || dirty & /*root, items*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[11].url))) {
					attr(a, "href", a_href_value);
				}

				if (!current || dirty & /*items*/ 2 && a_data_href_value !== (a_data_href_value = /*item*/ ctx[11].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenuitemlabel.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenuitemlabel.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				destroy_component(uisidemenuitemlabel);
				mounted = false;
				dispose();
			}
		};
	}

	// (42:3) <UISideMenuItemLabel {item} >
	function create_default_slot_1(ctx) {
		let uisidemenutrigger;
		let current;

		function toggle_handler_1(...args) {
			return /*toggle_handler_1*/ ctx[6](/*index*/ ctx[13], ...args);
		}

		uisidemenutrigger = new Ui_trigger({});
		uisidemenutrigger.$on("toggle", toggle_handler_1);

		return {
			c() {
				create_component(uisidemenutrigger.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenutrigger, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenutrigger.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenutrigger.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenutrigger, detaching);
			}
		};
	}

	// (37:3) <UISideMenuItemLabel {item} >
	function create_default_slot(ctx) {
		let uisidemenutrigger;
		let current;

		function toggle_handler(...args) {
			return /*toggle_handler*/ ctx[5](/*index*/ ctx[13], ...args);
		}

		uisidemenutrigger = new Ui_trigger({});
		uisidemenutrigger.$on("toggle", toggle_handler);

		return {
			c() {
				create_component(uisidemenutrigger.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenutrigger, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenutrigger.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenutrigger.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenutrigger, detaching);
			}
		};
	}

	// (32:0) {#each items as item, index}
	function create_each_block$3(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$8, create_else_block_1];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*item*/ ctx[11].items && /*item*/ ctx[11].items.length) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function create_fragment$a(ctx) {
		let ul;
		let ul_class_value;
		let current;
		let each_value = ensure_array_like(/*items*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				ul = element("ul");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(ul, "class", ul_class_value = "menu-list " + (/*closed*/ ctx[2] ? 'is-closed' : ''));
			},
			m(target, anchor) {
				insert(target, ul, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*items, root, closedChildren, onClick*/ 27) {
					each_value = ensure_array_like(/*items*/ ctx[1]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$3(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$3(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(ul, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty & /*closed*/ 4 && ul_class_value !== (ul_class_value = "menu-list " + (/*closed*/ ctx[2] ? 'is-closed' : ''))) {
					attr(ul, "class", ul_class_value);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(ul);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$a($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let closedChildren = {};
		let { root = '' } = $$props;
		let { items = [] } = $$props;
		let { closed = false } = $$props;

		function onClick(ev) {
			ev.preventDefault();

			dispatch('navigate', {
				full: ev.target.getAttribute('href'),
				short: ev.target.dataset.href
			});

			return false;
		}

		const toggle_handler = (index, { detail }) => {
			$$invalidate(3, closedChildren[index] = detail.closed, closedChildren);
		};

		const toggle_handler_1 = (index, { detail }) => {
			$$invalidate(3, closedChildren[index] = detail.closed, closedChildren);
		};

		function ui_items_closed_binding(value, index) {
			if ($$self.$$.not_equal(closedChildren[index], value)) {
				closedChildren[index] = value;
				$$invalidate(3, closedChildren);
			}
		}

		function navigate_handler(event) {
			bubble.call(this, $$self, event);
		}

		function navigate_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('items' in $$props) $$invalidate(1, items = $$props.items);
			if ('closed' in $$props) $$invalidate(2, closed = $$props.closed);
		};

		return [
			root,
			items,
			closed,
			closedChildren,
			onClick,
			toggle_handler,
			toggle_handler_1,
			ui_items_closed_binding,
			navigate_handler,
			navigate_handler_1
		];
	}

	class Ui_items extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$a, create_fragment$a, safe_not_equal, { root: 0, items: 1, closed: 2 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.section.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$6(ctx) {
		let if_block_anchor;
		let current;
		let if_block = (/*sectionItems*/ ctx[2].length || /*section*/ ctx[0].component || /*section*/ ctx[0].tag || /*section*/ ctx[0].indicator) && create_if_block_2$4(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*sectionItems*/ ctx[2].length || /*section*/ ctx[0].component || /*section*/ ctx[0].tag || /*section*/ ctx[0].indicator) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*sectionItems, section*/ 5) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_2$4(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (15:0) {#if sectionItems.length || section.component || section.tag || section.indicator }
	function create_if_block_2$4(ctx) {
		let p;
		let show_if;
		let current_block_type_index;
		let if_block0;
		let t0;
		let t1;
		let p_class_value;
		let current;
		const if_block_creators = [create_if_block_5$1, create_else_block$5];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (dirty & /*section*/ 1) show_if = null;
			if (show_if == null) show_if = !!(/*section*/ ctx[0].type === 'component' && /*section*/ ctx[0].component && COMPONENTS$2.contains(/*section*/ ctx[0].component));
			if (show_if) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx, -1);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*section*/ ctx[0].tag && create_if_block_4$2(ctx);
		let if_block2 = /*section*/ ctx[0].indicator && create_if_block_3$4(ctx);

		return {
			c() {
				p = element("p");
				if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(p, "class", p_class_value = "menu-label " + /*section*/ ctx[0].classes);
			},
			m(target, anchor) {
				insert(target, p, anchor);
				if_blocks[current_block_type_index].m(p, null);
				append(p, t0);
				if (if_block1) if_block1.m(p, null);
				append(p, t1);
				if (if_block2) if_block2.m(p, null);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(p, t0);
				}

				if (/*section*/ ctx[0].tag) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*section*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_4$2(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(p, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*section*/ ctx[0].indicator) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*section*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_3$4(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(p, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*section*/ 1 && p_class_value !== (p_class_value = "menu-label " + /*section*/ ctx[0].classes)) {
					attr(p, "class", p_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}

				if_blocks[current_block_type_index].d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (23:2) {:else}
	function create_else_block$5(ctx) {
		let t_value = /*$LOCALE*/ ctx[3][/*section*/ ctx[0].title] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, section*/ 9 && t_value !== (t_value = /*$LOCALE*/ ctx[3][/*section*/ ctx[0].title] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (17:2) {#if (section.type==='component' && section.component && COMPONENTS.contains(section.component)) }
	function create_if_block_5$1(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ id: /*section*/ ctx[0].id }, /*section*/ ctx[0].props];
		var switch_value = COMPONENTS$2.get(/*section*/ ctx[0].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*section*/ 1) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [{ id: /*section*/ ctx[0].id }, get_spread_object(/*section*/ ctx[0].props)]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*section*/ 1 && switch_value !== (switch_value = COMPONENTS$2.get(/*section*/ ctx[0].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*section*/ 1)
					? get_spread_update(switch_instance_spread_levels, [
							{ id: /*section*/ ctx[0].id },
							get_spread_object(/*section*/ ctx[0].props)
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (26:2) {#if section.tag }
	function create_if_block_4$2(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*section*/ ctx[0].id }, /*section*/ ctx[0].tag];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*section*/ 1)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*section*/ ctx[0].id }, get_spread_object(/*section*/ ctx[0].tag)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (29:2) {#if section.indicator }
	function create_if_block_3$4(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*section*/ ctx[0].id }, /*section*/ ctx[0].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*section*/ 1)
				? get_spread_update(uiindicator_spread_levels, [
						{ id: /*section*/ ctx[0].id },
						get_spread_object(/*section*/ ctx[0].indicator)
					])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	// (35:0) {#if sectionItems.length }
	function create_if_block$7(ctx) {
		let uisidemenuitems;
		let current;

		uisidemenuitems = new Ui_items({
				props: {
					root: /*root*/ ctx[1],
					items: /*sectionItems*/ ctx[2]
				}
			});

		uisidemenuitems.$on("navigate", /*navigate_handler*/ ctx[5]);

		return {
			c() {
				create_component(uisidemenuitems.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenuitems, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uisidemenuitems_changes = {};
				if (dirty & /*root*/ 2) uisidemenuitems_changes.root = /*root*/ ctx[1];
				if (dirty & /*sectionItems*/ 4) uisidemenuitems_changes.items = /*sectionItems*/ ctx[2];
				uisidemenuitems.$set(uisidemenuitems_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenuitems.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenuitems.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenuitems, detaching);
			}
		};
	}

	function create_fragment$9(ctx) {
		let t;
		let if_block1_anchor;
		let current;
		let if_block0 = /*section*/ ctx[0] && create_if_block_1$6(ctx);
		let if_block1 = /*sectionItems*/ ctx[2].length && create_if_block$7(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*section*/ ctx[0]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*section*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$6(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*sectionItems*/ ctx[2].length) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*sectionItems*/ 4) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$7(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	function instance$9($$self, $$props, $$invalidate) {
		let sectionItems;
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(3, $LOCALE = $$value));
		let { section } = $$props;
		let { items = [] } = $$props;
		let { root = '' } = $$props;

		function navigate_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('section' in $$props) $$invalidate(0, section = $$props.section);
			if ('items' in $$props) $$invalidate(4, items = $$props.items);
			if ('root' in $$props) $$invalidate(1, root = $$props.root);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*items, section*/ 17) {
				$$invalidate(2, sectionItems = items.filter(item => section.id === item.section));
			}
		};

		return [section, root, sectionItems, $LOCALE, items, navigate_handler];
	}

	let Ui_section$1 = class Ui_section extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$9, create_fragment$9, safe_not_equal, { section: 0, items: 4, root: 1 });
		}
	};

	/* node_modules/not-bulma/src/frame/components/navigation/side/ui.side.menu.svelte generated by Svelte v4.2.19 */

	function get_each_context$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	// (16:0) {#each sections as section}
	function create_each_block$2(ctx) {
		let uisidemenusection;
		let current;

		uisidemenusection = new Ui_section$1({
				props: {
					section: /*section*/ ctx[5],
					items: /*items*/ ctx[1],
					root: /*root*/ ctx[0]
				}
			});

		uisidemenusection.$on("navigate", /*onClick*/ ctx[3]);

		return {
			c() {
				create_component(uisidemenusection.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uisidemenusection, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uisidemenusection_changes = {};
				if (dirty & /*sections*/ 4) uisidemenusection_changes.section = /*section*/ ctx[5];
				if (dirty & /*items*/ 2) uisidemenusection_changes.items = /*items*/ ctx[1];
				if (dirty & /*root*/ 1) uisidemenusection_changes.root = /*root*/ ctx[0];
				uisidemenusection.$set(uisidemenusection_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uisidemenusection.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uisidemenusection.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uisidemenusection, detaching);
			}
		};
	}

	function create_fragment$8(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*sections*/ ctx[2]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*sections, items, root, onClick*/ 15) {
					each_value = ensure_array_like(/*sections*/ ctx[2]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$2(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$2(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$8($$self, $$props, $$invalidate) {
		let { root = '' } = $$props;
		let { items = [] } = $$props;
		let { sections = [] } = $$props;
		let { navigate = null } = $$props;

		function onClick(ev) {
			if (typeof navigate === 'function') {
				navigate(ev.detail);
			}
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('items' in $$props) $$invalidate(1, items = $$props.items);
			if ('sections' in $$props) $$invalidate(2, sections = $$props.sections);
			if ('navigate' in $$props) $$invalidate(4, navigate = $$props.navigate);
		};

		return [root, items, sections, onClick, navigate];
	}

	class Ui_side_menu extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$8, create_fragment$8, safe_not_equal, {
				root: 0,
				items: 1,
				sections: 2,
				navigate: 4
			});
		}
	}

	const TYPE$1 = "side";

	let notSideMenu$1 = class notSideMenu extends Menu {
	    static nav;
	    static main;
	    static aside;

	    static DEFAULT = {
	        section: "any",
	        sectionTitle: "Меню",
	        priority: 0,
	        open: true,
	    };

	    static options = {
	        type: TYPE$1,
	        items: [],
	        sections: [],
	        targetSelector: `#${TYPE$1}-menu`,
	        toggleSelector: `.${TYPE$1}-menu-toggle`,
	        root: "/",
	        open: true,
	        navigate: (urls) => {
	            if (this.isTouch()) {
	                this.hide();
	                this.app.emit("top-navbar-burger:update", { closed: true });
	            }
	            if (!this.isDirectNavigation() && this.app) {
	                let func = this.app.getWorking("router");
	                if (func) {
	                    return func.navigate(urls.short);
	                }
	            }
	            document.location.assign(urls.full);
	        },
	    };

	    static render(app) {
	        if (app) {
	            this.setApp(app);
	        }
	        this.prepareData();
	        if (!this.menu) {
	            this.createUI();
	        }
	    }

	    static update() {
	        if (this.menu) {
	            this.menu.$destroy();
	            this.createUI();
	        }
	    }

	    static createUI() {
	        let target = document.querySelector(this.getOptions().targetSelector);
	        if (!target) {
	            return;
	        }
	        this.menu = new Ui_side_menu({
	            target,
	            props: {
	                items: this.items,
	                sections: this.sections,
	                root: this.getOptions().root,
	                navigate: this.getOptions().navigate,
	            },
	        });
	        this.initSizeResponse();

	        this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	        this.bindToggle();
	    }

	    static itemIsActive(itemURL) {
	        return (this.location + "/").indexOf(itemURL + "/") > -1;
	    }

	    static updateMenu() {
	        Array.from(
	            document.querySelectorAll(this.getOptions().targetSelector + " a")
	        ).forEach((item) => {
	            if (this.itemIsActive(item.getAttribute("href"))) {
	                item.classList.add("is-active");
	            } else {
	                item.classList.remove("is-active");
	            }
	        });
	    }

	    static updateMenuActiveItem() {
	        let url = window.location.toString(),
	            lastLocation = this.location;
	        if (lastLocation) {
	            if (url !== lastLocation) {
	                this.location = url;
	                this.updateMenu();
	            }
	        } else {
	            this.location = url;
	            this.updateMenu();
	        }
	    }

	    static initSizeResponse() {
	        this.nav = document.querySelector("nav.navbar");
	        this.aside = document.querySelector("aside");
	        this.main = document.querySelector("main");
	        this.resizeAsideAndMain(this.aside, this.main, this.nav);
	        this.resizeMain(this.main, this.aside);
	        window.addEventListener("resize", this.resizeMain.bind(this));
	        if (this.isTouch()) {
	            if (this.getOptions().open) {
	                this.show();
	            } else {
	                this.hide();
	            }
	        }
	    }

	    static resizeMain() {
	        if (this.isTouch()) {
	            if (this.aside.classList.contains("is-active")) {
	                this.main.style.display = "none";
	            } else {
	                this.main.style.display = "block";
	                this.main.style.marginLeft = "0px";
	            }
	        } else {
	            let rect = this.aside.getBoundingClientRect();
	            this.main.style.display = "block";
	            if (this.main.style.height === "0px") {
	                this.main.style.height = "auto";
	            }
	            this.main.style.marginLeft = rect.width + rect.left + "px";
	        }
	    }

	    static resizeAside() {
	        if (this.aside.style.display !== "none") {
	            let rect = this.nav.getBoundingClientRect();
	            this.aside.style.height = window.innerHeight - rect.height + "px";
	            this.aside.style.marginTop = rect.height + "px";
	        }
	    }

	    static resizeAsideAndMain() {
	        let rect = this.nav.getBoundingClientRect();
	        this.aside.style.height = window.innerHeight - rect.height + "px";
	        //this.aside.style.paddingTop = (rect.height) + 'px';
	        //this.main.style.marginTop = (rect.height) + 'px';
	    }

	    static bindToggle() {
	        let els = document.querySelectorAll(this.getOptions().toggleSelector);
	        Array.from(els).forEach((el) => {
	            el.removeEventListener("click", this.toggle.bind(this));
	            el.addEventListener("click", this.toggle.bind(this));
	        });
	    }

	    static toggle(e) {
	        e && e.preventDefault();
	        if (this.aside) {
	            if (this.isTouch()) {
	                this.aside.classList.toggle("is-active");
	            } else {
	                this.aside.classList.toggle("is-closed");
	            }
	            this.resizeMain();
	        }
	        return false;
	    }

	    static hide(e) {
	        e && e.preventDefault();
	        if (this.aside) {
	            if (this.isTouch()) {
	                this.aside.classList.remove("is-active");
	            } else {
	                this.aside.classList.add("is-closed");
	            }
	            this.resizeMain();
	        }
	        return false;
	    }

	    static show(e) {
	        e && e.preventDefault();
	        if (this.aside) {
	            if (this.isTouch()) {
	                this.aside.classList.add("is-active");
	            } else {
	                this.aside.classList.remove("is-closed");
	            }
	            this.resizeMain();
	        }
	        return false;
	    }

	    static isOpen() {
	        if (this.aside) {
	            if (this.isTouch()) {
	                return this.aside.classList.contains("is-active");
	            } else {
	                return !this.aside.classList.contains("is-closed");
	            }
	        } else {
	            return true;
	        }
	    }
	};

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.brand.svelte generated by Svelte v4.2.19 */

	function create_if_block$6(ctx) {
		let html_tag;
		let raw_value = `<span class="navbar-item-brand-title">${/*title*/ ctx[1]}</span>` + "";
		let html_anchor;

		return {
			c() {
				html_tag = new HtmlTag(false);
				html_anchor = empty();
				html_tag.a = html_anchor;
			},
			m(target, anchor) {
				html_tag.m(raw_value, target, anchor);
				insert(target, html_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*title*/ 2 && raw_value !== (raw_value = `<span class="navbar-item-brand-title">${/*title*/ ctx[1]}</span>` + "")) html_tag.p(raw_value);
			},
			d(detaching) {
				if (detaching) {
					detach(html_anchor);
					html_tag.d();
				}
			}
		};
	}

	function create_fragment$7(ctx) {
		let a;
		let uiicon;
		let t;
		let current;
		const uiicon_spread_levels = [/*icon*/ ctx[2]];
		let uiicon_props = {};

		for (let i = 0; i < uiicon_spread_levels.length; i += 1) {
			uiicon_props = assign(uiicon_props, uiicon_spread_levels[i]);
		}

		uiicon = new Ui_icon({ props: uiicon_props });
		let if_block = /*title*/ ctx[1] && create_if_block$6(ctx);

		return {
			c() {
				a = element("a");
				create_component(uiicon.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				attr(a, "class", "navbar-item");
				attr(a, "href", /*url*/ ctx[0]);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				mount_component(uiicon, a, null);
				append(a, t);
				if (if_block) if_block.m(a, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const uiicon_changes = (dirty & /*icon*/ 4)
				? get_spread_update(uiicon_spread_levels, [get_spread_object(/*icon*/ ctx[2])])
				: {};

				uiicon.$set(uiicon_changes);

				if (/*title*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$6(ctx);
						if_block.c();
						if_block.m(a, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (!current || dirty & /*url*/ 1) {
					attr(a, "href", /*url*/ ctx[0]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiicon.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiicon.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				destroy_component(uiicon);
				if (if_block) if_block.d();
			}
		};
	}

	function instance$7($$self, $$props, $$invalidate) {
		let { url = "/" } = $$props;
		let { title = "" } = $$props;

		let { icon = {
			src: "https://via.placeholder.com/56x28",
			width: 28,
			height: 56
		} } = $$props;

		$$self.$$set = $$props => {
			if ('url' in $$props) $$invalidate(0, url = $$props.url);
			if ('title' in $$props) $$invalidate(1, title = $$props.title);
			if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		};

		return [url, title, icon];
	}

	class Ui_brand extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$7, create_fragment$7, safe_not_equal, { url: 0, title: 1, icon: 2 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.item.content.svelte generated by Svelte v4.2.19 */

	function create_else_block$4(ctx) {
		let t_value = /*$LOCALE*/ ctx[1][/*item*/ ctx[0].title] + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*$LOCALE, item*/ 3 && t_value !== (t_value = /*$LOCALE*/ ctx[1][/*item*/ ctx[0].title] + "")) set_data(t, t_value);
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (24:94) 
	function create_if_block_3$3(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;
		const switch_instance_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].props];
		var switch_value = COMPONENTS$2.get(/*item*/ ctx[0].component);

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*item*/ 1) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].props)]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, switch_instance_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*item*/ 1 && switch_value !== (switch_value = COMPONENTS$2.get(/*item*/ ctx[0].component))) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*item*/ 1)
					? get_spread_update(switch_instance_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].props)])
					: {};

					switch_instance.$set(switch_instance_changes);
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};
	}

	// (22:0) {#if item.icon}
	function create_if_block_2$3(ctx) {
		let uiicon;
		let current;
		const uiicon_spread_levels = [/*item*/ ctx[0].icon];
		let uiicon_props = {};

		for (let i = 0; i < uiicon_spread_levels.length; i += 1) {
			uiicon_props = assign(uiicon_props, uiicon_spread_levels[i]);
		}

		uiicon = new Ui_icon({ props: uiicon_props });

		return {
			c() {
				create_component(uiicon.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiicon, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiicon_changes = (dirty & /*item*/ 1)
				? get_spread_update(uiicon_spread_levels, [get_spread_object(/*item*/ ctx[0].icon)])
				: {};

				uiicon.$set(uiicon_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiicon.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiicon.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiicon, detaching);
			}
		};
	}

	// (34:0) {#if item.tag }
	function create_if_block_1$5(ctx) {
		let uitag;
		let current;

		const uitag_spread_levels = [
			{ top: true },
			{ right: true },
			{ size: "small" },
			{ id: /*item*/ ctx[0].id },
			/*item*/ ctx[0].tag
		];

		let uitag_props = {};

		for (let i = 0; i < uitag_spread_levels.length; i += 1) {
			uitag_props = assign(uitag_props, uitag_spread_levels[i]);
		}

		uitag = new Ui_tag({ props: uitag_props });

		return {
			c() {
				create_component(uitag.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uitag, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uitag_changes = (dirty & /*item*/ 1)
				? get_spread_update(uitag_spread_levels, [
						uitag_spread_levels[0],
						uitag_spread_levels[1],
						uitag_spread_levels[2],
						{ id: /*item*/ ctx[0].id },
						get_spread_object(/*item*/ ctx[0].tag)
					])
				: {};

				uitag.$set(uitag_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uitag.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uitag.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uitag, detaching);
			}
		};
	}

	// (38:0) {#if item.indicator }
	function create_if_block$5(ctx) {
		let uiindicator;
		let current;
		const uiindicator_spread_levels = [{ id: /*item*/ ctx[0].id }, /*item*/ ctx[0].indicator];
		let uiindicator_props = {};

		for (let i = 0; i < uiindicator_spread_levels.length; i += 1) {
			uiindicator_props = assign(uiindicator_props, uiindicator_spread_levels[i]);
		}

		uiindicator = new Ui_indicator({ props: uiindicator_props });

		return {
			c() {
				create_component(uiindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uiindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uiindicator_changes = (dirty & /*item*/ 1)
				? get_spread_update(uiindicator_spread_levels, [{ id: /*item*/ ctx[0].id }, get_spread_object(/*item*/ ctx[0].indicator)])
				: {};

				uiindicator.$set(uiindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uiindicator, detaching);
			}
		};
	}

	function create_fragment$6(ctx) {
		let show_if;
		let current_block_type_index;
		let if_block0;
		let t0;
		let t1;
		let if_block2_anchor;
		let current;
		const if_block_creators = [create_if_block_2$3, create_if_block_3$3, create_else_block$4];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (dirty & /*item*/ 1) show_if = null;
			if (/*item*/ ctx[0].icon) return 0;
			if (show_if == null) show_if = !!(/*item*/ ctx[0].type === 'component' && /*item*/ ctx[0].component && COMPONENTS$2.contains(/*item*/ ctx[0].component));
			if (show_if) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx, -1);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*item*/ ctx[0].tag && create_if_block_1$5(ctx);
		let if_block2 = /*item*/ ctx[0].indicator && create_if_block$5(ctx);

		return {
			c() {
				if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx, dirty);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}

				if (/*item*/ ctx[0].tag) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*item*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$5(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*item*/ ctx[0].indicator) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*item*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block$5(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(if_block2_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
			}
		};
	}

	function instance$6($$self, $$props, $$invalidate) {
		let $LOCALE;
		component_subscribe($$self, LOCALE, $$value => $$invalidate(1, $LOCALE = $$value));
		let { item } = $$props;

		$$self.$$set = $$props => {
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
		};

		return [item, $LOCALE];
	}

	class Ui_item_content extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$6, create_fragment$6, safe_not_equal, { item: 0 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.item.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$4(ctx) {
		let hr;
		let hr_class_value;

		return {
			c() {
				hr = element("hr");

				attr(hr, "class", hr_class_value = "navbar-divider " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + "");
			},
			m(target, anchor) {
				insert(target, hr, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*hidden*/ 4 && hr_class_value !== (hr_class_value = "navbar-divider " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + "")) {
					attr(hr, "class", hr_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(hr);
				}
			}
		};
	}

	// (31:0) {:else}
	function create_else_block$3(ctx) {
		let div;
		let uiitemcontent;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*item*/ ctx[1] } });

		return {
			c() {
				div = element("div");
				create_component(uiitemcontent.$$.fragment);

				attr(div, "class", div_class_value = "navbar-item " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + " " + /*item*/ ctx[1].classes + " " + /*classes*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uiitemcontent, div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*onClick*/ ctx[4]),
						listen(div, "keyup", /*onClick*/ ctx[4])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*item*/ 2) uiitemcontent_changes.item = /*item*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*hidden, item, classes*/ 14 && div_class_value !== (div_class_value = "navbar-item " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + " " + /*item*/ ctx[1].classes + " " + /*classes*/ ctx[3])) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uiitemcontent);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (20:0) {#if item.url}
	function create_if_block$4(ctx) {
		let a;
		let uiitemcontent;
		let a_class_value;
		let a_href_value;
		let a_data_href_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*item*/ ctx[1] } });

		return {
			c() {
				a = element("a");
				create_component(uiitemcontent.$$.fragment);

				attr(a, "class", a_class_value = "navbar-item " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + " " + /*item*/ ctx[1].classes + " " + /*classes*/ ctx[3] + "");

				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[1].url));
				attr(a, "data-href", a_data_href_value = /*item*/ ctx[1].url);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				mount_component(uiitemcontent, a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[4]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*item*/ 2) uiitemcontent_changes.item = /*item*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*hidden, item, classes*/ 14 && a_class_value !== (a_class_value = "navbar-item " + (/*hidden*/ ctx[2]
				? `is-hidden-${/*hidden*/ ctx[2]}`
				: '') + " " + /*item*/ ctx[1].classes + " " + /*classes*/ ctx[3] + "")) {
					attr(a, "class", a_class_value);
				}

				if (!current || dirty & /*root, item*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*item*/ ctx[1].url))) {
					attr(a, "href", a_href_value);
				}

				if (!current || dirty & /*item*/ 2 && a_data_href_value !== (a_data_href_value = /*item*/ ctx[1].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				destroy_component(uiitemcontent);
				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$5(ctx) {
		let t;
		let current_block_type_index;
		let if_block1;
		let if_block1_anchor;
		let current;
		let if_block0 = /*item*/ ctx[1].break && create_if_block_1$4(ctx);
		const if_block_creators = [create_if_block$4, create_else_block$3];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*item*/ ctx[1].url) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*item*/ ctx[1].break) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$4(ctx);
						if_block0.c();
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$5($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { root = "" } = $$props;
		let { item = {} } = $$props;
		let { hidden = "" } = $$props;
		let { classes = "" } = $$props;

		function onClick(event) {
			dispatch("click", { event, element: item });
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('item' in $$props) $$invalidate(1, item = $$props.item);
			if ('hidden' in $$props) $$invalidate(2, hidden = $$props.hidden);
			if ('classes' in $$props) $$invalidate(3, classes = $$props.classes);
		};

		return [root, item, hidden, classes, onClick];
	}

	class Ui_item extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$5, create_fragment$5, safe_not_equal, { root: 0, item: 1, hidden: 2, classes: 3 });
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.section.svelte generated by Svelte v4.2.19 */

	function get_each_context$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[10] = list[i];
		return child_ctx;
	}

	// (49:0) {:else}
	function create_else_block$2(ctx) {
		let div;
		let uiitemcontent;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*section*/ ctx[1] } });

		return {
			c() {
				div = element("div");
				create_component(uiitemcontent.$$.fragment);

				attr(div, "class", div_class_value = "navbar-item " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(uiitemcontent, div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen(div, "click", /*onClick*/ ctx[7]),
						listen(div, "keyup", /*onClick*/ ctx[7])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*section*/ 2) uiitemcontent_changes.item = /*section*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*hidden*/ 8 && div_class_value !== (div_class_value = "navbar-item " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "")) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(uiitemcontent);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (40:22) 
	function create_if_block_1$3(ctx) {
		let a;
		let uiitemcontent;
		let a_class_value;
		let a_href_value;
		let a_data_href_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*section*/ ctx[1] } });

		return {
			c() {
				a = element("a");
				create_component(uiitemcontent.$$.fragment);

				attr(a, "class", a_class_value = "navbar-item " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "");

				attr(a, "href", a_href_value = "" + (/*root*/ ctx[0] + /*section*/ ctx[1].url));
				attr(a, "data-href", a_data_href_value = /*section*/ ctx[1].url);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				mount_component(uiitemcontent, a, null);
				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[7]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*section*/ 2) uiitemcontent_changes.item = /*section*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*hidden*/ 8 && a_class_value !== (a_class_value = "navbar-item " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "")) {
					attr(a, "class", a_class_value);
				}

				if (!current || dirty & /*root, section*/ 3 && a_href_value !== (a_href_value = "" + (/*root*/ ctx[0] + /*section*/ ctx[1].url))) {
					attr(a, "href", a_href_value);
				}

				if (!current || dirty & /*section*/ 2 && a_data_href_value !== (a_data_href_value = /*section*/ ctx[1].url)) {
					attr(a, "data-href", a_data_href_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				destroy_component(uiitemcontent);
				mounted = false;
				dispose();
			}
		};
	}

	// (21:0) {#if items.length}
	function create_if_block$3(ctx) {
		let div1;
		let a;
		let uiitemcontent;
		let a_class_value;
		let t;
		let div0;
		let each_blocks = [];
		let each_1_lookup = new Map();
		let div0_class_value;
		let div1_class_value;
		let current;
		let mounted;
		let dispose;
		uiitemcontent = new Ui_item_content({ props: { item: /*section*/ ctx[1] } });
		let each_value = ensure_array_like(/*items*/ ctx[2]);
		const get_key = ctx => /*item*/ ctx[10].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context$1(ctx, each_value, i);
			let key = get_key(child_ctx);
			each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
		}

		return {
			c() {
				div1 = element("div");
				a = element("a");
				create_component(uiitemcontent.$$.fragment);
				t = space();
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(a, "href", "");
				attr(a, "class", a_class_value = "navbar-link " + (/*arrowless*/ ctx[5] ? 'is-arrowless' : ''));
				attr(div0, "class", div0_class_value = "navbar-dropdown " + (/*right*/ ctx[6] ? 'is-right' : ''));

				attr(div1, "class", div1_class_value = "navbar-item has-dropdown " + (/*hoverable*/ ctx[4] ? 'is-hoverable' : '') + " " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, a);
				mount_component(uiitemcontent, a, null);
				append(div1, t);
				append(div1, div0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				current = true;

				if (!mounted) {
					dispose = listen(a, "click", /*onClick*/ ctx[7]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				const uiitemcontent_changes = {};
				if (dirty & /*section*/ 2) uiitemcontent_changes.item = /*section*/ ctx[1];
				uiitemcontent.$set(uiitemcontent_changes);

				if (!current || dirty & /*arrowless*/ 32 && a_class_value !== (a_class_value = "navbar-link " + (/*arrowless*/ ctx[5] ? 'is-arrowless' : ''))) {
					attr(a, "class", a_class_value);
				}

				if (dirty & /*root, items*/ 5) {
					each_value = ensure_array_like(/*items*/ ctx[2]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
					check_outros();
				}

				if (!current || dirty & /*right*/ 64 && div0_class_value !== (div0_class_value = "navbar-dropdown " + (/*right*/ ctx[6] ? 'is-right' : ''))) {
					attr(div0, "class", div0_class_value);
				}

				if (!current || dirty & /*hoverable, hidden*/ 24 && div1_class_value !== (div1_class_value = "navbar-item has-dropdown " + (/*hoverable*/ ctx[4] ? 'is-hoverable' : '') + " " + (/*hidden*/ ctx[3]
				? `is-hidden-${/*hidden*/ ctx[3]}`
				: '') + "")) {
					attr(div1, "class", div1_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(uiitemcontent.$$.fragment, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(uiitemcontent.$$.fragment, local);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				destroy_component(uiitemcontent);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (35:12) {#each items as item (item.id)}
	function create_each_block$1(key_1, ctx) {
		let first;
		let uiitem;
		let current;

		uiitem = new Ui_item({
				props: {
					root: /*root*/ ctx[0],
					item: /*item*/ ctx[10]
				}
			});

		uiitem.$on("click", /*click_handler*/ ctx[8]);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				create_component(uiitem.$$.fragment);
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				mount_component(uiitem, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const uiitem_changes = {};
				if (dirty & /*root*/ 1) uiitem_changes.root = /*root*/ ctx[0];
				if (dirty & /*items*/ 4) uiitem_changes.item = /*item*/ ctx[10];
				uiitem.$set(uiitem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uiitem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uiitem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
				}

				destroy_component(uiitem, detaching);
			}
		};
	}

	function create_fragment$4(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$3, create_if_block_1$3, create_else_block$2];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*items*/ ctx[2].length) return 0;
			if (/*section*/ ctx[1].url) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$4($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { root = "" } = $$props;
		let { section = {} } = $$props;
		let { items = [] } = $$props;
		let { hidden = "" } = $$props;
		let { hoverable = true } = $$props;
		let { arrowless = false } = $$props;
		let { right = false } = $$props;

		function onClick(event) {
			dispatch("click", { event, element: section });
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$props => {
			if ('root' in $$props) $$invalidate(0, root = $$props.root);
			if ('section' in $$props) $$invalidate(1, section = $$props.section);
			if ('items' in $$props) $$invalidate(2, items = $$props.items);
			if ('hidden' in $$props) $$invalidate(3, hidden = $$props.hidden);
			if ('hoverable' in $$props) $$invalidate(4, hoverable = $$props.hoverable);
			if ('arrowless' in $$props) $$invalidate(5, arrowless = $$props.arrowless);
			if ('right' in $$props) $$invalidate(6, right = $$props.right);
		};

		return [
			root,
			section,
			items,
			hidden,
			hoverable,
			arrowless,
			right,
			onClick,
			click_handler
		];
	}

	class Ui_section extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$4, create_fragment$4, safe_not_equal, {
				root: 0,
				section: 1,
				items: 2,
				hidden: 3,
				hoverable: 4,
				arrowless: 5,
				right: 6
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.burger.svelte generated by Svelte v4.2.19 */

	function create_fragment$3(ctx) {
		let a;
		let span0;
		let t0;
		let span1;
		let t1;
		let span2;
		let a_class_value;
		let mounted;
		let dispose;

		return {
			c() {
				a = element("a");
				span0 = element("span");
				t0 = space();
				span1 = element("span");
				t1 = space();
				span2 = element("span");
				attr(span0, "aria-hidden", "true");
				attr(span1, "aria-hidden", "true");
				attr(span2, "aria-hidden", "true");
				attr(a, "href", "");
				attr(a, "role", "button");
				attr(a, "class", a_class_value = "navbar-burger " + (/*closed*/ ctx[0] ? '' : 'is-active'));
				attr(a, "aria-label", "menu");
				attr(a, "aria-expanded", "false");
				attr(a, "data-target", "navbar");
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, span0);
				append(a, t0);
				append(a, span1);
				append(a, t1);
				append(a, span2);

				if (!mounted) {
					dispose = listen(a, "click", /*toggle*/ ctx[1]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*closed*/ 1 && a_class_value !== (a_class_value = "navbar-burger " + (/*closed*/ ctx[0] ? '' : 'is-active'))) {
					attr(a, "class", a_class_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				mounted = false;
				dispose();
			}
		};
	}

	const COMPONENT_NAME = "top-navbar-burger";

	function getStandartUpdateEventName() {
		return COMPONENT_NAME + ":update";
	}

	function instance$3($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { events = {} } = $$props;
		let { register = notCommon$3.registerWidgetEvents.bind(notCommon$3) } = $$props;
		let { closed = true } = $$props;

		function toggle(e) {
			e.preventDefault();
			$$invalidate(0, closed = !closed);
			dispatch("toggle", { closed });
			return false;
		}

		let { onUpdate = data => {
			$$invalidate(0, closed = data.closed);
		} } = $$props;

		onMount(() => {
			if (!notCommon$3.objHas(events, getStandartUpdateEventName())) {
				$$invalidate(2, events[getStandartUpdateEventName()] = onUpdate, events);
			}

			register(events);
		});

		$$self.$$set = $$props => {
			if ('events' in $$props) $$invalidate(2, events = $$props.events);
			if ('register' in $$props) $$invalidate(3, register = $$props.register);
			if ('closed' in $$props) $$invalidate(0, closed = $$props.closed);
			if ('onUpdate' in $$props) $$invalidate(4, onUpdate = $$props.onUpdate);
		};

		return [closed, toggle, events, register, onUpdate];
	}

	class Ui_burger extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$3, create_fragment$3, safe_not_equal, {
				events: 2,
				register: 3,
				closed: 0,
				onUpdate: 4
			});
		}
	}

	/* node_modules/not-bulma/src/frame/components/navigation/top/ui.top.svelte generated by Svelte v4.2.19 */

	function get_each_context(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[13] = list[i];
		return child_ctx;
	}

	function get_each_context_1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[16] = list[i];
		return child_ctx;
	}

	function get_each_context_2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[16] = list[i];
		return child_ctx;
	}

	function get_each_context_3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[13] = list[i];
		return child_ctx;
	}

	// (63:4) {#if brand}
	function create_if_block_5(ctx) {
		let uibrand;
		let current;
		const uibrand_spread_levels = [/*brand*/ ctx[3]];
		let uibrand_props = {};

		for (let i = 0; i < uibrand_spread_levels.length; i += 1) {
			uibrand_props = assign(uibrand_props, uibrand_spread_levels[i]);
		}

		uibrand = new Ui_brand({ props: uibrand_props });

		return {
			c() {
				create_component(uibrand.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uibrand, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uibrand_changes = (dirty & /*brand*/ 8)
				? get_spread_update(uibrand_spread_levels, [get_spread_object(/*brand*/ ctx[3])])
				: {};

				uibrand.$set(uibrand_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uibrand.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uibrand.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uibrand, detaching);
			}
		};
	}

	// (67:8) {#if section.showOnTouch}
	function create_if_block_4$1(ctx) {
		let uinavbaritem;
		let current;

		uinavbaritem = new Ui_item({
				props: {
					hidden: "desktop",
					item: /*section*/ ctx[13],
					root: /*root*/ ctx[2]
				}
			});

		uinavbaritem.$on("click", /*onClick*/ ctx[8]);

		return {
			c() {
				create_component(uinavbaritem.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbaritem, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinavbaritem_changes = {};
				if (dirty & /*sections*/ 1) uinavbaritem_changes.item = /*section*/ ctx[13];
				if (dirty & /*root*/ 4) uinavbaritem_changes.root = /*root*/ ctx[2];
				uinavbaritem.$set(uinavbaritem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinavbaritem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbaritem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbaritem, detaching);
			}
		};
	}

	// (66:4) {#each sections as section (section.id)}
	function create_each_block_3(key_1, ctx) {
		let first;
		let if_block_anchor;
		let current;
		let if_block = /*section*/ ctx[13].showOnTouch && create_if_block_4$1(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (/*section*/ ctx[13].showOnTouch) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*sections*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_4$1(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (77:8) {#if item.showOnTouch}
	function create_if_block_3$2(ctx) {
		let uinavbaritem;
		let current;

		uinavbaritem = new Ui_item({
				props: {
					hidden: "desktop",
					item: /*item*/ ctx[16],
					root: /*root*/ ctx[2]
				}
			});

		uinavbaritem.$on("click", /*onClick*/ ctx[8]);

		return {
			c() {
				create_component(uinavbaritem.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbaritem, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinavbaritem_changes = {};
				if (dirty & /*items*/ 2) uinavbaritem_changes.item = /*item*/ ctx[16];
				if (dirty & /*root*/ 4) uinavbaritem_changes.root = /*root*/ ctx[2];
				uinavbaritem.$set(uinavbaritem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinavbaritem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbaritem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbaritem, detaching);
			}
		};
	}

	// (76:4) {#each items as item (item.id)}
	function create_each_block_2(key_1, ctx) {
		let first;
		let if_block_anchor;
		let current;
		let if_block = /*item*/ ctx[16].showOnTouch && create_if_block_3$2(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (/*item*/ ctx[16].showOnTouch) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*items*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$2(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (81:4) {#if showBurger}
	function create_if_block_2$2(ctx) {
		let uinavbarburger;
		let current;
		uinavbarburger = new Ui_burger({});
		uinavbarburger.$on("toggle", /*toggleBurger*/ ctx[9]);

		return {
			c() {
				create_component(uinavbarburger.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbarburger, target, anchor);
				current = true;
			},
			p: noop$1,
			i(local) {
				if (current) return;
				transition_in(uinavbarburger.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbarburger.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbarburger, detaching);
			}
		};
	}

	// (88:12) {#if item.place === "start"}
	function create_if_block_1$2(ctx) {
		let uinavbaritem;
		let current;

		uinavbaritem = new Ui_item({
				props: { hidden: "touch", item: /*item*/ ctx[16] }
			});

		uinavbaritem.$on("click", /*onClick*/ ctx[8]);

		return {
			c() {
				create_component(uinavbaritem.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbaritem, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinavbaritem_changes = {};
				if (dirty & /*items*/ 2) uinavbaritem_changes.item = /*item*/ ctx[16];
				uinavbaritem.$set(uinavbaritem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinavbaritem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbaritem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbaritem, detaching);
			}
		};
	}

	// (87:8) {#each items as item}
	function create_each_block_1(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*item*/ ctx[16].place === "start" && create_if_block_1$2(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*item*/ ctx[16].place === "start") {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*items*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_1$2(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (95:12) {#if (sectionsItemsCount[section.id] || section.indicator || section.tag) && section.place == "end"}
	function create_if_block$2(ctx) {
		let uinavbarsection;
		let current;

		uinavbarsection = new Ui_section({
				props: {
					right: true,
					hidden: /*section*/ ctx[13].hidden,
					root: /*root*/ ctx[2],
					section: /*section*/ ctx[13],
					items: /*sectionsItems*/ ctx[7][/*section*/ ctx[13].id]
				}
			});

		uinavbarsection.$on("click", /*onClick*/ ctx[8]);

		return {
			c() {
				create_component(uinavbarsection.$$.fragment);
			},
			m(target, anchor) {
				mount_component(uinavbarsection, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const uinavbarsection_changes = {};
				if (dirty & /*sections*/ 1) uinavbarsection_changes.hidden = /*section*/ ctx[13].hidden;
				if (dirty & /*root*/ 4) uinavbarsection_changes.root = /*root*/ ctx[2];
				if (dirty & /*sections*/ 1) uinavbarsection_changes.section = /*section*/ ctx[13];
				if (dirty & /*sectionsItems, sections*/ 129) uinavbarsection_changes.items = /*sectionsItems*/ ctx[7][/*section*/ ctx[13].id];
				uinavbarsection.$set(uinavbarsection_changes);
			},
			i(local) {
				if (current) return;
				transition_in(uinavbarsection.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(uinavbarsection.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(uinavbarsection, detaching);
			}
		};
	}

	// (94:8) {#each sections as section (section.id)}
	function create_each_block(key_1, ctx) {
		let first;
		let if_block_anchor;
		let current;
		let if_block = (/*sectionsItemsCount*/ ctx[6][/*section*/ ctx[13].id] || /*section*/ ctx[13].indicator || /*section*/ ctx[13].tag) && /*section*/ ctx[13].place == "end" && create_if_block$2(ctx);

		return {
			key: key_1,
			first: null,
			c() {
				first = empty();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				this.first = first;
			},
			m(target, anchor) {
				insert(target, first, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if ((/*sectionsItemsCount*/ ctx[6][/*section*/ ctx[13].id] || /*section*/ ctx[13].indicator || /*section*/ ctx[13].tag) && /*section*/ ctx[13].place == "end") {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*sectionsItemsCount, sections*/ 65) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$2(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(first);
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function create_fragment$2(ctx) {
		let div0;
		let t0;
		let each_blocks_3 = [];
		let each0_lookup = new Map();
		let t1;
		let each_blocks_2 = [];
		let each1_lookup = new Map();
		let t2;
		let t3;
		let div3;
		let div1;
		let t4;
		let div2;
		let each_blocks = [];
		let each3_lookup = new Map();
		let div3_class_value;
		let current;
		let if_block0 = /*brand*/ ctx[3] && create_if_block_5(ctx);
		let each_value_3 = ensure_array_like(/*sections*/ ctx[0]);
		const get_key = ctx => /*section*/ ctx[13].id;

		for (let i = 0; i < each_value_3.length; i += 1) {
			let child_ctx = get_each_context_3(ctx, each_value_3, i);
			let key = get_key(child_ctx);
			each0_lookup.set(key, each_blocks_3[i] = create_each_block_3(key, child_ctx));
		}

		let each_value_2 = ensure_array_like(/*items*/ ctx[1]);
		const get_key_1 = ctx => /*item*/ ctx[16].id;

		for (let i = 0; i < each_value_2.length; i += 1) {
			let child_ctx = get_each_context_2(ctx, each_value_2, i);
			let key = get_key_1(child_ctx);
			each1_lookup.set(key, each_blocks_2[i] = create_each_block_2(key, child_ctx));
		}

		let if_block1 = /*showBurger*/ ctx[4] && create_if_block_2$2(ctx);
		let each_value_1 = ensure_array_like(/*items*/ ctx[1]);
		let each_blocks_1 = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
			each_blocks_1[i] = null;
		});

		let each_value = ensure_array_like(/*sections*/ ctx[0]);
		const get_key_2 = ctx => /*section*/ ctx[13].id;

		for (let i = 0; i < each_value.length; i += 1) {
			let child_ctx = get_each_context(ctx, each_value, i);
			let key = get_key_2(child_ctx);
			each3_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
		}

		return {
			c() {
				div0 = element("div");
				if (if_block0) if_block0.c();
				t0 = space();

				for (let i = 0; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].c();
				}

				t1 = space();

				for (let i = 0; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].c();
				}

				t2 = space();
				if (if_block1) if_block1.c();
				t3 = space();
				div3 = element("div");
				div1 = element("div");

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].c();
				}

				t4 = space();
				div2 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div0, "class", "navbar-brand");
				attr(div1, "class", "navbar-start");
				attr(div2, "class", "navbar-end");
				attr(div3, "id", "navbar");
				attr(div3, "class", div3_class_value = "navbar-menu " + (/*menuClosed*/ ctx[5] ? '' : 'is-active'));
			},
			m(target, anchor) {
				insert(target, div0, anchor);
				if (if_block0) if_block0.m(div0, null);
				append(div0, t0);

				for (let i = 0; i < each_blocks_3.length; i += 1) {
					if (each_blocks_3[i]) {
						each_blocks_3[i].m(div0, null);
					}
				}

				append(div0, t1);

				for (let i = 0; i < each_blocks_2.length; i += 1) {
					if (each_blocks_2[i]) {
						each_blocks_2[i].m(div0, null);
					}
				}

				append(div0, t2);
				if (if_block1) if_block1.m(div0, null);
				insert(target, t3, anchor);
				insert(target, div3, anchor);
				append(div3, div1);

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					if (each_blocks_1[i]) {
						each_blocks_1[i].m(div1, null);
					}
				}

				append(div3, t4);
				append(div3, div2);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div2, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (/*brand*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*brand*/ 8) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_5(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div0, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (dirty & /*sections, root, onClick*/ 261) {
					each_value_3 = ensure_array_like(/*sections*/ ctx[0]);
					group_outros();
					each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx, each_value_3, each0_lookup, div0, outro_and_destroy_block, create_each_block_3, t1, get_each_context_3);
					check_outros();
				}

				if (dirty & /*items, root, onClick*/ 262) {
					each_value_2 = ensure_array_like(/*items*/ ctx[1]);
					group_outros();
					each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, div0, outro_and_destroy_block, create_each_block_2, t2, get_each_context_2);
					check_outros();
				}

				if (/*showBurger*/ ctx[4]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*showBurger*/ 16) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$2(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div0, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (dirty & /*items, onClick*/ 258) {
					each_value_1 = ensure_array_like(/*items*/ ctx[1]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks_1[i]) {
							each_blocks_1[i].p(child_ctx, dirty);
							transition_in(each_blocks_1[i], 1);
						} else {
							each_blocks_1[i] = create_each_block_1(child_ctx);
							each_blocks_1[i].c();
							transition_in(each_blocks_1[i], 1);
							each_blocks_1[i].m(div1, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (dirty & /*sections, root, sectionsItems, onClick, sectionsItemsCount*/ 453) {
					each_value = ensure_array_like(/*sections*/ ctx[0]);
					group_outros();
					each_blocks = update_keyed_each(each_blocks, dirty, get_key_2, 1, ctx, each_value, each3_lookup, div2, outro_and_destroy_block, create_each_block, null, get_each_context);
					check_outros();
				}

				if (!current || dirty & /*menuClosed*/ 32 && div3_class_value !== (div3_class_value = "navbar-menu " + (/*menuClosed*/ ctx[5] ? '' : 'is-active'))) {
					attr(div3, "class", div3_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);

				for (let i = 0; i < each_value_3.length; i += 1) {
					transition_in(each_blocks_3[i]);
				}

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks_2[i]);
				}

				transition_in(if_block1);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks_1[i]);
				}

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(if_block0);

				for (let i = 0; i < each_blocks_3.length; i += 1) {
					transition_out(each_blocks_3[i]);
				}

				for (let i = 0; i < each_blocks_2.length; i += 1) {
					transition_out(each_blocks_2[i]);
				}

				transition_out(if_block1);
				each_blocks_1 = each_blocks_1.filter(Boolean);

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					transition_out(each_blocks_1[i]);
				}

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div0);
					detach(t3);
					detach(div3);
				}

				if (if_block0) if_block0.d();

				for (let i = 0; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].d();
				}

				for (let i = 0; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].d();
				}

				if (if_block1) if_block1.d();
				destroy_each(each_blocks_1, detaching);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].d();
				}
			}
		};
	}

	function instance$2($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { sections = [] } = $$props;
		let { items = [] } = $$props;
		let { root = "" } = $$props;
		let { navigate = null } = $$props;
		let { brand = false } = $$props;
		let { showBurger = true } = $$props;
		let { burgerControlsSidemenu = true } = $$props;
		let menuClosed = true;

		function onClick({ detail }) {
			let { event, element } = detail;

			if (Object.hasOwn(element, "action")) {
				return element.action(event, element);
			}

			event.preventDefault();

			if (typeof navigate === "function") {
				navigate({
					full: event.currentTarget.getAttribute("href"),
					short: event.currentTarget.dataset.href
				});
			}

			return false;
		}

		let sectionsItemsCount = {};
		let sectionsItems = {};

		beforeUpdate(() => {
			for (let section of sections) {
				$$invalidate(7, sectionsItems[section.id] = items.filter(t => t.section === section.id), sectionsItems);
				$$invalidate(6, sectionsItemsCount[section.id] = items.filter(t => t.section === section.id).length, sectionsItemsCount);
			}
		});

		function toggleBurger({ detail }) {
			if (burgerControlsSidemenu) {
				notSideMenu$1.toggle();
			} else {
				dispatch("toggleBurger", detail);
				$$invalidate(5, menuClosed = detail.closed);
			}
		}

		$$self.$$set = $$props => {
			if ('sections' in $$props) $$invalidate(0, sections = $$props.sections);
			if ('items' in $$props) $$invalidate(1, items = $$props.items);
			if ('root' in $$props) $$invalidate(2, root = $$props.root);
			if ('navigate' in $$props) $$invalidate(10, navigate = $$props.navigate);
			if ('brand' in $$props) $$invalidate(3, brand = $$props.brand);
			if ('showBurger' in $$props) $$invalidate(4, showBurger = $$props.showBurger);
			if ('burgerControlsSidemenu' in $$props) $$invalidate(11, burgerControlsSidemenu = $$props.burgerControlsSidemenu);
		};

		return [
			sections,
			items,
			root,
			brand,
			showBurger,
			menuClosed,
			sectionsItemsCount,
			sectionsItems,
			onClick,
			toggleBurger,
			navigate,
			burgerControlsSidemenu
		];
	}

	class Ui_top extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$2, create_fragment$2, safe_not_equal, {
				sections: 0,
				items: 1,
				root: 2,
				navigate: 10,
				brand: 3,
				showBurger: 4,
				burgerControlsSidemenu: 11
			});
		}
	}

	const TYPE = 'top';

	let notTopMenu$3 = class notTopMenu extends Menu{
	  static DEFAULT = {
	    section: 'any',
	    sectionTitle: 'Меню',
	    priority: 0,
	    //link, button, dropdown, component
	    type:       'link',
	    place:      'main'
	  };

	  static options = {
	    brand:     false,
	    type:     TYPE,
	    items:     [],
	    sections: [],
	    targetSelector: `#${TYPE}-menu`,
	    root: '/',
	    directNavigation: false,
	    navigate: (urls) => {
	      this.hide();
	      if (!(this.isDirectNavigation()) && this.app) {
	        let func = this.app.getWorking('router');
	        if (func) {
	          return func.navigate(urls.short);
	        }
	      }
	      document.location.assign(urls.full);
	    }
	  };

	  static render(app){
	    if(app){
	      this.setApp(app);
	    }
	    this.prepareData();
	    if (!this.menu) {
	      let target = document.querySelector(this.getOptions().targetSelector);
	      if (!target){return;}
	      this.menu = new Ui_top({
	        target,
	        props:{
	          brand:         this.getOptions().brand,
	          items:        this.items,
	          sections:      this.sections,
	          root:         this.getOptions().root,
	          navigate:      this.getOptions().navigate
	        }
	      });
	      this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	    }
	  }

	  static updateMenu(url){
	    Array.from(document.querySelectorAll(this.getOptions().targetSelector + ' aside.menu a')).forEach((item) => {
	      if( (item.href == url) || (url.href && url.href.indexOf(item.href) == 0)){
	        item.classList.add('is-active');
	      }else {
	        item.classList.remove('is-active');
	      }
	    });
	  }

	  static updateMenuActiveItem(){
	    let url = window.location.toString(),  lastLocation = this.location;
	    if(lastLocation){
	      if ( url !== lastLocation ){
	        this.location = url;
	        this.updateMenu(url);
	      }
	    }else {
	      this.location = url;
	      this.updateMenu(url);
	    }
	  }

	  static toggle(){
	    let el = document.querySelector(this.getOptions().targetSelector);
	    el.classList.toggle('is-active');
	  }

	  static hide(){
	    let el = document.querySelector(this.getOptions().targetSelector);
	    el.classList.remove('is-active');
	  }

	  static setBurgerState(menuClosed){
	    this.menu.$set({
	      menuClosed
	    });
	  }

	};

	const DEFAULT_TRASFORMER = (res) => {
	    return Object.hasOwn(res, "status") && Object.hasOwn(res, "result")
	        ? res.result
	        : res;
	};

	var create_crud_action_ui_view = ({ ACTION, TITLE, UIConstructor, dataProvider, goBack }) => {
	    return class {
	        static async run(controller, params) {
	            try {
	                controller.setBreadcrumbs([
	                    {
	                        title: `Просмотр "${TITLE}"`,
	                    },
	                ]);
	                await controller.preloadVariants(ACTION);
	                if (controller.ui[ACTION]) {
	                    return;
	                } else {
	                    controller.$destroyUI();
	                }
	                let data = {};
	                if (dataProvider) {
	                    if (notCommon$3.isFunc(dataProvider)) {
	                        if (notCommon$3.isAsync(dataProvider)) {
	                            data = await dataProvider(params);
	                        } else {
	                            data = dataProvider(params);
	                        }
	                    } else {
	                        data = { ...dataProvider };
	                    }
	                }
	                const resultTransformer = controller.getOptions(
	                    `${ACTION}.transformer`,
	                    DEFAULT_TRASFORMER
	                );
	                controller.ui[ACTION] = new UIConstructor({
	                    target: controller.getContainerInnerElement(),
	                    props: { params, ...resultTransformer(data) },
	                });
	                controller.emit(`after:render:${ACTION}`);
	                if (goBack && notCommon$3.isFunc(goBack)) {
	                    controller.ui[ACTION].on("reject", () => goBack());
	                }
	            } catch (e) {
	                controller.report(e);
	                controller.showErrorMessage(e);
	            }
	        }
	    };
	};

	const PRELOADABLE = ['create','update','list','delete','details'];

	class CRUDVariantsPreloader{
	  static async preload(controller, type = 'list'){
	    try{
	      if (!PRELOADABLE.includes(type)) { return; }
	      let preload = controller.getOptions(`${type}.preload`, {});
	      if(Object.keys(preload).length == 0){
	        preload = controller.getOptions(`preload`, {});
	      }
	      if(Object.keys(preload).length > 0){
	        let libProps = Object.keys(preload);
	        let proms = [];
	        libProps.forEach((prop)=>{
	          let modelName = notCommon$3.lowerFirstLetter(preload[prop]);
	          let Model = controller.make[modelName]({});
	          proms.push(Model.$listAll());
	        });
	        let results = await Promise.all(proms);
	        for(let i = 0; i < libProps.length; i++){
	          const propName = libProps[i];
	          if(Array.isArray(results[i])){
	            const variants = results[i].map(item => {
	              return {
	                id: item._id,
	                title: item.title
	              };
	            });
	            controller.getOptions(`variants.${type}.${propName}`, variants);
	          }
	        }
	      }
	      controller.log('preload finished');
	    }catch(e){
	      controller.report(e);
	      controller.showErrorMessage(e);
	    }
	  }
	}

	const DEFAULT_ACTION = "list";

	class notCRUDRouter {
	    static extractActionName(controller, params) {
	        let actionName = DEFAULT_ACTION;
	        if (params.length === 1) {
	            if (params[0] === "create") {
	                actionName = "create";
	            } else if (controller.actionHandlerExists(params[0])) {
	                actionName = params[0];
	            } else {
	                actionName = "details";
	            }
	        } else if (params.length > 1) {
	            if (params[1] === "delete") {
	                actionName = "delete";
	            } else if (params[1] === "update") {
	                actionName = "update";
	            } else {
	                actionName = params[1];
	            }
	        }
	        return actionName;
	    }

	    static route(controller, params) {
	        try {
	            const actionName = notCRUDRouter.extractActionName(
	                controller,
	                params
	            );
	            controller.setCurrentAction(actionName);
	            return controller.runAction(actionName, params);
	        } catch (e) {
	            controller.report(e);
	            controller.showErrorMessage(e);
	        }
	    }
	}

	class CRUDMessage {
	    static error(controller, title, message) {
	        controller.setUI(
	            "__message__",
	            new Ui_error({
	                target: controller.getContainerInnerElement(),
	                props: { title, message },
	            })
	        );
	    }

	    static success(controller, title, message) {
	        controller.setUI(
	            "__message__",
	            new Ui_success({
	                target: controller.getContainerInnerElement(),
	                props: { title, message },
	            })
	        );
	    }
	}

	const DEFAULT_BREADCRUMB_TAIL$2 = "Просмотр";

	/**
	 * Generic CRUD action class
	 * @class
	 */
	class CRUDGenericAction {
	    static get NAVIGATION_DELAY() {
	        return NAVIGATION_DELAY_DEFAULT;
	    }
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	    static get deafultBreadcrumbsTail() {
	        return DEFAULT_BREADCRUMB_TAIL$2;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	    static get breadcrumbsTails() {
	        return {
	            preset: DEFAULT_BREADCRUMB_TAIL$2,
	            set: 'Просмотр, "{:title}"',
	        };
	    }

	    /**
	     * Returns template of breadcrumbs tail
	     * @param   {string}    name
	     * @returns {string}    template string
	     */
	    static getBreadcrumbsTail(name) {
	        if (!this.breadcrumbsTails) {
	            return "";
	        }
	        return notCommon$3.select(
	            this.breadcrumbsTails,
	            name,
	            this.deafultBreadcrumbsTail
	        );
	    }
	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	    static get ACTION() {
	        return "details";
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_GET() {
	        return "get";
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_PUT() {
	        return "get";
	    }

	    /**
	     * @static {object} UIConstructor    constructor of UI component
	     */
	    static get UIConstructor() {
	        return notForm;
	    }
	    /**
	     * @static {function}   TRANSFORMER     response.result transformation function if want to change it's structure
	     */
	    static get TRANSFORMER() {
	        return DEFAULT_TRASFORMER;
	    }
	    /**
	     * Returns name of model identificaiton field
	     * @param {object} controller instance of controller
	     * @returns {string}    default id field name is '_id'
	     */
	    static getIdField(controller) {
	        return controller.getOptions(`${this.ACTION}.idField`, "_id");
	    }

	    static loadDataQuery(controller, params) {
	        const idField = this.getIdField(controller);
	        return { [idField]: params[0] };
	    }

	    /**
	     * Return Promise of API reponse
	     * @param {object} controller instance of controller
	     * @param {string[]} params     array of strings parsed from URI by router and passed to controller
	     * @returns {Promise}   API response {status:string, result:any, message:string, errors: {[fieldname]:[...errorMessages]}}
	     */
	    static async loadData(controller, params) {
	        const query = this.loadDataQuery(controller, params);
	        const actionName = this.getModelActionName(controller);
	        return await controller.getModel(query)[`$${actionName}`]();
	    }

	    /**
	     * Returns model API action name
	     * @param {object} controller instance of controller
	     * @returns {string}    network interface model action name, for API; default: this.MODEL_ACTION_GET
	     */
	    static getModelActionName(controller) {
	        return controller.getOptions(
	            `${this.ACTION}.actionName`,
	            this.MODEL_ACTION_GET
	        );
	    }

	    /**
	     * Sets breadcrumbs tail, without result details
	     * @param {object} controller instance of controller
	     * @param {string[]} params     list of route params
	     */
	    static presetBreadcrumbs(controller, params) {
	        controller.setBreadcrumbs([
	            {
	                title: this.getBreadcrumbsTail("preset"),
	                url: controller.getModelActionURL(params[0], false),
	            },
	        ]);
	    }

	    static getTitle(contoller, params, response) {
	        return contoller.getItemTitle(response.result);
	    }

	    /**
	     * Sets breadcrumbs tail with response details, aka title of loaded item
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response in wrapper
	     * @param {object} response.result  API response result
	     */
	    static setBreadcrumbs(controller, params, response) {
	        const title = this.getTitle(controller, params, response);
	        const breadcrumbsTailTemplate = this.getBreadcrumbsTail("set");
	        controller.setBreadcrumbs([
	            {
	                title: breadcrumbsTailTemplate
	                    ? notLocale$1.format(breadcrumbsTailTemplate, { title })
	                    : title,
	                url: controller.getModelActionURL(params[0], false),
	            },
	        ]);
	    }

	    /**
	     * Checks response on success
	     * @param {object} response
	     * @param {string} response.status
	     * @returns {boolean}   true if response is bad
	     */
	    static isResponseBad(response) {
	        return !response || response.status !== "ok";
	    }

	    static getValidators(controller) {
	        return (
	            (controller.getValidators && controller.getValidators()) ||
	            controller.getOptions("Validators")
	        );
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	    static prepareUIOptions(controller, response) {
	        const detailsActionName = this.getModelActionName(controller);
	        return {
	            options: {
	                target: controller.getContainerInnerElement(),
	                model: controller.getModelName(),
	                action: detailsActionName,
	                name: `${controller.getName()}.${this.ACTION}Form`,
	                fields: {
	                    readonly: true,
	                },
	                validators: this.getValidators(controller),
	                variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	                masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	                injected: controller.getOptions(`${this.ACTION}.injected`, {}),
	            },
	            data: this.TRANSFORMER(response.result),
	        };
	    }

	    /**
	     * Returns instance of this action UI component from controller
	     * @param {object} controller   instance of controller
	     * @returns {object}    instance of UI component
	     */
	    static getUI(controller) {
	        return controller.ui[this.ACTION];
	    }

	    /**
	     * Sets UI of this action in controller
	     * @param {object} controller   instance of controller
	     * @param {object} ui           instance of UI component
	     */
	    static setUI(controller, ui) {
	        controller.ui[this.ACTION] = ui;
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `true`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	    static setUILoading(controller) {
	        this.getUI(controller).$set({ loading: true });
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `false`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	    static setUILoaded(controller) {
	        this.getUI(controller).$set({ loading: false });
	    }

	    /**
	     *  Sets via `.$set` method `error` to `message`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @param   {Error} message     error message
	     * @memberof CRUDGenericAction
	     */
	    static setUIError(controller, message) {
	        this.getUI(controller).$set({ error: message });
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    static bindUIEvents(controller, params, response) {
	        if (notCommon$3.isFunc(controller.goBack)) {
	            this.bindUIEvent(controller, "reject", () => controller.goBack());
	        }
	    }

	    /**
	     * Bind event handler named event to UI. Checks different binder notation $on/on
	     * @param {object} controller   instance of controller
	     * @param {string} event        event name
	     * @param {function} callback   callback function on event
	     * @returns
	     */
	    static bindUIEvent(controller, event, callback) {
	        const ui = this.getUI(controller);
	        if (ui.$on) {
	            return ui.$on(event, callback);
	        }
	        if (ui.on) {
	            return ui.on(event, callback);
	        }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	    static isUIRendered(controller) {
	        if (this.getUI(controller)) {
	            return true;
	        } else {
	            controller.$destroyUI();
	        }
	        return false;
	    }

	    static tweakUIOptions(options) {
	        return options;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	    static async run(controller, params) {
	        try {
	            //inform that we are starting
	            controller.emit(`before:render:${this.ACTION}`, params);
	            //if UI for this action exists exiting
	            if (this.isUIRendered(controller)) {
	                return;
	            }
	            //indicating that we are working
	            controller.renderLoadingScreen && controller.renderLoadingScreen();
	            //preloading form variants
	            await controller.preloadVariants(this.ACTION);
	            //setting initial state of breadcrumbs tail
	            this.presetBreadcrumbs(controller, params);
	            //loading data
	            const response = await this.loadData(controller, params);
	            //showing error message if response is 'bad'
	            if (this.isResponseBad(response)) {
	                return controller.showErrorMessage(response);
	            }
	            //updating breadcrumbs tail with more details from response
	            this.setBreadcrumbs(controller, params, response);
	            //creating action UI component
	            const uiComponent = this.UIConstructor;
	            this.setUI(
	                controller,
	                new uiComponent(
	                    this.tweakUIOptions(
	                        this.prepareUIOptions(controller, response)
	                    )
	                )
	            );
	            //bind events to UI
	            this.bindUIEvents(controller, params, response);
	            //inform that we are ready
	            controller.emit(`after:render:${this.ACTION}`, params, response);
	        } catch (e) {
	            //informing about exception
	            controller.emit(`exception:render:${this.ACTION}`, params, e);
	            //reporting exception
	            controller.report(e);
	            //showing error message
	            controller.showErrorMessage(e);
	        }
	    }

	    static goBackAfterDelay(controller) {
	        controller.goBack(this.NAVIGATION_DELAY);
	    }

	    static goBack(controller) {
	        controller.goBack(0);
	    }
	}

	const ACTION$2 = "create";
	const DEFAULT_BREADCRUMB_TAIL$1 = "Создание";

	class CRUDGenericActionCreate extends CRUDGenericAction {
	    static get deafultBreadcrumbsTail() {
	        return DEFAULT_BREADCRUMB_TAIL$1;
	    }

	    static get breadcrumbsTails() {
	        return undefined;
	    }

	    static get ACTION() {
	        return ACTION$2;
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_GET() {
	        return ACTION$2;
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_PUT() {
	        return ACTION$2;
	    }

	    /**
	     *
	     * @param {import('../../controller.crud')} controller
	     * @param {any}                         params
	     * @returns {import('not-node/src/types').notAppResponse}
	     */
	    static loadData(controller, params) {
	        let defData = controller.createDefault();
	        if (defData.getData) {
	            defData = defData.getData();
	        }
	        return {
	            status: "ok",
	            result: defData,
	        };
	    }

	    static getTitle(contoller, params, response) {
	        return contoller.getItemTitle(response);
	    }

	    static prepareUIOptions(controller, response) {
	        const actionName = this.getModelActionName(controller);
	        return {
	            options: {
	                target: controller.getContainerInnerElement(),
	                model: controller.getModelName(),
	                action: actionName,
	                name: `${controller.getName()}.${this.ACTION}Form`,
	                validators: this.getValidators(controller),
	                variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	                masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	            },
	            data: this.TRANSFORMER(response),
	        };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    static bindUIEvents(controller, params, response) {
	        if (notCommon$3.isFunc(controller.goBack)) {
	            this.bindUIEvent(controller, "reject", () =>
	                this.goBack(controller)
	            );
	        }
	        if (notCommon$3.isFunc(controller.onActionSubmit)) {
	            this.bindUIEvent(controller, "submit", async (ev) => {
	                const success = await controller.onActionSubmit(this.ACTION, {
	                    ...this.loadDataQuery(controller, params),
	                    ...ev.detail,
	                });
	                if (success) {
	                    this.goBackAfterDelay(controller);
	                }
	            });
	        }
	    }
	}

	class CRUDActionCreate extends CRUDGenericActionCreate{}

	/**
	 * Generic CRUD Details action class
	 * @class
	 */
	class CRUDGenericActionRead extends CRUDGenericAction {
	    static tweakUIOptions(options) {
	        options.options.ui = {
	            submit: {
	                enabled: false,
	            },
	        };
	        return options;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	    static async run(controller, params) {
	        try {
	            //inform that we are starting
	            controller.emit(`before:render:${this.ACTION}`, params);
	            //if UI for this action exists exiting
	            if (this.isUIRendered(controller)) {
	                return;
	            }
	            //indicating that we are working
	            controller.renderLoadingScreen && controller.renderLoadingScreen();
	            //preloading form variants
	            await controller.preloadVariants(this.ACTION);
	            //setting initial state of breadcrumbs tail
	            this.presetBreadcrumbs(controller, params);
	            //loading data
	            const response = await this.loadData(controller, params);
	            //showing error message if response is 'bad'
	            if (this.isResponseBad(response)) {
	                return controller.showErrorMessage(response);
	            }
	            //updating breadcrumbs tail with more details from response
	            this.setBreadcrumbs(controller, params, response);
	            //creating action UI component
	            const uiComponent = this.UIConstructor;
	            this.setUI(
	                controller,
	                new uiComponent(
	                    this.tweakUIOptions(
	                        this.prepareUIOptions(controller, response)
	                    )
	                )
	            );
	            //bind events to UI
	            this.bindUIEvents(controller, params, response);
	            //inform that we are ready
	            controller.emit(`after:render:${this.ACTION}`, params, response);
	        } catch (e) {
	            //informing about exception
	            controller.emit(`exception:render:${this.ACTION}`, params, e);
	            //reporting exception
	            controller.report(e);
	            //showing error message
	            controller.showErrorMessage(e);
	        }
	    }
	}

	/**
	 * CRUD action details
	 */
	class CRUDActionDetails extends CRUDGenericActionRead {}

	const DEFAULT_BREADCRUMB_TAIL = "Редактирование";
	/**
	 * Generic CRUD Update action class
	 * @class
	 */
	class CRUDGenericActionUpdate extends CRUDGenericAction {
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	    static get deafultBreadcrumbsTail() {
	        return DEFAULT_BREADCRUMB_TAIL;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	    static get breadcrumbsTails() {
	        return {
	            preset: DEFAULT_BREADCRUMB_TAIL,
	            set: `${DEFAULT_BREADCRUMB_TAIL}: "{:title}"`,
	        };
	    }

	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	    static get ACTION() {
	        return "update";
	    }

	    /**
	     * @static {string} MODEL_ACTION_GET    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_GET() {
	        return "getRaw";
	    }

	    /**
	     * @static {string} MODEL_ACTION_PUT    network model interface action name, used in API
	     */
	    static get MODEL_ACTION_PUT() {
	        return "update";
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	    static prepareUIOptions(controller, response) {
	        this.getModelActionName(controller);
	        return {
	            options: {
	                target: controller.getContainerInnerElement(),
	                model: controller.getModelName(),
	                action: this.MODEL_ACTION_PUT, //will be used to get form fields information from manifest
	                name: `${controller.getName()}.${this.ACTION}Form`,
	                validators: this.getValidators(controller),
	                variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	                ui: controller.getOptions(`${this.ACTION}.ui`, {}),
	                fields: controller.getOptions(`${this.ACTION}.fields`, {}),
	                masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	            },
	            data: this.TRANSFORMER(notCommon$3.stripProxy(response.result)),
	        };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    static bindUIEvents(controller, params, response) {
	        if (notCommon$3.isFunc(controller.goBack)) {
	            this.bindUIEvent(controller, "reject", () =>
	                this.goBack(controller)
	            );
	        }
	        if (notCommon$3.isFunc(controller.onActionSubmit)) {
	            this.bindUIEvent(controller, "submit", async (ev) => {
	                const success = await controller.onActionSubmit(this.ACTION, {
	                    ...this.loadDataQuery(controller, params),
	                    ...ev.detail,
	                });
	                if (success) {
	                    this.goBackAfterDelay(controller);
	                }
	            });
	        }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	    static isUIRendered(controller) {
	        if (this.getUI(controller)) {
	            return true;
	        } else {
	            controller.$destroyUI();
	        }
	        return false;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	    static async run(controller, params) {
	        try {
	            //inform that we are starting
	            controller.emit(`before:render:${this.ACTION}`, [params]);
	            //if UI for this action exists exiting
	            if (this.isUIRendered(controller)) {
	                return;
	            }
	            //indicating that we are working
	            controller.renderLoadingScreen && controller.renderLoadingScreen();
	            //preloading form variants
	            await controller.preloadVariants(this.ACTION);
	            //setting initial state of breadcrumbs tail
	            this.presetBreadcrumbs(controller, params);
	            //loading data
	            const response = await this.loadData(controller, params);
	            //showing error message if response is 'bad'
	            if (this.isResponseBad(response)) {
	                return controller.showErrorMessage(response);
	            }
	            //updating breadcrumbs tail with more details from response
	            this.setBreadcrumbs(controller, params, response);
	            //creating action UI component
	            const uiComponent = this.UIConstructor;
	            this.setUI(
	                controller,
	                new uiComponent(
	                    this.tweakUIOptions(
	                        this.prepareUIOptions(controller, response)
	                    )
	                )
	            );
	            //bind events to UI
	            this.bindUIEvents(controller, params, response);
	            //inform that we are ready
	            controller.emit(`after:render:${this.ACTION}`, params);
	        } catch (e) {
	            //informing about exception
	            controller.emit(`exception:render:${this.ACTION}`, params, e);
	            //reporting exception
	            controller.report(e);
	            //showing error message
	            controller.showErrorMessage(e);
	        }
	    }
	}

	/**
	 * CRUD action update
	 */
	class CRUDActionUpdate extends CRUDGenericActionUpdate {}

	const ACTION$1 = 'delete';
	const MODEL_ACTION = 'delete';

	class CRUDActionDelete{
	  static async run(controller, params) {
	    try{

	      if (controller.ui[ACTION$1]) {
	        return;
	      } else {
	        controller.$destroyUI();
	      }

	      controller.ui[ACTION$1] = new notActionUI({
	        name: 'CRUDDelete',
	        target: controller.getContainerInnerElement(),
	        options: {
	          loaderActive: true,
	          loaderStyle: 'container',
	          loaderTitle: 'not-node:crud_delete_action_waiting',
	          container: {
	            id: `crud-delete-action-${params[0]}`
	          }
	        }
	      });

	      controller.setBreadcrumbs([{
	        title: 'Удаление',
	        url: controller.getModelActionURL(params[0], ACTION$1)
	      }]);

	      if (confirm('Удалить запись?')) {
	        const deleteActionName = controller.getOptions(`${ACTION$1}.actionName`, MODEL_ACTION);
	        const success = await controller.onActionSubmit(deleteActionName, {
	          _id: params[0]
	        });
	        if(success){
	          controller.goList();
	        }
	        return;
	      }
	      controller.goList();
	    }catch(e){
	      controller.report(e);
	      controller.showErrorMessage(e);
	    }
	  }

	}

	const ACTION = "list";

	class CRUDActionList {
	    static tweakActionsList(controller, ACTIONS_LIST) {
	        if (controller.getOptions(`${ACTION}.createAction`, true)) {
	            ACTIONS_LIST.push({
	                title: "Создать",
	                action: () => controller.goCreate(),
	            });
	        }
	        return ACTIONS_LIST;
	    }

	    static tweakUIOptions(options) {
	        return options;
	    }

	    static createActionsButtons(
	        controller,
	        value,
	        delay = 0,
	        actions = ["details", "update", "delete"],
	        prepend = [],
	        append = []
	    ) {
	        const ACTIONS = {
	            details: {
	                action: () => controller.goDetails(value, delay),
	                title: "Подробнее",
	                size: "small",
	            },
	            update: {
	                action: () => controller.goUpdate(value, delay),
	                title: "Изменить",
	                size: "small",
	            },
	            delete: {
	                action: () => controller.goDelete(value, delay),
	                color: "danger",
	                title: "Удалить",
	                size: "small",
	                style: "outlined",
	            },
	        };
	        const actionsButtons = [...prepend];
	        if (Array.isArray(actions)) {
	            actions.forEach((actionName) =>
	                actionsButtons.push(ACTIONS[actionName])
	            );
	        }
	        actionsButtons.push(...append);
	        return actionsButtons;
	    }

	    static async run(controller, params) {
	        try {
	            //indicating that we are working
	            controller.renderLoadingScreen && controller.renderLoadingScreen();

	            await controller.preloadVariants(ACTION);

	            controller.setBreadcrumbs([
	                {
	                    title: "Список",
	                    url: controller.getModelURL(),
	                },
	            ]);

	            if (controller.ui[ACTION]) {
	                return;
	            } else {
	                controller.$destroyUI();
	            }

	            controller.ui[ACTION] = new notTable(
	                this.tweakUIOptions(CRUDActionList.prepareOptions(controller))
	            );

	            controller.emit(
	                `after:render:${ACTION}`,
	                params,
	                controller.ui[ACTION]
	            );
	        } catch (e) {
	            //informing about exception
	            controller.emit(`exception:render:${ACTION}`, params, e);
	            controller.report(e);
	            controller.showErrorMessage(e);
	        }
	    }

	    static prepareOptions(controller) {
	        const DEFAULT_OPTIONS_TABLE = {
	            interface: controller.getOptions(`${ACTION}.interface`, {
	                combined: true,
	                factory: controller.getInterface(),
	            }),
	            fields: undefined,
	            showSelect: undefined,
	            getItemId: undefined,
	            idField: undefined,
	            preload: {},
	            filterUI: controller.getOptions(`${ACTION}.filterUI`),
	            pager: { size: 50, page: 0 },
	            sorter: {
	                id: -1,
	            },
	            filter: undefined,
	            ui: undefined,
	        };
	        //forming actions buttons list
	        let ACTIONS_LIST = [...controller.getOptions(`${ACTION}.actions`, [])];
	        ACTIONS_LIST = this.tweakActionsList(controller, ACTIONS_LIST);
	        //
	        const TABLE_OPTIONS = {
	            options: {
	                targetEl: controller.getContainerInnerElement(),
	                endless: false,
	                actions: ACTIONS_LIST,
	            },
	        };
	        Object.keys(DEFAULT_OPTIONS_TABLE).forEach((key) => {
	            let optVal = controller.getOptions(
	                `${ACTION}.${key}`,
	                DEFAULT_OPTIONS_TABLE[key]
	            );
	            if (typeof optVal !== "undefined") {
	                TABLE_OPTIONS.options[key] = optVal;
	            }
	        });
	        return TABLE_OPTIONS;
	    }
	}

	var CRUDActions = {
	  create: CRUDActionCreate,
	  details: CRUDActionDetails,
	  update: CRUDActionUpdate,
	  delete: CRUDActionDelete,
	  list: CRUDActionList,
	};

	const BREADCRUMBS = [];
	const TITLE_FIELDS_PRIORITY = ["title", "label", "id", "name"];

	let notCRUD$1 = class notCRUD extends notController$1 {
	    #actions = { ...CRUDActions };
	    #router = notCRUDRouter;
	    #preloader = CRUDVariantsPreloader;

	    TITLE_FIELDS_PRIORITY = TITLE_FIELDS_PRIORITY;

	    static ERROR_DEFAULT = UICommon$1.ERROR_DEFAULT;

	    TOP_CLASS = ["box"];
	    MAIN_CLASS = ["box"];
	    BOTTOM_CLASS = ["box"];

	    WS_CHECK_INTERVAL = 200;

	    constructor(
	        app,
	        name,
	        { actions, router, preloader } = {
	            actions: undefined,
	            router: undefined,
	            preloader: undefined,
	        }
	    ) {
	        super(app, `CRUD.${name}`);
	        if (actions) {
	            // @ts-ignore
	            this.#actions = { ...this.#actions, ...actions };
	        }
	        if (router) {
	            this.#router = router;
	        }
	        if (preloader) {
	            this.#preloader = preloader;
	        }
	        this.ui = {};
	        this.els = {};
	        this.setOptions("names", {
	            module: "",
	            plural: "plural",
	            single: "single",
	        });
	        this.setOptions(
	            "containerSelector",
	            this.app?.getOptions("crud.containerSelector")
	        );
	        this.buildFrame();
	        return this;
	    }

	    setValidators(validators) {
	        //not-module-name -> [not,module,name]
	        const ModuleNameParts = this.getModuleName().split("-");
	        //[not,module,name] -> ModuleName
	        const ModuleName = (
	            ModuleNameParts[0] === "not"
	                ? ModuleNameParts.splice(1)
	                : ModuleNameParts
	        )
	            .map(notCommon$3.capitalizeFirstLetter)
	            .join("");
	        const serviceName = `ns${ModuleName}Common`;
	        const CommonModuleService = this.app?.getService(serviceName);
	        this.setWorking(
	            "validators",
	            CommonModuleService.augmentValidators(validators)
	        );
	    }

	    getValidators() {
	        return this.getWorking("validators");
	    }

	    start() {
	        let newHead = [];
	        if (this.getModuleName() && this.getOptions("names.module")) {
	            newHead.push({
	                title: this.getOptions("names.module"),
	                url: false,
	            });
	        }
	        newHead.push({
	            title: this.getOptions("names.plural"),
	            url: this.getModelURL(),
	        });
	        BREADCRUMBS.splice(0, BREADCRUMBS.length, ...newHead);
	        notBreadcrumbs.setHead(BREADCRUMBS).render({
	            root: "",
	            target: this.els.top,
	            navigate: (url) => this.app?.getWorking("router").navigate(url),
	        });
	        this.route(this.getOptions("params"));
	    }

	    startWhenWSClientReady() {
	        if (this.app?.getWSClient()) {
	            if (this.app?.getWSClient().isConnected()) {
	                this.start();
	            } else {
	                this.app
	                    .getWSClient()
	                    .once("connected", this.startWhenWSClientReady.bind(this));
	            }
	        } else {
	            setTimeout(
	                () => this.startWhenWSClientReady(),
	                this.WS_CHECK_INTERVAL
	            );
	        }
	    }

	    setBreadcrumbs(tail) {
	        notBreadcrumbs.setTail(tail).update();
	    }

	    backToList() {
	        this.navigate(this.linkBackToList());
	    }

	    linkBackToList() {
	        return this.getModelURL();
	    }

	    afterAction(action = "list") {
	        let navBack = this.app?.getOptions("crud.navigateBackAfter", []);
	        if (navBack && Array.isArray(navBack) && navBack.indexOf(action) > -1) {
	            window.history.back();
	        } else {
	            this.backToList();
	        }
	    }

	    buildFrame() {
	        let el = document.querySelector(
	            this.app?.getOptions("crud.containerSelector", "body")
	        );
	        while (el.firstChild) {
	            el.removeChild(el.firstChild);
	        }
	        this.els.top = document.createElement("div");
	        this.els.top.id = "crud-top";
	        this.getFrameClasses().TOP_CLASS.forEach((name) =>
	            this.els.top.classList.add(name)
	        );
	        el.appendChild(this.els.top);
	        this.els.main = document.createElement("div");
	        this.els.main.id = "crud-main";
	        this.getFrameClasses().MAIN_CLASS.forEach((name) =>
	            this.els.main.classList.add(name)
	        );
	        el.appendChild(this.els.main);
	        this.els.bottom = document.createElement("div");
	        this.els.bottom.id = "crud-bottom";
	        this.getFrameClasses().BOTTOM_CLASS.forEach((name) =>
	            this.els.bottom.classList.add(name)
	        );
	        el.appendChild(this.els.bottom);
	    }

	    getFrameClasses() {
	        return {
	            TOP_CLASS: this.TOP_CLASS,
	            MAIN_CLASS: this.MAIN_CLASS,
	            BOTTOM_CLASS: this.BOTTOM_CLASS,
	        };
	    }

	    getContainerTopElement() {
	        return this.els.top;
	    }

	    getContainerInnerElement() {
	        return this.els.main;
	    }

	    getContainerBottomElement() {
	        return this.els.bottom;
	    }

	    async preloadVariants(type = "list") {
	        await this.#preloader.preload(this, type);
	    }

	    getTitleFromLib(propName, id) {
	        throw new Error("not suported anymore");
	        //return Form.getVariant(propName, id).title;
	    }

	    getItemTitle(item) {
	        const fieldName = this.TITLE_FIELDS_PRIORITY.find((key) =>
	            notCommon$3.objHas(item, key)
	        );
	        if (fieldName) {
	            return item[fieldName];
	        } else {
	            return "";
	        }
	    }

	    createDefault() {
	        return this.getModel({}).toDefault();
	    }

	    route(params = []) {
	        try {
	            return this.#router.route(this, params);
	        } catch (e) {
	            this.report(e);
	            this.showErrorMessage(e);
	        }
	    }

	    actionHandlerExists(actionName) {
	        if (Object.keys(this.#actions).includes(actionName)) {
	            return true;
	        }
	        if (
	            typeof this["run" + notCommon$3.capitalizeFirstLetter(actionName)] ===
	            "function"
	        ) {
	            return true;
	        }
	        return false;
	    }

	    runAction(actionName, params) {
	        if (Object.keys(this.#actions).includes(actionName)) {
	            return this.#actions[actionName].run(this, params);
	        } else if (
	            typeof this["run" + notCommon$3.capitalizeFirstLetter(actionName)] ===
	            "function"
	        ) {
	            return this["run" + notCommon$3.capitalizeFirstLetter(actionName)](
	                params
	            );
	        } else {
	            throw new Error(
	                `No such action: ${actionName} in contoller ${this.getWorking(
                    "name"
                )}`
	            );
	        }
	    }

	    /**
	     *  Changes location to create page, after delay
	     *  @param {number|string} [delay=0] number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goCreate(delay = 0) {
	        this.goAfterDelay(this.getModelActionURL("", "create"), delay);
	    }

	    /**
	     *  Changes location to document details page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goDetails(id, delay = 0) {
	        this.goAfterDelay(this.getModelActionURL(id, ""), delay);
	    }

	    /**
	     * Changes location to document update page, after delay
	     * @param {string}          id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goUpdate(id, delay = 0) {
	        this.goAfterDelay(this.getModelActionURL(id, "update"), delay);
	    }

	    /**
	     *  Changes location to document delete page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goDelete(id, delay = 0) {
	        this.goAfterDelay(this.getModelActionURL(id, "delete"), delay);
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goList(delay = 0) {
	        this.goAfterDelay(this.getModelURL(), delay);
	    }

	    /**
	     *
	     * @param {string} url
	     * @param {number|string} delay
	     */
	    goAfterDelay(url, delay = 0) {
	        this.navigateWithDelay(url, delay, () => this.$destroyUI());
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	    goBack(delay = 0) {
	        this.goList(delay);
	    }

	    async onActionSubmit(action, item) {
	        let state = true;
	        const actionUI = this.ui[action];
	        if (actionUI) {
	            try {
	                actionUI.setLoading();
	                let result = await this.getModel(item)[`$${action}`]();
	                state = actionUI.processResult(result);
	            } catch (e) {
	                state = actionUI.processResult(e);
	            } finally {
	                actionUI.resetLoading();
	                return state;
	            }
	        }
	        throw new Error("Action UI doesnt exist");
	    }

	    $destroyUI() {
	        for (let name in this.ui) {
	            this.ui[name].$destroy && this.ui[name].$destroy();
	            this.ui[name].destroy && this.ui[name].destroy();
	            delete this.ui[name];
	        }
	    }

	    showErrorMessage(res) {
	        this.error && this.error(res);
	        this.app &&
	            this.app.emit("error", {
	                title: "Произошла ошибка",
	                message: res.message ? res.message : UICommon$1.ERROR_DEFAULT,
	            });
	        CRUDMessage.error(
	            this,
	            "Произошла ошибка",
	            res.message ? res.message : UICommon$1.ERROR_DEFAULT
	        );
	    }

	    showSuccessMessage(title, message) {
	        this.app && this.app.emit("success", { title, message });
	        CRUDMessage.success(this, title, message);
	    }

	    setUI(name, val) {
	        this.$destroyUI();
	        this.ui[name] = val;
	    }

	    getActionUI() {
	        return this.ui[this.getCurrentAction()];
	    }

	    renderLoadingScreen() {
	        this.setUI("loading_screen", this.createLoaderUI());
	    }

	    createLoaderUI() {
	        return new Ui_loader({
	            target: this.getContainerInnerElement(),
	            props: {
	                loading: true,
	                title: "",
	            },
	        });
	    }
	};

	const ROUTE_LIST = "list";
	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	class notCRUDPlainRouter {
	    static DEFAULT_ROUTE = ROUTE_LIST;
	    /**
	     * Returns first item from params or throws Error
	     * @param {string[]} params array of strings parsed from URI by route rules
	     * @returns {string}
	     */
	    static extractActionName(params) {
	        if (params.length > 0) {
	            return params[0];
	        }
	        return this.DEFAULT_ROUTE;
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	    static route(controller, params) {
	        try {
	            const actionName = this.extractActionName(params);
	            controller.setCurrentAction(actionName);
	            return controller.runAction(actionName, params);
	        } catch (e) {
	            controller.report(e);
	            controller.showErrorMessage(e);
	        }
	    }
	}

	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	class notCRUDRouterSwitch {
	    /**
	     * Variants of this action
	     */
	    static get routesVariants() {
	        return {
	            /**
	            routeName: Action
	             */
	        };
	    }

	    /**
	     * Returns true if variant name is valid
	     * @param {string} name    name of route variant
	     * @returns {boolean}
	     */
	    static isRouteVariantValid(name) {
	        return name !== "" && notCommon$3.objHas(this.routesVariants, name);
	    }

	    /**
	     * This function returns which of routes variant should be executed
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]}    params  params passed to router
	     * @returns {Promise<string>}    name of route variant
	     */
	    static async determineRoute(controller, params = []) {
	        return "";
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	    static async route(controller, params) {
	        try {
	            const actionName = await this.determineRoute(controller, params);
	            if (this.isRouteVariantValid(actionName)) {
	                controller.setCurrentAction(actionName);
	                const routerAction = this.routesVariants[actionName];
	                if (notCommon$3.isAsync(routerAction.run)) {
	                    await routerAction.run(controller, params);
	                } else {
	                    routerAction.run(controller, params);
	                }
	            } else {
	                throw new Error(
	                    `No such action: ${actionName} in contoller ${controller.getWorking(
                        "name"
                    )}`
	                );
	            }
	        } catch (e) {
	            controller.report(e);
	            controller.showErrorMessage(e);
	        }
	    }
	}

	const emptyResult = () => {
	    return {
	        list: [],
	        count: 0,
	        page: 0,
	        pages: 0,
	        skip: 0,
	    };
	};

	class notServiceModelSearch {
	    constructor(app, modelName) {
	        this.modelName = modelName;
	        this.app = app;
	    }

	    destroy() {
	        delete this.app;
	    }

	    getSearchRouteName() {
	        return "listAndCount";
	    }

	    getDataLoadRouteName() {
	        return "get";
	    }

	    transformSearchResult(result) {
	        result.list = result.list.map((item) => {
	            return {
	                _id: item._id,
	                id: item[`${this.modelName}ID`],
	                title: item.name || item.title || item.label || item.username,
	            };
	        });
	        return result;
	    }

	    transformSelectedResult(result) {
	        return {
	            _id: result._id,
	            [`${this.modelName}ID`]: result.id,
	            title: result.title,
	        };
	    }

	    async searchByTerm(term) {
	        try {
	            if (term.value.length > 2) {
	                const model = this.app.getModel(this.modelName);
	                model.setSearch(term.value);
	                const response = await model[`$${this.getSearchRouteName()}`]();
	                if (response.status === "ok") {
	                    return this.transformSearchResult(response.result);
	                } else {
	                    return emptyResult();
	                }
	            } else {
	                return emptyResult();
	            }
	        } catch (e) {
	            return emptyResult();
	        }
	    }

	    openSelector() {
	        return new Promise((resolve, reject) => {
	            try {
	                const el = new Ui_generic_selector({
	                    target: document.body,
	                    props: {},
	                });
	                el.$on("termChange", async ({ detail }) => {
	                    const results = await this.searchByTerm(detail);
	                    el.$set({ results });
	                });

	                el.$on("next", () => {
	                    console.log("next selector results");
	                });

	                el.$on("prev", () => {
	                    console.log("prev selector results");
	                });

	                el.$on("reject", () => {
	                    el.$destroy();
	                    reject();
	                });
	                el.$on("resolve", ({ detail }) => {
	                    el.$destroy();
	                    resolve(this.transformSelectedResult(detail));
	                });
	            } catch (e) {
	                this.app.error(e);
	                reject(e);
	            }
	        });
	    }

	    async loadData(_id) {
	        try {
	            if (_id && _id.length > 10) {
	                const model = this.app.getModel(this.modelName, { _id });
	                const response = await model[
	                    `$${this.getDataLoadRouteName()}`
	                ]();
	                if (response.status === "ok") {
	                    return response.result;
	                } else {
	                    return null;
	                }
	            } else {
	                return null;
	            }
	        } catch (e) {
	            this.app.error(e);
	            return null;
	        }
	    }
	}

	//import 'babel-polyfill/dist/polyfill';


	const ncCRUD = notCRUD$1; //legacy alias

	var Frame = /*#__PURE__*/Object.freeze({
		__proto__: null,
		COMPONENTS: COMPONENTS$2,
		FIELDS: FIELDS$2,
		UIForm: Form,
		VARIANTS: VARIANTS$1,
		createCRUDActionUIView: create_crud_action_ui_view,
		ncCRUD: ncCRUD,
		notAPI: index,
		notApp: notApp$1,
		notBase: notBase$1,
		notBreadcrumbs: notBreadcrumbs,
		notCRUD: notCRUD$1,
		notCRUDRouter: notCRUDRouter,
		notCRUDRouterPlain: notCRUDPlainRouter,
		notCRUDRouterSwitch: notCRUDRouterSwitch,
		notCommon: notCommon$3,
		notController: notController$1,
		notForm: notForm,
		notFormHelpers: FormHelpers,
		notFormRules: notFormRules,
		notFormSet: notFormSet,
		notFormUtils: notFormUtils$1,
		notInterface: notInterface,
		notPath: notPath$1,
		notRecord: notRecord,
		notRouter: notRouter$1,
		notServiceModelSearch: notServiceModelSearch,
		notSideMenu: notSideMenu$1,
		notStores: stores,
		notTable: notTable,
		notTopMenu: notTopMenu$3
	});

	const { notCommon: notCommon$2, COMPONENTS: COMPONENTS$1, FIELDS, VARIANTS, notFormUtils } = Frame;

	Object.keys(Elements).forEach((componentsSetName) => {
	    Object.keys(Elements[componentsSetName]).forEach((componentName) => {
	        notFormUtils$1.addComponent(
	            componentName,
	            Elements[componentsSetName][componentName]
	        );
	    });
	});

	/**
	*	Template of error.js
	*	For building for specific environment.
	*	Node.js or Browser
	*	@param {string}	env	node|browser in wich env it will be running
	*	@param {string}	url	URL of report collector
	*	@param {string}	key	key to indetificate reporter
	*/
	/**
	* Error reporting with features, saving browser info, uri and so on.
	* @module not-error/error
	*/
	class notError extends Error {
		constructor(message, options = {}, error = null){
			super(message);
			this.options = options;
			this.adopt(error);
			this.fill();
			this.getTime();
			return this;
		}

		/**
		*	Adopting native error object
		*	@param {Error}	error 	Error object
		*	@return {notError}		chainable
		*/
		adopt(error){
			if(error instanceof Error){
				this.parent = error;
			}
			return this;
		}

		getStack(){
			if(this.parent){
				return this.parent.stack;
			}else {
				return this.stack;
			}
		}

		getDetails(){
			let src = this;
			if(this.parent){
				src = this.parent;
			}
			return {
				columnNumber:    	src.columnNumber,
				fileName:        	src.fileName,
				lineNumber:      	src.lineNumber,
				name:            	src.name,
				message:        	src.message,
				stack:          	src.stack
			};
		}

		/**
		*	Updating this.env.date property
		*	@return  {object}	{timestamp, offset}
		*/
		getTime(){
			let date = new Date();
			this.env.date = {
				timestamp : date.getTime(),
				offset: date.getTimezoneOffset()
			};
			return this.env.date;
		}


		/**
		******************************************************************************************************
		******************************************************************************************************
		***	Browser Section
		******************************************************************************************************
		******************************************************************************************************
		**/

		/**
		*	Collecting information specific for browsers
		*	@return {notError}		chainable
		*/
		fill(){
			this.env = {
				browser: true,
				node: false,
				document: {
					title: document.title
				},
				location: {
					hash: 			window.location.hash,
					port:				window.location.port,
					protocol:		window.location.protocol,
					search:			window.location.search,
					host:				window.location.host,
					url:				window.location.url,
					href:				window.location.href,
					hostname: 	window.location.hostname,
					pathname: 	window.location.pathname,
				},
				navigator:{
					appName: 				navigator.appName,
					appCodeName: 		navigator.appCodeName,
					appVersion: 		navigator.appVersion,
					userAgent: 			navigator.userAgent,
					platform: 			navigator.platform,
					language: 			navigator.language,
					product: 				navigator.product,
					onLine: 				navigator.onLine,
					cookieEnabled:	navigator.cookieEnabled,
				},
				window:{
					height: 				window.innerHeight,
					width: 					window.innerWidth,
				}
			};
			return this;
		}


	}

	//reportable
	class notValidationError extends notError{
		constructor(message, fields = {}, err = null, params = {}){
			super(message, {fields, params}, err);
			return this;
		}

		/**
	  * Sets hash of fields errors messages for usage in forms
	  *	@return {Object}	hash of field->errors [key:string]: Array<string>
	  **/
		setFieldsErrors(messages){
			this.options.fields = messages;
		}

		/**
	  * Returns hash of errors
	  *	@return {Object}	hash of field->errors [key:string]: Array<string>
	  **/
		getFieldsErrors(){
			return this.options.fields;
		}

	}

	//reportable
	class notRequestError extends notError{
		constructor(
			message,
			{code, errors, redirect, params} = {code:500, errors:{}, redirect: false, params:{}},
			error = null
		){
			super(
				message,
				{
					code,
					errors,
					redirect,
					params
				},
				error
			);
			return this;
		}

		setRedirect(url){
			this.options.redirect = url;
		}

		getRedirect(){
			return this.options.redirect;
		}

		setCode(code){
			this.options.code = code;
		}

		getCode(){
			return this.options.code;
		}

		setErrors(list){
			this.options.errors = list;
		}

		getErrors(){
			return this.options.errors;
		}

		getResult(){
			return {
				message:  this.message,
				code:     this.getCode(),
				errors:   this.getErrors(),
				redirect: this.getRedirect(),
			};
		}

	}

	/**
	*  Template of reporter.js
	*  For building for specific environment.
	*  Node.js or Browser
	*  @param {string}  env  node|browser in wich env it will be running
	*  @param {string}  url  URL of report collector
	*  @param {string}  key  key to indetificate reporter
	*/

	const PARASITES = ['report@', 'notError@'];
	const LINES_TO_CAPTURE = 6;
	const STACK_PROPS = [
		'file',
		'path',
		'type',
		'line',
		'column',
		'function',
	];

	const FILE_LINE_PARSERS = [
		{
			test: (line)=>{
				const tester = /(.*)@(.+):(\d+):(\d+)/gi;
				let matches = [...line.matchAll(tester)];
				if(matches.length){
					let res = matches[0];
					if(res && res.length > 2 ){
						return res;
					}
				}
				return false;
			},
			parse: (res)=>{
				if(res){
					//separation of different types of data
					let functionFullPath = res[1].split('.');
					let file = res[2];
					//extraction of exact values
					let pathParts = file.split('/');
					let fileName = pathParts[pathParts.length - 1];
					pathParts.pop();
					let filePath = pathParts.join('/');
					let lineNumber = parseInt(res[3]);
					let columnNumber = parseInt(res[4]);
					let functionName = functionFullPath[functionFullPath.length - 1];
					if (functionName.replaceAll){
						functionName = functionName.replaceAll('/' , '').replaceAll('\\' , '').replaceAll('>', '').replaceAll('<', '');
					}
					let fileDir;
					if(pathParts && pathParts.length){
						fileDir = pathParts.pop();
					}
					return {
						file: fileName,
						path: filePath,
						line: lineNumber,
						column: columnNumber,
						function: functionName,
						type: fileDir,
					};
				}else {
					return false;
				}
			}
		},
		{
			test: (line)=>{
				const tester = /\sat\s(.+)\s\((.+)\)/gi;
				let matches = [...line.matchAll(tester)];
				if(matches.length){
					let res = matches[0];
					if(res && res.length > 2 ){
						return res;
					}
				}
				return false;
			},
			parse: (res)=>{
				if(res){
					//separation of different types of data
					let functionFullPath = res[1].split('.');
					let file = res[2].split(':');
					//extraction of exact values
					let pathParts = file[0].split('/');
					let fileName = pathParts[pathParts.length - 1];
					pathParts.pop();
					let filePath = pathParts.join('/');
					let lineNumber = parseInt(file[1]);
					let columnNumber = parseInt(file[2]);
					let functionName = functionFullPath[functionFullPath.length - 1];
					if (functionName.replaceAll){
						functionName = functionName.replaceAll('/' , '').replaceAll('\\' , '').replaceAll('>', '').replaceAll('<', '');
					}
					let fileDir;
					if(pathParts && pathParts.length){
						fileDir = pathParts.pop();
					}
					return {
						file: fileName,
						path: filePath,
						line: lineNumber,
						column: columnNumber,
						function: functionName,
						type: fileDir,
					};
				}else {
					return false;
				}
			}
		},
	];


	const LOG = window.console;
	const NOT_NODE_ERROR_URL_BROWSER = 'https://appmon.ru/api/key/collect';


	const DEFAULT_OPTIONS$2 = {
			envFirst: false,
			origin: {},
			url:undefined,
			key:undefined,
			registerAll: true
		};

	/**
	* Error reporting with features, saving browser info, uri and so on.
	* @module not-error/error
	*/
	class notErrorReporter{
		static notError = notError;
		static notValidationError = notValidationError;
		static notRequestError = notRequestError;

		constructor(opts = DEFAULT_OPTIONS$2){
			let {envFirst, origin,	url, key,registerAll } = opts;
			this.envFirst = envFirst;
			this.processWatching = false;
			this.setOrigin(origin);
			this.setKey(key);
			this.setURL(url);
			this.setRegisterAll(registerAll);
			
			window.addEventListener('error', this.registerError.bind(this));
			
			return this;
		}

		setOrigin(origin){
			this.origin = origin;
			return this;
		}

		setKey(key){
			this.key = key;
			return this;
		}

		setURL(url){
			this.url = url;
			return this;
		}

		setRegisterAll(registerAll = true){
			this.registerAll = registerAll;
			return this;
		}

		errorIsReportable(error){
			return error instanceof notError;
		}

		async report(error, notSecure){
			let local = false;
			if(!this.errorIsReportable(error)){
				error = new notError(error.message, {}, error);
				local = true;
			}
			let data = await this.packError(error, local);
			return await this._report(data, this.getReportURL(), notSecure, 'error');
		}

		reportError(name, opts = {}, parent = null, notSecure){
			return this.report(new notError(name, opts, parent), notSecure);
		}

		isLineParasite(line){
			return PARASITES.some((str) => line.includes(str));
		}

		trunkStack(stack){
			let lines = stack.split("\n");
			while(lines.length && this.isLineParasite(lines[0])){
				lines.shift();
			}
			return lines;
		}

		__stackFirstLineParser(line){
			let result;
			let parser = FILE_LINE_PARSERS.find((itm) =>{ return result = itm.test(line);});
			if(parser){
				return parser.parse(result);
			}
			return false;
		}

		__stackFirstLineSearcher(stack){
			for(let i = 0; stack.length > i; i++){
				let	line = stack[i];
				if(!line){continue;}
				let res = this.__stackFirstLineParser(line);
				if(res){
					return res;
				}else {
					continue;
				}
			}
			return false;
		}

		parseStack(rawStack){
			try{
				let stack = this.trunkStack(rawStack);
				let res = this.__stackFirstLineSearcher(stack);
				if(!res){
					return {stack};
				}
				let fileinfo = this.__stackFirstLineSearcher(stack);
				if(!fileinfo){
					return {stack};
				}
				return {
					stack,
					...fileinfo
				};
			}catch(e){
				LOG.error(e);
				return false;
			}
		}

		extractDataFromError(err, local){
			let res = err.getDetails();
			if(res.stack){
				let stackInfo = this.parseStack(res.stack);
				if(stackInfo && stackInfo.stack){
					if(local){
						res.stack = stackInfo.stack.join("\n");
						STACK_PROPS.forEach((j) => {
							if(stackInfo[j]){ res[j] = stackInfo[j];}
						});
					}else {
						STACK_PROPS.forEach((j) => {
							if(!res[j]){res[j] = stackInfo[j];}
						});
					}
				}
			}
			return res;
		}

		async packError(error, local = false){
			let result = {};
			result.details   = this.extractDataFromError(error, local);
			await this.tryToGetSourceBlock(result);
			result.options   = error.options;
			result.env       = error.env;
			result.origin   = this.origin?this.origin:{};
			return result;
		}

		async tryToGetSourceBlock(result){
			if(result.details.fileName && !isNaN(result.details.lineNumber)){
				try{
					let text = await this.loadSources(result.details.fileName);
					if(text){
						let lines = this.extractLinesFromFile(text, parseInt(result.details.lineNumber));
						result.lines = lines;
					}
				}catch(e){
					return false;
				}
			}
		}

		extractLinesFromFile(text, targetLine){
			let lines = text.split("\n");
			targetLine = parseInt(targetLine) - 1;
			let fromLine = (targetLine - LINES_TO_CAPTURE);
			let toLine = (targetLine + LINES_TO_CAPTURE);
			if(fromLine < 0){
				fromLine = 0;
			}
			if(toLine > lines.length - 1){
				toLine = lines.length - 1;
			}
			let result = [];
			for(let t = fromLine; t < toLine; t++){
				result.push({l: t + 1, txt: lines[t], color: { danger: targetLine === t} });
			}
			return result;
		}


		/**
		******************************************************************************************************
		******************************************************************************************************
		***	Browser Section
		******************************************************************************************************
		******************************************************************************************************
		**/
		getReportURL(){
			if(typeof this.url !== 'undefined'){
				return this.url;
			}else	if(window.NOT_NODE_ERROR_URL_BROWSER && window.NOT_NODE_ERROR_URL_BROWSER.length>0){
				return window.NOT_NODE_ERROR_URL_BROWSER;
			}if(window.APPMON_URL && typeof window.APPMON_URL === 'string' && window.APPMON_URL.length>0){
				return window.APPMON_URL;
			}else if(NOT_NODE_ERROR_URL_BROWSER.length>0){
				return NOT_NODE_ERROR_URL_BROWSER;
			}else {
				return '/api/error';
			}
		}

		getReportKey(){
			if(typeof this.key !== 'undefined'){
				return this.key;
			}else	if(window.NOT_NODE_ERROR_KEY && window.NOT_NODE_ERROR_KEY.length > 0){
				return window.NOT_NODE_ERROR_KEY;
			}else	if(window.APPMON_KEY && typeof window.APPMON_KEY === 'string' && window.APPMON_KEY.length > 0){
				return window.APPMON_KEY;
			}else {
				return '';
			}
		}

		_report(data, url){
			let report = {
				report: data,
				type: 'error',
				key: this.getReportKey(),
			};
			return fetch(url, {
				method: 			'PUT',
				cache: 				'no-cache',
				headers: 			{
					'Content-Type': 'application/json; charset=utf-8'
				},
				redirect: 		'follow',
				referrer: 		'no-referrer',
				body: 				JSON.stringify(report),
			});
		}

		async loadSources(filePath){
			let res = await fetch(filePath);
			if(parseInt(res.status) === 200){
				return await res.text();
			}else {
				return false;
			}
		}

		registerError(ev){
			if(this.registerAll){
				this.report(ev.error);
			}
		}


	}

	class Common{
		static DEFAULT_REDIRECT_TIMEOUT = 5000;
		static CLASS_OK = 'is-success';
		static CLASS_ERR = 'is-danger';
	  static isError(e){
	    return e instanceof Error;
	  }
	}

	var mod_0 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: Common
	});

	const { notBase } = Frame;

	const OPT_DEFAULT_PAGE_SIZE = 20,
		OPT_DEFAULT_PAGE_NUMBER = 0,
		OPT_DEFAULT_PAGE_RANGE = 6,
		OPT_DEFAULT_SORT_DIRECTION = 1,
		OPT_DEFAULT_SEARCH = "",
		OPT_DEFAULT_RETURN = {},
		OPT_DEFAULT_COMBINED_ACTION = "listAndCount",
		OPT_DEFAULT_SORT_FIELD = "_id";

	/**
		Few concepts
			*	two modes 1 - live requesting from server, 2 - static data

			*	in live mode: changing of filters or sorters leads to another request
				to server, in endless mode after scroll down to the bottom of
				table next page will be requested and glued to the bottom of the
				table, in pagination mode after change of sorter or filter
				pagination will be reset

			*	in static mode: change in filters or sorters will lead to pagination
				reset

		let input = {
			data:	//array of items to be presented in table
					//in case of static - unfiltered
					//in case of live - will be mirrored to table without any changes
			options: {
				pager:{
					size: 50,		//how many rows per "page"
					number: 0,		//default page number aka first
				},
				interface:{			//for online requested list
					factory: 		//target notRecord factory with notRecordInterface, source of online data
					listAction:		//which action will be called to retrieve data from server, default 'list'
					countAction:	//which action will be called to retrieve raws count from server, default 'count'
					combined: 		//cobined request list and count
					combinedAction:	//name of combined action
					onSuccess:		//will be called after successfull request
					onError:		//will be called after failed request
				}
			}
		}
	*/

	class notFilter extends notBase {
		constructor(input) {
			super(input);
			this.data = {
				pagination: {
					items: {
						count: 0,
						from: 0,
						to: 0,
					},
					pages: {
						count: 0,
						from: 0,
						to: 0,
						current: 0,
						list: [],
					},
				},
			};
			if (Object.prototype.hasOwnProperty.call(input.options, "filter")) {
				this.setFilter(input.options.filter, true);
			} else {
				this.resetFilter();
			}
			if (Object.prototype.hasOwnProperty.call(input.options, "pager")) {
				this.setPager(input.options.pager, true);
			} else {
				this.resetPager();
			}
			if (Object.prototype.hasOwnProperty.call(input.options, "sorter")) {
				this.setSorter(input.options.sorter, true);
			} else {
				this.resetSorter(true);
			}
			if (Object.prototype.hasOwnProperty.call(input.options, "return")) {
				this.setReturn(input.options.return);
			} else {
				this.setReturn();
			}
			if (Object.prototype.hasOwnProperty.call(input.options, "search")) {
				this.setSearch(input.options.search, true);
			} else {
				this.setSearch();
			}
		}

		////////////////////////////////////////////////////////////////////////////
		////navigation
		////////////////////////////////////////////////////////////////////////////
		getNext() {
			let next = isNaN(this.getWorking("pager").page)
				? this.getDefaultPageNumber()
				: this.getWorking("pager").page + 1;
			this.getWorking("pager").page = Math.min(
				next,
				this.data.pagination.pages.to
			);
			return this.loadData();
		}

		getPrev() {
			let prev = isNaN(this.getWorking("pager").page)
				? this.getDefaultPageNumber()
				: this.getWorking("pager").page - 1;
			this.getWorking("pager").page = Math.max(
				prev,
				this.data.pagination.pages.from
			);
			return this.loadData();
		}

		getFirst() {
			this.getWorking("pager").page = this.data.pagination.pages.from;
			return this.loadData();
		}

		getLast() {
			this.getWorking("pager").page = this.data.pagination.pages.to;
			return this.loadData();
		}

		getPage(pageNumber = 0) {
			this.getWorking("pager").page = pageNumber;
			return this.loadData();
		}

		///////////////////////////////////////////////////////////////////////////
		////networking
		///////////////////////////////////////////////////////////////////////////
		getDataInterface() {
			return this.getOptions("interface.factory")({});
		}

		getCombinedActionName() {
			return this.getOptions("interface.combinedAction")
				? this.getOptions("interface.combinedAction")
				: OPT_DEFAULT_COMBINED_ACTION;
		}

		loadData() {
			//load from server
			let query = this.getDataInterface()
					.setFilter(this.getFilter())
					.setSorter(this.getSorter())
					.setReturn(this.getReturn())
					.setSearch(this.getSearch())
					.setPager(this.getPager().size, this.getPager().page),
				actionName = this.getCombinedActionName();
			return query["$" + actionName]()
				.then(this.extractResult.bind(this))
				.then(this.updatePagination.bind(this));
		}

		extractResult(response) {
			const resultPath = this.getOptions("resultPath", ":");
			if (resultPath) {
				return notPath$1.get(resultPath, response);
			} else {
				return response;
			}
		}

		updatePagination(result) {
			return new Promise((resolve, reject) => {
				try {
					this.data.pagination.pages.list.splice(
						0,
						this.data.pagination.pages.list.length
					);
					let itemsCount = result.count,
						itemsFrom =
	                        (this.getPager().page - OPT_DEFAULT_PAGE_NUMBER) *
	                            this.getPager().size +
	                        1,
						pagesCount =
	                        itemsCount % this.getPager().size
	                        	? Math.floor(itemsCount / this.getPager().size) + 1
	                        	: Math.round(itemsCount / this.getPager().size),
						pagesFrom = Math.max(
							OPT_DEFAULT_PAGE_NUMBER,
							this.getPager().page - OPT_DEFAULT_PAGE_RANGE
						),
						pagesTo = Math.min(
							pagesCount - (1 - OPT_DEFAULT_PAGE_NUMBER),
							this.getPager().page + OPT_DEFAULT_PAGE_RANGE
						),
						list = [],
						itemsTo = Math.min(
							itemsFrom + this.getPager().size - 1,
							itemsCount
						);
					for (let t = pagesFrom; t <= pagesTo; t++) {
						list.push({
							index: t,
							active: t === this.getPager().page,
						});
					}
					this.data.pagination.items.count = itemsCount;
					this.data.pagination.items.from = itemsFrom;
					this.data.pagination.items.to = itemsTo;
					this.data.pagination.pages.count = pagesCount;
					this.data.pagination.pages.from = pagesFrom;
					this.data.pagination.pages.to = pagesTo;
					this.data.pagination.pages.current = this.getPager().page;
					this.data.pagination.pages.list.splice(
						0,
						this.data.pagination.pages.list.length,
						...list
					);
					result.pagination = this.data.pagination;
					resolve(result);
				} catch (e) {
					e.response = result;
					reject(e);
				}
			});
		}

		///////////////////////////////////////////////////////////////////////////
		////sorter
		///////////////////////////////////////////////////////////////////////////
		setSorter(hash) {
			this.setWorking("sorter", hash);
			return this;
		}

		resetSorter() {
			let t = {};
			t[OPT_DEFAULT_SORT_FIELD] = OPT_DEFAULT_SORT_DIRECTION;
			return this.setSorter(t);
		}

		getSorter() {
			return this.getWorking("sorter");
		}

		getSorterDirection() {
			try {
				let names = Object.keys(this.getSorter());
				return this.getSorter()[names[0]];
			} catch (_) {
				return OPT_DEFAULT_SORT_DIRECTION;
			}
		}

		///////////////////////////////////////////////////////////////////////////
		////search
		///////////////////////////////////////////////////////////////////////////
		getSearch() {
			let search =
	            typeof this.getWorking("search") !== "undefined" &&
	            this.getWorking("search") !== null;
			return search ? this.getWorking("search") : "";
		}

		setSearch(line = OPT_DEFAULT_SEARCH) {
			this.setWorking("search", line);
			return this;
		}

		///////////////////////////////////////////////////////////////////////////
		////return
		///////////////////////////////////////////////////////////////////////////
		getReturn() {
			return this.getWorking("return");
		}

		setReturn(ret = OPT_DEFAULT_RETURN) {
			this.setWorking("return", ret);
			return this;
		}

		///////////////////////////////////////////////////////////////////////////
		////filter
		///////////////////////////////////////////////////////////////////////////
		setFilter(hash) {
			this.setWorking("filter", hash);
			return this;
		}

		resetFilter() {
			return this.setFilter({});
		}

		getFilter() {
			return this.getWorking("filter");
		}

		///////////////////////////////////////////////////////////////////////////
		////pager
		///////////////////////////////////////////////////////////////////////////
		setPager(hash) {
			this.setWorking("pager", hash);
			return this;
		}

		getDefaultPageNumber() {
			return isNaN(this.getOptions("pager.page"))
				? OPT_DEFAULT_PAGE_NUMBER
				: this.getOptions("pager.page");
		}

		getDefaultPageSize() {
			return isNaN(this.getOptions("pager.size"))
				? OPT_DEFAULT_PAGE_SIZE
				: this.getOptions("pager.size");
		}

		resetPager() {
			this.setWorking("pager", {
				size: this.getDefaultPageSize(),
				page: this.getDefaultPageNumber(),
			});
			return this;
		}

		getPager() {
			return this.getWorking("pager");
		}
	}

	const manifest$6 = {};

	const services$5 = {};

	var mod_1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$6,
		notFilter: notFilter,
		services: services$5
	});

	const notCRUD = notCRUD$1;
	const UICommon = UICommon$1;

	const MODULE_NAME = "";
	const MODEL_NAME = "notification";

	const LABELS = {
	    plural: "not-notification:labelPlural",
	    single: "not-notification:labelSingle",
	};

	class ncNotification extends notCRUD {
	    static MODULE_NAME = MODULE_NAME;
	    static MODEL_NAME = MODEL_NAME;

	    constructor(app, params, { actions: ACTIONS, router: NotificationRouter }) {
	        super(app, `${MODULE_NAME}.${MODEL_NAME}`);
	        this.setModuleName(MODULE_NAME.toLowerCase());
	        this.setModelName(MODEL_NAME.toLowerCase());
	        this.setOptions("names", LABELS);
	        this.setOptions("Validators", {});
	        this.setOptions("params", params);
	        this.setOptions("list", {
	            interface: {
	                combined: true,
	                combinedAction: "inbox",
	                factory: this.getInterface(this.getModelName()),
	            },
	            endless: false,
	            preload: {},
	            sorter: {
	                createdAt: -1,
	            },
	            actions: [],
	            showSearch: true,
	            idField: "_id",
	            fields: [
	                {
	                    path: ":title",
	                    title: "not-notification:fieldTitle",
	                    searchable: true,
	                    maxLength: 50,
	                    sortable: true,
	                },
	                {
	                    path: ":text",
	                    title: "not-notification:fieldText",
	                    searchable: true,
	                    sortable: true,
	                    maxLength: 50,
	                },
	                {
	                    path: ":createdAt",
	                    title: "not-notification:fieldCreatedAt",
	                    sortable: true,
	                    searchable: true,
	                    preprocessor: (value) => {
	                        return UICommon.formatTimestamp(
	                            new Date(value).getTime()
	                        );
	                    },
	                },
	                {
	                    path: ":new",
	                    title: "not-notification:fieldNew",
	                    type: "boolean",
	                    sortable: true,
	                    searchable: true,
	                    preprocessor(value) {
	                        return [{ value }];
	                    },
	                },
	                {
	                    path: ":_id",
	                    title: "not-notification:fieldAction",
	                    type: "button",
	                    preprocessor: (value) => {
	                        return [
	                            {
	                                action: () => this.goDetails(value),
	                                title: "not-notification:actionDetails",
	                                size: "small",
	                            },
	                            {
	                                action: () => this.goDelete(value),
	                                color: "danger",
	                                title: "not-notification:actionDelete",
	                                size: "small",
	                                style: "outlined",
	                            },
	                        ];
	                    },
	                },
	            ],
	        });
	        this.start();
	        return this;
	    }

	    goInbox() {
	        this.app
	            .getWorking("router")
	            .navigate(this.getModelActionURL(false, "inbox"));
	    }

	    goMarkAsRead(value) {
	        this.app
	            .getWorking("router")
	            .navigate(this.getModelActionURL(value, "markAsRead"));
	    }

	    updateNotifications() {
	        this.app.getService("nsNotification").update();
	    }
	}

	const {notTopMenu: notTopMenu$2} = Frame;

	const INTERVAL = 360;
	const SECTION_ID$1 = 'notification';
	const SHORT_LIST_SIZE = 5;
	const INIT_UPDATE_DELAY = 5;

	const MAX_TITLE_LENGTH = 50;

	class nsNotification {
	  INTERVAL;
	  SHORT_LIST_SIZE;
	  INIT_UPDATE_DELAY;

	  constructor(app) {
	    this.app = app;
	    this.interface = this.app.getInterface('notification');
	    if(this.interface){
	      this.init();
	    }else {
	      app.error('no notification interface');
	    }
	  };

	  init() {
	    setTimeout(this.update.bind(this), INIT_UPDATE_DELAY * 100);
	    this.int = setInterval(this.update.bind(this), INTERVAL * 1000);
	    window.addEventListener('unload', () => {
	      clearInterval(this.int);
	      delete this.app;
	      delete this.interface;
	    });
	  }

	  update() {
	    this.updateLatestShort();
	  }

	  updateLatestShort() {
	    this.interface({}).setFilter({new: true}).setPageSize(SHORT_LIST_SIZE).$inbox({})
	      .then((res) => {
	        if (res && res.status === 'ok') {
	          this.app.log(res.result);
	          if (res.result) {
	            let menuItems = this.createMenuItems(res.result);
	            notTopMenu$2.updateSectionItems('notification', () => {
	              return menuItems;
	            });
	            setTimeout(()=>{
	              this.app.emit(`tag-${SECTION_ID$1}:update`, {
	                title: res.result.freshCount > 0 ? res.result.freshCount : false
	              });
	            }, 1000);
	          }
	        }
	      })
	      .catch(e => {
	        this.app.error(e);
	      });
	  }

	  createMenuItems({list, count}) {
	    let items = list.map(this.createMenuItem.bind(this));
	    items.push(this.createShowAllMenuItem(count));
	    items.push(this.createMarkAllAsReadMenuItem());
	    return items;
	  }

	  createMenuItem(item) {
	    let time = this.getTimeDiff(item);
	    let title = item.title;
	    if(title.length > MAX_TITLE_LENGTH){
	      title = title.substr(0, MAX_TITLE_LENGTH);
	      title+='...';
	    }
	    return {
	      id: `${SECTION_ID$1}.${item._id}`,
	      section: SECTION_ID$1,
	      title: `${title} - ${time}`,
	      url: `/notification/${item._id}`
	    };
	  }

	  createShowAllMenuItem(count) {
	    return {
	      break: true,
	      id: `${SECTION_ID$1}.all`,
	      section: SECTION_ID$1,
	      title: say(`not-notification:showAll`, {count}),
	      url: '/notification/inbox'
	    };
	  }

	  createMarkAllAsReadMenuItem() {
	    return {
	      break: true,
	      id: `${SECTION_ID$1}.markAllAsRead`,
	      section: SECTION_ID$1,
	      classes: 'is-clickable',
	      title: `not-notification:markAllAsRead`,
	      action:  this.markAllAsRead.bind(this)
	    };
	  }

	  markAllAsRead(){
	    this.interface({}).$markAllAsRead()
	      .then(()=>{
	        this.update();
	      })
	      .catch((e) => {
	        this.app.error(e);
	      });
	  }

	  declOfNum(n, text_forms) {
	    n = Math.abs(n) % 100;
	    let n1 = n % 10;
	    if (n > 10 && n < 20) { return text_forms[2]; }
	    if (n1 > 1 && n1 < 5) { return text_forms[1]; }
	    if (n1 == 1) { return text_forms[0]; }
	    return text_forms[2];
	  }

	  getTimeDiff({
	    createdAt
	  }) {
	    let currentTime = new Date().getTime(),
	      date = new Date(createdAt).getTime();
	    let sec = Math.round((currentTime - date) / 1000);
	    let unit;
	    if (sec < 60) {
	      unit = this.declOfNum(
	        sec,
	        [
	          'not-notification:second-1',
	          'not-notification:second-2',
	          'not-notification:second-3'
	        ]
	      );
	      return say('not-notification:timeAgo', {time: sec, unit: say(unit)});
	    } else if (sec < 3600) {
	      let min = Math.floor(sec / 60);
	      unit = this.declOfNum(
	        min,
	        [
	        'not-notification:minute-1',
	        'not-notification:minute-2',
	        'not-notification:minute-3'
	        ]
	      );
	      return say('not-notification:timeAgo', {time: min, unit: say(unit)});
	    } else {
	      let hours = Math.floor(sec / (60 * 60));
	      unit = this.declOfNum(
	        hours,
	        [
	          'not-notification:hour-1',
	          'not-notification:hour-2',
	          'not-notification:hour-3'
	        ]
	      );
	      return say('not-notification:timeAgo', {time: hours, unit: say(unit)});
	    }
	  }

	}

	/*!
	 * bulma-toast 2.4.4 
	 * (c) 2018-present @rfoel <rafaelfr@outlook.com> 
	 * Released under the MIT License.
	 */
	function ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d);}return c}function _objectSpread2(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?ownKeys(Object(b),!0).forEach(function(c){_defineProperty(a,c,b[c]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c));});return a}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c);}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),a}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}var baseConfig={duration:2e3,position:"top-right",closeOnClick:!0,opacity:1,single:!1,offsetTop:0,offsetBottom:0,offsetLeft:0,offsetRight:0,extraClasses:""},defaults=_objectSpread2({},baseConfig),containers={},doc=null,COMMON_STYLES="width:100%;z-index:99999;position:fixed;pointer-events:none;display:flex;flex-direction:column;padding:15px;",CONTAINER_STYLES=function(a,b,c,d,e){return "top-left"===a?"left:".concat(d,";top:").concat(b,";text-align:left;align-items:flex-start;"):"top-right"===a?"right:".concat(e,";top:").concat(b,";text-align:right;align-items:flex-end;"):"top-center"===a?"top:".concat(b,";left:0;right:0;text-align:center;align-items:center;"):"bottom-left"===a?"left:".concat(d,";bottom:").concat(c,";text-align:left;align-items:flex-start;"):"bottom-right"===a?"right:".concat(e,";bottom:").concat(c,";text-align:right;align-items:flex-end;"):"bottom-center"===a?"bottom:".concat(c,";left:0;right:0;text-align:center;align-items:center;"):"center"===a?"top:0;left:0;right:0;bottom:0;flex-flow:column;justify-content:center;align-items:center;":void 0};function getDocument(){var a;return null!==(a=doc)&&void 0!==a?a:document}function findOrCreateContainer(a,b,c,d,e,f){if(containers.position)return containers.position;var g=getDocument().createElement("div");return g.setAttribute("style",COMMON_STYLES+CONTAINER_STYLES(b,c,d,e,f)),a.appendChild(g),containers.position=g,g}function toast(a){if(!a.message)throw new Error("message is required");var b=_objectSpread2(_objectSpread2({},defaults),a),c=new Toast(b),d=findOrCreateContainer(b.appendTo||getDocument().body,b.position||defaults.position,b.offsetTop||defaults.offsetTop,b.offsetBottom||defaults.offsetBottom,b.offsetLeft||defaults.offsetLeft,b.offsetRight||defaults.offsetRight);if(b.single)for(var e=d.lastElementChild;e;)d.removeChild(e),e=d.lastElementChild;d.appendChild(c.element);}var Toast=/*#__PURE__*/function(){function a(b){var c=this;_classCallCheck(this,a),this.element=getDocument().createElement("div"),this.opacity=b.opacity,this.type=b.type,this.animate=b.animate,this.dismissible=b.dismissible,this.closeOnClick=b.closeOnClick,this.message=b.message,this.duration=b.duration,this.pauseOnHover=b.pauseOnHover,this.offsetTop=b.offsetTop,this.offsetBottom=b.offsetBottom,this.offsetLeft=b.offsetLeft,this.offsetRight=b.offsetRight,this.extraClasses=b.extraClasses;var d="width:auto;pointer-events:auto;display:inline-flex;white-space:pre-wrap;opacity:".concat(this.opacity,";"),e=["notification",this.extraClasses];if(this.type&&e.push(this.type),this.animate&&this.animate["in"]){var f="animate__".concat(this.animate["in"]),g=this.animate.speed?"animate__".concat(this.animate.speed):"animate__faster";e.push("animate__animated ".concat(f," ").concat(g)),this.onAnimationEnd(function(){return c.element.classList.remove(f)});}if(this.element.className=e.join(" "),this.dismissible){var h=getDocument().createElement("button");h.className="delete",h.addEventListener("click",function(){c.destroy();}),this.element.insertAdjacentElement("afterbegin",h);}else d+="padding: 1.25rem 1.5rem";this.closeOnClick&&this.element.addEventListener("click",function(){c.destroy();}),this.element.setAttribute("style",d),"string"==typeof this.message?this.element.insertAdjacentHTML("beforeend",this.message):this.element.appendChild(this.message);var i=new Timer(function(){c.destroy();},this.duration);this.pauseOnHover&&(this.element.addEventListener("mouseover",function(){i.pause();}),this.element.addEventListener("mouseout",function(){i.resume();}));}return _createClass(a,[{key:"destroy",value:function(){var a=this;this.animate&&this.animate.out?(this.element.classList.add("animate__".concat(this.animate.out)),this.onAnimationEnd(function(){a.removeParent(a.element.parentNode),a.element.remove();})):(this.removeParent(this.element.parentNode),this.element.remove());}},{key:"removeParent",value:function(a){a&&1>=a.children.length&&(a.remove(),delete containers.position);}},{key:"onAnimationEnd",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:function(){},b={animation:"animationend",OAnimation:"oAnimationEnd",MozAnimation:"mozAnimationEnd",WebkitAnimation:"webkitAnimationEnd"};for(var c in b)if(void 0!==this.element.style[c]){this.element.addEventListener(b[c],function(){return a()});break}}}]),a}(),Timer=/*#__PURE__*/function(){function a(b,c){_classCallCheck(this,a),this.timer,this.start,this.remaining=c,this.callback=b,this.resume();}return _createClass(a,[{key:"pause",value:function(){"undefined"==typeof document||(window.clearTimeout(this.timer),this.remaining-=new Date-this.start);}},{key:"resume",value:function(){"undefined"==typeof document||(this.start=new Date,window.clearTimeout(this.timer),this.timer=window.setTimeout(this.callback,this.remaining));}}]),a}();

	function show(data){
		toast({
			...data,
			dismissible: true,
			animate: { in: "fadeIn",
				out: "fadeOut"
			},
			closeOnClick: true
		});
	}

	class nsToast {
		constructor(app) {
			this.app = app;
		}

		success(message){
			this.custom({
				type: 'is-success',
				message: say(message)
			});
		}

		error(title, message){
			title = say(title);
			message = say(message);
			this.custom({
				type: 'is-danger',
				message: `${title}: ${message}`
			});
		}

		custom(data){
			show(data);
		}

		static show = show;
	}

	const {notCommon: notCommon$1} = Frame;

	async function onUpdate(/*payload*/){
		try{
			notCommon$1.getApp().getService('nsNotification').update();
		}catch(e){
			notCommon$1.error(e);
		}
	}

	const main$1 = {
		router:{
			routes:{
				event: {
					'notification//update': onUpdate
				}
			}
		}
	};

	const services$4 = { nsNotification, nsToast };

	const wsc$2 = {
		main: main$1
	};

	const manifest$5 = {
		router: {
			manifest: [
				ncNotification.getRoutes()
			]
		},
		menu:{
			top:{
				sections:[
					{
						id: 'notification',
						url: '/notification',
						icon: {
							font: 'envelope',
							size: 'medium',
							svg: '',
							src: '',
						},
						tag: {
							padding: 	'small',
							bold: 		true,
							color: 		'warning',
							title: 		0
						},
						showOnTouch: true,
						place: 'end'
					}
				]
			},
			side: {
				items: [{
					id: 			'account.notification',
					section: 	'account',
					title: 		'not-notification:labelPlural',
					url: 			'/notification'
				}]
			}
		}
	};

	var mod_2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$5,
		ncNotification: ncNotification,
		services: services$4,
		wsc: wsc$2
	});

	/**
	 * detects current locale, loads dictionary from server
	 *
	 **/

	const SECTION_ID = "locale";

	const { notTopMenu: notTopMenu$1 } = Frame;

	class nsLocale {
	    constructor(app) {
	        this.app = app;
	        this.locales = [];
	        this.failures = 0;
	        this.app.on("wsClient:main:connected", this.update.bind(this));
	        notLocale$1.on("change", () => {
	            this.app.emit("locale");
	        });
	    }

	    /**
	     * Creates network interface for this service
	     */
	    interface(data) {
	        return this.app.getInterface("locale")(data);
	    }

	    /**
	     * Retrieves dictionary for current locale
	     * sets dictionary in notLocale object
	     */
	    async update() {
	        try {
	            await this.updateAvailable();
	            let res = await this.interface({
	                locale: this.getCurrentLocale(),
	            }).$get({});
	            if (res.status === "ok" && res.result) {
	                notLocale$1.set(res.result);
	            } else {
	                this.scheduleUpdate();
	            }
	        } catch (e) {
	            notCommon$2.error(e);
	            this.scheduleUpdate();
	        }
	    }

	    scheduleUpdate() {
	        this.failures++;
	        if (this.failures < 100) {
	            setTimeout(this.update.bind(this), 1000 * this.failures);
	        } else {
	            notCommon$2.error("Too many failures of locale loading");
	        }
	    }

	    async updateAvailable() {
	        try {
	            let res = await this.interface({}).$available({});
	            if (res.status === "ok" && res.result) {
	                this.setAvailable(res.result);
	            }
	        } catch (e) {
	            notCommon$2.error(e);
	        }
	    }

	    updateUI(list) {
	        let menuItems = this.createMenuItems(list);
	        notTopMenu$1.updateSectionItems(SECTION_ID, () => {
	            return menuItems;
	        });
	        setTimeout(() => {
	            this.app.emit(`tag-${SECTION_ID}:update`, {
	                title: this.getCurrentLocale(),
	            });
	        }, 1000);
	    }

	    createMenuItems(list) {
	        let items = list.map(this.createMenuItem.bind(this));
	        return items;
	    }

	    createMenuItem(item) {
	        return {
	            id: `${SECTION_ID}.${item}`,
	            section: SECTION_ID,
	            title: item,
	            classes: " is-clickable ",
	            action: this.changeLocale.bind(this, item),
	        };
	    }

	    changeLocale(locale) {
	        this.saveLocaleToStore(locale);
	        this.update();
	    }

	    /**
	     * @returns {string}   code of current locale
	     **/
	    getCurrentLocale() {
	        let stored = this.restoreLocaleFromStore();
	        if (stored) {
	            if (this.locales.includes(stored)) {
	                return stored;
	            }
	        }
	        return this.selectBest();
	    }

	    /**
	     * @returns {Promise<Array>}   of locales objects {code, title}
	     **/
	    getAvailable() {
	        return this.interface().$available({});
	    }

	    setAvailable(list) {
	        this.locales = list;
	        this.updateUI(list);
	    }

	    restoreLocaleFromStore() {
	        if (window.localStorage) {
	            try {
	                return window.localStorage.getItem("locale");
	            } catch (e) {
	                this.app.error(e);
	                return false;
	            }
	        }
	        return false;
	    }

	    saveLocaleToStore(locale) {
	        if (window.localStorage) {
	            try {
	                return window.localStorage.setItem("locale", locale);
	            } catch (e) {
	                this.app.error(e);
	                return false;
	            }
	        }
	        return false;
	    }

	    selectBest() {
	        if (navigator.languages) {
	            let locale = navigator.languages.find((itm) => {
	                return this.locales.includes(itm);
	            });
	            if (locale) {
	                return locale;
	            }
	        }
	        return this.app.getWorking(
	            "locale",
	            this.app.getOptions("modules.locale.default", "ru")
	        );
	    }
	}

	const services$3 = { nsLocale };
	const manifest$4 = {
	  modules:{
	    locale:{
	      default: 'ru'
	    }
	  },
	  menu:{
	    top:{
	      sections:[
					{
						id: 'locale',
	          title: '',
						icon: {
							font: 'language',
							size: 'medium',
							svg: '',
							src: '',
						},
						tag: {
							padding: 	'small',
							bold: 		true,
							color: 		'success',
							title: 		''
						},
						showOnTouch: true,
						place: 'end'
					}
				]
	    }
	  }
	};

	var mod_3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$4,
		services: services$3
	});

	/* node_modules/not-key/src/controllers/common/UIListOfURLs.svelte generated by Svelte v4.2.19 */

	function create_if_block_1$1(ctx) {
		let span;

		function select_block_type(ctx, dirty) {
			if (/*valid*/ ctx[6] === true) return create_if_block_2$1;
			if (/*valid*/ ctx[6] === false) return create_if_block_3$1;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (76:35) 
	function create_if_block_3$1(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (74:6) {#if valid === true }
	function create_if_block_2$1(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (85:2) {:else}
	function create_else_block$1(ctx) {
		let t;

		return {
			c() {
				t = text(" ");
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p: noop$1,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (83:2) {#if !(validated && valid) && (inputStarted) }
	function create_if_block$1(ctx) {
		let t;

		return {
			c() {
				t = text(/*helper*/ ctx[11]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*helper*/ 2048) set_data(t, /*helper*/ ctx[11]);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	function create_fragment$1(ctx) {
		let div;
		let textarea;
		let textarea_id_value;
		let textarea_class_value;
		let textarea_aria_controls_value;
		let textarea_aria_describedby_value;
		let t0;
		let t1;
		let p;
		let p_class_value;
		let p_id_value;
		let mounted;
		let dispose;
		let if_block0 = /*validated*/ ctx[7] === true && create_if_block_1$1(ctx);

		function select_block_type_1(ctx, dirty) {
			if (!(/*validated*/ ctx[7] && /*valid*/ ctx[6]) && /*inputStarted*/ ctx[0]) return create_if_block$1;
			return create_else_block$1;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block1 = current_block_type(ctx);

		return {
			c() {
				div = element("div");
				textarea = element("textarea");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				p = element("p");
				if_block1.c();
				attr(textarea, "id", textarea_id_value = "form-field-listOfUrls-" + /*fieldname*/ ctx[2]);
				attr(textarea, "name", /*fieldname*/ ctx[2]);
				attr(textarea, "class", textarea_class_value = "textarea " + /*validationClasses*/ ctx[9]);
				textarea.readOnly = /*readonly*/ ctx[5];
				textarea.disabled = /*readonly*/ ctx[5];
				attr(textarea, "invalid", /*invalid*/ ctx[10]);
				textarea.required = /*required*/ ctx[4];
				attr(textarea, "rows", /*rows*/ ctx[3]);
				attr(textarea, "placeholder", /*placeholder*/ ctx[1]);
				attr(textarea, "aria-controls", textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(textarea, "aria-describedby", textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(div, "class", "control");
				attr(p, "class", p_class_value = "help " + /*validationClasses*/ ctx[9]);
				attr(p, "id", p_id_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, textarea);
				set_input_value(textarea, /*listText*/ ctx[8]);
				append(div, t0);
				if (if_block0) if_block0.m(div, null);
				insert(target, t1, anchor);
				insert(target, p, anchor);
				if_block1.m(p, null);

				if (!mounted) {
					dispose = [
						listen(textarea, "input", /*textarea_input_handler*/ ctx[19]),
						listen(textarea, "change", /*onBlur*/ ctx[12]),
						listen(textarea, "input", /*onInput*/ ctx[13])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*fieldname*/ 4 && textarea_id_value !== (textarea_id_value = "form-field-listOfUrls-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "id", textarea_id_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(textarea, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*validationClasses*/ 512 && textarea_class_value !== (textarea_class_value = "textarea " + /*validationClasses*/ ctx[9])) {
					attr(textarea, "class", textarea_class_value);
				}

				if (dirty & /*readonly*/ 32) {
					textarea.readOnly = /*readonly*/ ctx[5];
				}

				if (dirty & /*readonly*/ 32) {
					textarea.disabled = /*readonly*/ ctx[5];
				}

				if (dirty & /*invalid*/ 1024) {
					attr(textarea, "invalid", /*invalid*/ ctx[10]);
				}

				if (dirty & /*required*/ 16) {
					textarea.required = /*required*/ ctx[4];
				}

				if (dirty & /*rows*/ 8) {
					attr(textarea, "rows", /*rows*/ ctx[3]);
				}

				if (dirty & /*placeholder*/ 2) {
					attr(textarea, "placeholder", /*placeholder*/ ctx[1]);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_controls_value !== (textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-controls", textarea_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_describedby_value !== (textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-describedby", textarea_aria_describedby_value);
				}

				if (dirty & /*listText*/ 256) {
					set_input_value(textarea, /*listText*/ ctx[8]);
				}

				if (/*validated*/ ctx[7] === true) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$1(ctx);
						if_block0.c();
						if_block0.m(div, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1.d(1);
					if_block1 = current_block_type(ctx);

					if (if_block1) {
						if_block1.c();
						if_block1.m(p, null);
					}
				}

				if (dirty & /*validationClasses*/ 512 && p_class_value !== (p_class_value = "help " + /*validationClasses*/ ctx[9])) {
					attr(p, "class", p_class_value);
				}

				if (dirty & /*fieldname*/ 4 && p_id_value !== (p_id_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(p, "id", p_id_value);
				}
			},
			i: noop$1,
			o: noop$1,
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t1);
					detach(p);
				}

				if (if_block0) if_block0.d();
				if_block1.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$1($$self, $$props, $$invalidate) {
		let allErrors;
		let helper;
		let invalid;
		let validationClasses;
		const UICommon = { Elements };
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = [] } = $$props;
		let { placeholder = 'List of urls' } = $$props;
		let { fieldname = 'list-of-urls' } = $$props;
		let { rows = 10 } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;
		let listText = '';

		onMount(() => {
			$$invalidate(8, listText = value.join("\n"));
		});

		function onBlur(ev) {
			$$invalidate(14, value = listText.split("\n"));
			let data = { field: fieldname, value };
			$$invalidate(0, inputStarted = true);
			dispatch('change', data);
			return true;
		}

		function onInput(ev) {
			$$invalidate(14, value = listText.split("\n"));
			let data = { field: fieldname, value };
			$$invalidate(0, inputStarted = true);
			dispatch('change', data);
			return true;
		}

		function textarea_input_handler() {
			listText = this.value;
			$$invalidate(8, listText);
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(0, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(14, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('rows' in $$props) $$invalidate(3, rows = $$props.rows);
			if ('required' in $$props) $$invalidate(4, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(5, readonly = $$props.readonly);
			if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(7, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(15, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(16, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(17, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*errors, formErrors*/ 98304) {
				$$invalidate(18, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*allErrors, placeholder*/ 262146) {
				$$invalidate(11, helper = allErrors ? allErrors.join(', ') : placeholder);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 131136) {
				$$invalidate(10, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 65) {
				$$invalidate(9, validationClasses = valid === true || !inputStarted
				? UICommon.CLASS_OK
				: UICommon.CLASS_ERR);
			}
		};

		return [
			inputStarted,
			placeholder,
			fieldname,
			rows,
			required,
			readonly,
			valid,
			validated,
			listText,
			validationClasses,
			invalid,
			helper,
			onBlur,
			onInput,
			value,
			errors,
			formErrors,
			formLevelError,
			allErrors,
			textarea_input_handler
		];
	}

	class UIListOfURLs extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$1, create_fragment$1, safe_not_equal, {
				inputStarted: 0,
				value: 14,
				placeholder: 1,
				fieldname: 2,
				rows: 3,
				required: 4,
				readonly: 5,
				valid: 6,
				validated: 7,
				errors: 15,
				formErrors: 16,
				formLevelError: 17
			});
		}
	}

	/* node_modules/not-key/src/controllers/common/UIJSON.svelte generated by Svelte v4.2.19 */

	function create_else_block(ctx) {
		let textarea;
		let textarea_id_value;
		let textarea_class_value;
		let textarea_aria_controls_value;
		let textarea_aria_describedby_value;
		let t0;
		let t1;
		let if_block1_anchor;
		let mounted;
		let dispose;
		let if_block0 = /*icon*/ ctx[3] && create_if_block_4(ctx);
		let if_block1 = /*validated*/ ctx[8] === true && create_if_block_1(ctx);

		return {
			c() {
				textarea = element("textarea");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(textarea, "id", textarea_id_value = "form-field-textarea-" + /*fieldname*/ ctx[2]);
				attr(textarea, "invalid", /*invalid*/ ctx[12]);
				textarea.disabled = /*disabled*/ ctx[7];
				textarea.required = /*required*/ ctx[5];
				textarea.readOnly = /*readonly*/ ctx[6];
				attr(textarea, "class", textarea_class_value = "textarea " + /*validationClasses*/ ctx[11]);
				attr(textarea, "name", /*fieldname*/ ctx[2]);
				attr(textarea, "placeholder", /*placeholder*/ ctx[1]);
				attr(textarea, "rows", /*rows*/ ctx[4]);
				attr(textarea, "aria-controls", textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
				attr(textarea, "aria-describedby", textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, textarea, anchor);
				set_input_value(textarea, /*editingValue*/ ctx[9]);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);

				if (!mounted) {
					dispose = [
						listen(textarea, "blur", /*onBlur*/ ctx[16]),
						listen(textarea, "input", /*textarea_input_handler*/ ctx[22])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*fieldname*/ 4 && textarea_id_value !== (textarea_id_value = "form-field-textarea-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "id", textarea_id_value);
				}

				if (dirty & /*invalid*/ 4096) {
					attr(textarea, "invalid", /*invalid*/ ctx[12]);
				}

				if (dirty & /*disabled*/ 128) {
					textarea.disabled = /*disabled*/ ctx[7];
				}

				if (dirty & /*required*/ 32) {
					textarea.required = /*required*/ ctx[5];
				}

				if (dirty & /*readonly*/ 64) {
					textarea.readOnly = /*readonly*/ ctx[6];
				}

				if (dirty & /*validationClasses*/ 2048 && textarea_class_value !== (textarea_class_value = "textarea " + /*validationClasses*/ ctx[11])) {
					attr(textarea, "class", textarea_class_value);
				}

				if (dirty & /*fieldname*/ 4) {
					attr(textarea, "name", /*fieldname*/ ctx[2]);
				}

				if (dirty & /*placeholder*/ 2) {
					attr(textarea, "placeholder", /*placeholder*/ ctx[1]);
				}

				if (dirty & /*rows*/ 16) {
					attr(textarea, "rows", /*rows*/ ctx[4]);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_controls_value !== (textarea_aria_controls_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-controls", textarea_aria_controls_value);
				}

				if (dirty & /*fieldname*/ 4 && textarea_aria_describedby_value !== (textarea_aria_describedby_value = "input-field-helper-" + /*fieldname*/ ctx[2])) {
					attr(textarea, "aria-describedby", textarea_aria_describedby_value);
				}

				if (dirty & /*editingValue*/ 512) {
					set_input_value(textarea, /*editingValue*/ ctx[9]);
				}

				if (/*icon*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4(ctx);
						if_block0.c();
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*validated*/ ctx[8] === true) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(textarea);
					detach(t0);
					detach(t1);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (58:6) {#if readonly }
	function create_if_block(ctx) {
		let pre;
		let t;

		return {
			c() {
				pre = element("pre");
				t = text(/*readonlyValueStringified*/ ctx[10]);
			},
			m(target, anchor) {
				insert(target, pre, anchor);
				append(pre, t);
			},
			p(ctx, dirty) {
				if (dirty & /*readonlyValueStringified*/ 1024) set_data(t, /*readonlyValueStringified*/ ctx[10]);
			},
			d(detaching) {
				if (detaching) {
					detach(pre);
				}
			}
		};
	}

	// (73:6) {#if icon }
	function create_if_block_4(ctx) {
		let span;
		let i;
		let i_class_value;

		return {
			c() {
				span = element("span");
				i = element("i");
				attr(i, "class", i_class_value = "fas fa-" + /*icon*/ ctx[3]);
				attr(span, "class", "icon is-small is-left");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, i);
			},
			p(ctx, dirty) {
				if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fas fa-" + /*icon*/ ctx[3])) {
					attr(i, "class", i_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (76:6) {#if validated === true }
	function create_if_block_1(ctx) {
		let span;

		function select_block_type_1(ctx, dirty) {
			if (/*valid*/ ctx[0] === true) return create_if_block_2;
			if (/*valid*/ ctx[0] === false) return create_if_block_3;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block = current_block_type && current_block_type(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "icon is-small is-right");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(span, null);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) {
					if_block.d();
				}
			}
		};
	}

	// (80:37) 
	function create_if_block_3(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-exclamation-triangle");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	// (78:8) {#if valid === true }
	function create_if_block_2(ctx) {
		let i;

		return {
			c() {
				i = element("i");
				attr(i, "class", "fas fa-check");
			},
			m(target, anchor) {
				insert(target, i, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(i);
				}
			}
		};
	}

	function create_fragment(ctx) {
		let div;
		let div_class_value;
		let t;
		let errorslist;
		let updating_errors;
		let updating_show;
		let updating_classes;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*readonly*/ ctx[6]) return create_if_block;
			return create_else_block;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		function errorslist_errors_binding(value) {
			/*errorslist_errors_binding*/ ctx[23](value);
		}

		function errorslist_show_binding(value) {
			/*errorslist_show_binding*/ ctx[24](value);
		}

		function errorslist_classes_binding(value) {
			/*errorslist_classes_binding*/ ctx[25](value);
		}

		let errorslist_props = {
			id: "input-field-helper-" + /*fieldname*/ ctx[2]
		};

		if (/*allErrors*/ ctx[14] !== void 0) {
			errorslist_props.errors = /*allErrors*/ ctx[14];
		}

		if (/*showErrors*/ ctx[13] !== void 0) {
			errorslist_props.show = /*showErrors*/ ctx[13];
		}

		if (/*validationClasses*/ ctx[11] !== void 0) {
			errorslist_props.classes = /*validationClasses*/ ctx[11];
		}

		errorslist = new Ui_errors_list({ props: errorslist_props });
		binding_callbacks.push(() => bind(errorslist, 'errors', errorslist_errors_binding));
		binding_callbacks.push(() => bind(errorslist, 'show', errorslist_show_binding));
		binding_callbacks.push(() => bind(errorslist, 'classes', errorslist_classes_binding));

		return {
			c() {
				div = element("div");
				if_block.c();
				t = space();
				create_component(errorslist.$$.fragment);
				attr(div, "class", div_class_value = "control " + /*iconClasses*/ ctx[15]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				insert(target, t, anchor);
				mount_component(errorslist, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div, null);
					}
				}

				if (!current || dirty & /*iconClasses*/ 32768 && div_class_value !== (div_class_value = "control " + /*iconClasses*/ ctx[15])) {
					attr(div, "class", div_class_value);
				}

				const errorslist_changes = {};
				if (dirty & /*fieldname*/ 4) errorslist_changes.id = "input-field-helper-" + /*fieldname*/ ctx[2];

				if (!updating_errors && dirty & /*allErrors*/ 16384) {
					updating_errors = true;
					errorslist_changes.errors = /*allErrors*/ ctx[14];
					add_flush_callback(() => updating_errors = false);
				}

				if (!updating_show && dirty & /*showErrors*/ 8192) {
					updating_show = true;
					errorslist_changes.show = /*showErrors*/ ctx[13];
					add_flush_callback(() => updating_show = false);
				}

				if (!updating_classes && dirty & /*validationClasses*/ 2048) {
					updating_classes = true;
					errorslist_changes.classes = /*validationClasses*/ ctx[11];
					add_flush_callback(() => updating_classes = false);
				}

				errorslist.$set(errorslist_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errorslist.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errorslist.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
				}

				if_block.d();
				destroy_component(errorslist, detaching);
			}
		};
	}

	function instance($$self, $$props, $$invalidate) {
		let iconClasses;
		let allErrors;
		let showErrors;
		let invalid;
		let validationClasses;
		let readonlyValueStringified;
		let dispatch = createEventDispatcher();
		let { inputStarted = false } = $$props;
		let { value = {} } = $$props;
		let { placeholder = 'input some text here, please' } = $$props;
		let { fieldname = 'textarea' } = $$props;
		let { icon = false } = $$props;
		let { rows = 10 } = $$props;
		let { required = true } = $$props;
		let { readonly = false } = $$props;
		let { disabled = false } = $$props;
		let { valid = true } = $$props;
		let { validated = false } = $$props;
		let { errors = false } = $$props;
		let { formErrors = false } = $$props;
		let { formLevelError = false } = $$props;

		function onBlur(ev) {
			try {
				$$invalidate(18, value = JSON.parse(editingValue));
				$$invalidate(0, valid = true);
				$$invalidate(19, errors = false);
				let data = { field: fieldname, value };
				$$invalidate(17, inputStarted = true);
				dispatch('change', data);
				return true;
			} catch(e) {
				$$invalidate(0, valid = false);
				$$invalidate(19, errors = ["JSON parsing error"]);
			}
		}

		let editingValue = '';

		onMount(() => {
			$$invalidate(9, editingValue = JSON.stringify(value, null, 4));
		});

		function textarea_input_handler() {
			editingValue = this.value;
			$$invalidate(9, editingValue);
		}

		function errorslist_errors_binding(value) {
			allErrors = value;
			(($$invalidate(14, allErrors), $$invalidate(19, errors)), $$invalidate(20, formErrors));
		}

		function errorslist_show_binding(value) {
			showErrors = value;
			((($$invalidate(13, showErrors), $$invalidate(8, validated)), $$invalidate(0, valid)), $$invalidate(17, inputStarted));
		}

		function errorslist_classes_binding(value) {
			validationClasses = value;
			(($$invalidate(11, validationClasses), $$invalidate(0, valid)), $$invalidate(17, inputStarted));
		}

		$$self.$$set = $$props => {
			if ('inputStarted' in $$props) $$invalidate(17, inputStarted = $$props.inputStarted);
			if ('value' in $$props) $$invalidate(18, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('fieldname' in $$props) $$invalidate(2, fieldname = $$props.fieldname);
			if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
			if ('rows' in $$props) $$invalidate(4, rows = $$props.rows);
			if ('required' in $$props) $$invalidate(5, required = $$props.required);
			if ('readonly' in $$props) $$invalidate(6, readonly = $$props.readonly);
			if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
			if ('valid' in $$props) $$invalidate(0, valid = $$props.valid);
			if ('validated' in $$props) $$invalidate(8, validated = $$props.validated);
			if ('errors' in $$props) $$invalidate(19, errors = $$props.errors);
			if ('formErrors' in $$props) $$invalidate(20, formErrors = $$props.formErrors);
			if ('formLevelError' in $$props) $$invalidate(21, formLevelError = $$props.formLevelError);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*icon*/ 8) {
				$$invalidate(15, iconClasses = (icon ? ' has-icons-left ' : '') + ' has-icons-right ');
			}

			if ($$self.$$.dirty & /*errors, formErrors*/ 1572864) {
				$$invalidate(14, allErrors = [].concat(errors ? errors : [], formErrors ? formErrors : []));
			}

			if ($$self.$$.dirty & /*validated, valid, inputStarted*/ 131329) {
				$$invalidate(13, showErrors = !(validated && valid) && inputStarted);
			}

			if ($$self.$$.dirty & /*valid, formLevelError*/ 2097153) {
				$$invalidate(12, invalid = valid === false || formLevelError);
			}

			if ($$self.$$.dirty & /*valid, inputStarted*/ 131073) {
				$$invalidate(11, validationClasses = valid === true || !inputStarted
				? UICommon$1.CLASS_OK
				: UICommon$1.CLASS_ERR);
			}

			if ($$self.$$.dirty & /*value*/ 262144) {
				$$invalidate(10, readonlyValueStringified = JSON.stringify(value, null, 4));
			}
		};

		return [
			valid,
			placeholder,
			fieldname,
			icon,
			rows,
			required,
			readonly,
			disabled,
			validated,
			editingValue,
			readonlyValueStringified,
			validationClasses,
			invalid,
			showErrors,
			allErrors,
			iconClasses,
			onBlur,
			inputStarted,
			value,
			errors,
			formErrors,
			formLevelError,
			textarea_input_handler,
			errorslist_errors_binding,
			errorslist_show_binding,
			errorslist_classes_binding
		];
	}

	class UIJSON extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance, create_fragment, safe_not_equal, {
				inputStarted: 17,
				value: 18,
				placeholder: 1,
				fieldname: 2,
				icon: 3,
				rows: 4,
				required: 5,
				readonly: 6,
				disabled: 7,
				valid: 0,
				validated: 8,
				errors: 19,
				formErrors: 20,
				formLevelError: 21
			});
		}
	}

	const uis$1 = { UIListOfUrls: UIListOfURLs, UIJSON };

	const manifest$3 = {};

	var mod_4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$3,
		uis: uis$1
	});

	class nsErrorReporter {
	    constructor(app) {
	        this.app = app;
	        this.reporter = new notErrorReporter();
	        this.reporter.setOrigin({ server: window.location.host });
	        this.reporter.setRegisterAll(
	            this.app.getOptions("module.error.registerAll", true)
	        );
	    }

	    report(e) {
	        return this.reporter.report(e);
	    }
	}

	const manifest$2 = {};
	const services$2 = { nsErrorReporter };

	var mod_5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$2,
		notError: notError,
		notErrorReporter: notErrorReporter,
		notRequestError: notRequestError,
		notValidationError: notValidationError,
		services: services$2
	});

	const STATE = {
	//нет подключения
		NOT_CONNECTED: 0,
		//есть подключение
		CONNECTED: 1,
		//есть авторизация
		AUTHORIZED: 2,
		//нет отклика
		NO_PING: 3,
		//ошибка соединения
		ERRORED: 4
	};

	const STATE_NAME = {
		0: 'Не подключен',
		1: 'Подключен',
		2: 'Авторизован',
		3: 'Нет отклика',
		4: 'Ошибка связи',
	};

	//деятельность объекта, не завершенное дествие
	const ACTIVITY = {
		IDLE: 0,
		//идёт подключение
		CONNECTING: 1,
		//закрытие соединения
		CLOSING: 2,
		//разрыв соединения
		TERMINATING: 3,
		//авторизация по токену
		AUTHORIZING: 4
	};

	const ACTIVITY_NAME = {
		0: 'Простаивает',
		1: 'Открытие связи',
		2: 'Закрытие связи',
		3: 'Обрыв связи',
		4: 'Авторизация',
	};


	//Список кодов закрытия взят с https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
	let WS_CLOSURE_REASONS = {
		1000 : 'Normal Closure',
		1001 : 'Going Away',
		1002 : 'Protocol Error',
		1003 : 'Unsupported Data',
		1005 : 'No Status Recvd',
		1006 : 'Abnormal Closure',
		1007 : 'Invalid frame payload data',
		1008 : 'Policy Violation',
		1009 : 'Message too big',
		1010 : 'Missing Extension',
		1011 : 'Internal Error',
		1012 : 'Service Restart',
		1013 : 'Try Again Later',
		1014 : 'Bad Gateway',
		1015 : 'TLS Handshake'
	};

	//Возвращает описание причины возникновения ивента закрытия WS-подключения
	function mapWsCloseCodes(event){
		if(!event) return 'unknown reason'; //Если event не задан, то причина неизвестна.
		if(event.reason) return event.reason; //Если reason уже задан, возвращаем его.
		//Определяем reason-код и ищем его в WS_CLOSURE_REASONS
		let code = (typeof event.code !== 'undefined'? event.code.toString(): 'undefined');
		if (!isNaN(parseInt(event))){
			code = event;
		}
		return Object.hasOwn(WS_CLOSURE_REASONS, code) ? WS_CLOSURE_REASONS[code] : `Unknown reason: ${code}`;
	}

	const SYMBOL_ACTIVITY$1 = Symbol('activity');
	const SYMBOL_STATE$1 = Symbol('state');
	const DEFAULT_CLIENT_NAME = 'not-ws link';
	const DEFAULT_SERVER_NAME = 'not-ws server';

	const ERR_MSG = {
		REQUEST_TIMEOUT: 'Request timeout',
		MSG_ID_IS_NOT_VALID: 'Message ID is not valid uuidv4',
		MSG_CREDENTIALS_IS_NOT_VALID: 'Message Credentials is not valid!',
		MSG_TYPE_IS_NOT_VALID: 'Message Type is not valid!',
		MSG_NAME_IS_NOT_VALID: 'Message Name is not valid!',
	};

	const PING_TIMEOUT = 5000;
	const HEARTBEAT_INTERVAL = 5000;
	const CLIENT_RECONNECT_TIMEOUT = 5000;
	const CLIENT_RECONNECT_TIMEOUT_LONG = 30000;
	const TIME_OFFSET_REQUEST_INTERVAL = 5 * 60 * 1000;
	const CLIENT_AUTO_RECONNECT = true;

	const TOKEN_TTL = 1800;
	const TOKEN_RENEW_TTL = 300;

	const MSG_TYPE = {
		REQUEST: 'request',
		RESPONSE: 'response',
		EVENT: 'event',
		COMMAND: 'command',
	};

	const DEV_ENV = 'development';

	class notWSException extends Error{
		constructor(){
			super(...arguments);
		}
	}



	let [, hash] = location.hash.split('#');
	const ENV_TYPE = hash;

	var CONST = {
		ENV_TYPE,
		DEV_ENV,
		STATE,
		STATE_NAME,
		ACTIVITY,
		ACTIVITY_NAME,
		WS_CLOSURE_REASONS,
		mapWsCloseCodes,
		HEARTBEAT_INTERVAL,
		SYMBOL_ACTIVITY: SYMBOL_ACTIVITY$1,
		SYMBOL_STATE: SYMBOL_STATE$1,
		DEFAULT_SERVER_NAME,
		DEFAULT_CLIENT_NAME,
		ERR_MSG,
		PING_TIMEOUT,
		CLIENT_RECONNECT_TIMEOUT,
		CLIENT_RECONNECT_TIMEOUT_LONG,
		CLIENT_AUTO_RECONNECT,
		TIME_OFFSET_REQUEST_INTERVAL,
		MSG_TYPE,
		TOKEN_TTL,
		TOKEN_RENEW_TTL,
		notWSException
	};

	//Проверка является ли переменная функцией.
	function isFunc(func){
		return typeof(func) === 'function';
	}

	/**
	* Returns true if argument is Async function
	* @param {function} func to test
	* @return {boolean} if this function is constructed as AsyncFunction
	**/
	function isAsync(func){
		return func.constructor.name === "AsyncFunction";
	}

	/**
	* Executes method in appropriate way inside Promise
	* @param {function} proc function to execute
	* @param {Array} params array of params
	* @return {Promise} results of method execution
	**/
	async function executeFunctionAsAsync (proc, params){
		if (isFunc(proc)) {
			if (isAsync(proc)) {
				return await proc(...params);
			} else {
				return proc(...params);
			}
		}
	//throw new Error("Could not execute `proc` is not a function");
	}

	function noop() {}
	function heartbeat() { this._alive = true;}

	function ObjHas(obj, prop){
		return Object.hasOwn(obj, prop);
	}

	//Проверка строки на JSON(со stackoverflow).
	//http://stackoverflow.com/questions/3710204/how-to-check-if-a-string-is-a-valid-json-string-in-javascript-without-using-try
	let tryParseJSON = function (jsonString){
		try {
			let o = JSON.parse(jsonString);
			// Handle non-exception-throwing cases:
			// Neither JSON.parse(false) or JSON.parse(1234) throw errors, hence the type-checking,
			// but... JSON.parse(null) returns null, and typeof null === "object",
			// so we must check for that, too. Thankfully, null is falsey, so this suffices:
			if (o && typeof o === "object") {
				return o;
			}
		}catch (e) {
			// eslint-disable-next-line no-console
			console.error(e);
		}
		return false;
	};

	function isArray(val){
		return Array.isArray(val);
	}

	let capitalizeFirstLetter = function(name){
		return name.charAt(0).toUpperCase() + name.slice(1);
	};


	var Func = {
		isFunc,
		isAsync,
		executeFunctionAsAsync,
		isArray,
		noop,
		heartbeat,
		ObjHas,
		tryParseJSON,
		capitalizeFirstLetter
	};

	/**
	      * Routing for messages
	      *
	      */

	class notWSRouter extends EventEmitter{
		constructor({name, routes = {}, logger}){
			super();
			this.__name = name || 'notWSRouter';
			this.logMsg = logger?logger.log:()=>{};
			this.logDebug = logger?logger.debug:()=>{};
			this.logError = logger?logger.error:()=>{};
			this.routes = {
				__service: {
					updateToken:()=>{
						this.emit('updateToken');
						return Promise.resolve();
					}
				},
				test: {
					sayHello:()=>{
						this.logMsg('Say hello for test route!');
						return Promise.resolve(true);
					}
				},
				request:{
					auth:()=>{
						this.logMsg('request.auth');
					}
				}
			};
			if(routes && Object.keys(routes).length > 0 ){
				this.initRoutes(routes);
			}
			return this;
		}

		initRoutes(routes){
			for(let type in routes){
				this.setRoutesForType(type, routes[type]);
			}
		}

		/**
	      * Routing action
	      * @parms {object} messageServiceData object with fields:
	      type - msg type, routes set
	      name - action name
	      cred - some credentials info
	      @params {object} data payload information from message
	      @params {object} client WS Connection
	      @returns {Promise} from targeted action or throwing Error if route doesn't exist
	      */
		async route({type, name, cred}, data, client){
	      
			const identity = client.identity;
	          
			if(
				Func.ObjHas(this.routes, type) &&
	            Func.ObjHas(this.routes[type], name)
			){
				this.logMsg('ip:', client.getIP(), type, name);
				if(Array.isArray(this.routes[type][name]) && this.routes[type][name].length > 1){
					const len = this.routes[type][name].length;
					const guards = this.routes[type][name].slice(0, len - 1);
					const actualRoute = this.routes[type][name][len - 1];
					await Promise.all(
						guards.map((guard) => Func.executeFunctionAsAsync(guard, [{data, cred, client, identity}]))
					);
					return Func.executeFunctionAsAsync(actualRoute,[{data, cred, client, identity}]);

				}else if(Func.isFunc(this.routes[type][name])){
					return await Func.executeFunctionAsAsync(this.routes[type][name], [{data, cred, client, identity}]);
				}
			}
			throw (new CONST.notWSException(`Route not found ${type}/${name}`));
		}

		/**
	            * Adding routes, chainable
	            * @params {string} type name of type
	            * @params {object} routes hash with name => () => {return new Promise} alike workers
	            * @returns {object} self
	            */
		setRoutesForType(type, routes){
			this.validateType(type);
			this.validateRoutes(routes);
			if (Func.ObjHas(this.routes, type)){
				this.routes[type] = Object.assign(this.routes[type], routes);
			}else {
				this.routes[type] = routes;
			}
			return this;
		}

		unsetRoutesForType(type, list = []){
			this.validateType(type);
			this.validateRoutesList(list);
			if (Func.ObjHas(this.routes, type)){
				for(let name of list){
					if(Func.ObjHas(this.routes[type], name)){
						delete this.routes[type][name];
					}
				}
				if(Object.keys(this.routes[type]).length === 0){
					delete this.routes[type];
				}
			}
			return this;
		}

		validateType(type){
			if((typeof type !== 'string') || (type === '')){
				throw new CONST.notWSException('Route\'s type name should be a String!');
			}
			return true;
		}

		validateRoutes(routes){
			if((typeof routes !== 'object') || (routes === null) || (routes === undefined)){
				throw new CONST.notWSException('Route\'s type\'s routes set should be an Object!');
			}
			return true;
		}

		validateRoutesList(list){
			if(!Array.isArray(list) || (typeof list === 'undefined')){
				throw new CONST.notWSException('List of routes names should be an Array!');
			}
			return true;
		}

		getRoutes(){
			return this.routes;
		}

	}

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	let getRandomValues;
	const rnds8 = new Uint8Array(16);
	function rng() {
	  // lazy load so that environments that need to polyfill have a chance to do so
	  if (!getRandomValues) {
	    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
	    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

	    if (!getRandomValues) {
	      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	    }
	  }

	  return getRandomValues(rnds8);
	}

	var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

	function validate(uuid) {
	  return typeof uuid === 'string' && REGEX.test(uuid);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	const byteToHex = [];

	for (let i = 0; i < 256; ++i) {
	  byteToHex.push((i + 0x100).toString(16).slice(1));
	}

	function unsafeStringify(arr, offset = 0) {
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
	}

	const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
	var native = {
	  randomUUID
	};

	function v4(options, buf, offset) {
	  if (native.randomUUID && !buf && !options) {
	    return native.randomUUID();
	  }

	  options = options || {};
	  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  return unsafeStringify(rnds);
	}

	/**
	 * set of default options
	 */
	const DEFAULT_OPTIONS$1 = {
		validateType:         true, //validation of message type
		validateTypeAndName:  true, //validation of message type and name
		secure: false, // if true - all not validated credentials are wrong
		securityException: ['request.auth'], //пример того как указывать пути без аутентификации, даже при secure=true
		validators: { //additional validators for validate method
			/**
	    credentials(credentials){
	      return (credentials.password === 'password') && (credentials.login === 'login');
	    }
	    */
		},
		types:      {
			'typeOfMessage':  ['list', 'of', 'name\'s', 'of', 'actions'],
			'test': ['sayHello'],
			'__service': ['updateToken'],
		},
		wrap:{
			ok: undefined,
			error: undefined
		},
		isErrored: undefined,             //override rule of defining unpacked message as failed (msg):void
		markMessageAsErrored: undefined   //override rule of marking message as errored (msg, serviceData, error):void
	};

	/***
	message format for this default adaptor
	{
	  id:uuidv4
	  type:string
	  name:string
	  payload:{} <- payload
	  cred:any
	  time:int
	  error:{} <- if errored on communitaction level, errors from other levels could be transported in payload

	}
	*/

	/**
	 * Message pre/post transmittion adapter
	 * Creates standart interface, mostly freeing other parts from
	 * understanding message inner structure
	 */
	class notWSMessenger extends EventEmitter {
		constructor(options = {}) {
			super();
			this.options = {...DEFAULT_OPTIONS$1, ...options};
			if(Func.ObjHas(this.options.types, CONST.MSG_TYPE.REQUEST) && !Func.ObjHas(this.options.types, CONST.MSG_TYPE.RESPONSE)){
				this.options.types[CONST.MSG_TYPE.RESPONSE] = this.options.types[CONST.MSG_TYPE.REQUEST];
			}
			return this;
		}

		setCredentials(credentials) {
			this.options.credentials = credentials;
			return this;
		}

		getServiceData(msg) {
			if(Func.ObjHas(msg, 'service')){
				return msg.service;
			}else {
				return {
					id: msg.id,
					time: msg.time,
					type: msg.type,
					name: msg.name,
				};
			}
		}

		getType(msg) {
			return msg.type;
		}

		getName(msg) {
			return msg.name;
		}

		getCredentials(msg) {
			return msg.cred;
		}

		getPayload(msg) {
			return msg.payload;
		}

		isErrored(msg) {
			if(Func.isFunc(this.options.isErrored)){
				return this.options.isErrored(msg);
			}else {
				return (typeof msg.error !== 'undefined') && (msg.error !== null);
			}
		}

		markMessageAsErrored(msg, serviceData, error ){
			if(Func.isFunc(this.options.markMessageAsErrored)){
				this.options.markMessageAsErrored(msg, serviceData, error);
			}else {
				if (error instanceof CONST.notWSException) {
					msg.error = error;
				}
			}
		}

		getErrorMessage(msg) {
			if (typeof msg.error === 'string') {
				return msg.error;
			} else if (typeof msg.error === 'object') {
				return `${msg.error.code}: ${msg.error.message}`;
			} else {
				throw new CONST.notWSException('No error data in message');
			}
		}

		getErrorReport(msg) {
			return msg.error;
		}

		/**
	   *
	   *
	   */
		pack(payload, serviceData, error) {
			if (!error && (typeof serviceData === 'undefined') || (serviceData === null)) {
				throw new CONST.notWSException('No Service Data or Error for packing notWSMsg');
			}
			const payloadWrapped = this.wrapPayload(payload, serviceData, error);
			let msg = {
				id: v4(),
				time: (new Date()).getTime(),
				payload: payloadWrapped,
			};    
			if (this.options.credentials) {
				msg.cred = this.options.credentials;
			}
			this.markMessageAsErrored(msg, serviceData, error);
			return Object.assign(msg, serviceData);
		}

		wrapPayload(payload, serviceData, error){
			if((error && error instanceof Error)){
				return this.wrapPayloadAs('error', payload, serviceData, error);
			}else {
				return this.wrapPayloadAs('ok', payload, serviceData, error);
			}
		}

		wrapPayloadAs(status, payload, serviceData, error){
			if(typeof this.options.wrap === 'object' && Func.isFunc(this.options.wrap[status])){
				return this.options.wrap[status](payload, serviceData, error);
			}else {
				return payload;
			}
		}

		unpack(msg) {
			if (this.isErrored(msg)) {
				let err = new CONST.notWSException(this.getErrorMessage(msg));
				err.report = this.getErrorReport(msg);
				throw err;
			}
			return {
				cred: this.getCredentials(msg),
				service: this.getServiceData(msg),
				payload: this.getPayload(msg)
			};
		}

		validateCredentials(credentials = {}, serviceData) {
			if (this.options.validators && this.options.validators.credentials) {
				return this.options.validators.credentials(credentials, serviceData);
			}
			return !this.options.secure;
		}

		validateType(type) {
			if (this.options.types) {
				return Object.keys(this.options.types).indexOf(type) > -1;
			}
			return false;
		}

		validateTypeAndName(type, name) {
			if (this.options.types && Func.ObjHas(this.options.types, type)) {
				return this.options.types[type].indexOf(name) > -1;
			}
			return false;
		}

		routeIsSecurityException(type, name) {
			let route = `${type}.${name}`;
			if (this.options.securityException && Array.isArray(this.options.securityException)) {
				return (this.options.securityException.indexOf(route) > -1);
			}
			return false;
		}

		validate(msg) {
			let serviceData = this.getServiceData(msg);
			if (!validate(serviceData.id)) {
				throw new CONST.notWSException(CONST.ERR_MSG.MSG_ID_IS_NOT_VALID);
			}
			if (
			//если не в списке исключений
				!this.routeIsSecurityException(serviceData.type, serviceData.name) &&
	      //проверяем права доступа
	      !this.validateCredentials(this.getCredentials(msg), serviceData)
			) {
				throw new CONST.notWSException(CONST.ERR_MSG.MSG_CREDENTIALS_IS_NOT_VALID);
			}
			//not neccessary, but
			this.validateRouteTypeAndName(msg);
			return msg;
		}

		validateRouteTypeAndName(msg){
			//default: false
			if(this.options.validateTypeAndName){
				this.validateRouteType(msg);
				let type = this.getType(msg),
					name = this.getName(msg);
				if (!this.validateTypeAndName(type, name)) {
					let err = new CONST.notWSException(CONST.ERR_MSG.MSG_NAME_IS_NOT_VALID);
					err.details = {type,name};
					throw err;
				}
			}else {
				this.validateRouteType(msg);
			}
		}

		validateRouteType(msg){
			let type = this.getType(msg);
			//default: true
			if(this.options.validateType){
				if (!this.validateType(type)) {
					let err = new CONST.notWSException(CONST.ERR_MSG.MSG_TYPE_IS_NOT_VALID);
					err.details = {type};
					throw err;
				}
			}
		}

		enableRoute(route, name){
			if(!Func.ObjHas(this.options, 'types')){
				this.options.types = {};
			}
			if(!Func.ObjHas(this.options.types, route)){
				this.options.types[route] = [];
			}
			if(this.options.types[route].indexOf(name) === -1){
				this.options.types[route].push(name);
			}
			return this;
		}

		disableRoute(route, name){
			if(!Func.ObjHas(this.options, 'types')){
				return this;
			}
			if(!Func.ObjHas(this.options.types, route)){
				return this;
			}
			if(this.options.types[route].indexOf(name) > -1){
				this.options.types[route].splice(this.options.types[route].indexOf(name), 1);
			}
			return this;
		}
	}

	//imports




	const SYMBOL_ACTIVITY = Symbol('activity');
	const SYMBOL_STATE = Symbol('state');

	const MAX_HISTORY_DEPTH = 40;

	const DEFAULT_OPTIONS = {
		secure:     true,
		reconnect:  true,
		ping:       true,
		count:      true,
	};

	class notWSConnection extends EventEmitter{
		constructor(options, slave = false){
			super();
			this.options = Object.assign({}, DEFAULT_OPTIONS, options);
			if(this.options.ws){
				this.ws = options.ws;
				delete options.ws;
				if(this.ws.readyState === 1){
					this.setAlive(); //результат пинг запросов
					this[SYMBOL_STATE] = CONST.STATE.CONNECTED;
					if(this.options.secure){
						this[SYMBOL_STATE] = CONST.STATE.AUTHORIZED;
					}
				}else {
					this[SYMBOL_STATE] = CONST.STATE.NOT_CONNECTED;
					this.setDead(); //результат пинг запросов
				}
			}else {
				this[SYMBOL_STATE] = CONST.STATE.NOT_CONNECTED;
				this.setDead(); //результат пинг запросов
				this.ws = null; //Подключение к websocket серверу.
			}
			this[SYMBOL_ACTIVITY] = CONST.ACTIVITY.IDLE;
			//if was terminated
			this.isTerminated = false;
			this.isReconnecting = false;
			this.closing = false;
			this.slave = slave;
			this.heartbeatTimeout = null;
			this.connectInterval = null;
			this.connCount = 0; //Количество неудачных попыток подключения к websocket серверу.
			this.connCountMax = 10; //Количество попыток по превышении которого считаем что соединение с серверов разорвано.
			this.errConnMsg = null; //Идентификатор сообщения об ошибке подключения к вебсокет серверу.
			this.firstConn = true;
			this.bindEnvEvents();
			this.bindSocketEvents();
			//message history
			this.history = [];
			this.passed = {
				in:  0,
				out: 0,
			};
			return this;
		}

		getStatus(){
			return {
				state:          CONST.STATE_NAME[this[SYMBOL_STATE]],
				activity:       CONST.ACTIVITY_NAME[this[SYMBOL_ACTIVITY]],
				isAlive:        this.isAlive(),
				isTerminated:   this.isTerminated,
				isReconnecting: this.isReconnecting,
				in:             this.passed.in,
				out:            this.passed.out,
			};
		}

		getSocket(){
			return this.ws;
		}

		getIP(){
			if(this.isOpen() && this.ws._socket && this.ws._socket.remoteAddress){
				return this.ws._socket.remoteAddress;
			}else {
				return false;
			}
		}

		bindSocketEvents(){
			if(this.ws){
				this.listeners = {
					open: this.onOpen.bind(this),
					message: this.onMessage.bind(this),
					close: this.onClose.bind(this),
					error: this.onError.bind(this)
				};
	    
				this.ws.onopen = this.listeners.open;
				this.ws.onmessage = this.listeners.message;
				this.ws.onclose = this.listeners.close;
				this.ws.onerror = this.listeners.error;
	    
			}
		}



		bindEnvEvents(){
	    
			window.onunload = this.disconnect.bind(this);
			window.onbeforeunload = this.disconnect.bind(this);
	    
		}

		//Отключение от ws сервиса.
		disconnect(){
			this.emit('diconnecting');
			if(this.ws){
				//заменяем метод для onclose на пустую функцию.
	      
				this.ws.onclose = Func.noop;
				this.ws.onerror = Func.noop;
				this.ws.onmessage = Func.noop;
				this.ws.onopen = Func.noop;
	      
				//закрываем подключение.
				this.ws.close && this.ws.close();
				this.terminate();
			}
		}

		terminate() {
			if(this.connectInterval){
				clearInterval(this.connectInterval);
			}
			if (this.ws) {
				this.activity = CONST.ACTIVITY.TERMINATING;
	      
				this.ws.terminate && this.ws.terminate();
			}
			this.isTerminated = true;
			this.ws = null;
			if(this.state !== CONST.STATE.NOT_CONNECTED){
				this.state = CONST.STATE.NOT_CONNECTED;
			}
			this.setDead();
		}

		//Подключение к websocket сервису.
		async connect(){
			try{
				if(!this.jwtToken){        
					this.scheduleReconnect();
					return;
				}
				if(this.ws && (this.ws.readyState !== WebSocket.CLOSED)){
					this.disconnect();
				}
				this.setAlive();
				this.isTerminated = false;
				//Счётчик колиества попыток подключения:
				this.connCount++;
				//пытаемся подключиться к вебсокет сервису.
				let connURI = this.getConnectURI();
				this.emit('connectURI', connURI);
				this.activity = CONST.ACTIVITY.CONNECTING;
				this.ws = new WebSocket(connURI);
				this.bindSocketEvents();
			}catch(e){
				this.emit('error',e);
				this.scheduleReconnect();
			}
		}

		setHalfDead(){
			if(this._alive){
				this._alive = false;
			}else {
				this.setDead();
			}
		}

		setAlive(){
			this._alive = true;
			this.alive = true;
		}

		setDead(){
			this.alive = false;
		}

		isAlive(){
			return this.alive;
		}

		isDead(){
			return !this.alive;
		}

		getConnectURI(){
			let protocol = 'ws';
			if(this.options.protocol){
				protocol = this.options.protocol;
			}else {
				if(this.options.ssl){
					protocol = 'wss';
				}
			}
			let base = `${protocol}://${this.options.host}`;
			if(this.options.port && parseInt(this.options.port) !== 80){
				base = `${base}:${this.options.port}/${this.options.path}`;
			}else {
				base = `${base}/${this.options.path}`;
			}    
			if(this.isSecure()){
				return `${base}?token=${this.jwtToken}`;
			}else {
				return base;
			}
		}

		setToken(token){
			this.jwtToken = token;
		}

		onOpen(){
			//Сбрасываем счётчик количества попыток подключения и данные об ошибках.
			this.connCount = 0;
			this.setAlive();
			clearInterval(this.connectInterval);
			this.connectInterval = false;
			this.errConnMsg = null;
			this.state = CONST.STATE.CONNECTED;
			if(this.isSecure()){
				this.state = CONST.STATE.AUTHORIZED;
			}
			this.initPing();
			this.emit('ready');
			this.sendAllFromHistory();
		}

		//Обработчик сообщений пришедших от сервера.
		//msg - это messageEvent пришедший по WS, соответственно данные лежат в msg.data.
		onMessage(input){
			try{
				this.countPassed(input, 'in');
				//проверяем не "понг" ли это, если так - выходим
	      
				let rawMsg = input.data;
	      
				if(this.checkPingMsg(rawMsg)){
					return;
				}
				let data = Func.tryParseJSON(rawMsg);
				//Не удалось распарсить ответ от сервера как JSON
				if(!data){
					this.emit('messageInWrongFormat', rawMsg);
					return;
				}
				this.emit('message', data);
			}catch(e){
				this.emit('error', e);
			}
		}

		onError(err){
			if(this.connectInterval){
				clearInterval(this.connectInterval);
				this.connectInterval = false;
			}
			if (this.activity === CONST.ACTIVITY.TERMINATING) {
				this.state = CONST.STATE.NOT_CONNECTED;
			} else {
				this.state = CONST.STATE.ERRORED;
			}
			this.emit('error', err);
		}

		//Обработчик закрытия подключения.
		onClose(event){
			if (typeof event.code !== 'undefined') {
				let reason = `${event.code}::` + CONST.mapWsCloseCodes(event);
				this.emit('close', reason);
			}else {
				if (isNaN(event)) {
					this.emit('close', event);
				} else {
					this.emit('terminated', CONST.mapWsCloseCodes(event));
				}
			}

			if (this.activity === CONST.ACTIVITY.CLOSING) {
				this.state = CONST.STATE.NOT_CONNECTED;
			} else {
				this.state = CONST.STATE.ERRORED;
			}
		}

		suicide() {
			this.emit('errored', this);
		}

		getReconnectTimeout(){
			if(this.connCount >= this.connCountMax){
				return CONST.CLIENT_RECONNECT_TIMEOUT_LONG;
			} else {
				return CONST.CLIENT_RECONNECT_TIMEOUT;
			}
		}

		scheduleReconnect(){
			if (!this.slave) {
				let timeout = this.getReconnectTimeout();
				this.emit('reconnectiningEvery', timeout);
				if (this.connectInterval) {
					clearInterval(this.connectInterval);
				}
				this.connectInterval = setInterval(this.performReconnect.bind(this), timeout);
			}
		}

		performReconnect(){
			if (!this.ws || this.ws.readyState === this.ws.CLOSED) {
				this.connect();
			}
		}

		reconnect() {
			if(!this.slave){
				if ([CONST.ACTIVITY.CONNECTING].indexOf(this.activity) > -1) {
					this.emit('concurentActivity', CONST.ACTIVITY[this.activity]);
					return;
				} else {
					this.scheduleReconnect();
				}
			}
		}

		/**
	  *  Требуется аутентификация или нет
	  */
		isSecure() {
			return this.options.secure;
		}

		isAutoReconnect(){
			if(this.slave){
				return false;
			}else {
				if (typeof this.options.reconnect !== 'undefined'){
					return this.options.reconnect;
				}else {
					return CONST.CLIENT_AUTO_RECONNECT;
				}
			}
		}

		/**
	   *  Returns true if user connected, if secure===true,
	   *  then client should be authentificated too
	   *  @params {boolean} secure      if user should be connected and authenticated
	   */
		isConnected(secure = true){
			if(this.ws && this.isAlive()){
				if(secure){
					return this.isConnectionSecure();
				}else {
					return true;
				}
			}else {
				return false;
			}
		}

		isConnectionSecure(){
			let state = CONST.STATE.CONNECTED;
			if (this.isSecure()) {
				state = CONST.STATE.AUTHORIZED;
			}
			return (this.state === state) && (this.ws.readyState === 1); // 1- OPEN
		}

		isOpen(){
			return this.ws && this.ws.readyState === 1;
		}

		isMessageTokenUpdateRequest(data){
			return data.type === '__service' && data.name === 'updateToken';
		}

		initPing(){
			//if server side client, only react on pong
			if(this.slave){
				this.on('pong', Func.heartbeat);
			}else {
				//if client send ping requests
				if(this.options.ping){
					if(this.pingInterval){
						clearInterval(this.pingInterval);
						this.pingInterval = false;
					}
					this.pingInterval = setInterval(this.sendPing.bind(this), this.options.pingTimeout || CONST.PING_TIMEOUT);
				}
			}
		}

		/**
	  * If not connected, reconnects, else sets connection isNotAlive and sends ping
	  */
		sendPing(){
			if(!this.isAlive()){
				this.emit('noPong');
				if(this.state === CONST.STATE.CONNECTED){
					this.state = CONST.STATE.NOT_CONNECTED;
				}
				return;
			}
			this.setHalfDead();
			this.ping();
		}

		pong(){
			if(this.isOpen()){
				this.wsSend('pong');
				this.emit('pong');
			}
		}

		/**
	  * Ping connection
	  */
		ping(){
			if(this.isOpen()){
	      
				this.wsSend('ping').catch(Func.noop);
	      
				this.emit('ping');
			}
		}

		/**
	  * If message is plain text 'pong', then it sets connections as isAlive
	  * @params {string}  msg   incoming message
	  * @returns {boolean}  if it 'pong' message
	  **/
		checkPingMsg(msg){
			if (msg === 'ping'){
				this.setAlive();
				this.emit('pinged');
				this.pong();
				return true;
			}
			if (msg === 'pong'){
				this.setAlive();
				this.emit('ponged');
				return true;
			}
			return false;
		}

	  

		/**
	  * Отправка сообщения
	  * @param  {object|string} данные в виде
	  *                         - строки, будут обернуты в соотвествии со спецификацией
	  *                         - объекта, будут переданы без изменений
	  * @return {Promise} resolve - удачно, reject - сбой
	  */
		async send(data, secure) {
			//Проверяем что клиент подключен
			try {
				if (this.isConnected(secure) || (this.isOpen() && this.isMessageTokenUpdateRequest(data))) {
					//Пытаемся отправить сообщение клиенту.
					await this.wsSend(JSON.stringify(data));
				} else {
					this.emit('messageNotSent', CONST.STATE_NAME[this.state]);
					this.addToHistory(data);
				}
			} catch (e) {
				this.state = CONST.STATE.ERRORED;
				throw e;
			}
		}

		addToHistory(data) {
			this.emit('addToHistory', data);
			this.history.push(data);
			if (this.history.length > MAX_HISTORY_DEPTH) {
				this.history.shift();
			}
		}

		sendAllFromHistory() {
			while (this.history.length) {
				let msg = this.history.shift();
				//sending out but only in secure manner, all messages for not auth users will be dropped
				this.send(msg, true).catch(this.onError.bind(this));
			}
		}

		/**
	  * Finite states machine
	  */

		get state() {
			return this[SYMBOL_STATE];
		}

		set state(state = CONST.STATE.NOT_CONNECTED) {
			if (Object.values(CONST.STATE).indexOf(state) > -1) {
				this.emit('stateChange', state, CONST.STATE_NAME[state]);
				//для каждого варианта, есть только ограниченное кол-во вариантов перехода
				//из "нет соединения" в "авторизован" не прыгнуть
				switch (this[SYMBOL_STATE]) {
				//можем только подключиться или вылететь с ошибкой подключения
				case CONST.STATE.NOT_CONNECTED:
					if ([CONST.STATE.CONNECTED, CONST.STATE.ERRORED].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
					//можем повиснуть, авторизоваться вылететь с ошибкой
				case CONST.STATE.CONNECTED:
					if (
						[
							CONST.STATE.AUTHORIZED,
							CONST.STATE.NO_PING,
							CONST.STATE.ERRORED,
							CONST.STATE.NOT_CONNECTED
						].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
					//можем потерять авторизацию, но продолжить висеть на линии
					//повиснуть
					//вылететь с ошибкой связи
				case CONST.STATE.AUTHORIZED:
					if (
						[
							CONST.STATE.CONNECTED,
							CONST.STATE.NO_PING,
							CONST.STATE.ERRORED,
							CONST.STATE.NOT_CONNECTED
						].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
					////из остояний разрыва связи, можно уйти только в "не подключен"
					//можем только отключиться
				case CONST.STATE.NO_PING:
					if ([CONST.STATE.NOT_CONNECTED].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
					//можем только отключиться
				case CONST.STATE.ERRORED:
					if ([
						CONST.STATE.NOT_CONNECTED,
						CONST.STATE.ERRORED
					].indexOf(state) > -1) {
						this[SYMBOL_STATE] = state;
						this.activity = CONST.ACTIVITY.IDLE;
					} else {
						throw new CONST.notWSException('Wrong state transition: ' + CONST.STATE_NAME[this[SYMBOL_STATE]] + ' -> ' + CONST.STATE_NAME[state]);
					}
					break;
				}
				switch(this[SYMBOL_STATE]){
				case CONST.STATE.NOT_CONNECTED:
					//если идём на обрыв, то переподключение не запускаем
					this.emit('disconnected');
					if(this.isAlive()){
						this.emit('beforeReconnect');
						this.reconnect();
					}else {
						if(this.isAutoReconnect()){
							this.scheduleReconnect();
						}
					}
					break;
				case CONST.STATE.CONNECTED:  this.emit('connected');        break;
				case CONST.STATE.AUTHORIZED:  this.emit('authorized');      break;
				case CONST.STATE.NO_PING:
					this.emit('noPing');
					this.disconnectTimeout = setTimeout(this.disconnect.bind(this), 100);
					break;
				case CONST.STATE.ERRORED:
					this.emit('errored');
					this.disconnectTimeout = setTimeout(this.disconnect.bind(this), 100);
					break;
				}
			} else {
				throw new CONST.notWSException('set: Unknown notWSServerClient state: ' + state);
			}
		}

		get activity() {
			return this[SYMBOL_ACTIVITY];
		}

		//
		/*
	IDLE: 0,
	//идёт подключение
	CONNECTING: 1,
	//закрытие соединения
	CLOSING: 2,
	//разрыв соединения
	TERMINATING: 3,
	//авторизация по токену
	AUTHORIZING: 4
	*/
		set activity(activity = CONST.ACTIVITY.IDLE) {
			if (Object.values(CONST.ACTIVITY).indexOf(activity) > -1) {
				this.emit('changeActivity', activity, CONST.ACTIVITY_NAME[activity]);
				//для каждого варианта, есть только ограниченное кол-во вариантов перехода
				//из "нет соединения" в "авторизован" не прыгнуть
				switch (this[SYMBOL_ACTIVITY]) {
				//можем только подключиться
				case CONST.ACTIVITY.IDLE:
					if ([
						CONST.ACTIVITY.CONNECTING,
						CONST.ACTIVITY.CLOSING,
						CONST.ACTIVITY.TERMINATING,
						CONST.ACTIVITY.AUTHORIZING
					].indexOf(activity) > -1) {
						this[SYMBOL_ACTIVITY] = activity;
					}
					break;
				case CONST.ACTIVITY.CONNECTING:
				case CONST.ACTIVITY.CLOSING:
				case CONST.ACTIVITY.TERMINATING:
				case CONST.ACTIVITY.AUTHORIZING:
					if ([CONST.ACTIVITY.IDLE].indexOf(activity) > -1) {
						this[SYMBOL_ACTIVITY] = activity;
					}
					break;
				}
				switch(this[SYMBOL_ACTIVITY]){
				case CONST.ACTIVITY.IDLE:         this.emit('idle', this); break;
				case CONST.ACTIVITY.CONNECTING:   this.emit('connecting', this); break;
				case CONST.ACTIVITY.AUTHORIZING:  this.emit('authorizing', this); break;
				case CONST.ACTIVITY.CLOSING:      this.emit('closing', this); break;
				case CONST.ACTIVITY.TERMINATING:  this.emit('terminating', this); break;
				}
			} else {
				throw new CONST.notWSException('set: Unknown notWSServerClient activity: ' + activity);
			}
		}

		wsSend(msg){
			return new Promise((res, rej)=>{
				this.ws.send(this.countPassed(msg, 'out'), (err)=>{
					if(err){
						rej(err);
					}else {
						res();
					}
				});
			});

		}

		countPassed(input, where){
			this.passed[where] += this.options.count?this.getMessageSize(input):0;
			return input;
		}

		getMessageSize(input){
	    
			return new Blob([input]).size;
	    
		}

		destroy(){
			clearInterval(this.connectInterval);
			clearInterval(this.pingInterval);
			clearTimeout(this.disconnectTimeout);
			this.emit('destroyed');
			this.removeAllListeners();
		}
	}

	/**
	*
	* Client - main function is to connect and handle requests from/to server.
	*
	* Options
	* @params {string}          name              - client name, optional. default: WSCLient
	* @params {object}          connection        - object describing server and behaviour of this client
	*         {string}            host            - server address
	*         {string}            port            - server port
	*         {string}            path            - path on server
	*         {string}            protocol        - connection protocol, preffered over 'ssl' option
	*         {boolean}           ssl             - user ssl encryption for connection
	*         {boolean}           secure          - auth needed
	*         {boolean}           reconnect       - reconnect if disconnected
	*         {boolean}           ping            - ping server to indentify connection problems ASAP
	* @params {function}        getToken          - should return token for auth on server
	* @params {notWSMessenger}  messenger         - message handler or its config
	* @params {notWSRouter}     router            - request handler or its config
	* @params {object}          logger            - log interface {function:log, function:debug, function:error}
	* @params {boolean}         slave             - true - this is server child connection for remote client, false - it is connection to another server
	* @params {Array<string>}   debug             - list of features to debug and show more information
	*
	**/

	class notWSClient extends EventEmitter{
		constructor({
			name,
			connection,
			getToken,
			messenger,
			router,
			logger,
			identity,          //user information
			credentials,        //client creds for access
			slave = false,
			debug = []
		}){
			if(!router){
				throw new CONST.notWSException('Router is not set or is not instance of notWSRouter');
			}
			if(!(router instanceof notWSRouter)){
				router = new notWSRouter(router);
			}
			if(!messenger){
				throw new CONST.notWSException('Messenger is not set or is not instance of notWSMessenger');
			}
			if (!(messenger instanceof notWSMessenger)){
				messenger = new notWSMessenger(messenger);
			}
			super();
			//Основные параметры
			this.__name = name ? name : CONST.DEFAULT_CLIENT_NAME;
			//jwt
			this.jwtToken = null; //Токен авторизации.
			this.jwtExpire = null; //Время до истечения токена.
			this.jwtDate = null; //Дата создания токена.
			//setting envs
			this.tokenGetter = getToken;
			this.identity = identity;
			this.credentials = credentials;
			this.messenger = messenger;
			this.router =   router;
			this.slave = slave;
			this.debug = debug;
			//Подключение к WS
			this.initConnection(connection, this.slave);
			if(!this.slave){
				this.router.on('updateToken', this.renewToken.bind(this));
			}
			//common constructor part for client browser client, node client, node server client
			//logging
			this.logMsg = logger?logger.log:()=>{};
			this.logDebug = logger?logger.debug:()=>{};
			this.logError = logger?logger.error:()=>{};
			//requests processing
			this.requests = []; //Список текущих запросов к API.
			this.reqTimeout = 15000; //Таймаут для выполнения запросов.
			this.reqChkTimer = null; //Таймер для проверки таймаутов выполнения запросов.
			this.reqChkStep = 2000; //Таймер для проверки таймаутов выполнения запросов.
			//time off set from server time
			this._timeOffset = 0;
			this.getTimeOffsetInt = null;
			if(!this.slave){
				this.connect();
			}
			return this;
		}

		getIP(){
			return this.connection?this.connection.getIP():false;
		}

		initConnection(connection){
			this.connection = new notWSConnection(connection);
			this.connection.on('disconnected', ()=>{
				this.logMsg('disconnected');
				this.stopReqChckTimer();
				this.emit('close', this);
				this.emit('disconnected', this);
			});
			this.connection.on('connected', ()=>{
				this.logMsg('connected');
				//Запускаем таймер проверки списка запросов.
				this.startReqChckTimer();
				this.emit('open', this);
				this.emit('connected', this);
			});
			this.connection.on('connectURI', (e)=>{this.logMsg('connectURI', e);});
			this.connection.on('close', (e)=>{this.logMsg('close', e);});
			this.connection.on('error', (e)=>{
				this.logError(e);
			});
			this.connection.on('message', this.processMessage.bind(this));

			this.connection.on('ready', ()=>{
				this.logMsg('ready');
				this.emit('ready', this);
			});

			if(this.connect.debug && this.connect.debug.includes('ping')){
				this.connection.on('ping', ()=>{
					this.logDebug('ping');
				});
				this.connection.on('pong', ()=>{
					this.logDebug('pong');
				});

				this.connection.on('pinged', ()=>{
					this.logDebug('pinged');
				});
				this.connection.on('ponged', ()=>{
					this.logDebug('ponged');
				});
			}
		}

		async connect(){
			if(!this.slave){
				try{
					if(!this.isConnected()){
						//если нужна аутентификация
						if(this.connection.isSecure()){
							//получаем и сохраняем токен токен
							this.saveToken(await this.getToken());
						}
						//подключаемся
						this.connection.connect();
					}
				}catch(e){
					this.logError(e);
				}
			}
		}

		suicide() {
			this.emit('errored', this);
		}

		disconnect(){
			this.connection.disconnect();
		}

		terminate(){
			this.connection.terminate();
			this.connection.destroy();
		}

		destroy(){
			clearInterval(this.getTimeOffsetInt);
			this.emit('destroyed');
			this.removeAllListeners();
		}

		isDead() {
			return !this.connection.isAlive();
		}

		isAlive() {
			return this.connection.isAlive();
		}

		reconnect() {
			this.connection.reconnect();
		}

		isConnected(secure = true) {
			return this.connection.isConnected(secure);
		}

		isSecure() {
			return this.connection.isSecure();
		}

		isAutoReconnect(){
			return this.connection.isAutoReconnect();
		}

	  
		//Запуск таймера проверки запросов.
		startReqChckTimer() {
			clearTimeout(this.reqChkTimer);
			this.reqChkTimer = setTimeout(this.checkRequests.bind(this), this.reqChkStep);
		}

		stopReqChckTimer() {
			clearTimeout(this.reqChkTimer);
		}

		//Поиск запроса по uuid
		findRequest(id) {
			for (let i = 0; i < this.requests.length; i++) {
				if (this.requests[i].id === id) {
					return i;
				}
			}
			return false;
		}

		fullfillRequest(id){
			let reqIndex = this.findRequest(id);
			if(reqIndex === false) {
				this.logMsg(`failed to find request for response ${id}`);
				return null;
			}
			let request = this.requests[reqIndex];
			//Удаление элемента из списка запросов.
			this.requests.splice(reqIndex, 1);
			//Выполнение callback'а запроса.
			if(Func.isFunc(request.cb)) {
				return request;
			} else {
				return null;
			}
		}

		addRequest(id, callback) {
			this.requests.push({
				id, //Идентификатор запроса.
				time: Date.now(), //Время отправки запроса.
				cb: callback //callback для обработки результатов запроса.
			});
		}

		//Проверка списка запросов.
		checkRequests() {
			//Формирование списка запросов для удаления по таймауту.
			let list = [];
			let now = Date.now();
			this.requests.forEach((req) => {
				let reqAge = now - req.time;
				if (reqAge > this.reqTimeout) {
					list.push(req.id);
				}
			});
			//Удаление запросов по таймауту.
			list.forEach((reqId) => {
				let reqIndex = this.findRequest(reqId);
				if (reqIndex === false) {
					this.logMsg(`timeout check:failed to find request for response ${reqId}`);
					return;
				}
				let request = this.requests[reqIndex];
				if (Func.isFunc(request.cb)) {
					request.cb(CONST.ERR_MSG.REQUEST_TIMEOUT);
				} else {
					this.logMsg(`timeout check:Не задан callback для запроса с id: ${reqId}`);
				}
				this.requests.splice(reqIndex, 1);
			});
		}


	  

		//Получение токена.
		//Возможно реализовать разными способами, поэтому выделено в отдельный метод.
		getToken(renew = false){
	    
			let token = localStorage.getItem('token');
			if((typeof token !== 'undefined') && (token !== 'undefined') && token && !renew){
				return Promise.resolve(token);
			}else {
	    
				if(Func.isFunc(this.tokenGetter)){
					return this.tokenGetter();
				}else {
					return Promise.reject();
				}
	    
			}
	    
		}

		async renewToken(){
			if (!this.slave){
				try{
					let token = await this.getToken(true);
					if(token){
						this.saveToken(token);
					}else {
						throw new Error('Token isn\'t renewed');
					}
				}catch(e){
					this.logError(e);
				}
			}
		}

		saveToken(token){
			if (!this.slave){
	      
				localStorage.setItem('token', token);
	      
				this.jwtToken = token;
				this.messenger.setCredentials(token);
				this.connection.setToken(token);
				this.emit('tokenUpdated', token);
			}
		}

		clearToken(){
			this.saveToken(undefined);
		}

		ping(){
			this.connection.sendPing();
		}

		processMessage(data) {
			try{
				this.messenger.validate(data);
				let msg = this.messenger.unpack(data);
				this.emit('message', msg, this);
				this.emit(msg.service.type + ':' + msg.service.name, msg.service, msg.payload, this.connection.getSocket());
				//routing
				this.selectRoute(msg);
			}catch(e){
				this.logError(e, e.details);
	      
			}
		}

		selectRoute(msg){
			switch(msg.service.type){
			//couple of special types
			case CONST.MSG_TYPE.RESPONSE: this.routeResponse(msg);  break;
			case CONST.MSG_TYPE.REQUEST:   this.routeRequest(msg);  break;
			case CONST.MSG_TYPE.EVENT:    this.routeEvent(msg);     break;
				//all other
			default:                      this.routeCommon(msg);
			}
		}

		routeResponse(msg){
			let request = this.fullfillRequest(msg.service.id);
			if(request !== null){
				request.cb(msg);
			}
		}

		routeEvent(msg){
			this.router.route(msg.service, msg.payload, this)
				.catch((e)=>{
					this.logError(e);
				});
		}

		routeCommon(msg){
			this.router.route(msg.service, msg.payload, this)
				.catch((e)=>{
					this.logError(e);
					this.respond({}, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name}, e);
				});
		}

		routeRequest(msg){
			this.router.route(msg.service, msg.payload, this)
				.then((responseData)=>{
					this.respond(responseData, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name});
				})
				.catch((e)=>{
					this.logError(e);
					this.respond({}, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name}, e);
				});
		}

		/**
	  *  Отправка данных определенного типа и названия
	  *  @param {string}  type  тип данных
	  *  @param {string}  name  название
	  *  @param {object}  payload  данные
	  *  @returns  {Promise}
	  */
		send(type, name, payload){
			if(type === CONST.MSG_TYPE.REQUEST){
				return this.request(name, payload);
			}else {
				return this.message(type, name, payload);
			}
		}

		respond(resp, service = {}, error){
			if(typeof resp === 'object' && resp !== null){
				let msg = this.messenger.pack(resp, service, error);
				return this.connection.send(msg);
			}else {
				return true;
			}
		}

		__request(name, payload, cb, secure = true) {
			let message = this.messenger.pack(payload, {
				type: CONST.MSG_TYPE.REQUEST,
				timeOffset: this.timeOffset,
				name,
			});
			this.addRequest(this.messenger.getServiceData(message).id, cb);
			this.connection.send(message, secure).catch(this.logError.bind(this));
		}

		request(name, payload, secure = true) {
			return new Promise((resolve, reject) => {
				try {
					this.__request(name, payload, (response) => {
						if (response === CONST.ERR_MSG.REQUEST_TIMEOUT_MESSAGE) {
							return reject(response);
						}
						if (this.messenger.isErrored(response)) {
							return reject(response);
						}
						resolve(response);
					}, secure);
				} catch (e) {
					reject(e);
				}
			});
		}

		message(type, name, payload){
			if((payload!== 'pong') && ( payload!== 'ping')){
				this.logDebug('outgoing message', type, name);
			}
			let message = this.messenger.pack(payload, {
				type,
				timeOffset: this.timeOffset,
				name,
			});
			return this.connection.send(message).catch(this.logError.bind(this));
		}


		informClientAboutExperiedToken(){
			this.logMsg('force to update token');
			this.send('__service', 'updateToken', {}, false).catch(this.logError.bind(this));
		}


		/**
	  * Server time
	  */
		requestServerTime() {
			if (this.connection.isConnected()) {
				const sendTime = Date.now();
				this.request('getTime', {}, )
					.then((result)=>{
						const receiveTime = Date.now();
						const correction = Math.round((receiveTime - sendTime) / 2);
						const serverTime = parseInt(result, 10);
						const correctedTime = serverTime + correction;
						const offset = correctedTime - receiveTime;
						this.timeOffset = offset;
					})
					.catch((err)=>{
						this.logError(err);
					});
			}
		}

		set timeOffset(val) {
			this._timeOffset = val;
		}

		get timeOffset() {
			return this._timeOffset;
		}

		getTimeOnAuthorized(){
			if (this.getTimeOffsetInt) {
				clearInterval(this.getTimeOffsetInt);
				this.getTimeOffsetInt = null;
			}
			this.requestServerTime();
			this.getTimeOffsetInt = setInterval(this.requestServerTime.bind(this), CONST.TIME_OFFSET_REQUEST_INTERVAL);
		}

	}

	class nsWS {
	    constructor(app) {
	        this.app = app;
	        this.init();
	        app.on("token//updated", () => this.getTokenFromApp());
	    }

	    getTokenFromApp() {
	        const clients = this.app.getOptions("wsc", {});
	        for (let client in clients) {
	            this.app
	                .getWSClient(client)
	                .saveToken(this.app.getWorking("token"));
	            this.app.getWSClient(client).disconnect();
	            this.app.getWSClient(client).connect().catch(this.app.report);
	        }
	    }

	    init() {
	        const clients = this.app.getOptions("wsc", {});
	        for (let client in clients) {
	            this.initClient(client, clients[client]);
	        }
	        this.app.on("user.logout", this.clearMainToken.bind(this));
	    }

	    initClient(name, opts) {
	        try {
	            let options = {},
	                optionsFromAppConfig = false;
	            //integrating with collected from modules
	            for (let optName of [
	                "name",
	                "messenger",
	                "router",
	                "getToken",
	                "logger",
	                "debug",
	            ]) {
	                if (Object.hasOwn(opts, optName)) {
	                    options[optName] = opts[optName];
	                }
	            }
	            //copy opts from app wide config
	            optionsFromAppConfig = this.app.getOptions(
	                `modules.ws.clients.${name}`,
	                false
	            );
	            if (optionsFromAppConfig) {
	                if (!Object.hasOwn(options, "connection")) {
	                    options.connection = {};
	                }
	                options.connection = Object.assign(options.connection, {
	                    ...optionsFromAppConfig,
	                });
	            }
	            let client = new notWSClient(options);
	            client.once(
	                "ready",
	                this.app.emit.bind(this.app, `wsClient:${name}:ready`, client)
	            );
	            client.on(
	                "connected",
	                this.app.emit.bind(
	                    this.app,
	                    `wsClient:${name}:connected`,
	                    client
	                )
	            );
	            client.on(
	                "diconnected",
	                this.app.emit.bind(
	                    this.app,
	                    `wsClient:${name}:diconnected`,
	                    client
	                )
	            );
	            this.app.setWSClient(name, client);
	        } catch (e) {
	            this.app.error(e);
	        }
	    }

	    clearMainToken() {
	        const client = this.app.getWSClient("main");
	        if (client) {
	            client.clearToken();
	        }
	    }
	}

	const services$1 = {nsWS};

	var mod_6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		services: services$1
	});

	const logger = notCommon$2.createLogger(`WSClient(main)`);
	const main = {
	  logger: logger,
	  getToken: function () {
	    return notCommon$2.getApp().getModel("user", {}).$token({}).then(function (res) {
	      notCommon$2.getApp().setWorking("token", res.result);
	      return res.result;
	    });
	  },
	  messenger: {
	    validateTypeAndName: false,
	    secure: false,
	    //not secure, bc its not issuing tokens and has no secret key
	    types: {
	      __service: ["updateToken"],
	      request: [],
	      response: [],
	      event: []
	    }
	  },
	  router: {
	    routes: {
	      event: {
	        notification() {
	          console.log(...arguments);
	        }
	      }
	    }
	  }
	};

	let manifest$1 = {
	  brand: {
	    icon: {
	      src: "",
	      width: 48,
	      height: 28
	    },
	    title: "notUserTestApp",
	    url: "/"
	  },
	  modules: {
	    ws: {
	      clients: {
	        //options for ws client here
	        main: {
	          host: `${window.location.hostname}:7358/`,
	          path: "",
	          secure: true,
	          ssl: false
	        }
	      }
	    }
	  },
	  crud: {
	    containerSelector: ".main-container"
	  }
	};
	const wsc$1 = {
	  main
	};

	var mod_7 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest$1,
		wsc: wsc$1
	});

	const {
	  notSideMenu,
	  notTopMenu,
	  notController
	} = Frame;
	class ncInit extends notController {
	  constructor(app) {
	    super(app);
	    this.setModuleName("init");
	    this.log("init app");
	    notSideMenu.render(app);
	    notTopMenu.render(app);
	    return this;
	  }
	}

	let manifest = {
	  environment: "user",
	  router: {
	    manifest: []
	  },
	  crud: {
	    containerSelector: ".main-container"
	  },
	  modules: {
	    user: {
	      loginFormContainerSelector: ".main-container",
	      registerFormContainerSelector: ".main-container"
	    }
	  },
	  initController: ncInit
	};

	var mod_8 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		manifest: manifest,
		ncInit: ncInit
	});

	window.NOT_NODE_ERROR_URL_BROWSER = '/api/key/collect';
	const {
	  notCommon,
	  notApp,
	  COMPONENTS
	} = Frame;
	notCommon.register('backlog', true);
	window.dumpBacklog = notCommon.dumpBacklog.bind(notCommon);
	window.addEventListener('error', function (e) {
	  new notErrorReporter().report(e);
	}, true);

	//Базовые настройки
	let appDefaultOptions = {
	  //url from which will take interfaceManifest json file
	  manifestURL: '/api/manifest',
	  //routes for client-side
	  router: {
	    root: '/',
	    manifest: [],
	    index: ''
	  },
	  language: 'ru',
	  crud: {
	    navigateBackAfter: ['create', 'update', 'delete']
	  },
	  modules: {
	    user: {
	      redirectTimout: 1000,
	      afterLoginURL: '/dashboard',
	      loginModes: ['login', 'requestLoginCodeOnEmail', 'loginByCode'],
	      colorsOfRoles: {
	        //style_color_name:[string]
	        primary: {
	          danger: ['guest'],
	          warning: ['user'],
	          link: ['client'],
	          success: ['admin'],
	          primary: ['root']
	        },
	        secondary: {
	          info: ['confirmed', 'manager', 'hr', 'logist']
	        }
	      },
	      loginFormContainerSelector: '.main-container',
	      restoreFormContainerSelector: '.main-container',
	      registerFormContainerSelector: '.main-container'
	    }
	  }
	};
	let services = {},
	  uis = {},
	  wsc = {},
	  fields = {};
	appDefaultOptions = notCommon.absorbModule({
	  defaultConf: appDefaultOptions,
	  mod: mod_0,
	  services,
	  uis,
	  wsc,
	  fields
	});
	appDefaultOptions = notCommon.absorbModule({
	  defaultConf: appDefaultOptions,
	  mod: mod_1,
	  services,
	  uis,
	  wsc,
	  fields
	});
	appDefaultOptions = notCommon.absorbModule({
	  defaultConf: appDefaultOptions,
	  mod: mod_2,
	  services,
	  uis,
	  wsc,
	  fields
	});
	appDefaultOptions = notCommon.absorbModule({
	  defaultConf: appDefaultOptions,
	  mod: mod_3,
	  services,
	  uis,
	  wsc,
	  fields
	});
	appDefaultOptions = notCommon.absorbModule({
	  defaultConf: appDefaultOptions,
	  mod: mod_4,
	  services,
	  uis,
	  wsc,
	  fields
	});
	appDefaultOptions = notCommon.absorbModule({
	  defaultConf: appDefaultOptions,
	  mod: mod_5,
	  services,
	  uis,
	  wsc,
	  fields
	});
	appDefaultOptions = notCommon.absorbModule({
	  defaultConf: appDefaultOptions,
	  mod: mod_6,
	  services,
	  uis,
	  wsc,
	  fields
	});
	appDefaultOptions = notCommon.absorbModule({
	  defaultConf: appDefaultOptions,
	  mod: mod_7,
	  services,
	  uis,
	  wsc,
	  fields
	});
	appDefaultOptions = notCommon.absorbModule({
	  defaultConf: appDefaultOptions,
	  mod: mod_8,
	  services,
	  uis,
	  wsc,
	  fields
	});
	COMPONENTS.import(uis);
	appDefaultOptions.services = services;
	appDefaultOptions.wsc = wsc;
	notCommon.startApp(function () {
	  return new notApp(appDefaultOptions);
	});

})();
